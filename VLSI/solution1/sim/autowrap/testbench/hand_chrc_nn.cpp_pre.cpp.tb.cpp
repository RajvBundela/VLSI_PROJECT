// ==============================================================
// File generated on Sun Nov 13 23:42:04 +0530 2022
// Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC v2018.3 (64-bit)
// SW Build 2405991 on Thu Dec  6 23:38:27 MST 2018
// IP Build 2404404 on Fri Dec  7 01:43:56 MST 2018
// Copyright 1986-2018 Xilinx, Inc. All Rights Reserved.
// ==============================================================
#1 "C:/Users/91917/Downloads/VLSI_Project/vlsi_project/hand_chrc_nn.cpp"
#1 "<built-in>"
#1 "<command-line>"
#1 "C:/Users/91917/Downloads/VLSI_Project/vlsi_project/hand_chrc_nn.cpp"

#1 "C:/Xilinx/Vivado/2018.3/include/hls_math.h" 1
#35 "C:/Xilinx/Vivado/2018.3/include/hls_math.h"
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cmath" 1 3
#39 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cmath" 3

#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cmath" 3

#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++config.h" 1 3
#196 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++config.h" 3

#196 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++config.h" 3
namespace std
{
  typedef long long unsigned int size_t;
  typedef long long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;

}
#218 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++config.h" 3
namespace std
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
namespace __gnu_cxx
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
#495 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++config.h" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/os_defines.h" 1 3
#496 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++config.h" 2 3


#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/cpu_defines.h" 1 3
#499 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++config.h" 2 3
#42 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cmath" 2 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/cpp_type_traits.h" 1 3
#35 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/cpp_type_traits.h" 3

#36 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/cpp_type_traits.h" 3
#67 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/cpp_type_traits.h" 3
extern "C++" {

namespace std
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };





  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_integer<char16_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char32_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#261 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/cpp_type_traits.h" 3
template<> struct __is_integer<__int128> { enum { __value = 1 }; typedef __true_type __type; }; template<> struct __is_integer<unsigned __int128> { enum { __value = 1 }; typedef __true_type __type; };
#278 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/cpp_type_traits.h" 3
  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };



  template<typename _Iterator>
    inline _Iterator
    __miter_base(_Iterator __it)
    { return __it; }


}
}
#43 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cmath" 2 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ext/type_traits.h" 1 3
#32 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ext/type_traits.h" 3

#33 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ext/type_traits.h" 3




extern "C++" {

namespace __gnu_cxx
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }


  inline bool
  __is_null_pointer(std::nullptr_t)
  { return true; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };

  template<typename _Tp, typename _Up,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type>
    struct __promote_2
    {
      typedef __typeof__(_Tp2() + _Up2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type>
    struct __promote_3
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type,
           typename _Wp2 = typename __promote<_Wp>::__type>
    struct __promote_4
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
    };


}
}
#44 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cmath" 2 3

#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 1 3
#10 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3

#11 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3


#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/crtdefs.h" 1 3
#10 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/crtdefs.h" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 1 3
#12 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_mac.h" 1 3
#88 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_mac.h" 3

#97 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_mac.h" 3

#13 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 2 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_secapi.h" 1 3
#44 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_secapi.h" 3
extern "C++" {
template <bool __test, typename __dsttype>
  struct __if_array;
template <typename __dsttype>
  struct __if_array <true, __dsttype> {
    typedef __dsttype __type;
};
}
#14 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 2 3
#275 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/vadefs.h" 1 3
#9 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/vadefs.h" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 1 3
#565 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/sdks/_mingw_directx.h" 1 3
#566 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 2 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/sdks/_mingw_ddk.h" 1 3
#567 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 2 3
#10 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/vadefs.h" 2 3




#pragma pack(push,_CRT_PACKING)



extern "C" {





  typedef __builtin_va_list __gnuc_va_list;






  typedef __gnuc_va_list va_list;
#99 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/vadefs.h" 3
}



#pragma pack(pop)
#276 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 2 3
#534 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 3
extern "C" {




void __attribute__((__cdecl__)) __debugbreak(void);
extern __inline__ __attribute__((__always_inline__,__gnu_inline__)) void __attribute__((__cdecl__)) __debugbreak(void)
{
  __asm__ __volatile__("int {$}3":);
}




const char *__mingw_get_crt_info (void);


}
#11 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/crtdefs.h" 2 3




#pragma pack(push,_CRT_PACKING)
#35 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/crtdefs.h" 3
__extension__ typedef unsigned long long size_t;
#45 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/crtdefs.h" 3
__extension__ typedef long long ssize_t;






typedef size_t rsize_t;
#62 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/crtdefs.h" 3
__extension__ typedef long long intptr_t;
#75 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/crtdefs.h" 3
__extension__ typedef unsigned long long uintptr_t;
#88 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/crtdefs.h" 3
__extension__ typedef long long ptrdiff_t;
#106 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/crtdefs.h" 3
typedef unsigned short wint_t;
typedef unsigned short wctype_t;





typedef int errno_t;




typedef long __time32_t;




__extension__ typedef long long __time64_t;
#138 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/crtdefs.h" 3
typedef __time64_t time_t;
#422 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/crtdefs.h" 3
struct threadlocaleinfostruct;
struct threadmbcinfostruct;
typedef struct threadlocaleinfostruct *pthreadlocinfo;
typedef struct threadmbcinfostruct *pthreadmbcinfo;
struct __lc_time_data;

typedef struct localeinfo_struct {
  pthreadlocinfo locinfo;
  pthreadmbcinfo mbcinfo;
} _locale_tstruct,*_locale_t;



typedef struct tagLC_ID {
  unsigned short wLanguage;
  unsigned short wCountry;
  unsigned short wCodePage;
} LC_ID,*LPLC_ID;




typedef struct threadlocaleinfostruct {
  int refcount;
  unsigned int lc_codepage;
  unsigned int lc_collate_cp;
  unsigned long lc_handle[6];
  LC_ID lc_id[6];
  struct {
    char *locale;
    wchar_t *wlocale;
    int *refcount;
    int *wrefcount;
  } lc_category[6];
  int lc_clike;
  int mb_cur_max;
  int *lconv_intl_refcount;
  int *lconv_num_refcount;
  int *lconv_mon_refcount;
  struct lconv *lconv;
  int *ctype1_refcount;
  unsigned short *ctype1;
  const unsigned short *pctype;
  const unsigned char *pclmap;
  const unsigned char *pcumap;
  struct __lc_time_data *lc_time_curr;
} threadlocinfo;







#pragma pack(pop)
#14 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 2 3

struct _exception;

#pragma pack(push,_CRT_PACKING)
#77 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
extern "C++" {
template <typename type1, typename type2> struct __mingw_types_compatible_p {
  static const bool result = false;
};

template <typename type1> struct __mingw_types_compatible_p<type1, type1> {
 static const bool result = true;
};

template <typename type1> struct __mingw_types_compatible_p<const type1, type1> {
  static const bool result = true;
};

template <typename type1> struct __mingw_types_compatible_p<type1, const type1> {
  static const bool result = true;
};
}
#111 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
extern "C" {







  typedef union __mingw_dbl_type_t {
    double x;
    unsigned long long val;
    __extension__ struct {
      unsigned int low, high;
    } lh;
  } __mingw_dbl_type_t;

  typedef union __mingw_flt_type_t {
    float x;
    unsigned int val;
  } __mingw_flt_type_t;

  typedef union __mingw_ldbl_type_t
  {
    long double x;
    __extension__ struct {
      unsigned int low, high;
      int sign_exponent : 16;
      int res1 : 16;
      int res0 : 32;
    } lh;
  } __mingw_ldbl_type_t;

  typedef union __mingw_fp_types_t
  {
    long double *ld;
    double *d;
    float *f;
    __mingw_ldbl_type_t *ldt;
    __mingw_dbl_type_t *dt;
    __mingw_flt_type_t *ft;
  } __mingw_fp_types_t;




  extern double * __imp__HUGE;
#168 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
  struct _exception {
    int type;
    const char *name;
    double arg1;
    double arg2;
    double retval;
  };

  void __mingw_raise_matherr (int typ, const char *name, double a1, double a2,
         double rslt);
  void __mingw_setusermatherr (int (__attribute__((__cdecl__)) *)(struct _exception *));
  __attribute__ ((__dllimport__)) void __setusermatherr(int (__attribute__((__cdecl__)) *)(struct _exception *));



  double __attribute__((__cdecl__)) sin(double _X);
  double __attribute__((__cdecl__)) cos(double _X);
  double __attribute__((__cdecl__)) tan(double _X);
  double __attribute__((__cdecl__)) sinh(double _X);
  double __attribute__((__cdecl__)) cosh(double _X);
  double __attribute__((__cdecl__)) tanh(double _X);
  double __attribute__((__cdecl__)) asin(double _X);
  double __attribute__((__cdecl__)) acos(double _X);
  double __attribute__((__cdecl__)) atan(double _X);
  double __attribute__((__cdecl__)) atan2(double _Y,double _X);
  double __attribute__((__cdecl__)) exp(double _X);
  double __attribute__((__cdecl__)) log(double _X);
  double __attribute__((__cdecl__)) log10(double _X);
  double __attribute__((__cdecl__)) pow(double _X,double _Y);
  double __attribute__((__cdecl__)) sqrt(double _X);
  double __attribute__((__cdecl__)) ceil(double _X);
  double __attribute__((__cdecl__)) floor(double _X);


  extern float __attribute__((__cdecl__)) fabsf (float x);
  extern long double __attribute__((__cdecl__)) fabsl (long double);
  extern double __attribute__((__cdecl__)) fabs (double _X);
#243 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
  double __attribute__((__cdecl__)) ldexp(double _X,int _Y);
  double __attribute__((__cdecl__)) frexp(double _X,int *_Y);
  double __attribute__((__cdecl__)) modf(double _X,double *_Y);
  double __attribute__((__cdecl__)) fmod(double _X,double _Y);

  void __attribute__((__cdecl__)) sincos (double __x, double *p_sin, double *p_cos);
  void __attribute__((__cdecl__)) sincosl (long double __x, long double *p_sin, long double *p_cos);
  void __attribute__((__cdecl__)) sincosf (float __x, float *p_sin, float *p_cos);



  int __attribute__((__cdecl__)) abs(int _X);
  long __attribute__((__cdecl__)) labs(long _X);



  double __attribute__((__cdecl__)) atof(const char *_String);
  double __attribute__((__cdecl__)) _atof_l(const char *_String,_locale_t _Locale);
#270 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
  struct _complex {
    double x;
    double y;
  };


  double __attribute__((__cdecl__)) _cabs(struct _complex _ComplexA);
  double __attribute__((__cdecl__)) _hypot(double _X,double _Y);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _j0(double _X);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _j1(double _X);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _jn(int _X,double _Y);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _y0(double _X);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _y1(double _X);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _yn(int _X,double _Y);


  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _matherr (struct _exception *);
#297 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _chgsign (double _X);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _copysign (double _Number,double _Sign);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _logb (double);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _nextafter (double, double);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _scalb (double, long);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _finite (double);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fpclass (double);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isnan (double);






__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) j0 (double) ;
__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) j1 (double) ;
__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) jn (int, double) ;
__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) y0 (double) ;
__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) y1 (double) ;
__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) yn (int, double) ;

__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) chgsign (double);
#327 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) finite (double);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) fpclass (double);
#372 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
typedef float float_t;
typedef double double_t;
#407 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
  extern int __attribute__((__cdecl__)) __fpclassifyl (long double);
  extern int __attribute__((__cdecl__)) __fpclassifyf (float);
  extern int __attribute__((__cdecl__)) __fpclassify (double);
#520 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
  extern int __attribute__((__cdecl__)) __isnan (double);
  extern int __attribute__((__cdecl__)) __isnanf (float);
  extern int __attribute__((__cdecl__)) __isnanl (long double);
#607 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
  extern int __attribute__((__cdecl__)) __signbit (double);
  extern int __attribute__((__cdecl__)) __signbitf (float);
  extern int __attribute__((__cdecl__)) __signbitl (long double);
#664 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
  extern float __attribute__((__cdecl__)) sinf(float _X);
  extern long double __attribute__((__cdecl__)) sinl(long double);

  extern float __attribute__((__cdecl__)) cosf(float _X);
  extern long double __attribute__((__cdecl__)) cosl(long double);

  extern float __attribute__((__cdecl__)) tanf(float _X);
  extern long double __attribute__((__cdecl__)) tanl(long double);
  extern float __attribute__((__cdecl__)) asinf(float _X);
  extern long double __attribute__((__cdecl__)) asinl(long double);

  extern float __attribute__((__cdecl__)) acosf (float);
  extern long double __attribute__((__cdecl__)) acosl (long double);

  extern float __attribute__((__cdecl__)) atanf (float);
  extern long double __attribute__((__cdecl__)) atanl (long double);

  extern float __attribute__((__cdecl__)) atan2f (float, float);
  extern long double __attribute__((__cdecl__)) atan2l (long double, long double);


  extern float __attribute__((__cdecl__)) sinhf(float _X);



  extern long double __attribute__((__cdecl__)) sinhl(long double);

  extern float __attribute__((__cdecl__)) coshf(float _X);



  extern long double __attribute__((__cdecl__)) coshl(long double);

  extern float __attribute__((__cdecl__)) tanhf(float _X);



  extern long double __attribute__((__cdecl__)) tanhl(long double);



  extern double __attribute__((__cdecl__)) acosh (double);
  extern float __attribute__((__cdecl__)) acoshf (float);
  extern long double __attribute__((__cdecl__)) acoshl (long double);


  extern double __attribute__((__cdecl__)) asinh (double);
  extern float __attribute__((__cdecl__)) asinhf (float);
  extern long double __attribute__((__cdecl__)) asinhl (long double);


  extern double __attribute__((__cdecl__)) atanh (double);
  extern float __attribute__((__cdecl__)) atanhf (float);
  extern long double __attribute__((__cdecl__)) atanhl (long double);



  extern float __attribute__((__cdecl__)) expf(float _X);



  extern long double __attribute__((__cdecl__)) expl(long double);


  extern double __attribute__((__cdecl__)) exp2(double);
  extern float __attribute__((__cdecl__)) exp2f(float);
  extern long double __attribute__((__cdecl__)) exp2l(long double);



  extern double __attribute__((__cdecl__)) expm1(double);
  extern float __attribute__((__cdecl__)) expm1f(float);
  extern long double __attribute__((__cdecl__)) expm1l(long double);


  extern float frexpf(float _X,int *_Y);



  extern long double __attribute__((__cdecl__)) frexpl(long double,int *);




  extern int __attribute__((__cdecl__)) ilogb (double);
  extern int __attribute__((__cdecl__)) ilogbf (float);
  extern int __attribute__((__cdecl__)) ilogbl (long double);


  extern float __attribute__((__cdecl__)) ldexpf(float _X,int _Y);



  extern long double __attribute__((__cdecl__)) ldexpl (long double, int);


  extern float __attribute__((__cdecl__)) logf (float);
  extern long double __attribute__((__cdecl__)) logl(long double);


  extern float __attribute__((__cdecl__)) log10f (float);
  extern long double __attribute__((__cdecl__)) log10l(long double);


  extern double __attribute__((__cdecl__)) log1p(double);
  extern float __attribute__((__cdecl__)) log1pf(float);
  extern long double __attribute__((__cdecl__)) log1pl(long double);


  extern double __attribute__((__cdecl__)) log2 (double);
  extern float __attribute__((__cdecl__)) log2f (float);
  extern long double __attribute__((__cdecl__)) log2l (long double);


  extern double __attribute__((__cdecl__)) logb (double);
  extern float __attribute__((__cdecl__)) logbf (float);
  extern long double __attribute__((__cdecl__)) logbl (long double);
#863 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
  extern float __attribute__((__cdecl__)) modff (float, float*);
  extern long double __attribute__((__cdecl__)) modfl (long double, long double*);


  extern double __attribute__((__cdecl__)) scalbn (double, int);
  extern float __attribute__((__cdecl__)) scalbnf (float, int);
  extern long double __attribute__((__cdecl__)) scalbnl (long double, int);

  extern double __attribute__((__cdecl__)) scalbln (double, long);
  extern float __attribute__((__cdecl__)) scalblnf (float, long);
  extern long double __attribute__((__cdecl__)) scalblnl (long double, long);



  extern double __attribute__((__cdecl__)) cbrt (double);
  extern float __attribute__((__cdecl__)) cbrtf (float);
  extern long double __attribute__((__cdecl__)) cbrtl (long double);


  extern double __attribute__((__cdecl__)) hypot (double, double) ;
  extern float __attribute__((__cdecl__)) hypotf (float x, float y);



  extern long double __attribute__((__cdecl__)) hypotl (long double, long double);


  extern float __attribute__((__cdecl__)) powf(float _X,float _Y);



  extern long double __attribute__((__cdecl__)) powl (long double, long double);


  extern float __attribute__((__cdecl__)) sqrtf (float);
  extern long double sqrtl(long double);


  extern double __attribute__((__cdecl__)) erf (double);
  extern float __attribute__((__cdecl__)) erff (float);
  extern long double __attribute__((__cdecl__)) erfl (long double);


  extern double __attribute__((__cdecl__)) erfc (double);
  extern float __attribute__((__cdecl__)) erfcf (float);
  extern long double __attribute__((__cdecl__)) erfcl (long double);


  extern double __attribute__((__cdecl__)) lgamma (double);
  extern float __attribute__((__cdecl__)) lgammaf (float);
  extern long double __attribute__((__cdecl__)) lgammal (long double);

  extern int signgam;


  extern double __attribute__((__cdecl__)) tgamma (double);
  extern float __attribute__((__cdecl__)) tgammaf (float);
  extern long double __attribute__((__cdecl__)) tgammal (long double);


  extern float __attribute__((__cdecl__)) ceilf (float);
  extern long double __attribute__((__cdecl__)) ceill (long double);


  extern float __attribute__((__cdecl__)) floorf (float);
  extern long double __attribute__((__cdecl__)) floorl (long double);


  extern double __attribute__((__cdecl__)) nearbyint ( double);
  extern float __attribute__((__cdecl__)) nearbyintf (float);
  extern long double __attribute__((__cdecl__)) nearbyintl (long double);



extern double __attribute__((__cdecl__)) rint (double);
extern float __attribute__((__cdecl__)) rintf (float);
extern long double __attribute__((__cdecl__)) rintl (long double);


extern long __attribute__((__cdecl__)) lrint (double);
extern long __attribute__((__cdecl__)) lrintf (float);
extern long __attribute__((__cdecl__)) lrintl (long double);

__extension__ long long __attribute__((__cdecl__)) llrint (double);
__extension__ long long __attribute__((__cdecl__)) llrintf (float);
__extension__ long long __attribute__((__cdecl__)) llrintl (long double);
#1030 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
  extern double __attribute__((__cdecl__)) round (double);
  extern float __attribute__((__cdecl__)) roundf (float);
  extern long double __attribute__((__cdecl__)) roundl (long double);


  extern long __attribute__((__cdecl__)) lround (double);
  extern long __attribute__((__cdecl__)) lroundf (float);
  extern long __attribute__((__cdecl__)) lroundl (long double);
  __extension__ long long __attribute__((__cdecl__)) llround (double);
  __extension__ long long __attribute__((__cdecl__)) llroundf (float);
  __extension__ long long __attribute__((__cdecl__)) llroundl (long double);



  extern double __attribute__((__cdecl__)) trunc (double);
  extern float __attribute__((__cdecl__)) truncf (float);
  extern long double __attribute__((__cdecl__)) truncl (long double);


  extern float __attribute__((__cdecl__)) fmodf (float, float);
  extern long double __attribute__((__cdecl__)) fmodl (long double, long double);


  extern double __attribute__((__cdecl__)) remainder (double, double);
  extern float __attribute__((__cdecl__)) remainderf (float, float);
  extern long double __attribute__((__cdecl__)) remainderl (long double, long double);


  extern double __attribute__((__cdecl__)) remquo(double, double, int *);
  extern float __attribute__((__cdecl__)) remquof(float, float, int *);
  extern long double __attribute__((__cdecl__)) remquol(long double, long double, int *);


  extern double __attribute__((__cdecl__)) copysign (double, double);
  extern float __attribute__((__cdecl__)) copysignf (float, float);
  extern long double __attribute__((__cdecl__)) copysignl (long double, long double);
#1087 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
  extern double __attribute__((__cdecl__)) nan(const char *tagp);
  extern float __attribute__((__cdecl__)) nanf(const char *tagp);
  extern long double __attribute__((__cdecl__)) nanl(const char *tagp);
#1098 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
  extern double __attribute__((__cdecl__)) nextafter (double, double);
  extern float __attribute__((__cdecl__)) nextafterf (float, float);
  extern long double __attribute__((__cdecl__)) nextafterl (long double, long double);


  extern double __attribute__((__cdecl__)) nexttoward (double, long double);
  extern float __attribute__((__cdecl__)) nexttowardf (float, long double);
  extern long double __attribute__((__cdecl__)) nexttowardl (long double, long double);



  extern double __attribute__((__cdecl__)) fdim (double x, double y);
  extern float __attribute__((__cdecl__)) fdimf (float x, float y);
  extern long double __attribute__((__cdecl__)) fdiml (long double x, long double y);







  extern double __attribute__((__cdecl__)) fmax (double, double);
  extern float __attribute__((__cdecl__)) fmaxf (float, float);
  extern long double __attribute__((__cdecl__)) fmaxl (long double, long double);


  extern double __attribute__((__cdecl__)) fmin (double, double);
  extern float __attribute__((__cdecl__)) fminf (float, float);
  extern long double __attribute__((__cdecl__)) fminl (long double, long double);



  extern double __attribute__((__cdecl__)) fma (double, double, double);
  extern float __attribute__((__cdecl__)) fmaf (float, float, float);
  extern long double __attribute__((__cdecl__)) fmal (long double, long double, long double);
#1181 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
   __attribute__ ((__dllimport__)) float __attribute__((__cdecl__)) _copysignf (float _Number,float _Sign);
   __attribute__ ((__dllimport__)) float __attribute__((__cdecl__)) _chgsignf (float _X);
   __attribute__ ((__dllimport__)) float __attribute__((__cdecl__)) _logbf(float _X);
   __attribute__ ((__dllimport__)) float __attribute__((__cdecl__)) _nextafterf(float _X,float _Y);
   __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _finitef(float _X);
   __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isnanf(float _X);
   __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fpclassf(float _X);



   extern long double __attribute__((__cdecl__)) _chgsignl (long double);
#1576 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
}




#pragma pack(pop)
#46 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cmath" 2 3
#77 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cmath" 3
extern "C++"
{
namespace std
{



  inline constexpr double
  abs(double __x)
  { return __builtin_fabs(__x); }



  inline constexpr float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    abs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::acos;


  inline constexpr float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline constexpr long double
  acos(long double __x)
  { return __builtin_acosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;


  inline constexpr float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline constexpr long double
  asin(long double __x)
  { return __builtin_asinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;


  inline constexpr float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline constexpr long double
  atan(long double __x)
  { return __builtin_atanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;


  inline constexpr float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline constexpr long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  using ::ceil;


  inline constexpr float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline constexpr long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;


  inline constexpr float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline constexpr long double
  cos(long double __x)
  { return __builtin_cosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;


  inline constexpr float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline constexpr long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;


  inline constexpr float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline constexpr long double
  exp(long double __x)
  { return __builtin_expl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;


  inline constexpr float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;


  inline constexpr float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline constexpr long double
  floor(long double __x)
  { return __builtin_floorl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;


  inline constexpr float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline constexpr long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmod(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmod(__type(__x), __type(__y));
    }

  using ::frexp;


  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;


  inline constexpr float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline constexpr long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ldexp(_Tp __x, int __exp)
    { return __builtin_ldexp(__x, __exp); }

  using ::log;


  inline constexpr float
  log(float __x)
  { return __builtin_logf(__x); }

  inline constexpr long double
  log(long double __x)
  { return __builtin_logl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;


  inline constexpr float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline constexpr long double
  log10(long double __x)
  { return __builtin_log10l(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;


  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }


  using ::pow;


  inline constexpr float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline constexpr long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }
#435 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cmath" 3
  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }

  using ::sin;


  inline constexpr float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline constexpr long double
  sin(long double __x)
  { return __builtin_sinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;


  inline constexpr float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline constexpr long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;


  inline constexpr float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline constexpr long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;


  inline constexpr float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline constexpr long double
  tan(long double __x)
  { return __builtin_tanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;


  inline constexpr float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline constexpr long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }


}
#559 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cmath" 3
namespace std
{





  constexpr int
  fpclassify(float __x)
  { return __builtin_fpclassify(0x0100, (0x0100 | 0x0400), 0x0400,
    (0x0400 | 0x4000), 0x4000, __x); }

  constexpr int
  fpclassify(double __x)
  { return __builtin_fpclassify(0x0100, (0x0100 | 0x0400), 0x0400,
    (0x0400 | 0x4000), 0x4000, __x); }

  constexpr int
  fpclassify(long double __x)
  { return __builtin_fpclassify(0x0100, (0x0100 | 0x0400), 0x0400,
    (0x0400 | 0x4000), 0x4000, __x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              int>::__type
    fpclassify(_Tp __x)
    { return __x != 0 ? 0x0400 : 0x4000; }


  constexpr bool
  isfinite(float __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(double __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(long double __x)
  { return __builtin_isfinite(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isfinite(_Tp __x)
    { return true; }


  constexpr bool
  isinf(float __x)
  { return __builtin_isinf(__x); }





  constexpr bool
  isinf(double __x)
  { return __builtin_isinf(__x); }


  constexpr bool
  isinf(long double __x)
  { return __builtin_isinf(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isinf(_Tp __x)
    { return false; }


  constexpr bool
  isnan(float __x)
  { return __builtin_isnan(__x); }





  constexpr bool
  isnan(double __x)
  { return __builtin_isnan(__x); }


  constexpr bool
  isnan(long double __x)
  { return __builtin_isnan(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnan(_Tp __x)
    { return false; }


  constexpr bool
  isnormal(float __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(double __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(long double __x)
  { return __builtin_isnormal(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnormal(_Tp __x)
    { return __x != 0 ? true : false; }



  constexpr bool
  signbit(float __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(double __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(long double __x)
  { return __builtin_signbit(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    signbit(_Tp __x)
    { return __x < 0 ? true : false; }


  constexpr bool
  isgreater(float __x, float __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(double __x, double __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(long double __x, long double __y)
  { return __builtin_isgreater(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreater(__type(__x), __type(__y));
    }


  constexpr bool
  isgreaterequal(float __x, float __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(double __x, double __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(long double __x, long double __y)
  { return __builtin_isgreaterequal(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreaterequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreaterequal(__type(__x), __type(__y));
    }


  constexpr bool
  isless(float __x, float __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(double __x, double __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(long double __x, long double __y)
  { return __builtin_isless(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isless(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isless(__type(__x), __type(__y));
    }


  constexpr bool
  islessequal(float __x, float __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(double __x, double __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(long double __x, long double __y)
  { return __builtin_islessequal(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessequal(__type(__x), __type(__y));
    }


  constexpr bool
  islessgreater(float __x, float __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(double __x, double __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(long double __x, long double __y)
  { return __builtin_islessgreater(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessgreater(__type(__x), __type(__y));
    }


  constexpr bool
  isunordered(float __x, float __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(double __x, double __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(long double __x, long double __y)
  { return __builtin_isunordered(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isunordered(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isunordered(__type(__x), __type(__y));
    }
#956 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cmath" 3

}
#1072 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cmath" 3
namespace std
{



  using ::double_t;
  using ::float_t;


  using ::acosh;
  using ::acoshf;
  using ::acoshl;

  using ::asinh;
  using ::asinhf;
  using ::asinhl;

  using ::atanh;
  using ::atanhf;
  using ::atanhl;

  using ::cbrt;
  using ::cbrtf;
  using ::cbrtl;

  using ::copysign;
  using ::copysignf;
  using ::copysignl;

  using ::erf;
  using ::erff;
  using ::erfl;

  using ::erfc;
  using ::erfcf;
  using ::erfcl;

  using ::exp2;
  using ::exp2f;
  using ::exp2l;

  using ::expm1;
  using ::expm1f;
  using ::expm1l;

  using ::fdim;
  using ::fdimf;
  using ::fdiml;

  using ::fma;
  using ::fmaf;
  using ::fmal;

  using ::fmax;
  using ::fmaxf;
  using ::fmaxl;

  using ::fmin;
  using ::fminf;
  using ::fminl;

  using ::hypot;
  using ::hypotf;
  using ::hypotl;

  using ::ilogb;
  using ::ilogbf;
  using ::ilogbl;

  using ::lgamma;
  using ::lgammaf;
  using ::lgammal;

  using ::llrint;
  using ::llrintf;
  using ::llrintl;

  using ::llround;
  using ::llroundf;
  using ::llroundl;

  using ::log1p;
  using ::log1pf;
  using ::log1pl;

  using ::log2;
  using ::log2f;
  using ::log2l;

  using ::logb;
  using ::logbf;
  using ::logbl;

  using ::lrint;
  using ::lrintf;
  using ::lrintl;

  using ::lround;
  using ::lroundf;
  using ::lroundl;

  using ::nan;
  using ::nanf;
  using ::nanl;

  using ::nearbyint;
  using ::nearbyintf;
  using ::nearbyintl;

  using ::nextafter;
  using ::nextafterf;
  using ::nextafterl;

  using ::nexttoward;
  using ::nexttowardf;
  using ::nexttowardl;

  using ::remainder;
  using ::remainderf;
  using ::remainderl;

  using ::remquo;
  using ::remquof;
  using ::remquol;

  using ::rint;
  using ::rintf;
  using ::rintl;

  using ::round;
  using ::roundf;
  using ::roundl;

  using ::scalbln;
  using ::scalblnf;
  using ::scalblnl;

  using ::scalbn;
  using ::scalbnf;
  using ::scalbnl;

  using ::tgamma;
  using ::tgammaf;
  using ::tgammal;

  using ::trunc;
  using ::truncf;
  using ::truncl;



  constexpr float
  acosh(float __x)
  { return __builtin_acoshf(__x); }

  constexpr long double
  acosh(long double __x)
  { return __builtin_acoshl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    acosh(_Tp __x)
    { return __builtin_acosh(__x); }


  constexpr float
  asinh(float __x)
  { return __builtin_asinhf(__x); }

  constexpr long double
  asinh(long double __x)
  { return __builtin_asinhl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    asinh(_Tp __x)
    { return __builtin_asinh(__x); }


  constexpr float
  atanh(float __x)
  { return __builtin_atanhf(__x); }

  constexpr long double
  atanh(long double __x)
  { return __builtin_atanhl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    atanh(_Tp __x)
    { return __builtin_atanh(__x); }


  constexpr float
  cbrt(float __x)
  { return __builtin_cbrtf(__x); }

  constexpr long double
  cbrt(long double __x)
  { return __builtin_cbrtl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    cbrt(_Tp __x)
    { return __builtin_cbrt(__x); }


  constexpr float
  copysign(float __x, float __y)
  { return __builtin_copysignf(__x, __y); }

  constexpr long double
  copysign(long double __x, long double __y)
  { return __builtin_copysignl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    copysign(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return copysign(__type(__x), __type(__y));
    }


  constexpr float
  erf(float __x)
  { return __builtin_erff(__x); }

  constexpr long double
  erf(long double __x)
  { return __builtin_erfl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erf(_Tp __x)
    { return __builtin_erf(__x); }


  constexpr float
  erfc(float __x)
  { return __builtin_erfcf(__x); }

  constexpr long double
  erfc(long double __x)
  { return __builtin_erfcl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erfc(_Tp __x)
    { return __builtin_erfc(__x); }


  constexpr float
  exp2(float __x)
  { return __builtin_exp2f(__x); }

  constexpr long double
  exp2(long double __x)
  { return __builtin_exp2l(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    exp2(_Tp __x)
    { return __builtin_exp2(__x); }


  constexpr float
  expm1(float __x)
  { return __builtin_expm1f(__x); }

  constexpr long double
  expm1(long double __x)
  { return __builtin_expm1l(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    expm1(_Tp __x)
    { return __builtin_expm1(__x); }


  constexpr float
  fdim(float __x, float __y)
  { return __builtin_fdimf(__x, __y); }

  constexpr long double
  fdim(long double __x, long double __y)
  { return __builtin_fdiml(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fdim(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fdim(__type(__x), __type(__y));
    }


  constexpr float
  fma(float __x, float __y, float __z)
  { return __builtin_fmaf(__x, __y, __z); }

  constexpr long double
  fma(long double __x, long double __y, long double __z)
  { return __builtin_fmal(__x, __y, __z); }


  template<typename _Tp, typename _Up, typename _Vp>
    constexpr typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
    fma(_Tp __x, _Up __y, _Vp __z)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
      return fma(__type(__x), __type(__y), __type(__z));
    }


  constexpr float
  fmax(float __x, float __y)
  { return __builtin_fmaxf(__x, __y); }

  constexpr long double
  fmax(long double __x, long double __y)
  { return __builtin_fmaxl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmax(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmax(__type(__x), __type(__y));
    }


  constexpr float
  fmin(float __x, float __y)
  { return __builtin_fminf(__x, __y); }

  constexpr long double
  fmin(long double __x, long double __y)
  { return __builtin_fminl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmin(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmin(__type(__x), __type(__y));
    }


  constexpr float
  hypot(float __x, float __y)
  { return __builtin_hypotf(__x, __y); }

  constexpr long double
  hypot(long double __x, long double __y)
  { return __builtin_hypotl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    hypot(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return hypot(__type(__x), __type(__y));
    }


  constexpr int
  ilogb(float __x)
  { return __builtin_ilogbf(__x); }

  constexpr int
  ilogb(long double __x)
  { return __builtin_ilogbl(__x); }


  template<typename _Tp>
    constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    int>::__type
    ilogb(_Tp __x)
    { return __builtin_ilogb(__x); }


  constexpr float
  lgamma(float __x)
  { return __builtin_lgammaf(__x); }

  constexpr long double
  lgamma(long double __x)
  { return __builtin_lgammal(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    lgamma(_Tp __x)
    { return __builtin_lgamma(__x); }


  constexpr long long
  llrint(float __x)
  { return __builtin_llrintf(__x); }

  constexpr long long
  llrint(long double __x)
  { return __builtin_llrintl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llrint(_Tp __x)
    { return __builtin_llrint(__x); }


  constexpr long long
  llround(float __x)
  { return __builtin_llroundf(__x); }

  constexpr long long
  llround(long double __x)
  { return __builtin_llroundl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llround(_Tp __x)
    { return __builtin_llround(__x); }


  constexpr float
  log1p(float __x)
  { return __builtin_log1pf(__x); }

  constexpr long double
  log1p(long double __x)
  { return __builtin_log1pl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log1p(_Tp __x)
    { return __builtin_log1p(__x); }



  constexpr float
  log2(float __x)
  { return __builtin_log2f(__x); }

  constexpr long double
  log2(long double __x)
  { return __builtin_log2l(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log2(_Tp __x)
    { return __builtin_log2(__x); }


  constexpr float
  logb(float __x)
  { return __builtin_logbf(__x); }

  constexpr long double
  logb(long double __x)
  { return __builtin_logbl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    logb(_Tp __x)
    { return __builtin_logb(__x); }


  constexpr long
  lrint(float __x)
  { return __builtin_lrintf(__x); }

  constexpr long
  lrint(long double __x)
  { return __builtin_lrintl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lrint(_Tp __x)
    { return __builtin_lrint(__x); }


  constexpr long
  lround(float __x)
  { return __builtin_lroundf(__x); }

  constexpr long
  lround(long double __x)
  { return __builtin_lroundl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lround(_Tp __x)
    { return __builtin_lround(__x); }


  constexpr float
  nearbyint(float __x)
  { return __builtin_nearbyintf(__x); }

  constexpr long double
  nearbyint(long double __x)
  { return __builtin_nearbyintl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nearbyint(_Tp __x)
    { return __builtin_nearbyint(__x); }


  constexpr float
  nextafter(float __x, float __y)
  { return __builtin_nextafterf(__x, __y); }

  constexpr long double
  nextafter(long double __x, long double __y)
  { return __builtin_nextafterl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    nextafter(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return nextafter(__type(__x), __type(__y));
    }


  constexpr float
  nexttoward(float __x, long double __y)
  { return __builtin_nexttowardf(__x, __y); }

  constexpr long double
  nexttoward(long double __x, long double __y)
  { return __builtin_nexttowardl(__x, __y); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nexttoward(_Tp __x, long double __y)
    { return __builtin_nexttoward(__x, __y); }


  constexpr float
  remainder(float __x, float __y)
  { return __builtin_remainderf(__x, __y); }

  constexpr long double
  remainder(long double __x, long double __y)
  { return __builtin_remainderl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remainder(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remainder(__type(__x), __type(__y));
    }


  inline float
  remquo(float __x, float __y, int* __pquo)
  { return __builtin_remquof(__x, __y, __pquo); }

  inline long double
  remquo(long double __x, long double __y, int* __pquo)
  { return __builtin_remquol(__x, __y, __pquo); }


  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remquo(_Tp __x, _Up __y, int* __pquo)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remquo(__type(__x), __type(__y), __pquo);
    }


  constexpr float
  rint(float __x)
  { return __builtin_rintf(__x); }

  constexpr long double
  rint(long double __x)
  { return __builtin_rintl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    rint(_Tp __x)
    { return __builtin_rint(__x); }


  constexpr float
  round(float __x)
  { return __builtin_roundf(__x); }

  constexpr long double
  round(long double __x)
  { return __builtin_roundl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    round(_Tp __x)
    { return __builtin_round(__x); }


  constexpr float
  scalbln(float __x, long __ex)
  { return __builtin_scalblnf(__x, __ex); }

  constexpr long double
  scalbln(long double __x, long __ex)
  { return __builtin_scalblnl(__x, __ex); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbln(_Tp __x, long __ex)
    { return __builtin_scalbln(__x, __ex); }


  constexpr float
  scalbn(float __x, int __ex)
  { return __builtin_scalbnf(__x, __ex); }

  constexpr long double
  scalbn(long double __x, int __ex)
  { return __builtin_scalbnl(__x, __ex); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbn(_Tp __x, int __ex)
    { return __builtin_scalbn(__x, __ex); }


  constexpr float
  tgamma(float __x)
  { return __builtin_tgammaf(__x); }

  constexpr long double
  tgamma(long double __x)
  { return __builtin_tgammal(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    tgamma(_Tp __x)
    { return __builtin_tgamma(__x); }


  constexpr float
  trunc(float __x)
  { return __builtin_truncf(__x); }

  constexpr long double
  trunc(long double __x)
  { return __builtin_truncl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    trunc(_Tp __x)
    { return __builtin_trunc(__x); }


}
#1797 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cmath" 3
}
#36 "C:/Xilinx/Vivado/2018.3/include/hls_math.h" 2
#1 "C:/Xilinx/Vivado/2018.3/include/hls_half.h" 1
#31 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cmath" 1 3
#39 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cmath" 3

#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cmath" 3
#32 "C:/Xilinx/Vivado/2018.3/include/hls_half.h" 2
#43 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstddef" 1 3
#42 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstddef" 3

#43 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstddef" 3







#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include/stddef.h" 1 3 4
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stddef.h" 1 3 4
#13 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stddef.h" 3 4
extern "C" {




  __attribute__ ((__dllimport__)) extern int *__attribute__((__cdecl__)) _errno(void);

  errno_t __attribute__((__cdecl__)) _set_errno(int _Value);
  errno_t __attribute__((__cdecl__)) _get_errno(int *_Value);


  __attribute__ ((__dllimport__)) extern unsigned long __attribute__((__cdecl__)) __threadid(void);

  __attribute__ ((__dllimport__)) extern uintptr_t __attribute__((__cdecl__)) __threadhandle(void);


}
#423 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;
#2 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include/stddef.h" 2 3 4
#51 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstddef" 2 3


namespace std
{

  using ::max_align_t;
}
#44 "C:/Xilinx/Vivado/2018.3/include/hls_half.h" 2
#1 "C:/Xilinx/Vivado/2018.3/include/hls_fpo.h" 1
#59 "C:/Xilinx/Vivado/2018.3/include/hls_fpo.h"
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/math.h" 1 3
#36 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/math.h" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cmath" 1 3
#39 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cmath" 3

#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cmath" 3
#37 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/math.h" 2 3

using std::abs;
using std::acos;
using std::asin;
using std::atan;
using std::atan2;
using std::cos;
using std::sin;
using std::tan;
using std::cosh;
using std::sinh;
using std::tanh;
using std::exp;
using std::frexp;
using std::ldexp;
using std::log;
using std::log10;
using std::modf;
using std::pow;
using std::sqrt;
using std::ceil;
using std::fabs;
using std::floor;
using std::fmod;


using std::fpclassify;
using std::isfinite;
using std::isinf;
using std::isnan;
using std::isnormal;
using std::signbit;
using std::isgreater;
using std::isgreaterequal;
using std::isless;
using std::islessequal;
using std::islessgreater;
using std::isunordered;



using std::acosh;
using std::asinh;
using std::atanh;
using std::cbrt;
using std::copysign;
using std::erf;
using std::erfc;
using std::exp2;
using std::expm1;
using std::fdim;
using std::fma;
using std::fmax;
using std::fmin;
using std::hypot;
using std::ilogb;
using std::lgamma;
using std::llrint;
using std::llround;
using std::log1p;
using std::log2;
using std::logb;
using std::lrint;
using std::lround;
using std::nearbyint;
using std::nextafter;
using std::nexttoward;
using std::remainder;
using std::remquo;
using std::rint;
using std::round;
using std::scalbln;
using std::scalbn;
using std::tgamma;
using std::trunc;
#60 "C:/Xilinx/Vivado/2018.3/include/hls_fpo.h" 2


#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/assert.h" 1 3
#17 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/assert.h" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/stdlib.h" 1 3
#36 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/stdlib.h" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdlib" 1 3
#39 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdlib" 3

#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
#75 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 1 3
#10 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include-fixed/limits.h" 1 3 4
#34 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include-fixed/limits.h" 3 4
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include-fixed/syslimits.h" 1 3 4






#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include-fixed/limits.h" 1 3 4
#168 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include-fixed/limits.h" 3 4
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/limits.h" 1 3 4
#169 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include-fixed/limits.h" 2 3 4
#8 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include-fixed/syslimits.h" 2 3 4
#35 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include-fixed/limits.h" 2 3 4
#11 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 2 3
#25 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
#pragma pack(push,_CRT_PACKING)


extern "C" {
#49 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  typedef int (__attribute__((__cdecl__)) *_onexit_t)(void);
#59 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  typedef struct _div_t {
    int quot;
    int rem;
  } div_t;

  typedef struct _ldiv_t {
    long quot;
    long rem;
  } ldiv_t;





#pragma pack(4)
  typedef struct {
    unsigned char ld[10];
  } _LDOUBLE;
#pragma pack()



  typedef struct {
    double x;
  } _CRT_DOUBLE;

  typedef struct {
    float f;
  } _CRT_FLOAT;




  typedef struct {
    long double x;
  } _LONGDOUBLE;



#pragma pack(4)
  typedef struct {
    unsigned char ld12[12];
  } _LDBL12;
#pragma pack()
#114 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  extern int * __imp___mb_cur_max;
#140 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  typedef void (__attribute__((__cdecl__)) *_purecall_handler)(void);

  __attribute__ ((__dllimport__)) _purecall_handler __attribute__((__cdecl__)) _set_purecall_handler(_purecall_handler _Handler);
  __attribute__ ((__dllimport__)) _purecall_handler __attribute__((__cdecl__)) _get_purecall_handler(void);

  typedef void (__attribute__((__cdecl__)) *_invalid_parameter_handler)(const wchar_t *,const wchar_t *,const wchar_t *,unsigned int,uintptr_t);
  __attribute__ ((__dllimport__)) _invalid_parameter_handler __attribute__((__cdecl__)) _set_invalid_parameter_handler(_invalid_parameter_handler _Handler);
  __attribute__ ((__dllimport__)) _invalid_parameter_handler __attribute__((__cdecl__)) _get_invalid_parameter_handler(void);
#156 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  __attribute__ ((__dllimport__)) unsigned long *__attribute__((__cdecl__)) __doserrno(void);

  errno_t __attribute__((__cdecl__)) _set_doserrno(unsigned long _Value);
  errno_t __attribute__((__cdecl__)) _get_doserrno(unsigned long *_Value);




  extern __attribute__((dllimport)) char *_sys_errlist[1];
  extern __attribute__((dllimport)) int _sys_nerr;
#180 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  extern int * __imp___argc;







  extern char *** __imp___argv;







  extern wchar_t *** __imp___wargv;
#208 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  extern char *** __imp__environ;
#217 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  extern wchar_t *** __imp__wenviron;
#226 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  extern char ** __imp__pgmptr;
#235 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  extern wchar_t ** __imp__wpgmptr;



  errno_t __attribute__((__cdecl__)) _get_pgmptr(char **_Value);
  errno_t __attribute__((__cdecl__)) _get_wpgmptr(wchar_t **_Value);




  extern int * __imp__fmode;



  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _set_fmode(int _Mode);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _get_fmode(int *_PMode);





  extern unsigned int * __imp__osplatform;
#265 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  extern unsigned int * __imp__osver;
#274 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  extern unsigned int * __imp__winver;
#283 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  extern unsigned int * __imp__winmajor;
#292 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  extern unsigned int * __imp__winminor;




  errno_t __attribute__((__cdecl__)) _get_osplatform(unsigned int *_Value);
  errno_t __attribute__((__cdecl__)) _get_osver(unsigned int *_Value);
  errno_t __attribute__((__cdecl__)) _get_winver(unsigned int *_Value);
  errno_t __attribute__((__cdecl__)) _get_winmajor(unsigned int *_Value);
  errno_t __attribute__((__cdecl__)) _get_winminor(unsigned int *_Value);




  extern "C++" {
    template <typename _CountofType,size_t _SizeOfArray> char (*__countof_helper( _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];

  }





  void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) exit(int _Code) __attribute__ ((__noreturn__));
  void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _exit(int _Code) __attribute__ ((__noreturn__));



  void __attribute__((__cdecl__)) _Exit(int) __attribute__ ((__noreturn__));








  void __attribute__((__cdecl__)) __attribute__((noreturn)) abort(void);




  __attribute__ ((__dllimport__)) unsigned int __attribute__((__cdecl__)) _set_abort_behavior(unsigned int _Flags,unsigned int _Mask);







  __extension__ long long __attribute__((__cdecl__)) _abs64(long long);

  extern __inline__ __attribute__((__always_inline__,__gnu_inline__)) long long __attribute__((__cdecl__)) _abs64(long long x) {
    return __builtin_llabs(x);
  }


  int __attribute__((__cdecl__)) atexit(void (__attribute__((__cdecl__)) *)(void));





  int __attribute__((__cdecl__)) atoi(const char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoi_l(const char *_Str,_locale_t _Locale);
  long __attribute__((__cdecl__)) atol(const char *_Str);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _atol_l(const char *_Str,_locale_t _Locale);


  void *__attribute__((__cdecl__)) bsearch(const void *_Key,const void *_Base,size_t _NumOfElements,size_t _SizeOfElements,int (__attribute__((__cdecl__)) *_PtFuncCompare)(const void *,const void *));
  void __attribute__((__cdecl__)) qsort(void *_Base,size_t _NumOfElements,size_t _SizeOfElements,int (__attribute__((__cdecl__)) *_PtFuncCompare)(const void *,const void *));

  unsigned short __attribute__((__cdecl__)) _byteswap_ushort(unsigned short _Short);
  unsigned long __attribute__((__cdecl__)) _byteswap_ulong (unsigned long _Long);
  __extension__ unsigned long long __attribute__((__cdecl__)) _byteswap_uint64(unsigned long long _Int64);
  div_t __attribute__((__cdecl__)) div(int _Numerator,int _Denominator);
  char *__attribute__((__cdecl__)) getenv(const char *_VarName) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _itoa(int _Value,char *_Dest,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _i64toa(long long _Val,char *_DstBuf,int _Radix) ;
  __extension__ __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ui64toa(unsigned long long _Val,char *_DstBuf,int _Radix) ;
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _atoi64(const char *_String);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _atoi64_l(const char *_String,_locale_t _Locale);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _strtoi64(const char *_String,char **_EndPtr,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _strtoi64_l(const char *_String,char **_EndPtr,int _Radix,_locale_t _Locale);
  __extension__ __attribute__ ((__dllimport__)) unsigned long long __attribute__((__cdecl__)) _strtoui64(const char *_String,char **_EndPtr,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) unsigned long long __attribute__((__cdecl__)) _strtoui64_l(const char *_String,char **_EndPtr,int _Radix,_locale_t _Locale);
  ldiv_t __attribute__((__cdecl__)) ldiv(long _Numerator,long _Denominator);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ltoa(long _Value,char *_Dest,int _Radix) ;
  int __attribute__((__cdecl__)) mblen(const char *_Ch,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _mblen_l(const char *_Ch,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstrlen(const char *_Str);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstrlen_l(const char *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstrnlen(const char *_Str,size_t _MaxCount);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstrnlen_l(const char *_Str,size_t _MaxCount,_locale_t _Locale);
  int __attribute__((__cdecl__)) mbtowc(wchar_t * __restrict__ _DstCh,const char * __restrict__ _SrcCh,size_t _SrcSizeInBytes);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _mbtowc_l(wchar_t * __restrict__ _DstCh,const char * __restrict__ _SrcCh,size_t _SrcSizeInBytes,_locale_t _Locale);
  size_t __attribute__((__cdecl__)) mbstowcs(wchar_t * __restrict__ _Dest,const char * __restrict__ _Source,size_t _MaxCount);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstowcs_l(wchar_t * __restrict__ _Dest,const char * __restrict__ _Source,size_t _MaxCount,_locale_t _Locale);
  int __attribute__((__cdecl__)) mkstemp(char *template_name);
  int __attribute__((__cdecl__)) rand(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _set_error_mode(int _Mode);
  void __attribute__((__cdecl__)) srand(unsigned int _Seed);
#404 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
inline __attribute__((__cdecl__))
double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtod(const char * __restrict__ _Str,char ** __restrict__ _EndPtr)
{
  double __attribute__((__cdecl__)) __mingw_strtod (const char * __restrict__, char ** __restrict__);
  return __mingw_strtod( _Str, _EndPtr);
}

inline __attribute__((__cdecl__))
float __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtof(const char * __restrict__ _Str,char ** __restrict__ _EndPtr)
{
  float __attribute__((__cdecl__)) __mingw_strtof (const char * __restrict__, char ** __restrict__);
  return __mingw_strtof( _Str, _EndPtr);
}






  long double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtold(const char * __restrict__ , char ** __restrict__ );


  extern double __attribute__((__cdecl__)) __attribute__ ((__nothrow__))
  __strtod (const char * __restrict__ , char ** __restrict__);






  float __attribute__((__cdecl__)) __mingw_strtof (const char * __restrict__, char ** __restrict__);
  double __attribute__((__cdecl__)) __mingw_strtod (const char * __restrict__, char ** __restrict__);
  long double __attribute__((__cdecl__)) __mingw_strtold(const char * __restrict__, char ** __restrict__);

  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _strtod_l(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,_locale_t _Locale);
  long __attribute__((__cdecl__)) strtol(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,int _Radix);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _strtol_l(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,int _Radix,_locale_t _Locale);
  unsigned long __attribute__((__cdecl__)) strtoul(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,int _Radix);
  __attribute__ ((__dllimport__)) unsigned long __attribute__((__cdecl__)) _strtoul_l(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,int _Radix,_locale_t _Locale);


  int __attribute__((__cdecl__)) system(const char *_Command);

  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ultoa(unsigned long _Value,char *_Dest,int _Radix) ;
  int __attribute__((__cdecl__)) wctomb(char *_MbCh,wchar_t _WCh) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wctomb_l(char *_MbCh,wchar_t _WCh,_locale_t _Locale) ;
  size_t __attribute__((__cdecl__)) wcstombs(char * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _MaxCount) ;
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _wcstombs_l(char * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _MaxCount,_locale_t _Locale) ;



  void *__attribute__((__cdecl__)) calloc(size_t _NumOfElements,size_t _SizeOfElements);
  void __attribute__((__cdecl__)) free(void *_Memory);
  void *__attribute__((__cdecl__)) malloc(size_t _Size);
  void *__attribute__((__cdecl__)) realloc(void *_Memory,size_t _NewSize);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _recalloc(void *_Memory,size_t _Count,size_t _Size);






  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _aligned_free(void *_Memory);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_malloc(size_t _Size,size_t _Alignment);



  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_offset_malloc(size_t _Size,size_t _Alignment,size_t _Offset);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_realloc(void *_Memory,size_t _Size,size_t _Alignment);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_recalloc(void *_Memory,size_t _Count,size_t _Size,size_t _Alignment);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_offset_realloc(void *_Memory,size_t _Size,size_t _Alignment,size_t _Offset);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_offset_recalloc(void *_Memory,size_t _Count,size_t _Size,size_t _Alignment,size_t _Offset);





  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _itow(int _Value,wchar_t *_Dest,int _Radix) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _ltow(long _Value,wchar_t *_Dest,int _Radix) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _ultow(unsigned long _Value,wchar_t *_Dest,int _Radix) ;

  double __attribute__((__cdecl__)) __mingw_wcstod(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr);
  float __attribute__((__cdecl__)) __mingw_wcstof(const wchar_t * __restrict__ nptr, wchar_t ** __restrict__ endptr);
  long double __attribute__((__cdecl__)) __mingw_wcstold(const wchar_t * __restrict__, wchar_t ** __restrict__);


  inline __attribute__((__cdecl__))
  double __attribute__((__cdecl__)) wcstod(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr){
    return __mingw_wcstod(_Str,_EndPtr);
  }
  inline __attribute__((__cdecl__))
  float __attribute__((__cdecl__)) wcstof(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr){
    return __mingw_wcstof(_Str,_EndPtr);
  }






  long double __attribute__((__cdecl__)) wcstold(const wchar_t * __restrict__, wchar_t ** __restrict__);

  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _wcstod_l(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,_locale_t _Locale);
  long __attribute__((__cdecl__)) wcstol(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,int _Radix);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wcstol_l(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,int _Radix,_locale_t _Locale);
  unsigned long __attribute__((__cdecl__)) wcstoul(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,int _Radix);
  __attribute__ ((__dllimport__)) unsigned long __attribute__((__cdecl__)) _wcstoul_l(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,int _Radix,_locale_t _Locale);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wgetenv(const wchar_t *_VarName) ;


  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wsystem(const wchar_t *_Command);

  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _wtof(const wchar_t *_Str);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _wtof_l(const wchar_t *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wtoi(const wchar_t *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wtoi_l(const wchar_t *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wtol(const wchar_t *_Str);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wtol_l(const wchar_t *_Str,_locale_t _Locale);

  __extension__ __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _i64tow(long long _Val,wchar_t *_DstBuf,int _Radix) ;
  __extension__ __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _ui64tow(unsigned long long _Val,wchar_t *_DstBuf,int _Radix) ;
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _wtoi64(const wchar_t *_Str);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _wtoi64_l(const wchar_t *_Str,_locale_t _Locale);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _wcstoi64(const wchar_t *_Str,wchar_t **_EndPtr,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _wcstoi64_l(const wchar_t *_Str,wchar_t **_EndPtr,int _Radix,_locale_t _Locale);
  __extension__ __attribute__ ((__dllimport__)) unsigned long long __attribute__((__cdecl__)) _wcstoui64(const wchar_t *_Str,wchar_t **_EndPtr,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) unsigned long long __attribute__((__cdecl__)) _wcstoui64_l(const wchar_t *_Str ,wchar_t **_EndPtr,int _Radix,_locale_t _Locale);


  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _putenv(const char *_EnvString);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wputenv(const wchar_t *_EnvString);



  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _fullpath(char *_FullPath,const char *_Path,size_t _SizeInBytes);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ecvt(double _Val,int _NumOfDigits,int *_PtDec,int *_PtSign) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _fcvt(double _Val,int _NumOfDec,int *_PtDec,int *_PtSign) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _gcvt(double _Val,int _NumOfDigits,char *_DstBuf) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atodbl(_CRT_DOUBLE *_Result,char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoldbl(_LDOUBLE *_Result,char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoflt(_CRT_FLOAT *_Result,char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atodbl_l(_CRT_DOUBLE *_Result,char *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoldbl_l(_LDOUBLE *_Result,char *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoflt_l(_CRT_FLOAT *_Result,char *_Str,_locale_t _Locale);
#563 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
unsigned long __attribute__((__cdecl__)) _lrotl(unsigned long,int);
unsigned long __attribute__((__cdecl__)) _lrotr(unsigned long,int);





  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _makepath(char *_Path,const char *_Drive,const char *_Dir,const char *_Filename,const char *_Ext);
  _onexit_t __attribute__((__cdecl__)) _onexit(_onexit_t _Func);



  void __attribute__((__cdecl__)) perror(const char *_ErrMsg);





  __extension__ unsigned long long __attribute__((__cdecl__)) _rotl64(unsigned long long _Val,int _Shift);
  __extension__ unsigned long long __attribute__((__cdecl__)) _rotr64(unsigned long long Value,int Shift);






  unsigned int __attribute__((__cdecl__)) _rotr(unsigned int _Val,int _Shift);
  unsigned int __attribute__((__cdecl__)) _rotl(unsigned int _Val,int _Shift);


  __extension__ unsigned long long __attribute__((__cdecl__)) _rotr64(unsigned long long _Val,int _Shift);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _searchenv(const char *_Filename,const char *_EnvVar,char *_ResultPath) ;
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _splitpath(const char *_FullPath,char *_Drive,char *_Dir,char *_Filename,char *_Ext) ;
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _swab(char *_Buf1,char *_Buf2,int _SizeInBytes);



  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wfullpath(wchar_t *_FullPath,const wchar_t *_Path,size_t _SizeInWords);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _wmakepath(wchar_t *_ResultPath,const wchar_t *_Drive,const wchar_t *_Dir,const wchar_t *_Filename,const wchar_t *_Ext);


  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _wperror(const wchar_t *_ErrMsg);

  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _wsearchenv(const wchar_t *_Filename,const wchar_t *_EnvVar,wchar_t *_ResultPath) ;
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _wsplitpath(const wchar_t *_FullPath,wchar_t *_Drive,wchar_t *_Dir,wchar_t *_Filename,wchar_t *_Ext) ;


  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _beep(unsigned _Frequency,unsigned _Duration) __attribute__ ((__deprecated__));

  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _seterrormode(int _Mode) __attribute__ ((__deprecated__));
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _sleep(unsigned long _Duration) __attribute__ ((__deprecated__));
#634 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  char *__attribute__((__cdecl__)) ecvt(double _Val,int _NumOfDigits,int *_PtDec,int *_PtSign) ;
  char *__attribute__((__cdecl__)) fcvt(double _Val,int _NumOfDec,int *_PtDec,int *_PtSign) ;
  char *__attribute__((__cdecl__)) gcvt(double _Val,int _NumOfDigits,char *_DstBuf) ;
  char *__attribute__((__cdecl__)) itoa(int _Val,char *_DstBuf,int _Radix) ;
  char *__attribute__((__cdecl__)) ltoa(long _Val,char *_DstBuf,int _Radix) ;
  int __attribute__((__cdecl__)) putenv(const char *_EnvString) ;



  void __attribute__((__cdecl__)) swab(char *_Buf1,char *_Buf2,int _SizeInBytes) ;


  char *__attribute__((__cdecl__)) ultoa(unsigned long _Val,char *_Dstbuf,int _Radix) ;
  _onexit_t __attribute__((__cdecl__)) onexit(_onexit_t _Func);





  typedef struct { __extension__ long long quot, rem; } lldiv_t;

  __extension__ lldiv_t __attribute__((__cdecl__)) lldiv(long long, long long);

  __extension__ long long __attribute__((__cdecl__)) llabs(long long);




  __extension__ long long __attribute__((__cdecl__)) strtoll(const char * __restrict__, char ** __restrict, int);
  __extension__ unsigned long long __attribute__((__cdecl__)) strtoull(const char * __restrict__, char ** __restrict__, int);


  __extension__ long long __attribute__((__cdecl__)) atoll (const char *);


  __extension__ long long __attribute__((__cdecl__)) wtoll (const wchar_t *);
  __extension__ char *__attribute__((__cdecl__)) lltoa (long long, char *, int);
  __extension__ char *__attribute__((__cdecl__)) ulltoa (unsigned long long , char *, int);
  __extension__ wchar_t *__attribute__((__cdecl__)) lltow (long long, wchar_t *, int);
  __extension__ wchar_t *__attribute__((__cdecl__)) ulltow (unsigned long long, wchar_t *, int);
#689 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
}


#pragma pack(pop)

#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/stdlib_s.h" 1 3
#9 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/stdlib_s.h" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/stdlib.h" 1 3
#30 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/stdlib.h" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 1 3
#31 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/stdlib.h" 2 3
#10 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/stdlib_s.h" 2 3




extern "C" {


  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _dupenv_s(char **_PBuffer,size_t *_PBufferSizeInBytes,const char *_VarName);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _itoa_s(int _Value,char *_DstBuf,size_t _Size,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _i64toa_s(long long _Val,char *_DstBuf,size_t _Size,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ui64toa_s(unsigned long long _Val,char *_DstBuf,size_t _Size,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ltoa_s(long _Val,char *_DstBuf,size_t _Size,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) mbstowcs_s(size_t *_PtNumOfCharConverted,wchar_t *_DstBuf,size_t _SizeInWords,const char *_SrcBuf,size_t _MaxCount);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _mbstowcs_s_l(size_t *_PtNumOfCharConverted,wchar_t *_DstBuf,size_t _SizeInWords,const char *_SrcBuf,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ultoa_s(unsigned long _Val,char *_DstBuf,size_t _Size,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wctomb_s_l(int *_SizeConverted,char *_MbCh,size_t _SizeInBytes,wchar_t _WCh,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcstombs_s(size_t *_PtNumOfCharConverted,char *_Dst,size_t _DstSizeInBytes,const wchar_t *_Src,size_t _MaxCountInBytes);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcstombs_s_l(size_t *_PtNumOfCharConverted,char *_Dst,size_t _DstSizeInBytes,const wchar_t *_Src,size_t _MaxCountInBytes,_locale_t _Locale);



  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _itow_s (int _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ltow_s (long _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ultow_s (unsigned long _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wgetenv_s(size_t *_ReturnSize,wchar_t *_DstBuf,size_t _DstSizeInWords,const wchar_t *_VarName);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wdupenv_s(wchar_t **_Buffer,size_t *_BufferSizeInWords,const wchar_t *_VarName);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _i64tow_s(long long _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ui64tow_s(unsigned long long _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix);



  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ecvt_s(char *_DstBuf,size_t _Size,double _Val,int _NumOfDights,int *_PtDec,int *_PtSign);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _fcvt_s(char *_DstBuf,size_t _Size,double _Val,int _NumOfDec,int *_PtDec,int *_PtSign);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _gcvt_s(char *_DstBuf,size_t _Size,double _Val,int _NumOfDigits);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _makepath_s(char *_PathResult,size_t _Size,const char *_Drive,const char *_Dir,const char *_Filename,const char *_Ext);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _putenv_s(const char *_Name,const char *_Value);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _searchenv_s(const char *_Filename,const char *_EnvVar,char *_ResultPath,size_t _SizeInBytes);

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _splitpath_s(const char *_FullPath,char *_Drive,size_t _DriveSize,char *_Dir,size_t _DirSize,char *_Filename,size_t _FilenameSize,char *_Ext,size_t _ExtSize);
  extern "C++" { template <size_t __drive_size, size_t __dir_size, size_t __name_size, size_t __ext_size> inline errno_t __attribute__((__cdecl__)) _splitpath_s(const char *_Dest, char (&__drive)[__drive_size], char (&__dir)[__dir_size], char (&__name)[__name_size], char (&__ext)[__ext_size]) { return _splitpath_s(_Dest, __drive, __drive_size, __dir, __dir_size, __name, __name_size, __ext, __ext_size); } }



  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wmakepath_s(wchar_t *_PathResult,size_t _SizeInWords,const wchar_t *_Drive,const wchar_t *_Dir,const wchar_t *_Filename,const wchar_t *_Ext);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wputenv_s(const wchar_t *_Name,const wchar_t *_Value);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wsearchenv_s(const wchar_t *_Filename,const wchar_t *_EnvVar,wchar_t *_ResultPath,size_t _SizeInWords);

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wsplitpath_s(const wchar_t *_FullPath,wchar_t *_Drive,size_t _DriveSizeInWords,wchar_t *_Dir,size_t _DirSizeInWords,wchar_t *_Filename,size_t _FilenameSizeInWords,wchar_t *_Ext,size_t _ExtSizeInWords);
  extern "C++" { template <size_t __drive_size, size_t __dir_size, size_t __name_size, size_t __ext_size> inline errno_t __attribute__((__cdecl__)) _wsplitpath_s(const wchar_t *_Dest, wchar_t (&__drive)[__drive_size], wchar_t (&__dir)[__dir_size], wchar_t (&__name)[__name_size], wchar_t (&__ext)[__ext_size]) { return _wsplitpath_s(_Dest, __drive, __drive_size, __dir, __dir_size, __name, __name_size, __ext, __ext_size); } }





  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) qsort_s(void *_Base,size_t _NumOfElements,size_t _SizeOfElements,int (__attribute__((__cdecl__)) *_PtFuncCompare)(void *,const void *,const void *),void *_Context);





}
#695 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 2 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/malloc.h" 1 3
#11 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/malloc.h" 3
#pragma pack(push,_CRT_PACKING)


extern "C" {
#46 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/malloc.h" 3
  typedef struct _heapinfo {
    int *_pentry;
    size_t _size;
    int _useflag;
  } _HEAPINFO;


  extern unsigned int _amblksiz;
#65 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/malloc.h" 3


#97 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/malloc.h" 3






void * __mingw_aligned_malloc (size_t _Size, size_t _Alignment);
void __mingw_aligned_free (void *_Memory);
void * __mingw_aligned_offset_realloc (void *_Memory, size_t _Size, size_t _Alignment, size_t _Offset);
void * __mingw_aligned_realloc (void *_Memory, size_t _Size, size_t _Offset);



  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _resetstkoflw (void);
  __attribute__ ((__dllimport__)) unsigned long __attribute__((__cdecl__)) _set_malloc_crt_max_wait(unsigned long _NewValue);

  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _expand(void *_Memory,size_t _NewSize);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _msize(void *_Memory);






  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _get_sbh_threshold(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _set_sbh_threshold(size_t _NewValue);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _set_amblksiz(size_t _Value);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _get_amblksiz(size_t *_Value);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapadd(void *_Memory,size_t _Size);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapchk(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapmin(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapset(unsigned int _Fill);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapwalk(_HEAPINFO *_EntryInfo);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _heapused(size_t *_Used,size_t *_Commit);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _get_heap_handle(void);
#144 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/malloc.h" 3
  static __inline void *_MarkAllocaS(void *_Ptr,unsigned int _Marker) {
    if(_Ptr) {
      *((unsigned int*)_Ptr) = _Marker;
      _Ptr = (char*)_Ptr + 16;
    }
    return _Ptr;
  }
#163 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/malloc.h" 3
  static __inline void __attribute__((__cdecl__)) _freea(void *_Memory) {
    unsigned int _Marker;
    if(_Memory) {
      _Memory = (char*)_Memory - 16;
      _Marker = *(unsigned int *)_Memory;
      if(_Marker==0xDDDD) {
 free(_Memory);
      }





    }
  }
#206 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/malloc.h" 3
}


#pragma pack(pop)
#696 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 2 3
#76 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdlib" 2 3
#118 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
extern "C++"
{
namespace std
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;
  using ::abs;
  using ::atexit;





  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;





  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;



  inline long
  abs(long __i) { return __builtin_labs(__i); }

  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }



  inline long long
  abs(long long __x) { return __builtin_llabs (__x); }



  inline __int128
  abs(__int128 __x) { return __x >= 0 ? __x : -__x; }
#201 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdlib" 3

}
#215 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
namespace __gnu_cxx
{



  using ::lldiv_t;





  using ::_Exit;



  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
#247 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}



}
#37 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/stdlib.h" 2 3

using std::abort;
using std::atexit;
using std::exit;
#51 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/stdlib.h" 3
using std::div_t;
using std::ldiv_t;

using std::abs;
using std::atof;
using std::atoi;
using std::atol;
using std::bsearch;
using std::calloc;
using std::div;
using std::free;
using std::getenv;
using std::labs;
using std::ldiv;
using std::malloc;

using std::mblen;
using std::mbstowcs;
using std::mbtowc;

using std::qsort;
using std::rand;
using std::realloc;
using std::srand;
using std::strtod;
using std::strtol;
using std::strtoul;
using std::system;

using std::wcstombs;
using std::wctomb;
#18 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/assert.h" 2 3



extern "C" {
#45 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/assert.h" 3
extern void __attribute__((__cdecl__))
_wassert(const wchar_t *_Message,const wchar_t *_File,unsigned _Line);
extern void __attribute__((__cdecl__))
_assert (const char *_Message, const char *_File, unsigned _Line);


}
#63 "C:/Xilinx/Vivado/2018.3/include/hls_fpo.h" 2
#186 "C:/Xilinx/Vivado/2018.3/include/hls_fpo.h"
#1 "C:/Xilinx/Vivado/2018.3/include/floating_point_v7_0_bitacc_cmodel.h" 1
#114 "C:/Xilinx/Vivado/2018.3/include/floating_point_v7_0_bitacc_cmodel.h"
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include/stdint.h" 1 3 4
#9 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include/stdint.h" 3 4
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdint.h" 1 3 4
#32 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdint.h" 3 4
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include/stddef.h" 1 3 4
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stddef.h" 1 3 4
#2 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include/stddef.h" 2 3 4
#33 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdint.h" 2 3 4


typedef signed char int8_t;
typedef unsigned char uint8_t;
typedef short int16_t;
typedef unsigned short uint16_t;
typedef int int32_t;
typedef unsigned uint32_t;
__extension__ typedef long long int64_t;
__extension__ typedef unsigned long long uint64_t;


typedef signed char int_least8_t;
typedef unsigned char uint_least8_t;
typedef short int_least16_t;
typedef unsigned short uint_least16_t;
typedef int int_least32_t;
typedef unsigned uint_least32_t;
__extension__ typedef long long int_least64_t;
__extension__ typedef unsigned long long uint_least64_t;





typedef signed char int_fast8_t;
typedef unsigned char uint_fast8_t;
typedef short int_fast16_t;
typedef unsigned short uint_fast16_t;
typedef int int_fast32_t;
typedef unsigned int uint_fast32_t;
__extension__ typedef long long int_fast64_t;
__extension__ typedef unsigned long long uint_fast64_t;


__extension__ typedef long long intmax_t;
__extension__ typedef unsigned long long uintmax_t;
#10 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include/stdint.h" 2 3 4
#115 "C:/Xilinx/Vivado/2018.3/include/floating_point_v7_0_bitacc_cmodel.h" 2

#115 "C:/Xilinx/Vivado/2018.3/include/floating_point_v7_0_bitacc_cmodel.h"
typedef int8_t xint8;
typedef int16_t xint16;
typedef int32_t xint32;
typedef int64_t xint64;
typedef uint8_t xuint8;
typedef uint16_t xuint16;
typedef uint32_t xuint32;
typedef uint64_t xuint64;


#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include/stdbool.h" 1 3 4
#126 "C:/Xilinx/Vivado/2018.3/include/floating_point_v7_0_bitacc_cmodel.h" 2


#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 1 3
#11 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_print_push.h" 1 3
#12 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 2 3

#pragma pack(push,_CRT_PACKING)



#16 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
extern "C" {
#26 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
  struct _iobuf {
    char *_ptr;
    int _cnt;
    char *_base;
    int _flag;
    int _file;
    int _charbuf;
    int _bufsiz;
    char *_tmpfname;
  };
  typedef struct _iobuf FILE;
#80 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_off_t.h" 1 3




  typedef long _off_t;

  typedef long off32_t;





  __extension__ typedef long long _off64_t;

  __extension__ typedef long long off64_t;
#26 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_off_t.h" 3
typedef off32_t off_t;
#81 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 2 3



  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) __iob_func(void);
#103 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
  __extension__ typedef long long fpos_t;
#139 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
extern
  __attribute__((__format__ (gnu_scanf, 2, 3))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_sscanf(const char * __restrict__ _Src,const char * __restrict__ _Format,...);
extern
  __attribute__((__format__ (gnu_scanf, 2, 0))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vsscanf (const char * __restrict__ _Str,const char * __restrict__ Format,va_list argp);
extern
  __attribute__((__format__ (gnu_scanf, 1, 2))) __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_scanf(const char * __restrict__ _Format,...);
extern
  __attribute__((__format__ (gnu_scanf, 1, 0))) __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_vscanf(const char * __restrict__ Format, va_list argp);
extern
  __attribute__((__format__ (gnu_scanf, 2, 3))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_fscanf(FILE * __restrict__ _File,const char * __restrict__ _Format,...);
extern
  __attribute__((__format__ (gnu_scanf, 2, 0))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vfscanf (FILE * __restrict__ fp, const char * __restrict__ Format,va_list argp);

extern
  __attribute__((__format__ (gnu_printf, 3, 0))) __attribute__ ((__nonnull__ (3)))
  int __attribute__((__cdecl__)) __mingw_vsnprintf(char * __restrict__ _DstBuf,size_t _MaxCount,const char * __restrict__ _Format,
                               va_list _ArgList);
extern
  __attribute__((__format__ (gnu_printf, 3, 4))) __attribute__ ((__nonnull__ (3)))
  int __attribute__((__cdecl__)) __mingw_snprintf(char * __restrict__ s, size_t n, const char * __restrict__ format, ...);
extern
  __attribute__((__format__ (gnu_printf, 1, 2))) __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_printf(const char * __restrict__ , ... ) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 1, 0))) __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_vprintf (const char * __restrict__ , va_list) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 2, 3))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_fprintf (FILE * __restrict__ , const char * __restrict__ , ...) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 2, 0))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vfprintf (FILE * __restrict__ , const char * __restrict__ , va_list) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 2, 3))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_sprintf (char * __restrict__ , const char * __restrict__ , ...) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 2, 0))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vsprintf (char * __restrict__ , const char * __restrict__ , va_list) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 2, 3))) __attribute__((nonnull (1,2)))
  int __attribute__((__cdecl__)) __mingw_asprintf(char ** __restrict__ , const char * __restrict__ , ...) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 2, 0))) __attribute__((nonnull (1,2)))
  int __attribute__((__cdecl__)) __mingw_vasprintf(char ** __restrict__ , const char * __restrict__ , va_list) __attribute__ ((__nothrow__));
#222 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
extern "C++" {


inline __attribute__((__cdecl__))
__attribute__((__format__ (gnu_scanf, 2, 3))) __attribute__ ((__nonnull__ (2)))
int sscanf(const char *__source, const char *__format, ...)
{
  register int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __mingw_vsscanf( __source, __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}

inline __attribute__((__cdecl__))
__attribute__((__format__ (gnu_scanf, 1, 2))) __attribute__ ((__nonnull__ (1)))
int scanf(const char *__format, ...)
{
  register int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __mingw_vscanf( __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}

inline __attribute__((__cdecl__))
__attribute__((__format__ (gnu_scanf, 2, 3))) __attribute__ ((__nonnull__ (2)))
int fscanf(FILE *__stream, const char *__format, ...)
{
  register int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __mingw_vfscanf( __stream, __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}



#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wshadow"


inline __attribute__((__cdecl__))
__attribute__((__format__ (gnu_scanf, 2, 0))) __attribute__ ((__nonnull__ (2)))
int vsscanf (const char *__source, const char *__format, __builtin_va_list __local_argv)
{
  return __mingw_vsscanf( __source, __format, __local_argv );
}

inline __attribute__((__cdecl__))
__attribute__((__format__ (gnu_scanf, 1, 0))) __attribute__ ((__nonnull__ (1)))
int vscanf(const char *__format, __builtin_va_list __local_argv)
{
  return __mingw_vscanf( __format, __local_argv );
}

inline __attribute__((__cdecl__))
__attribute__((__format__ (gnu_scanf, 2, 0))) __attribute__ ((__nonnull__ (2)))
int vfscanf (FILE *__stream, const char *__format, __builtin_va_list __local_argv)
{
  return __mingw_vfscanf( __stream, __format, __local_argv );
}


#pragma GCC diagnostic pop





inline __attribute__((__cdecl__))
__attribute__((__format__ (gnu_printf, 2, 3))) __attribute__ ((__nonnull__ (2)))
int fprintf (FILE *__stream, const char *__format, ...)
{
  register int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __mingw_vfprintf( __stream, __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}

inline __attribute__((__cdecl__))
__attribute__((__format__ (gnu_printf, 1, 2))) __attribute__ ((__nonnull__ (1)))
int printf (const char *__format, ...)
{
  register int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __mingw_vprintf( __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}

inline __attribute__((__cdecl__))
__attribute__((__format__ (gnu_printf, 2, 3))) __attribute__ ((__nonnull__ (2)))
int sprintf (char *__stream, const char *__format, ...)
{
  register int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __mingw_vsprintf( __stream, __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}

inline __attribute__((__cdecl__))
__attribute__((__format__ (gnu_printf, 2, 0))) __attribute__ ((__nonnull__ (2)))
int vfprintf (FILE *__stream, const char *__format, __builtin_va_list __local_argv)
{
  return __mingw_vfprintf( __stream, __format, __local_argv );
}

inline __attribute__((__cdecl__))
__attribute__((__format__ (gnu_printf, 1, 0))) __attribute__ ((__nonnull__ (1)))
int vprintf (const char *__format, __builtin_va_list __local_argv)
{
  return __mingw_vprintf( __format, __local_argv );
}

inline __attribute__((__cdecl__))
__attribute__((__format__ (gnu_printf, 2, 0))) __attribute__ ((__nonnull__ (2)))
int vsprintf (char *__stream, const char *__format, __builtin_va_list __local_argv)
{
  return __mingw_vsprintf( __stream, __format, __local_argv );
}

inline __attribute__((__cdecl__))
__attribute__((__format__ (gnu_printf, 3, 4))) __attribute__ ((__nonnull__ (3)))
int snprintf (char *__stream, size_t __n, const char *__format, ...)
{
  register int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __mingw_vsnprintf( __stream, __n, __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}

inline __attribute__((__cdecl__))
__attribute__((__format__ (gnu_printf, 3, 0))) __attribute__ ((__nonnull__ (3)))
int vsnprintf (char *__stream, size_t __n, const char *__format, __builtin_va_list __local_argv)
{
  return __mingw_vsnprintf( __stream, __n, __format, __local_argv );
}
#371 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
}
#450 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _filbuf(FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _flsbuf(int _Ch,FILE *_File);



  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _fsopen(const char *_Filename,const char *_Mode,int _ShFlag);

  void __attribute__((__cdecl__)) clearerr(FILE *_File);
  int __attribute__((__cdecl__)) fclose(FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fcloseall(void);



  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _fdopen(int _FileHandle,const char *_Mode);

  int __attribute__((__cdecl__)) feof(FILE *_File);
  int __attribute__((__cdecl__)) ferror(FILE *_File);
  int __attribute__((__cdecl__)) fflush(FILE *_File);
  int __attribute__((__cdecl__)) fgetc(FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fgetchar(void);
  int __attribute__((__cdecl__)) fgetpos(FILE * __restrict__ _File ,fpos_t * __restrict__ _Pos);
  int __attribute__((__cdecl__)) fgetpos64(FILE * __restrict__ _File ,fpos_t * __restrict__ _Pos);
  char *__attribute__((__cdecl__)) fgets(char * __restrict__ _Buf,int _MaxCount,FILE * __restrict__ _File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fileno(FILE *_File);



  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _tempnam(const char *_DirName,const char *_FilePrefix);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _flushall(void);
  FILE *__attribute__((__cdecl__)) fopen(const char * __restrict__ _Filename,const char * __restrict__ _Mode) ;
  FILE *fopen64(const char * __restrict__ filename,const char * __restrict__ mode);
  int __attribute__((__cdecl__)) fputc(int _Ch,FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fputchar(int _Ch);
  int __attribute__((__cdecl__)) fputs(const char * __restrict__ _Str,FILE * __restrict__ _File);
  size_t __attribute__((__cdecl__)) fread(void * __restrict__ _DstBuf,size_t _ElementSize,size_t _Count,FILE * __restrict__ _File);
  FILE *__attribute__((__cdecl__)) freopen(const char * __restrict__ _Filename,const char * __restrict__ _Mode,FILE * __restrict__ _File) ;
  int __attribute__((__cdecl__)) fsetpos(FILE *_File,const fpos_t *_Pos);
  int __attribute__((__cdecl__)) fsetpos64(FILE *_File,const fpos_t *_Pos);
  int __attribute__((__cdecl__)) fseek(FILE *_File,long _Offset,int _Origin);



  int fseeko64(FILE* stream, _off64_t offset, int whence);
  int fseeko(FILE* stream, _off_t offset, int whence);
#502 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
  long __attribute__((__cdecl__)) ftell(FILE *_File);

  _off_t ftello(FILE * stream);
  _off64_t ftello64(FILE * stream);
#514 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
  __extension__ int __attribute__((__cdecl__)) _fseeki64(FILE *_File,long long _Offset,int _Origin);
  __extension__ long long __attribute__((__cdecl__)) _ftelli64(FILE *_File);
  size_t __attribute__((__cdecl__)) fwrite(const void * __restrict__ _Str,size_t _Size,size_t _Count,FILE * __restrict__ _File);
  int __attribute__((__cdecl__)) getc(FILE *_File);
  int __attribute__((__cdecl__)) getchar(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _getmaxstdio(void);
  char *__attribute__((__cdecl__)) gets(char *_Buffer) ;
  int __attribute__((__cdecl__)) _getw(FILE *_File);




  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _pclose(FILE *_File);
  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _popen(const char *_Command,const char *_Mode);




  int __attribute__((__cdecl__)) putc(int _Ch,FILE *_File);
  int __attribute__((__cdecl__)) putchar(int _Ch);
  int __attribute__((__cdecl__)) puts(const char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _putw(int _Word,FILE *_File);


  int __attribute__((__cdecl__)) remove(const char *_Filename);
  int __attribute__((__cdecl__)) rename(const char *_OldFilename,const char *_NewFilename);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _unlink(const char *_Filename);

  int __attribute__((__cdecl__)) unlink(const char *_Filename) ;


  void __attribute__((__cdecl__)) rewind(FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _rmtmp(void);
  void __attribute__((__cdecl__)) setbuf(FILE * __restrict__ _File,char * __restrict__ _Buffer) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _setmaxstdio(int _Max);
  __attribute__ ((__dllimport__)) unsigned int __attribute__((__cdecl__)) _set_output_format(unsigned int _Format);
  __attribute__ ((__dllimport__)) unsigned int __attribute__((__cdecl__)) _get_output_format(void);
  int __attribute__((__cdecl__)) setvbuf(FILE * __restrict__ _File,char * __restrict__ _Buf,int _Mode,size_t _Size);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scprintf(const char * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snscanf(const char * __restrict__ _Src,size_t _MaxCount,const char * __restrict__ _Format,...) ;
  FILE *__attribute__((__cdecl__)) tmpfile(void) ;
  char *__attribute__((__cdecl__)) tmpnam(char *_Buffer);
  int __attribute__((__cdecl__)) ungetc(int _Ch,FILE *_File);

  __attribute__((__format__ (ms_printf, 3, 4))) __attribute__ ((__nonnull__ (3)))
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snprintf(char * __restrict__ _Dest,size_t _Count,const char * __restrict__ _Format,...) ;
  __attribute__((__format__ (ms_printf, 3, 0))) __attribute__ ((__nonnull__ (3)))
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnprintf(char * __restrict__ _Dest,size_t _Count,const char * __restrict__ _Format,va_list _Args) ;
#610 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vscprintf(const char * __restrict__ _Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _set_printf_count_output(int _Value);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _get_printf_count_output(void);




                                                     __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_swscanf(const wchar_t * __restrict__ _Src,const wchar_t * __restrict__ _Format,...);
                                                     __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vswscanf (const wchar_t * __restrict__ _Str,const wchar_t * __restrict__ Format,va_list argp);
                                                     __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_wscanf(const wchar_t * __restrict__ _Format,...);
                                                     __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_vwscanf(const wchar_t * __restrict__ Format, va_list argp);
                                                     __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_fwscanf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,...);
                                                     __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vfwscanf (FILE * __restrict__ fp, const wchar_t * __restrict__ Format,va_list argp);

                                                      __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_fwprintf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,...);
                                                      __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_wprintf(const wchar_t * __restrict__ _Format,...);
                                                     __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vfwprintf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,va_list _ArgList);
                                                     __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_vwprintf(const wchar_t * __restrict__ _Format,va_list _ArgList);
                                                      __attribute__ ((__nonnull__ (3)))
  int __attribute__((__cdecl__)) __mingw_snwprintf (wchar_t * __restrict__ s, size_t n, const wchar_t * __restrict__ format, ...);
                                                      __attribute__ ((__nonnull__ (3)))
  int __attribute__((__cdecl__)) __mingw_vsnwprintf (wchar_t * __restrict__ , size_t, const wchar_t * __restrict__ , va_list);
                                                      __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_swprintf(wchar_t * __restrict__ , const wchar_t * __restrict__ , ...);
                                                      __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vswprintf(wchar_t * __restrict__ , const wchar_t * __restrict__ ,va_list);






inline __attribute__((__cdecl__))
                                                     __attribute__ ((__nonnull__ (2)))
int swscanf(const wchar_t *__source, const wchar_t *__format, ...)
{
  register int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __mingw_vswscanf( __source, __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}

inline __attribute__((__cdecl__))
                                                     __attribute__ ((__nonnull__ (1)))
int wscanf(const wchar_t *__format, ...)
{
  register int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __mingw_vwscanf( __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}

inline __attribute__((__cdecl__))
                                                     __attribute__ ((__nonnull__ (2)))
int fwscanf(FILE *__stream, const wchar_t *__format, ...)
{
  register int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __mingw_vfwscanf( __stream, __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}


inline __attribute__((__cdecl__))
                                                     __attribute__ ((__nonnull__ (2)))
int vswscanf (const wchar_t * __restrict__ __source, const wchar_t * __restrict__ __format, __builtin_va_list __local_argv)
{
  return __mingw_vswscanf( __source, __format, __local_argv );
}

inline __attribute__((__cdecl__))
                                                     __attribute__ ((__nonnull__ (1)))
int vwscanf(const wchar_t *__format, __builtin_va_list __local_argv)
{
  return __mingw_vwscanf( __format, __local_argv );
}

inline __attribute__((__cdecl__))
                                                     __attribute__ ((__nonnull__ (2)))
int vfwscanf (FILE *__stream, const wchar_t *__format, __builtin_va_list __local_argv)
{
  return __mingw_vfwscanf( __stream, __format, __local_argv );
}




inline __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (2)))
int fwprintf (FILE *__stream, const wchar_t *__format, ...)
{
  register int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __mingw_vfwprintf( __stream, __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}

inline __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (1)))
int wprintf (const wchar_t *__format, ...)
{
  register int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __mingw_vwprintf( __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}

inline __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (2)))
int vfwprintf (FILE *__stream, const wchar_t *__format, __builtin_va_list __local_argv)
{
  return __mingw_vfwprintf( __stream, __format, __local_argv );
}

inline __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (1)))
int vwprintf (const wchar_t *__format, __builtin_va_list __local_argv)
{
  return __mingw_vwprintf( __format, __local_argv );
}


inline __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (3)))
int snwprintf (wchar_t *__stream, size_t __n, const wchar_t *__format, ...)
{
  register int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __mingw_vsnwprintf( __stream, __n, __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}

inline __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (3)))
int vsnwprintf (wchar_t *__stream, size_t __n, const wchar_t *__format, __builtin_va_list __local_argv)
{
  return __mingw_vsnwprintf( __stream, __n, __format, __local_argv );
}
#811 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _wfsopen(const wchar_t *_Filename,const wchar_t *_Mode,int _ShFlag);


  wint_t __attribute__((__cdecl__)) fgetwc(FILE *_File);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _fgetwchar(void);
  wint_t __attribute__((__cdecl__)) fputwc(wchar_t _Ch,FILE *_File);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _fputwchar(wchar_t _Ch);
  wint_t __attribute__((__cdecl__)) getwc(FILE *_File);
  wint_t __attribute__((__cdecl__)) getwchar(void);
  wint_t __attribute__((__cdecl__)) putwc(wchar_t _Ch,FILE *_File);
  wint_t __attribute__((__cdecl__)) putwchar(wchar_t _Ch);
  wint_t __attribute__((__cdecl__)) ungetwc(wint_t _Ch,FILE *_File);
  wchar_t *__attribute__((__cdecl__)) fgetws(wchar_t * __restrict__ _Dst,int _SizeInWords,FILE * __restrict__ _File);
  int __attribute__((__cdecl__)) fputws(const wchar_t * __restrict__ _Str,FILE * __restrict__ _File);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _getws(wchar_t *_String) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _putws(const wchar_t *_Str);

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scwprintf(const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swprintf_c(wchar_t * __restrict__ _DstBuf,size_t _SizeInWords,const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vswprintf_c(wchar_t * __restrict__ _DstBuf,size_t _SizeInWords,const wchar_t * __restrict__ _Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwprintf(wchar_t * __restrict__ _Dest,size_t _Count,const wchar_t * __restrict__ _Format,...) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnwprintf(wchar_t * __restrict__ _Dest,size_t _Count,const wchar_t * __restrict__ _Format,va_list _Args) ;
#863 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swprintf(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vswprintf(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Format,va_list _Args);


#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/swprintf.inl" 1 3
#21 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/swprintf.inl" 3
static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (3)))
int vswprintf (wchar_t *__stream, size_t __count, const wchar_t *__format, __builtin_va_list __local_argv)
{
  return vsnwprintf( __stream, __count, __format, __local_argv );
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (3)))
int swprintf (wchar_t *__stream, size_t __count, const wchar_t *__format, ...)
{
  register int __retval;
  __builtin_va_list __local_argv;

  __builtin_va_start( __local_argv, __format );
  __retval = vswprintf( __stream, __count, __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}



extern "C++" {

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (2)))
int vswprintf (wchar_t *__stream, const wchar_t *__format, __builtin_va_list __local_argv)
{

  return __mingw_vswprintf( __stream, __format, __local_argv );



}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (2)))
int swprintf (wchar_t *__stream, const wchar_t *__format, ...)
{
  register int __retval;
  __builtin_va_list __local_argv;

  __builtin_va_start( __local_argv, __format );
  __retval = vswprintf( __stream, __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}

}
#868 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 2 3
#877 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wtempnam(const wchar_t *_Directory,const wchar_t *_FilePrefix);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vscwprintf(const wchar_t * __restrict__ _Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwscanf(const wchar_t * __restrict__ _Src,size_t _MaxCount,const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _wfdopen(int _FileHandle ,const wchar_t *_Mode);
  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _wfopen(const wchar_t * __restrict__ _Filename,const wchar_t *__restrict__ _Mode) ;
  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _wfreopen(const wchar_t * __restrict__ _Filename,const wchar_t * __restrict__ _Mode,FILE * __restrict__ _OldFile) ;





  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _wpopen(const wchar_t *_Command,const wchar_t *_Mode);




  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wremove(const wchar_t *_Filename);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wtmpnam(wchar_t *_Buffer);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _fgetwc_nolock(FILE *_File);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _fputwc_nolock(wchar_t _Ch,FILE *_File);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _ungetwc_nolock(wint_t _Ch,FILE *_File);
#927 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _lock_file(FILE *_File);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _unlock_file(FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fclose_nolock(FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fflush_nolock(FILE *_File);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _fread_nolock(void * __restrict__ _DstBuf,size_t _ElementSize,size_t _Count,FILE * __restrict__ _File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fseek_nolock(FILE *_File,long _Offset,int _Origin);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _ftell_nolock(FILE *_File);
  __extension__ __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fseeki64_nolock(FILE *_File,long long _Offset,int _Origin);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _ftelli64_nolock(FILE *_File);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _fwrite_nolock(const void * __restrict__ _DstBuf,size_t _Size,size_t _Count,FILE * __restrict__ _File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _ungetc_nolock(int _Ch,FILE *_File);





  char *__attribute__((__cdecl__)) tempnam(const char *_Directory,const char *_FilePrefix) ;
  int __attribute__((__cdecl__)) fcloseall(void) ;
  FILE *__attribute__((__cdecl__)) fdopen(int _FileHandle,const char *_Format) ;
  int __attribute__((__cdecl__)) fgetchar(void) ;
  int __attribute__((__cdecl__)) fileno(FILE *_File) ;
  int __attribute__((__cdecl__)) flushall(void) ;
  int __attribute__((__cdecl__)) fputchar(int _Ch) ;
  int __attribute__((__cdecl__)) getw(FILE *_File) ;
  int __attribute__((__cdecl__)) putw(int _Ch,FILE *_File) ;
  int __attribute__((__cdecl__)) rmtmp(void) ;
#969 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
int __attribute__((__cdecl__)) __mingw_str_wide_utf8 (const wchar_t * const wptr, char **mbptr, size_t * buflen);
#983 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
int __attribute__((__cdecl__)) __mingw_str_utf8_wide (const char *const mbptr, wchar_t ** wptr, size_t * buflen);
#992 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
void __attribute__((__cdecl__)) __mingw_str_free(void *ptr);





  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnl(int _Mode,const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnle(int _Mode,const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnlp(int _Mode,const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnlpe(int _Mode,const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnv(int _Mode,const wchar_t *_Filename,const wchar_t *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnve(int _Mode,const wchar_t *_Filename,const wchar_t *const *_ArgList,const wchar_t *const *_Env);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnvp(int _Mode,const wchar_t *_Filename,const wchar_t *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnvpe(int _Mode,const wchar_t *_Filename,const wchar_t *const *_ArgList,const wchar_t *const *_Env);
#1022 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnv(int _Mode,const char *_Filename,const char *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnve(int _Mode,const char *_Filename,const char *const *_ArgList,const char *const *_Env);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnvp(int _Mode,const char *_Filename,const char *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnvpe(int _Mode,const char *_Filename,const char *const *_ArgList,const char *const *_Env);



}


#pragma pack(pop)

#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/stdio_s.h" 1 3
#9 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/stdio_s.h" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 1 3
#10 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/stdio_s.h" 2 3
#23 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/stdio_s.h" 3
extern "C" {




  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) clearerr_s(FILE *_File);
  int __attribute__((__cdecl__)) fprintf_s(FILE *_File,const char *_Format,...);
  size_t __attribute__((__cdecl__)) fread_s(void *_DstBuf,size_t _DstSize,size_t _ElementSize,size_t _Count,FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fscanf_s_l(FILE *_File,const char *_Format,_locale_t _Locale,...);
  int __attribute__((__cdecl__)) printf_s(const char *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scanf_l(const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scanf_s_l(const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snprintf_c(char *_DstBuf,size_t _MaxCount,const char *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnprintf_c(char *_DstBuf,size_t _MaxCount,const char *_Format,va_list _ArgList);

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fscanf_l(FILE *_File,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _sscanf_l(const char *_Src,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _sscanf_s_l(const char *_Src,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) sscanf_s(const char *_Src,const char *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snscanf_s(const char *_Src,size_t _MaxCount,const char *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snscanf_l(const char *_Src,size_t _MaxCount,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snscanf_s_l(const char *_Src,size_t _MaxCount,const char *_Format,_locale_t _Locale,...);
  int __attribute__((__cdecl__)) vfprintf_s(FILE *_File,const char *_Format,va_list _ArgList);
  int __attribute__((__cdecl__)) vprintf_s(const char *_Format,va_list _ArgList);

  int __attribute__((__cdecl__)) vsnprintf_s(char *_DstBuf,size_t _DstSize,size_t _MaxCount,const char *_Format,va_list _ArgList);
  extern "C++" { template <size_t __size> inline int __attribute__((__cdecl__)) vsnprintf_s(char (&_DstBuf)[__size], size_t _MaxCount, const char* _Format, va_list _ArgList) { return vsnprintf_s(_DstBuf,__size,_MaxCount,_Format,_ArgList); } }

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnprintf_s(char *_DstBuf,size_t _DstSize,size_t _MaxCount,const char *_Format,va_list _ArgList);
  extern "C++" { template <size_t __size> inline int __attribute__((__cdecl__)) _vsnprintf_s(char (&_DstBuf)[__size], size_t _MaxCount, const char* _Format, va_list _ArgList) { return _vsnprintf_s(_DstBuf,__size,_MaxCount,_Format,_ArgList); } }

  __attribute__((dllimport)) int __attribute__((__cdecl__)) vsprintf_s(char *_DstBuf,size_t _Size,const char *_Format,va_list _ArgList);
  extern "C++" { template <size_t __size> inline int __attribute__((__cdecl__)) vsprintf_s(char (&_DstBuf)[__size], const char* _Format, va_list _ArgList) { return vsprintf_s(_DstBuf,__size,_Format,_ArgList); } }

  __attribute__((dllimport)) int __attribute__((__cdecl__)) sprintf_s(char *_DstBuf,size_t _DstSize,const char *_Format,...);
  extern "C++" { template <size_t __size> inline int __attribute__((__cdecl__)) sprintf_s(char (&_DstBuf)[__size], const char* _Format, ...) { va_list __vaargs; __builtin_va_start(__vaargs,_Format); int __retval = vsprintf_s(_DstBuf,__size,_Format,__vaargs); __builtin_va_end(__vaargs); return __retval; } }

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snprintf_s(char *_DstBuf,size_t _DstSize,size_t _MaxCount,const char *_Format,...);
  extern "C++" { template <size_t __size> inline int __attribute__((__cdecl__)) _snprintf_s(char (&_DstBuf)[__size], size_t _MaxCount, const char* _Format, ...) { va_list __vaargs; __builtin_va_start(__vaargs,_Format); int __retval = _vsnprintf_s(_DstBuf,__size,_MaxCount,_Format,__vaargs); __builtin_va_end(__vaargs); return __retval; } }

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fprintf_p(FILE *_File,const char *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _printf_p(const char *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _sprintf_p(char *_Dst,size_t _MaxCount,const char *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfprintf_p(FILE *_File,const char *_Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vprintf_p(const char *_Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsprintf_p(char *_Dst,size_t _MaxCount,const char *_Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scprintf_p(const char *_Format,...);
  __attribute__((dllimport)) int __attribute__((__cdecl__)) _vscprintf_p(const char *_Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _printf_l(const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _printf_p_l(const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vprintf_l(const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vprintf_p_l(const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fprintf_l(FILE *_File,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fprintf_p_l(FILE *_File,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfprintf_l(FILE *_File,const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfprintf_p_l(FILE *_File,const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _sprintf_l(char *_DstBuf,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _sprintf_p_l(char *_DstBuf,size_t _MaxCount,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsprintf_l(char *_DstBuf,const char *_Format,_locale_t,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsprintf_p_l(char *_DstBuf,size_t _MaxCount,const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scprintf_l(const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scprintf_p_l(const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vscprintf_l(const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vscprintf_p_l(const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _printf_s_l(const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vprintf_s_l(const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fprintf_s_l(FILE *_File,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfprintf_s_l(FILE *_File,const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _sprintf_s_l(char *_DstBuf,size_t _DstSize,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsprintf_s_l(char *_DstBuf,size_t _DstSize,const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snprintf_s_l(char *_DstBuf,size_t _DstSize,size_t _MaxCount,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnprintf_s_l(char *_DstBuf,size_t _DstSize,size_t _MaxCount,const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snprintf_l(char *_DstBuf,size_t _MaxCount,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snprintf_c_l(char *_DstBuf,size_t _MaxCount,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnprintf_l(char *_DstBuf,size_t _MaxCount,const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnprintf_c_l(char *_DstBuf,size_t _MaxCount,const char *,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) fopen_s(FILE **_File,const char *_Filename,const char *_Mode);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) freopen_s(FILE** _File, const char *_Filename, const char *_Mode, FILE *_Stream);

  __attribute__ ((__dllimport__)) char* __attribute__((__cdecl__)) gets_s(char*,rsize_t);
  extern "C++" { template <size_t __size> inline char* __attribute__((__cdecl__)) get_s(char (&_DstBuf)[__size]) { return get_s(_DstBuf,__size); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) tmpnam_s(char*,rsize_t);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) tmpnam_s(char (&_DstBuf)[__size]) { return tmpnam_s(_DstBuf,__size); } }




  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _getws_s(wchar_t *_Str,size_t _SizeInWords);
  extern "C++" { template <size_t __size> inline wchar_t* __attribute__((__cdecl__)) _getws_s(wchar_t (&_DstBuf)[__size]) { return _getws_s(_DstBuf,__size); } }

  int __attribute__((__cdecl__)) fwprintf_s(FILE *_File,const wchar_t *_Format,...);
  int __attribute__((__cdecl__)) wprintf_s(const wchar_t *_Format,...);
  int __attribute__((__cdecl__)) vfwprintf_s(FILE *_File,const wchar_t *_Format,va_list _ArgList);
  int __attribute__((__cdecl__)) vwprintf_s(const wchar_t *_Format,va_list _ArgList);

  int __attribute__((__cdecl__)) vswprintf_s(wchar_t *_Dst,size_t _SizeInWords,const wchar_t *_Format,va_list _ArgList);
  extern "C++" { template <size_t __size> inline int __attribute__((__cdecl__)) vswprintf_s(wchar_t (&_Dst)[__size], const wchar_t* _Format, va_list _ArgList) { return vswprintf_s(_Dst,__size,_Format,_ArgList); } }

  int __attribute__((__cdecl__)) swprintf_s(wchar_t *_Dst,size_t _SizeInWords,const wchar_t *_Format,...);
  extern "C++" { template <size_t __size> inline int __attribute__((__cdecl__)) swprintf_s(wchar_t (&_Dst)[__size], const wchar_t* _Format, ...) { va_list __vaargs; __builtin_va_start(__vaargs,_Format); int __retval = vswprintf_s(_Dst,__size,_Format,__vaargs); __builtin_va_end(__vaargs); return __retval; } }

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnwprintf_s(wchar_t *_DstBuf,size_t _DstSizeInWords,size_t _MaxCount,const wchar_t *_Format,va_list _ArgList);
  extern "C++" { template <size_t __size> inline int __attribute__((__cdecl__)) _vsnwprintf_s(wchar_t (&_DstBuf)[__size], size_t _MaxCount, const wchar_t* _Format, va_list _ArgList) { return _vsnwprintf_s(_DstBuf,__size,_MaxCount,_Format,_ArgList); } }

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwprintf_s(wchar_t *_DstBuf,size_t _DstSizeInWords,size_t _MaxCount,const wchar_t *_Format,...);
  extern "C++" { template <size_t __size> inline int __attribute__((__cdecl__)) _snwprintf_s(wchar_t (&_DstBuf)[__size], size_t _MaxCount, const wchar_t* _Format, ...) { va_list __vaargs; __builtin_va_start(__vaargs,_Format); int __retval = _vsnwprintf_s(_DstBuf,__size,_MaxCount,_Format,__vaargs); __builtin_va_end(__vaargs); return __retval; } }


  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wprintf_s_l(const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vwprintf_s_l(const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fwprintf_s_l(FILE *_File,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfwprintf_s_l(FILE *_File,const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swprintf_s_l(wchar_t *_DstBuf,size_t _DstSize,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vswprintf_s_l(wchar_t *_DstBuf,size_t _DstSize,const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwprintf_s_l(wchar_t *_DstBuf,size_t _DstSize,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnwprintf_s_l(wchar_t *_DstBuf,size_t _DstSize,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fwscanf_s_l(FILE *_File,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swscanf_s_l(const wchar_t *_Src,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) swscanf_s(const wchar_t *_Src,const wchar_t *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwscanf_s(const wchar_t *_Src,size_t _MaxCount,const wchar_t *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwscanf_s_l(const wchar_t *_Src,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wscanf_s_l(const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wfopen_s(FILE **_File,const wchar_t *_Filename,const wchar_t *_Mode);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wfreopen_s(FILE **_File,const wchar_t *_Filename,const wchar_t *_Mode,FILE *_OldFile);

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wtmpnam_s(wchar_t *_DstBuf,size_t _SizeInWords);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _wtmpnam_s(wchar_t (&_DstBuf)[__size]) { return _wtmpnam_s(_DstBuf,__size); } }

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fwprintf_p(FILE *_File,const wchar_t *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wprintf_p(const wchar_t *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfwprintf_p(FILE *_File,const wchar_t *_Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vwprintf_p(const wchar_t *_Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swprintf_p(wchar_t *_DstBuf,size_t _MaxCount,const wchar_t *_Format,...);
  __attribute__((dllimport)) int __attribute__((__cdecl__)) _vswprintf_p(wchar_t *_DstBuf,size_t _MaxCount,const wchar_t *_Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scwprintf_p(const wchar_t *_Format,...);
  __attribute__((dllimport)) int __attribute__((__cdecl__)) _vscwprintf_p(const wchar_t *_Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wprintf_l(const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wprintf_p_l(const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vwprintf_l(const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vwprintf_p_l(const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fwprintf_l(FILE *_File,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fwprintf_p_l(FILE *_File,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfwprintf_l(FILE *_File,const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfwprintf_p_l(FILE *_File,const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swprintf_c_l(wchar_t *_DstBuf,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swprintf_p_l(wchar_t *_DstBuf,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vswprintf_c_l(wchar_t *_DstBuf,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vswprintf_p_l(wchar_t *_DstBuf,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scwprintf_l(const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scwprintf_p_l(const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vscwprintf_p_l(const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwprintf_l(wchar_t *_DstBuf,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnwprintf_l(wchar_t *_DstBuf,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __swprintf_l(wchar_t *_Dest,const wchar_t *_Format,_locale_t _Plocinfo,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __vswprintf_l(wchar_t *_Dest,const wchar_t *_Format,_locale_t _Plocinfo,va_list _Args);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vscwprintf_l(const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fwscanf_l(FILE *_File,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swscanf_l(const wchar_t *_Src,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwscanf_l(const wchar_t *_Src,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wscanf_l(const wchar_t *_Format,_locale_t _Locale,...);



  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _fread_nolock_s(void *_DstBuf,size_t _DstSize,size_t _ElementSize,size_t _Count,FILE *_File);


}
#1035 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 2 3

#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_print_pop.h" 1 3
#1037 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 2 3
#129 "C:/Xilinx/Vivado/2018.3/include/floating_point_v7_0_bitacc_cmodel.h" 2
#143 "C:/Xilinx/Vivado/2018.3/include/floating_point_v7_0_bitacc_cmodel.h"
#1 "C:/Xilinx/Vivado/2018.3/include/gmp.h" 1
#26 "C:/Xilinx/Vivado/2018.3/include/gmp.h"
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/iosfwd" 1 3
#36 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/iosfwd" 3

#37 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/iosfwd" 3


#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stringfwd.h" 1 3
#37 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stringfwd.h" 3

#38 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stringfwd.h" 3


#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/memoryfwd.h" 1 3
#46 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/memoryfwd.h" 3

#47 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/memoryfwd.h" 3



namespace std
{

#63 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/memoryfwd.h" 3
  template<typename>
    class allocator;

  template<>
    class allocator<void>;


  template<typename, typename>
    struct uses_allocator;




}
#41 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stringfwd.h" 2 3

namespace std
{








  template<class _CharT>
    struct char_traits;

  template<> struct char_traits<char>;


  template<> struct char_traits<wchar_t>;




  template<> struct char_traits<char16_t>;
  template<> struct char_traits<char32_t>;


namespace __cxx11 {

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;


  typedef basic_string<char> string;



  typedef basic_string<wchar_t> wstring;





  typedef basic_string<char16_t> u16string;


  typedef basic_string<char32_t> u32string;


}




}
#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/iosfwd" 2 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/postypes.h" 1 3
#38 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/postypes.h" 3

#39 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/postypes.h" 3

#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cwchar" 1 3
#39 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cwchar" 3

#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cwchar" 3




#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 1 3
#10 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_print_push.h" 1 3
#11 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 2 3
#25 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
#pragma pack(push,_CRT_PACKING)


extern "C" {
#80 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
  typedef unsigned long _fsize_t;




  struct _wfinddata32_t {
    unsigned attrib;
    __time32_t time_create;
    __time32_t time_access;
    __time32_t time_write;
    _fsize_t size;
    wchar_t name[260];
  };

  struct _wfinddata32i64_t {
    unsigned attrib;
    __time32_t time_create;
    __time32_t time_access;
    __time32_t time_write;
    __extension__ long long size;
    wchar_t name[260];
  };

  struct _wfinddata64i32_t {
    unsigned attrib;
    __time64_t time_create;
    __time64_t time_access;
    __time64_t time_write;
    _fsize_t size;
    wchar_t name[260];
  };

  struct _wfinddata64_t {
    unsigned attrib;
    __time64_t time_create;
    __time64_t time_access;
    __time64_t time_write;
    __extension__ long long size;
    wchar_t name[260];
  };
#178 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
  extern unsigned short ** __imp__pctype;
#192 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
  extern unsigned short ** __imp__wctype;
#207 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
  extern unsigned short ** __imp__pwctype;
#231 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
  int __attribute__((__cdecl__)) iswalpha(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswalpha_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswupper(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswupper_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswlower(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswlower_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswdigit(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswdigit_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswxdigit(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswxdigit_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswspace(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswspace_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswpunct(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswpunct_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswalnum(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswalnum_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswprint(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswprint_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswgraph(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswgraph_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswcntrl(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswcntrl_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswascii(wint_t _C);
  int __attribute__((__cdecl__)) isleadbyte(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isleadbyte_l(int _C,_locale_t _Locale);
  wint_t __attribute__((__cdecl__)) towupper(wint_t _C);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _towupper_l(wint_t _C,_locale_t _Locale);
  wint_t __attribute__((__cdecl__)) towlower(wint_t _C);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _towlower_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswctype(wint_t _C,wctype_t _Type);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswctype_l(wint_t _C,wctype_t _Type,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __iswcsymf(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswcsymf_l(wint_t _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __iswcsym(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswcsym_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) is_wctype(wint_t _C,wctype_t _Type);


  int __attribute__((__cdecl__)) iswblank(wint_t _C);







  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wgetcwd(wchar_t *_DstBuf,int _SizeInWords);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wgetdcwd(int _Drive,wchar_t *_DstBuf,int _SizeInWords);
  wchar_t *__attribute__((__cdecl__)) _wgetdcwd_nolock(int _Drive,wchar_t *_DstBuf,int _SizeInWords);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wchdir(const wchar_t *_Path);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wmkdir(const wchar_t *_Path);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wrmdir(const wchar_t *_Path);





  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _waccess(const wchar_t *_Filename,int _AccessMode);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wchmod(const wchar_t *_Filename,int _Mode);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcreat(const wchar_t *_Filename,int _PermissionMode) ;
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wfindfirst32(const wchar_t *_Filename,struct _wfinddata32_t *_FindData);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wfindnext32(intptr_t _FindHandle,struct _wfinddata32_t *_FindData);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wunlink(const wchar_t *_Filename);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wrename(const wchar_t *_OldFilename,const wchar_t *_NewFilename);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wmktemp(wchar_t *_TemplateName) ;
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wfindfirst32i64(const wchar_t *_Filename,struct _wfinddata32i64_t *_FindData);
  intptr_t __attribute__((__cdecl__)) _wfindfirst64i32(const wchar_t *_Filename,struct _wfinddata64i32_t *_FindData);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wfindfirst64(const wchar_t *_Filename,struct _wfinddata64_t *_FindData);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wfindnext32i64(intptr_t _FindHandle,struct _wfinddata32i64_t *_FindData);
  int __attribute__((__cdecl__)) _wfindnext64i32(intptr_t _FindHandle,struct _wfinddata64i32_t *_FindData);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wfindnext64(intptr_t _FindHandle,struct _wfinddata64_t *_FindData);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wsopen_s(int *_FileHandle,const wchar_t *_Filename,int _OpenFlag,int _ShareFlag,int _PermissionFlag);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wopen(const wchar_t *_Filename,int _OpenFlag,...) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wsopen(const wchar_t *_Filename,int _OpenFlag,int _ShareFlag,...) ;




  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wsetlocale(int _Category,const wchar_t *_Locale);




  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexecl(const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexecle(const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexeclp(const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexeclpe(const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexecv(const wchar_t *_Filename,const wchar_t *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexecve(const wchar_t *_Filename,const wchar_t *const *_ArgList,const wchar_t *const *_Env);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexecvp(const wchar_t *_Filename,const wchar_t *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexecvpe(const wchar_t *_Filename,const wchar_t *const *_ArgList,const wchar_t *const *_Env);
#378 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
  typedef unsigned short _ino_t;

  typedef unsigned short ino_t;





  typedef unsigned int _dev_t;

  typedef unsigned int dev_t;




#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_stat64.h" 1 3
#19 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_stat64.h" 3
  struct _stat32 {
    _dev_t st_dev;
   _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    _off_t st_size;
    __time32_t st_atime;
    __time32_t st_mtime;
    __time32_t st_ctime;
  };


  struct stat {
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    _off_t st_size;
    time_t st_atime;
    time_t st_mtime;
    time_t st_ctime;
  };


  struct _stat32i64 {
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    __extension__ long long st_size;
    __time32_t st_atime;
    __time32_t st_mtime;
    __time32_t st_ctime;
  };

  struct _stat64i32 {
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    _off_t st_size;
    __time64_t st_atime;
    __time64_t st_mtime;
    __time64_t st_ctime;
  };

  struct _stat64 {
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    __extension__ long long st_size;
    __time64_t st_atime;
    __time64_t st_mtime;
    __time64_t st_ctime;
  };
#394 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 2 3




  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wstat32(const wchar_t *_Name,struct _stat32 *_Stat);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wstat32i64(const wchar_t *_Name,struct _stat32i64 *_Stat);
  int __attribute__((__cdecl__)) _wstat64i32(const wchar_t *_Name,struct _stat64i32 *_Stat);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wstat64(const wchar_t *_Name,struct _stat64 *_Stat);
#412 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
  __attribute__ ((__dllimport__)) wchar_t *_cgetws(wchar_t *_Buffer) ;
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _getwch(void);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _getwche(void);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _putwch(wchar_t _WCh);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _ungetwch(wint_t _WCh);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cputws(const wchar_t *_String);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwprintf(const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwscanf(const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwscanf_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vcwprintf(const wchar_t * __restrict__ _Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwprintf_p(const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vcwprintf_p(const wchar_t * __restrict__ _Format,va_list _ArgList);

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwprintf_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vcwprintf_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwprintf_p_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vcwprintf_p_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,va_list _ArgList);
  wint_t __attribute__((__cdecl__)) _putwch_nolock(wchar_t _WCh);
  wint_t __attribute__((__cdecl__)) _getwch_nolock(void);
  wint_t __attribute__((__cdecl__)) _getwche_nolock(void);
  wint_t __attribute__((__cdecl__)) _ungetwch_nolock(wint_t _WCh);
#851 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcsdup(const wchar_t *_Str);
  wchar_t *__attribute__((__cdecl__)) wcscat(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source) ;
  wchar_t *__attribute__((__cdecl__)) wcschr(const wchar_t *_Str,wchar_t _Ch);
  int __attribute__((__cdecl__)) wcscmp(const wchar_t *_Str1,const wchar_t *_Str2);
  wchar_t *__attribute__((__cdecl__)) wcscpy(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source) ;
  size_t __attribute__((__cdecl__)) wcscspn(const wchar_t *_Str,const wchar_t *_Control);
  size_t __attribute__((__cdecl__)) wcslen(const wchar_t *_Str);
  size_t __attribute__((__cdecl__)) wcsnlen(const wchar_t *_Src,size_t _MaxCount);
  wchar_t *__attribute__((__cdecl__)) wcsncat(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _Count) ;
  int __attribute__((__cdecl__)) wcsncmp(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount);
  wchar_t *__attribute__((__cdecl__)) wcsncpy(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _Count) ;
  wchar_t *__attribute__((__cdecl__)) _wcsncpy_l(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _Count,_locale_t _Locale) ;
  wchar_t *__attribute__((__cdecl__)) wcspbrk(const wchar_t *_Str,const wchar_t *_Control);
  wchar_t *__attribute__((__cdecl__)) wcsrchr(const wchar_t *_Str,wchar_t _Ch);
  size_t __attribute__((__cdecl__)) wcsspn(const wchar_t *_Str,const wchar_t *_Control);
  wchar_t *__attribute__((__cdecl__)) wcsstr(const wchar_t *_Str,const wchar_t *_SubStr);
  wchar_t *__attribute__((__cdecl__)) wcstok(wchar_t * __restrict__ _Str,const wchar_t * __restrict__ _Delim) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcserror(int _ErrNum) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) __wcserror(const wchar_t *_Str) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsicmp(const wchar_t *_Str1,const wchar_t *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsicmp_l(const wchar_t *_Str1,const wchar_t *_Str2,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsnicmp(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsnicmp_l(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcsnset(wchar_t *_Str,wchar_t _Val,size_t _MaxCount) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcsrev(wchar_t *_Str);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcsset(wchar_t *_Str,wchar_t _Val) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcslwr(wchar_t *_String) ;
  __attribute__ ((__dllimport__)) wchar_t *_wcslwr_l(wchar_t *_String,_locale_t _Locale) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcsupr(wchar_t *_String) ;
  __attribute__ ((__dllimport__)) wchar_t *_wcsupr_l(wchar_t *_String,_locale_t _Locale) ;
  size_t __attribute__((__cdecl__)) wcsxfrm(wchar_t * __restrict__ _Dst,const wchar_t * __restrict__ _Src,size_t _MaxCount);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _wcsxfrm_l(wchar_t * __restrict__ _Dst,const wchar_t * __restrict__ _Src,size_t _MaxCount,_locale_t _Locale);
  int __attribute__((__cdecl__)) wcscoll(const wchar_t *_Str1,const wchar_t *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcscoll_l(const wchar_t *_Str1,const wchar_t *_Str2,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsicoll(const wchar_t *_Str1,const wchar_t *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsicoll_l(const wchar_t *_Str1,const wchar_t *_Str2,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsncoll(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsncoll_l(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsnicoll(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsnicoll_l(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount,_locale_t _Locale);


  wchar_t *__attribute__((__cdecl__)) wcsdup(const wchar_t *_Str) ;

  int __attribute__((__cdecl__)) wcsicmp(const wchar_t *_Str1,const wchar_t *_Str2) ;
  int __attribute__((__cdecl__)) wcsnicmp(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount) ;
  wchar_t *__attribute__((__cdecl__)) wcsnset(wchar_t *_Str,wchar_t _Val,size_t _MaxCount) ;
  wchar_t *__attribute__((__cdecl__)) wcsrev(wchar_t *_Str) ;
  wchar_t *__attribute__((__cdecl__)) wcsset(wchar_t *_Str,wchar_t _Val) ;
  wchar_t *__attribute__((__cdecl__)) wcslwr(wchar_t *_Str) ;
  wchar_t *__attribute__((__cdecl__)) wcsupr(wchar_t *_Str) ;
  int __attribute__((__cdecl__)) wcsicoll(const wchar_t *_Str1,const wchar_t *_Str2) ;





  struct tm {
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
  };





  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wasctime(const struct tm *_Tm);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wasctime_s (wchar_t *_Buf,size_t _SizeInWords,const struct tm *_Tm);
  wchar_t *__attribute__((__cdecl__)) _wctime32(const __time32_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wctime32_s (wchar_t *_Buf,size_t _SizeInWords,const __time32_t *_Time);
  size_t __attribute__((__cdecl__)) wcsftime(wchar_t * __restrict__ _Buf,size_t _SizeInWords,const wchar_t * __restrict__ _Format,const struct tm * __restrict__ _Tm);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _wcsftime_l(wchar_t * __restrict__ _Buf,size_t _SizeInWords,const wchar_t * __restrict__ _Format,const struct tm * __restrict__ _Tm,_locale_t _Locale);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wstrdate(wchar_t *_Buffer) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wstrdate_s (wchar_t *_Buf,size_t _SizeInWords);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wstrtime(wchar_t *_Buffer) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wstrtime_s (wchar_t *_Buf,size_t _SizeInWords);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wctime64(const __time64_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wctime64_s (wchar_t *_Buf,size_t _SizeInWords,const __time64_t *_Time);



  wchar_t *__attribute__((__cdecl__)) _wctime(const time_t *_Time) ;
#951 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
  errno_t __attribute__((__cdecl__)) _wctime_s(wchar_t *, size_t, const time_t *);
#963 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
  typedef int mbstate_t;
  typedef wchar_t _Wint_t;

  wint_t __attribute__((__cdecl__)) btowc(int);
  size_t __attribute__((__cdecl__)) mbrlen(const char * __restrict__ _Ch,size_t _SizeInBytes,mbstate_t * __restrict__ _State);
  size_t __attribute__((__cdecl__)) mbrtowc(wchar_t * __restrict__ _DstCh,const char * __restrict__ _SrcCh,size_t _SizeInBytes,mbstate_t * __restrict__ _State);
  size_t __attribute__((__cdecl__)) mbsrtowcs(wchar_t * __restrict__ _Dest,const char ** __restrict__ _PSrc,size_t _Count,mbstate_t * __restrict__ _State) ;
  size_t __attribute__((__cdecl__)) wcrtomb(char * __restrict__ _Dest,wchar_t _Source,mbstate_t * __restrict__ _State) ;
  size_t __attribute__((__cdecl__)) wcsrtombs(char * __restrict__ _Dest,const wchar_t ** __restrict__ _PSource,size_t _Count,mbstate_t * __restrict__ _State) ;
  int __attribute__((__cdecl__)) wctob(wint_t _WCh);


  wchar_t *__attribute__((__cdecl__)) wmemset(wchar_t *s, wchar_t c, size_t n);
  wchar_t *__attribute__((__cdecl__)) wmemchr(const wchar_t *s, wchar_t c, size_t n);
  int __attribute__((__cdecl__)) wmemcmp(const wchar_t *s1, const wchar_t *s2,size_t n);
  wchar_t *__attribute__((__cdecl__)) wmemcpy(wchar_t * __restrict__ s1,const wchar_t * __restrict__ s2,size_t n) ;
  wchar_t * __attribute__((__cdecl__)) wmempcpy (wchar_t *_Dst, const wchar_t *_Src, size_t _Size);
  wchar_t *__attribute__((__cdecl__)) wmemmove(wchar_t *s1, const wchar_t *s2, size_t n) ;
  int __attribute__((__cdecl__)) fwide(FILE *stream,int mode);
  int __attribute__((__cdecl__)) mbsinit(const mbstate_t *ps);
  __extension__ long long __attribute__((__cdecl__)) wcstoll(const wchar_t * __restrict__ nptr,wchar_t ** __restrict__ endptr, int base);
  __extension__ unsigned long long __attribute__((__cdecl__)) wcstoull(const wchar_t * __restrict__ nptr,wchar_t ** __restrict__ endptr, int base);


  void *__attribute__((__cdecl__)) memmove(void *_Dst,const void *_Src,size_t _MaxCount);
  void *__attribute__((__cdecl__)) memcpy(void * __restrict__ _Dst,const void * __restrict__ _Src,size_t _MaxCount) ;
#1066 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
}


#pragma pack(pop)

#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/wchar_s.h" 1 3
#9 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/wchar_s.h" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 1 3
#10 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/wchar_s.h" 2 3
#23 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/wchar_s.h" 3
extern "C" {




  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _waccess_s (const wchar_t *_Filename,int _AccessMode);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wmktemp_s (wchar_t *_TemplateName,size_t _SizeInWords);




  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _cgetws_s (wchar_t *_Buffer,size_t _SizeInWords,size_t *_SizeRead);
  __attribute__((dllimport)) int __attribute__((__cdecl__)) _cwprintf_s (const wchar_t *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwscanf_s(const wchar_t *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwscanf_s_l(const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__((dllimport)) int __attribute__((__cdecl__)) _vcwprintf_s (const wchar_t *_Format,va_list _ArgList);
  __attribute__((dllimport)) int __attribute__((__cdecl__)) _cwprintf_s_l (const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__((dllimport)) int __attribute__((__cdecl__)) _vcwprintf_s_l (const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
#120 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/wchar_s.h" 3
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) wcstok_s(wchar_t *_Str,const wchar_t *_Delim,wchar_t **_Context);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcserror_s(wchar_t *_Buf,size_t _SizeInWords,int _ErrNum);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) __wcserror_s(wchar_t *_Buffer,size_t _SizeInWords,const wchar_t *_ErrMsg);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsnset_s(wchar_t *_Dst,size_t _DstSizeInWords,wchar_t _Val,size_t _MaxCount);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsset_s(wchar_t *_Str,size_t _SizeInWords,wchar_t _Val);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcslwr_s(wchar_t *_Str,size_t _SizeInWords);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcslwr_s_l(wchar_t *_Str,size_t _SizeInWords,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsupr_s(wchar_t *_Str,size_t _Size);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsupr_s_l(wchar_t *_Str,size_t _Size,_locale_t _Locale);

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcscat_s(wchar_t *_Dst, rsize_t _DstSize, const wchar_t *_Src);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) wcscat_s(wchar_t (&_Dest)[__size], const wchar_t * _Source) { return wcscat_s(_Dest,__size,_Source); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcscpy_s(wchar_t *_Dst, rsize_t _DstSize, const wchar_t *_Src);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) wcscpy_s(wchar_t (&_Dest)[__size], const wchar_t * _Source) { return wcscpy_s(_Dest,__size,_Source); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcsncat_s(wchar_t *_Dst,size_t _DstSizeInChars,const wchar_t *_Src,size_t _MaxCount);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsncat_s_l(wchar_t *_Dst,size_t _DstSizeInChars,const wchar_t *_Src,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcsncpy_s(wchar_t *_Dst,size_t _DstSizeInChars,const wchar_t *_Src,size_t _MaxCount);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsncpy_s_l(wchar_t *_Dst,size_t _DstSizeInChars,const wchar_t *_Src,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcstok_s_l(wchar_t *_Str,const wchar_t *_Delim,wchar_t **_Context,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsset_s_l(wchar_t *_Str,size_t _SizeInChars,unsigned int _Val,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsnset_s_l(wchar_t *_Str,size_t _SizeInChars,unsigned int _Val, size_t _Count,_locale_t _Locale);

  inline __attribute__((__always_inline__)) size_t __attribute__((__cdecl__)) wcsnlen_s(const wchar_t * _src, size_t _count) {
    return _src ? wcsnlen(_src, _count) : 0;
  }




  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wasctime_s (wchar_t *_Buf,size_t _SizeInWords,const struct tm *_Tm);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wctime32_s (wchar_t *_Buf,size_t _SizeInWords,const __time32_t *_Time);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wstrdate_s (wchar_t *_Buf,size_t _SizeInWords);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wstrtime_s (wchar_t *_Buf,size_t _SizeInWords);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wctime64_s (wchar_t *_Buf,size_t _SizeInWords,const __time64_t *_Time);
#165 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/wchar_s.h" 3
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) mbsrtowcs_s(size_t *_Retval,wchar_t *_Dst,size_t _SizeInWords,const char **_PSrc,size_t _N,mbstate_t *_State);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) mbsrtowcs_s(size_t* _Retval, wchar_t (&_Dst)[__size], const char** _PSrc, size_t _N, mbstate_t _State) { return mbsrtowcs_s(_Retval, _Dst, __size, _PSrc, _N, _State); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcrtomb_s(size_t *_Retval,char *_Dst,size_t _SizeInBytes,wchar_t _Ch,mbstate_t *_State);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) wcrtomb_s(size_t* _Retval, char (&_Dst)[__size], wchar_t _Ch, mbstate_t _State) { return wcrtomb_s(_Retval, _Dst, __size, _Ch, _State); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcsrtombs_s(size_t *_Retval,char *_Dst,size_t _SizeInBytes,const wchar_t **_Src,size_t _Size,mbstate_t *_State);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) wcsrtombs_s(size_t _Retval, char (&_Dst)[__size], const wchar_t** _Src, size_t _Size, mbstate_t _State) { return wcsrtombs_s(_Retval, _Dst, __size, _Src, _Size, _State); } }

  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) wmemcpy_s (wchar_t *_dest,size_t _numberOfElements,const wchar_t *_src,size_t _count);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) wmemmove_s(wchar_t *_dest,size_t _numberOfElements,const wchar_t *_src,size_t _count);



}
#1072 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 2 3

#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_print_pop.h" 1 3
#1074 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 2 3
#45 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cwchar" 2 3
#62 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cwchar" 3
namespace std
{
  using ::mbstate_t;
}
#135 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cwchar" 3
namespace std
{


  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;

  using ::swprintf;

  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;


  using ::vswprintf;


  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;


  inline wchar_t*
  wcschr(wchar_t* __p, wchar_t __c)
  { return wcschr(const_cast<const wchar_t*>(__p), __c); }

  inline wchar_t*
  wcspbrk(wchar_t* __s1, const wchar_t* __s2)
  { return wcspbrk(const_cast<const wchar_t*>(__s1), __s2); }

  inline wchar_t*
  wcsrchr(wchar_t* __p, wchar_t __c)
  { return wcsrchr(const_cast<const wchar_t*>(__p), __c); }

  inline wchar_t*
  wcsstr(wchar_t* __s1, const wchar_t* __s2)
  { return wcsstr(const_cast<const wchar_t*>(__s1), __s2); }

  inline wchar_t*
  wmemchr(wchar_t* __p, wchar_t __c, size_t __n)
  { return wmemchr(const_cast<const wchar_t*>(__p), __c, __n); }



}







namespace __gnu_cxx
{





  using ::wcstold;
#257 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;

}

namespace std
{
  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;
}
#277 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cwchar" 3
namespace std
{

  using std::wcstof;


  using std::vfwscanf;


  using std::vswscanf;


  using std::vwscanf;



  using std::wcstold;
  using std::wcstoll;
  using std::wcstoull;

}
#41 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/postypes.h" 2 3
#68 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/postypes.h" 3
namespace std
{

#90 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/postypes.h" 3
  typedef long long streamoff;







  typedef ptrdiff_t streamsize;
#111 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
#133 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;



  typedef fpos<mbstate_t> u16streampos;

  typedef fpos<mbstate_t> u32streampos;



}
#41 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/iosfwd" 2 3

namespace std
{

#74 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/iosfwd" 3
  class ios_base;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;


namespace __cxx11 {

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

}

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  typedef basic_ios<char> ios;


  typedef basic_streambuf<char> streambuf;


  typedef basic_istream<char> istream;


  typedef basic_ostream<char> ostream;


  typedef basic_iostream<char> iostream;


  typedef basic_stringbuf<char> stringbuf;


  typedef basic_istringstream<char> istringstream;


  typedef basic_ostringstream<char> ostringstream;


  typedef basic_stringstream<char> stringstream;


  typedef basic_filebuf<char> filebuf;


  typedef basic_ifstream<char> ifstream;


  typedef basic_ofstream<char> ofstream;


  typedef basic_fstream<char> fstream;



  typedef basic_ios<wchar_t> wios;


  typedef basic_streambuf<wchar_t> wstreambuf;


  typedef basic_istream<wchar_t> wistream;


  typedef basic_ostream<wchar_t> wostream;


  typedef basic_iostream<wchar_t> wiostream;


  typedef basic_stringbuf<wchar_t> wstringbuf;


  typedef basic_istringstream<wchar_t> wistringstream;


  typedef basic_ostringstream<wchar_t> wostringstream;


  typedef basic_stringstream<wchar_t> wstringstream;


  typedef basic_filebuf<wchar_t> wfilebuf;


  typedef basic_ifstream<wchar_t> wifstream;


  typedef basic_ofstream<wchar_t> wofstream;


  typedef basic_fstream<wchar_t> wfstream;




}
#27 "C:/Xilinx/Vivado/2018.3/include/gmp.h" 2
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdio" 1 3
#39 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdio" 3

#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdio" 3
#96 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdio" 3
namespace std
{
  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;




  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;

  using ::tmpnam;

  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
#157 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdio" 3
namespace __gnu_cxx
{
#175 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;

}

namespace std
{
  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;
}
#28 "C:/Xilinx/Vivado/2018.3/include/gmp.h" 2
#198 "C:/Xilinx/Vivado/2018.3/include/gmp.h"

#198 "C:/Xilinx/Vivado/2018.3/include/gmp.h"
typedef unsigned long long int mp_limb_t;
typedef long long int mp_limb_signed_t;







typedef unsigned long long int mp_bitcnt_t;







typedef struct
{
  int _mp_alloc;

  int _mp_size;


  mp_limb_t *_mp_d;
} __mpz_struct;



typedef __mpz_struct mpz_t[1];

typedef mp_limb_t * mp_ptr;
typedef const mp_limb_t * mp_srcptr;


typedef long long int mp_size_t;
typedef long int mp_exp_t;






typedef struct
{
  __mpz_struct _mp_num;
  __mpz_struct _mp_den;
} __mpq_struct;

typedef __mpq_struct mpq_t[1];

typedef struct
{
  int _mp_prec;



  int _mp_size;


  mp_exp_t _mp_exp;
  mp_limb_t *_mp_d;
} __mpf_struct;

typedef __mpf_struct mpf_t[1];


typedef enum
{
  GMP_RAND_ALG_DEFAULT = 0,
  GMP_RAND_ALG_LC = GMP_RAND_ALG_DEFAULT
} gmp_randalg_t;


typedef struct
{
  mpz_t _mp_seed;
  gmp_randalg_t _mp_alg;
  union {
    void *_mp_lc;
  } _mp_algdata;
} __gmp_randstate_struct;
typedef __gmp_randstate_struct gmp_randstate_t[1];



typedef const __mpz_struct *mpz_srcptr;
typedef __mpz_struct *mpz_ptr;
typedef const __mpf_struct *mpf_srcptr;
typedef __mpf_struct *mpf_ptr;
typedef const __mpq_struct *mpq_srcptr;
typedef __mpq_struct *mpq_ptr;
#532 "C:/Xilinx/Vivado/2018.3/include/gmp.h"
extern "C" {
using std::FILE;



 void __gmp_set_memory_functions (void *(*) (size_t), void *(*) (void *, size_t, size_t), void (*) (void *, size_t))

                                      throw ();


 void __gmp_get_memory_functions (void *(**) (size_t), void *(**) (void *, size_t, size_t), void (**) (void *, size_t))

                                                                   throw ();


 extern const int __gmp_bits_per_limb;


 extern int __gmp_errno;


 extern const char * const __gmp_version;


 extern const char * const __mpir_version;





 void __gmp_randinit_default (gmp_randstate_t);


 void __gmp_randinit_lc_2exp (gmp_randstate_t, mpz_srcptr, unsigned long int, mp_bitcnt_t)

                          ;


 int __gmp_randinit_lc_2exp_size (gmp_randstate_t, mp_bitcnt_t);


 void __gmp_randinit_mt (gmp_randstate_t);


 void __gmp_randinit_set (gmp_randstate_t, const __gmp_randstate_struct *);


 void __gmp_randseed (gmp_randstate_t, mpz_srcptr);


 void __gmp_randseed_ui (gmp_randstate_t, unsigned long int);


 void __gmp_randclear (gmp_randstate_t);


 unsigned long __gmp_urandomb_ui (gmp_randstate_t, unsigned long);


 unsigned long __gmp_urandomm_ui (gmp_randstate_t, unsigned long);





 int __gmp_asprintf (char **, const char *, ...);



 int __gmp_fprintf (FILE *, const char *, ...);
#615 "C:/Xilinx/Vivado/2018.3/include/gmp.h"
 int __gmp_printf (const char *, ...);


 int __gmp_snprintf (char *, size_t, const char *, ...);


 int __gmp_sprintf (char *, const char *, ...);
#653 "C:/Xilinx/Vivado/2018.3/include/gmp.h"
 int __gmp_fscanf (FILE *, const char *, ...);



 int __gmp_scanf (const char *, ...);


 int __gmp_sscanf (const char *, const char *, ...);
#684 "C:/Xilinx/Vivado/2018.3/include/gmp.h"
 void *__gmpz_realloc (mpz_ptr, mp_size_t);




 void __gmpz_abs (mpz_ptr, mpz_srcptr);




 void __gmpz_add (mpz_ptr, mpz_srcptr, mpz_srcptr);



 void __gmpz_add_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_addmul (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_addmul_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_and (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_array_init (mpz_ptr, mp_size_t, mp_size_t);


 void __gmpz_bin_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_bin_uiui (mpz_ptr, unsigned long int, unsigned long int);


 void __gmpz_cdiv_q (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_cdiv_q_2exp (mpz_ptr, mpz_srcptr, unsigned long);


 unsigned long int __gmpz_cdiv_q_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_cdiv_qr (mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr);


 unsigned long int __gmpz_cdiv_qr_ui (mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_cdiv_r (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_cdiv_r_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);


 unsigned long int __gmpz_cdiv_r_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 unsigned long int __gmpz_cdiv_ui (mpz_srcptr, unsigned long int) __attribute__ ((__pure__));


 void __gmpz_clear (mpz_ptr);


 void __gmpz_clears (mpz_ptr, ...);


 void __gmpz_clrbit (mpz_ptr, mp_bitcnt_t);


 int __gmpz_cmp (mpz_srcptr, mpz_srcptr) throw () __attribute__ ((__pure__));


 int __gmpz_cmp_d (mpz_srcptr, double) __attribute__ ((__pure__));


 int __gmpz_cmp_si (mpz_srcptr, signed long int) throw () __attribute__ ((__pure__));


 int __gmpz_cmp_ui (mpz_srcptr, unsigned long int) throw () __attribute__ ((__pure__));


 int __gmpz_cmpabs (mpz_srcptr, mpz_srcptr) throw () __attribute__ ((__pure__));


 int __gmpz_cmpabs_d (mpz_srcptr, double) __attribute__ ((__pure__));


 int __gmpz_cmpabs_ui (mpz_srcptr, unsigned long int) throw () __attribute__ ((__pure__));


 void __gmpz_com (mpz_ptr, mpz_srcptr);


 void __gmpz_combit (mpz_ptr, mp_bitcnt_t);


 int __gmpz_congruent_p (mpz_srcptr, mpz_srcptr, mpz_srcptr) __attribute__ ((__pure__));


 int __gmpz_congruent_2exp_p (mpz_srcptr, mpz_srcptr, mp_bitcnt_t) throw () __attribute__ ((__pure__));


 int __gmpz_congruent_ui_p (mpz_srcptr, unsigned long, unsigned long) __attribute__ ((__pure__));


 void __gmpz_divexact (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_divexact_ui (mpz_ptr, mpz_srcptr, unsigned long);


 int __gmpz_divisible_p (mpz_srcptr, mpz_srcptr) __attribute__ ((__pure__));


 int __gmpz_divisible_ui_p (mpz_srcptr, unsigned long) __attribute__ ((__pure__));


 int __gmpz_divisible_2exp_p (mpz_srcptr, mp_bitcnt_t) throw () __attribute__ ((__pure__));


 void __gmpz_dump (mpz_srcptr);


 void *__gmpz_export (void *, size_t *, int, size_t, int, size_t, mpz_srcptr);


 void __gmpz_fac_ui (mpz_ptr, unsigned long int);


 void __gmpz_fdiv_q (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_fdiv_q_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);


 unsigned long int __gmpz_fdiv_q_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_fdiv_qr (mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr);


 unsigned long int __gmpz_fdiv_qr_ui (mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_fdiv_r (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_fdiv_r_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);


 unsigned long int __gmpz_fdiv_r_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 unsigned long int __gmpz_fdiv_ui (mpz_srcptr, unsigned long int) __attribute__ ((__pure__));


 void __gmpz_fib_ui (mpz_ptr, unsigned long int);


 void __gmpz_fib2_ui (mpz_ptr, mpz_ptr, unsigned long int);


 int __gmpz_fits_sint_p (mpz_srcptr) throw () __attribute__ ((__pure__));


 int __gmpz_fits_slong_p (mpz_srcptr) throw () __attribute__ ((__pure__));


 int __gmpz_fits_sshort_p (mpz_srcptr) throw () __attribute__ ((__pure__));



 int __gmpz_fits_uint_p (mpz_srcptr) throw () __attribute__ ((__pure__));




 int __gmpz_fits_ulong_p (mpz_srcptr) throw () __attribute__ ((__pure__));




 int __gmpz_fits_ushort_p (mpz_srcptr) throw () __attribute__ ((__pure__));



 void __gmpz_gcd (mpz_ptr, mpz_srcptr, mpz_srcptr);


 unsigned long int __gmpz_gcd_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_gcdext (mpz_ptr, mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr);


 double __gmpz_get_d (mpz_srcptr) __attribute__ ((__pure__));


 double __gmpz_get_d_2exp (signed long int *, mpz_srcptr);


 long int __gmpz_get_si (mpz_srcptr) throw () __attribute__ ((__pure__));


 char *__gmpz_get_str (char *, int, mpz_srcptr);



 unsigned long int __gmpz_get_ui (mpz_srcptr) throw () __attribute__ ((__pure__));




 mp_limb_t __gmpz_getlimbn (mpz_srcptr, mp_size_t) throw () __attribute__ ((__pure__));



 mp_bitcnt_t __gmpz_hamdist (mpz_srcptr, mpz_srcptr) throw () __attribute__ ((__pure__));


 void __gmpz_import (mpz_ptr, size_t, int, size_t, int, size_t, const void *);


 void __gmpz_init (mpz_ptr);


 void __gmpz_init2 (mpz_ptr, mp_bitcnt_t);


 void __gmpz_inits (mpz_ptr, ...);


 void __gmpz_init_set (mpz_ptr, mpz_srcptr);


 void __gmpz_init_set_d (mpz_ptr, double);


 void __gmpz_init_set_si (mpz_ptr, signed long int);


 int __gmpz_init_set_str (mpz_ptr, const char *, int);


 void __gmpz_init_set_ui (mpz_ptr, unsigned long int);



 size_t __gmpz_inp_raw (mpz_ptr, FILE *);




 size_t __gmpz_inp_str (mpz_ptr, FILE *, int);



 int __gmpz_invert (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_ior (mpz_ptr, mpz_srcptr, mpz_srcptr);


 int __gmpz_jacobi (mpz_srcptr, mpz_srcptr) __attribute__ ((__pure__));




 int __gmpz_kronecker_si (mpz_srcptr, long) __attribute__ ((__pure__));


 int __gmpz_kronecker_ui (mpz_srcptr, unsigned long) __attribute__ ((__pure__));


 int __gmpz_si_kronecker (long, mpz_srcptr) __attribute__ ((__pure__));


 int __gmpz_ui_kronecker (unsigned long, mpz_srcptr) __attribute__ ((__pure__));


 void __gmpz_lcm (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_lcm_ui (mpz_ptr, mpz_srcptr, unsigned long);




 void __gmpz_lucnum_ui (mpz_ptr, unsigned long int);


 void __gmpz_lucnum2_ui (mpz_ptr, mpz_ptr, unsigned long int);


 int __gmpz_millerrabin (mpz_srcptr, int) __attribute__ ((__pure__));


 void __gmpz_mod (mpz_ptr, mpz_srcptr, mpz_srcptr);





 void __gmpz_mul (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_mul_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);



 void __gmpz_mul_si (mpz_ptr, mpz_srcptr, long int);



 void __gmpz_mul_ui (mpz_ptr, mpz_srcptr, unsigned long int);




 void __gmpz_neg (mpz_ptr, mpz_srcptr);



 void __gmpz_nextprime (mpz_ptr, mpz_srcptr);


 void __gmpz_next_likely_prime (mpz_ptr, mpz_srcptr,gmp_randstate_t);



 size_t __gmpz_out_raw (FILE *, mpz_srcptr);




 size_t __gmpz_out_str (FILE *, int, mpz_srcptr);



 int __gmpz_perfect_power_p (mpz_srcptr) __attribute__ ((__pure__));



 int __gmpz_perfect_square_p (mpz_srcptr) __attribute__ ((__pure__));




 mp_bitcnt_t __gmpz_popcount (mpz_srcptr) throw () __attribute__ ((__pure__));



 void __gmpz_pow_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_powm (mpz_ptr, mpz_srcptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_powm_ui (mpz_ptr, mpz_srcptr, unsigned long int, mpz_srcptr);


 int __gmpz_probab_prime_p (mpz_srcptr, int) __attribute__ ((__pure__));


 int __gmpz_probable_prime_p (mpz_srcptr,gmp_randstate_t, int,unsigned long);


 int __gmpz_likely_prime_p (mpz_srcptr,gmp_randstate_t, unsigned long);


 void __gmpz_realloc2 (mpz_ptr, mp_bitcnt_t);


 unsigned long int __gmpz_remove (mpz_ptr, mpz_srcptr, mpz_srcptr);


 int __gmpz_root (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_nthroot (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_rootrem (mpz_ptr,mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_rrandomb (mpz_ptr, gmp_randstate_t, mp_bitcnt_t);


 mp_bitcnt_t __gmpz_scan0 (mpz_srcptr, mp_bitcnt_t) throw () __attribute__ ((__pure__));


 mp_bitcnt_t __gmpz_scan1 (mpz_srcptr, mp_bitcnt_t) throw () __attribute__ ((__pure__));



 void __gmpz_set (mpz_ptr, mpz_srcptr);


 void __gmpz_set_d (mpz_ptr, double);


 void __gmpz_set_f (mpz_ptr, mpf_srcptr);



 void __gmpz_set_q (mpz_ptr, mpq_srcptr);




 void __gmpz_set_si (mpz_ptr, signed long int);


 int __gmpz_set_str (mpz_ptr, const char *, int);



 void __gmpz_set_ui (mpz_ptr, unsigned long int);


 void __gmpz_setbit (mpz_ptr, mp_bitcnt_t);



 size_t __gmpz_size (mpz_srcptr) throw () __attribute__ ((__pure__));



 size_t __gmpz_sizeinbase (mpz_srcptr, int) throw () __attribute__ ((__pure__));


 void __gmpz_sqrt (mpz_ptr, mpz_srcptr);


 void __gmpz_sqrtrem (mpz_ptr, mpz_ptr, mpz_srcptr);



 void __gmpz_sub (mpz_ptr, mpz_srcptr, mpz_srcptr);



 void __gmpz_sub_ui (mpz_ptr, mpz_srcptr, unsigned long int);



 void __gmpz_ui_sub (mpz_ptr, unsigned long int, mpz_srcptr);


 void __gmpz_submul (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_submul_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_swap (mpz_ptr, mpz_ptr) throw ();


 unsigned long int __gmpz_tdiv_ui (mpz_srcptr, unsigned long int) __attribute__ ((__pure__));


 void __gmpz_tdiv_q (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_tdiv_q_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);


 unsigned long int __gmpz_tdiv_q_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_tdiv_qr (mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr);


 unsigned long int __gmpz_tdiv_qr_ui (mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_tdiv_r (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_tdiv_r_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);


 unsigned long int __gmpz_tdiv_r_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 int __gmpz_tstbit (mpz_srcptr, mp_bitcnt_t) throw () __attribute__ ((__pure__));


 void __gmpz_ui_pow_ui (mpz_ptr, unsigned long int, unsigned long int);


 void __gmpz_urandomb (mpz_ptr, gmp_randstate_t, mp_bitcnt_t);


 void __gmpz_urandomm (mpz_ptr, gmp_randstate_t, mpz_srcptr);



 void __gmpz_xor (mpz_ptr, mpz_srcptr, mpz_srcptr);






 void __gmpq_abs (mpq_ptr, mpq_srcptr);



 void __gmpq_add (mpq_ptr, mpq_srcptr, mpq_srcptr);


 void __gmpq_canonicalize (mpq_ptr);


 void __gmpq_clear (mpq_ptr);


 void __gmpq_clears (mpq_ptr, ...);


 int __gmpq_cmp (mpq_srcptr, mpq_srcptr) __attribute__ ((__pure__));


 int __gmpq_cmp_si (mpq_srcptr, long, unsigned long) __attribute__ ((__pure__));


 int __gmpq_cmp_ui (mpq_srcptr, unsigned long int, unsigned long int) __attribute__ ((__pure__));


 void __gmpq_div (mpq_ptr, mpq_srcptr, mpq_srcptr);


 void __gmpq_div_2exp (mpq_ptr, mpq_srcptr, mp_bitcnt_t);


 int __gmpq_equal (mpq_srcptr, mpq_srcptr) throw () __attribute__ ((__pure__));


 void __gmpq_get_num (mpz_ptr, mpq_srcptr);


 void __gmpq_get_den (mpz_ptr, mpq_srcptr);


 double __gmpq_get_d (mpq_srcptr) __attribute__ ((__pure__));


 char *__gmpq_get_str (char *, int, mpq_srcptr);


 void __gmpq_init (mpq_ptr);


 void __gmpq_inits (mpq_ptr, ...);



 size_t __gmpq_inp_str (mpq_ptr, FILE *, int);



 void __gmpq_inv (mpq_ptr, mpq_srcptr);


 void __gmpq_mul (mpq_ptr, mpq_srcptr, mpq_srcptr);


 void __gmpq_mul_2exp (mpq_ptr, mpq_srcptr, mp_bitcnt_t);



 void __gmpq_neg (mpq_ptr, mpq_srcptr);




 size_t __gmpq_out_str (FILE *, int, mpq_srcptr);



 void __gmpq_set (mpq_ptr, mpq_srcptr);


 void __gmpq_set_d (mpq_ptr, double);


 void __gmpq_set_den (mpq_ptr, mpz_srcptr);


 void __gmpq_set_f (mpq_ptr, mpf_srcptr);


 void __gmpq_set_num (mpq_ptr, mpz_srcptr);


 void __gmpq_set_si (mpq_ptr, signed long int, unsigned long int);


 int __gmpq_set_str (mpq_ptr, const char *, int);


 void __gmpq_set_ui (mpq_ptr, unsigned long int, unsigned long int);


 void __gmpq_set_z (mpq_ptr, mpz_srcptr);


 void __gmpq_sub (mpq_ptr, mpq_srcptr, mpq_srcptr);


 void __gmpq_swap (mpq_ptr, mpq_ptr) throw ();





 void __gmpf_abs (mpf_ptr, mpf_srcptr);


 void __gmpf_add (mpf_ptr, mpf_srcptr, mpf_srcptr);


 void __gmpf_add_ui (mpf_ptr, mpf_srcptr, unsigned long int);

 void __gmpf_ceil (mpf_ptr, mpf_srcptr);


 void __gmpf_clear (mpf_ptr);


 void __gmpf_clears (mpf_ptr, ...);


 int __gmpf_cmp (mpf_srcptr, mpf_srcptr) throw () __attribute__ ((__pure__));


 int __gmpf_cmp_d (mpf_srcptr, double) __attribute__ ((__pure__));


 int __gmpf_cmp_si (mpf_srcptr, signed long int) throw () __attribute__ ((__pure__));


 int __gmpf_cmp_ui (mpf_srcptr, unsigned long int) throw () __attribute__ ((__pure__));


 void __gmpf_div (mpf_ptr, mpf_srcptr, mpf_srcptr);


 void __gmpf_div_2exp (mpf_ptr, mpf_srcptr, mp_bitcnt_t);


 void __gmpf_div_ui (mpf_ptr, mpf_srcptr, unsigned long int);


 void __gmpf_dump (mpf_srcptr);


 int __gmpf_eq (mpf_srcptr, mpf_srcptr, unsigned long int) __attribute__ ((__pure__));


 int __gmpf_fits_sint_p (mpf_srcptr) throw () __attribute__ ((__pure__));


 int __gmpf_fits_slong_p (mpf_srcptr) throw () __attribute__ ((__pure__));


 int __gmpf_fits_sshort_p (mpf_srcptr) throw () __attribute__ ((__pure__));


 int __gmpf_fits_uint_p (mpf_srcptr) throw () __attribute__ ((__pure__));


 int __gmpf_fits_ulong_p (mpf_srcptr) throw () __attribute__ ((__pure__));


 int __gmpf_fits_ushort_p (mpf_srcptr) throw () __attribute__ ((__pure__));


 void __gmpf_floor (mpf_ptr, mpf_srcptr);


 double __gmpf_get_d (mpf_srcptr) __attribute__ ((__pure__));


 double __gmpf_get_d_2exp (signed long int *, mpf_srcptr);


 mp_bitcnt_t __gmpf_get_default_prec (void) throw () __attribute__ ((__pure__));


 mp_bitcnt_t __gmpf_get_prec (mpf_srcptr) throw () __attribute__ ((__pure__));


 long __gmpf_get_si (mpf_srcptr) throw () __attribute__ ((__pure__));


 char *__gmpf_get_str (char *, mp_exp_t *, int, size_t, mpf_srcptr);


 unsigned long __gmpf_get_ui (mpf_srcptr) throw () __attribute__ ((__pure__));


 void __gmpf_init (mpf_ptr);


 void __gmpf_init2 (mpf_ptr, mp_bitcnt_t);


 void __gmpf_inits (mpf_ptr, ...);


 void __gmpf_init_set (mpf_ptr, mpf_srcptr);


 void __gmpf_init_set_d (mpf_ptr, double);


 void __gmpf_init_set_si (mpf_ptr, signed long int);


 int __gmpf_init_set_str (mpf_ptr, const char *, int);


 void __gmpf_init_set_ui (mpf_ptr, unsigned long int);



 size_t __gmpf_inp_str (mpf_ptr, FILE *, int);



 int __gmpf_integer_p (mpf_srcptr) throw () __attribute__ ((__pure__));


 void __gmpf_mul (mpf_ptr, mpf_srcptr, mpf_srcptr);


 void __gmpf_mul_2exp (mpf_ptr, mpf_srcptr, mp_bitcnt_t);


 void __gmpf_mul_ui (mpf_ptr, mpf_srcptr, unsigned long int);


 void __gmpf_neg (mpf_ptr, mpf_srcptr);



 size_t __gmpf_out_str (FILE *, int, size_t, mpf_srcptr);



 void __gmpf_pow_ui (mpf_ptr, mpf_srcptr, unsigned long int);


 void __gmpf_random2 (mpf_ptr, mp_size_t, mp_exp_t);


 void __gmpf_rrandomb (mpf_ptr, gmp_randstate_t, mp_size_t, mp_exp_t);


 void __gmpf_reldiff (mpf_ptr, mpf_srcptr, mpf_srcptr);


 void __gmpf_set (mpf_ptr, mpf_srcptr);


 void __gmpf_set_d (mpf_ptr, double);


 void __gmpf_set_default_prec (mp_bitcnt_t) throw ();


 void __gmpf_set_prec (mpf_ptr, mp_bitcnt_t);


 void __gmpf_set_prec_raw (mpf_ptr, mp_bitcnt_t) throw ();


 void __gmpf_set_q (mpf_ptr, mpq_srcptr);


 void __gmpf_set_si (mpf_ptr, signed long int);


 int __gmpf_set_str (mpf_ptr, const char *, int);


 void __gmpf_set_ui (mpf_ptr, unsigned long int);


 void __gmpf_set_z (mpf_ptr, mpz_srcptr);


 size_t __gmpf_size (mpf_srcptr) throw () __attribute__ ((__pure__));


 void __gmpf_sqrt (mpf_ptr, mpf_srcptr);


 void __gmpf_sqrt_ui (mpf_ptr, unsigned long int);


 void __gmpf_sub (mpf_ptr, mpf_srcptr, mpf_srcptr);


 void __gmpf_sub_ui (mpf_ptr, mpf_srcptr, unsigned long int);


 void __gmpf_swap (mpf_ptr, mpf_ptr) throw ();


 void __gmpf_trunc (mpf_ptr, mpf_srcptr);


 void __gmpf_ui_div (mpf_ptr, unsigned long int, mpf_srcptr);


 void __gmpf_ui_sub (mpf_ptr, unsigned long int, mpf_srcptr);


 void __gmpf_urandomb (mpf_t, gmp_randstate_t, mp_bitcnt_t);
#1516 "C:/Xilinx/Vivado/2018.3/include/gmp.h"
 mp_limb_t __gmpn_add (mp_ptr, mp_srcptr, mp_size_t, mp_srcptr,mp_size_t);




 mp_limb_t __gmpn_add_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t) throw ();



 mp_limb_t __gmpn_add_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);


 mp_limb_t __gmpn_addmul_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t);


 mp_limb_t __gmpn_bdivmod (mp_ptr, mp_ptr, mp_size_t, mp_srcptr, mp_size_t, unsigned long int);


 mp_limb_t __gmpn_divrem (mp_ptr, mp_size_t, mp_ptr, mp_size_t, mp_srcptr, mp_size_t);


 int __gmpn_mulmod_2expp1 (mp_ptr, mp_srcptr, mp_srcptr,int,unsigned long, mp_ptr);


 void __gmpn_mulmod_2expm1 (mp_ptr, mp_ptr, mp_ptr,unsigned long, mp_ptr);



 int __gmpn_cmp (mp_srcptr, mp_srcptr, mp_size_t) throw () __attribute__ ((__pure__));






 mp_limb_t __gmpn_divexact_by3c (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t);





 mp_limb_t __gmpn_divrem_1 (mp_ptr, mp_size_t, mp_srcptr, mp_size_t, mp_limb_t);


 mp_limb_t __gmpn_divrem_2 (mp_ptr, mp_size_t, mp_ptr, mp_size_t, mp_srcptr);


 void __gmpn_invert (mp_ptr xp, mp_srcptr ap, mp_size_t n);


 mp_limb_t __gmpn_sb_divappr_q (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_limb_t dip)
                                               ;


 mp_limb_t __gmpn_dc_divappr_q_n (mp_ptr qp, mp_ptr np, mp_srcptr dp, mp_size_t n, mp_limb_t dip, mp_ptr tp)
                                     ;


 void __gmpn_dc_bdiv_q_n (mp_ptr qp, mp_ptr wp, mp_ptr np, mp_srcptr dp, mp_size_t n, mp_limb_t dinv, mp_ptr scratch)
                                                 ;


 mp_limb_t __gmpn_inv_divappr_q_n (mp_ptr qp, mp_ptr np, mp_srcptr dp, mp_size_t n, mp_srcptr dip)
                                        ;


 mp_limb_t __gmpn_dc_divappr_q (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t n, mp_limb_t dinv)
                                 ;


 mp_limb_t __gmpn_dc_div_q (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_limb_t dinv)
                                                     ;


 mp_limb_t __gmpn_inv_divappr_q (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t n, mp_srcptr dinv)
                                 ;


 mp_limb_t __gmpn_inv_div_q (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_srcptr dinv)
                                                     ;


 mp_limb_t __gmpn_inv_div_qr (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_srcptr dinv)
                                                     ;


 mp_limb_t __gmpn_inv_div_qr_n (mp_ptr qp, mp_ptr np, mp_srcptr dp, mp_size_t dn, mp_srcptr dinv)
                                                     ;


 mp_limb_t __gmpn_dc_div_qr (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_limb_t dinv)
                                                     ;


 mp_limb_t __gmpn_dc_div_qr_n (mp_ptr qp, mp_ptr np, mp_srcptr dp, mp_size_t n, mp_limb_t dinv, mp_ptr tp)
                                    ;


 mp_limb_t __gmpn_sb_div_q (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_limb_t dinv)
                                                     ;


 void __gmpn_sb_bdiv_q (mp_ptr qp, mp_ptr wp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_limb_t dinv)
                                                     ;


 void __gmpn_dc_bdiv_q (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_limb_t dinv)
                                                     ;


 mp_limb_t __gmpn_dc_bdiv_qr (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_limb_t dinv)
                                                     ;


 mp_limb_t __gmpn_dc_bdiv_qr_n (mp_ptr qp, mp_ptr np, mp_srcptr dp, mp_size_t n, mp_limb_t dinv, mp_ptr tp)
                                                               ;


 mp_limb_t __gmpn_sb_div_qr (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_limb_t dinv)
                                                     ;


 mp_limb_t __gmpn_sb_bdiv_qr (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_limb_t dinv)
                                                     ;


 void __gmpn_tdiv_q (mp_ptr qp, mp_srcptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn)
                                                               ;


 void __gmpn_divexact (mp_ptr qp, mp_srcptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn)
                                                               ;


 void __gmpn_redc_1 (mp_ptr, mp_ptr, mp_srcptr, mp_size_t, mp_limb_t);


 mp_size_t __gmpn_gcd (mp_ptr, mp_ptr, mp_size_t, mp_ptr, mp_size_t);


 mp_limb_t __gmpn_gcd_1 (mp_srcptr, mp_size_t, mp_limb_t) __attribute__ ((__pure__));


 mp_size_t __gmpn_gcdext (mp_ptr, mp_ptr, mp_size_t *, mp_ptr, mp_size_t, mp_ptr, mp_size_t);


 size_t __gmpn_get_str (unsigned char *, int, mp_ptr, mp_size_t);


 mp_bitcnt_t __gmpn_hamdist (mp_srcptr, mp_srcptr, mp_size_t) throw () __attribute__ ((__pure__));


 mp_limb_t __gmpn_lshift (mp_ptr, mp_srcptr, mp_size_t, unsigned int);


 mp_limb_t __gmpn_mod_1 (mp_srcptr, mp_size_t, mp_limb_t) __attribute__ ((__pure__));


 mp_limb_t __gmpn_mul (mp_ptr, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t);


 mp_limb_t __gmpn_mul_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t);


 void __gmpn_mul_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);


 void __gmpn_sqr (mp_ptr, mp_srcptr, mp_size_t);



 mp_limb_t __gmpn_neg_n (mp_ptr, mp_srcptr, mp_size_t);



 void __gmpn_com_n (mp_ptr, mp_srcptr, mp_size_t);


 int __gmpn_perfect_square_p (mp_srcptr, mp_size_t) __attribute__ ((__pure__));


 mp_bitcnt_t __gmpn_popcount (mp_srcptr, mp_size_t) throw () __attribute__ ((__pure__));


 mp_size_t __gmpn_pow_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t, mp_ptr);



 mp_limb_t __gmpn_preinv_mod_1 (mp_srcptr, mp_size_t, mp_limb_t, mp_limb_t) __attribute__ ((__pure__));


 void __gmpn_random (mp_ptr, mp_size_t);


 void __gmpn_random2 (mp_ptr, mp_size_t);


 void __gmpn_urandomb (mp_ptr, gmp_randstate_t, unsigned long);


 void __gmpn_urandomm (mp_ptr, gmp_randstate_t, mp_srcptr, mp_size_t);


 void __gmpn_randomb (mp_ptr, gmp_randstate_t, mp_size_t);


 void __gmpn_rrandom (mp_ptr, gmp_randstate_t, mp_size_t);


 mp_limb_t __gmpn_rshift (mp_ptr, mp_srcptr, mp_size_t, unsigned int);


 mp_bitcnt_t __gmpn_scan0 (mp_srcptr, mp_bitcnt_t) __attribute__ ((__pure__));


 mp_bitcnt_t __gmpn_scan1 (mp_srcptr, mp_bitcnt_t) __attribute__ ((__pure__));


 mp_size_t __gmpn_set_str (mp_ptr, const unsigned char *, size_t, int);


 mp_size_t __gmpn_sqrtrem (mp_ptr, mp_ptr, mp_srcptr, mp_size_t);



 mp_limb_t __gmpn_sub (mp_ptr, mp_srcptr, mp_size_t, mp_srcptr,mp_size_t);




 mp_limb_t __gmpn_sub_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t) throw ();



 mp_limb_t __gmpn_sub_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);


 mp_limb_t __gmpn_submul_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t);


 void __gmpn_tdiv_qr (mp_ptr, mp_ptr, mp_size_t, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t);


 void __gmpn_and_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

 void __gmpn_andn_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

 void __gmpn_nand_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

 void __gmpn_ior_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

 void __gmpn_iorn_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

 void __gmpn_nior_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

 void __gmpn_xor_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

 void __gmpn_xnor_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);


 void __gmpn_copyi (mp_ptr, mp_srcptr, mp_size_t);

 void __gmpn_copyd (mp_ptr, mp_srcptr, mp_size_t);

 void __gmpn_zero (mp_ptr, mp_size_t);
#1799 "C:/Xilinx/Vivado/2018.3/include/gmp.h"
extern __inline__ __attribute__((__gnu_inline__)) void
__gmpz_abs (mpz_ptr __gmp_w, mpz_srcptr __gmp_u)
{
  if (__gmp_w != __gmp_u)
    __gmpz_set (__gmp_w, __gmp_u);
  __gmp_w->_mp_size = ((__gmp_w->_mp_size) >= 0 ? (__gmp_w->_mp_size) : -(__gmp_w->_mp_size));
}
#1823 "C:/Xilinx/Vivado/2018.3/include/gmp.h"
extern __inline__ __attribute__((__gnu_inline__))

int
__gmpz_fits_uint_p (mpz_srcptr __gmp_z) throw ()
{
  mp_size_t __gmp_n = __gmp_z->_mp_size; mp_ptr __gmp_p = __gmp_z->_mp_d; return (__gmp_n == 0 || (__gmp_n == 1 && __gmp_p[0] <= (~ (unsigned) 0)));;
}




extern __inline__ __attribute__((__gnu_inline__))

int
__gmpz_fits_ulong_p (mpz_srcptr __gmp_z) throw ()
{
  mp_size_t __gmp_n = __gmp_z->_mp_size; mp_ptr __gmp_p = __gmp_z->_mp_d; return (__gmp_n == 0 || (__gmp_n == 1 && __gmp_p[0] <= (~ (unsigned long) 0)));;
}




extern __inline__ __attribute__((__gnu_inline__))

int
__gmpz_fits_ushort_p (mpz_srcptr __gmp_z) throw ()
{
  mp_size_t __gmp_n = __gmp_z->_mp_size; mp_ptr __gmp_p = __gmp_z->_mp_d; return (__gmp_n == 0 || (__gmp_n == 1 && __gmp_p[0] <= ((unsigned short) ~0)));;
}




extern __inline__ __attribute__((__gnu_inline__))

unsigned long
__gmpz_get_ui (mpz_srcptr __gmp_z) throw ()
{
  mp_ptr __gmp_p = __gmp_z->_mp_d;
  mp_size_t __gmp_n = __gmp_z->_mp_size;
  mp_limb_t __gmp_l = __gmp_p[0];






  return (unsigned long)(__gmp_n != 0 ? __gmp_l : 0);
#1879 "C:/Xilinx/Vivado/2018.3/include/gmp.h"
}




extern __inline__ __attribute__((__gnu_inline__))

mp_limb_t
__gmpz_getlimbn (mpz_srcptr __gmp_z, mp_size_t __gmp_n) throw ()
{
  mp_limb_t __gmp_result = 0;
  if (__builtin_expect ((__gmp_n >= 0 && __gmp_n < ((__gmp_z->_mp_size) >= 0 ? (__gmp_z->_mp_size) : -(__gmp_z->_mp_size))) != 0, 1))
    __gmp_result = __gmp_z->_mp_d[__gmp_n];
  return __gmp_result;
}



extern __inline__ __attribute__((__gnu_inline__)) void
__gmpz_neg (mpz_ptr __gmp_w, mpz_srcptr __gmp_u)
{
  if (__gmp_w != __gmp_u)
    __gmpz_set (__gmp_w, __gmp_u);
  __gmp_w->_mp_size = - __gmp_w->_mp_size;
}




extern __inline__ __attribute__((__gnu_inline__))

int
__gmpz_perfect_square_p (mpz_srcptr __gmp_a)
{
  mp_size_t __gmp_asize;
  int __gmp_result;

  __gmp_asize = __gmp_a->_mp_size;
  __gmp_result = (__gmp_asize >= 0);
  if (__builtin_expect ((__gmp_asize > 0) != 0, 1))
    __gmp_result = __gmpn_perfect_square_p (__gmp_a->_mp_d, __gmp_asize);
  return __gmp_result;
}




extern __inline__ __attribute__((__gnu_inline__))

mp_bitcnt_t
__gmpz_popcount (mpz_srcptr __gmp_u) throw ()
{
  mp_size_t __gmp_usize;
  mp_bitcnt_t __gmp_result;

  __gmp_usize = __gmp_u->_mp_size;
  __gmp_result = (__gmp_usize < 0 ? (~ (unsigned long) 0) : 0);
  if (__builtin_expect ((__gmp_usize > 0) != 0, 1))
    __gmp_result = __gmpn_popcount (__gmp_u->_mp_d, __gmp_usize);
  return __gmp_result;
}




extern __inline__ __attribute__((__gnu_inline__))

void
__gmpz_set_q (mpz_ptr __gmp_w, mpq_srcptr __gmp_u)
{
  __gmpz_tdiv_q (__gmp_w, (&((__gmp_u)->_mp_num)), (&((__gmp_u)->_mp_den)));
}




extern __inline__ __attribute__((__gnu_inline__))

size_t
__gmpz_size (mpz_srcptr __gmp_z) throw ()
{
  return ((__gmp_z->_mp_size) >= 0 ? (__gmp_z->_mp_size) : -(__gmp_z->_mp_size));
}






extern __inline__ __attribute__((__gnu_inline__)) void
__gmpq_abs (mpq_ptr __gmp_w, mpq_srcptr __gmp_u)
{
  if (__gmp_w != __gmp_u)
    __gmpq_set (__gmp_w, __gmp_u);
  __gmp_w->_mp_num._mp_size = ((__gmp_w->_mp_num._mp_size) >= 0 ? (__gmp_w->_mp_num._mp_size) : -(__gmp_w->_mp_num._mp_size));
}



extern __inline__ __attribute__((__gnu_inline__)) void
__gmpq_neg (mpq_ptr __gmp_w, mpq_srcptr __gmp_u)
{
  if (__gmp_w != __gmp_u)
    __gmpq_set (__gmp_w, __gmp_u);
  __gmp_w->_mp_num._mp_size = - __gmp_w->_mp_num._mp_size;
}
#2220 "C:/Xilinx/Vivado/2018.3/include/gmp.h"
extern __inline__ __attribute__((__gnu_inline__))

mp_limb_t
__gmpn_add (mp_ptr __gmp_wp, mp_srcptr __gmp_xp, mp_size_t __gmp_xsize, mp_srcptr __gmp_yp, mp_size_t __gmp_ysize)
{
  mp_limb_t __gmp_c;
  do { mp_size_t __gmp_i; mp_limb_t __gmp_x; __gmp_i = (__gmp_ysize); if (__gmp_i != 0) { if (__gmpn_add_n (__gmp_wp, __gmp_xp, __gmp_yp, __gmp_i)) { do { if (__gmp_i >= (__gmp_xsize)) { (__gmp_c) = 1; goto __gmp_done; } __gmp_x = (__gmp_xp)[__gmp_i]; } while ((((__gmp_wp)[__gmp_i++] = (__gmp_x + 1) & ((~ (static_cast<mp_limb_t> (0))) >> 0)) == 0)); } } if ((__gmp_wp) != (__gmp_xp)) do { mp_size_t __gmp_j; for (__gmp_j = (__gmp_i); __gmp_j < (__gmp_xsize); __gmp_j++) (__gmp_wp)[__gmp_j] = (__gmp_xp)[__gmp_j]; } while (0); (__gmp_c) = 0; __gmp_done: ; } while (0);
  return __gmp_c;
}




extern __inline__ __attribute__((__gnu_inline__))

mp_limb_t
__gmpn_add_1 (mp_ptr __gmp_dst, mp_srcptr __gmp_src, mp_size_t __gmp_size, mp_limb_t __gmp_n) throw ()
{
  mp_limb_t __gmp_c;
  do { mp_size_t __gmp_i; mp_limb_t __gmp_x, __gmp_r; __gmp_x = (__gmp_src)[0]; __gmp_r = __gmp_x + (__gmp_n); (__gmp_dst)[0] = __gmp_r; if (((__gmp_r) < ((__gmp_n)))) { (__gmp_c) = 1; for (__gmp_i = 1; __gmp_i < (__gmp_size);) { __gmp_x = (__gmp_src)[__gmp_i]; __gmp_r = __gmp_x + 1; (__gmp_dst)[__gmp_i] = __gmp_r; ++__gmp_i; if (!((__gmp_r) < (1))) { if ((__gmp_src) != (__gmp_dst)) do { mp_size_t __gmp_j; for (__gmp_j = (__gmp_i); __gmp_j < (__gmp_size); __gmp_j++) (__gmp_dst)[__gmp_j] = (__gmp_src)[__gmp_j]; } while (0); (__gmp_c) = 0; break; } } } else { if ((__gmp_src) != (__gmp_dst)) do { mp_size_t __gmp_j; for (__gmp_j = (1); __gmp_j < (__gmp_size); __gmp_j++) (__gmp_dst)[__gmp_j] = (__gmp_src)[__gmp_j]; } while (0); (__gmp_c) = 0; } } while (0);
  return __gmp_c;
}




extern __inline__ __attribute__((__gnu_inline__))

int
__gmpn_cmp (mp_srcptr __gmp_xp, mp_srcptr __gmp_yp, mp_size_t __gmp_size) throw ()
{
  int __gmp_result;
  do { mp_size_t __gmp_i; mp_limb_t __gmp_x, __gmp_y; (__gmp_result) = 0; __gmp_i = (__gmp_size); while (--__gmp_i >= 0) { __gmp_x = (__gmp_xp)[__gmp_i]; __gmp_y = (__gmp_yp)[__gmp_i]; if (__gmp_x != __gmp_y) { (__gmp_result) = (__gmp_x > __gmp_y ? 1 : -1); break; } } } while (0);
  return __gmp_result;
}




extern __inline__ __attribute__((__gnu_inline__))

mp_limb_t
__gmpn_sub (mp_ptr __gmp_wp, mp_srcptr __gmp_xp, mp_size_t __gmp_xsize, mp_srcptr __gmp_yp, mp_size_t __gmp_ysize)
{
  mp_limb_t __gmp_c;
  do { mp_size_t __gmp_i; mp_limb_t __gmp_x; __gmp_i = (__gmp_ysize); if (__gmp_i != 0) { if (__gmpn_sub_n (__gmp_wp, __gmp_xp, __gmp_yp, __gmp_i)) { do { if (__gmp_i >= (__gmp_xsize)) { (__gmp_c) = 1; goto __gmp_done; } __gmp_x = (__gmp_xp)[__gmp_i]; } while ((((__gmp_wp)[__gmp_i++] = (__gmp_x - 1) & ((~ (static_cast<mp_limb_t> (0))) >> 0)), __gmp_x == 0)); } } if ((__gmp_wp) != (__gmp_xp)) do { mp_size_t __gmp_j; for (__gmp_j = (__gmp_i); __gmp_j < (__gmp_xsize); __gmp_j++) (__gmp_wp)[__gmp_j] = (__gmp_xp)[__gmp_j]; } while (0); (__gmp_c) = 0; __gmp_done: ; } while (0);
  return __gmp_c;
}




extern __inline__ __attribute__((__gnu_inline__))

mp_limb_t
__gmpn_sub_1 (mp_ptr __gmp_dst, mp_srcptr __gmp_src, mp_size_t __gmp_size, mp_limb_t __gmp_n) throw ()
{
  mp_limb_t __gmp_c;
  do { mp_size_t __gmp_i; mp_limb_t __gmp_x, __gmp_r; __gmp_x = (__gmp_src)[0]; __gmp_r = __gmp_x - (__gmp_n); (__gmp_dst)[0] = __gmp_r; if (((__gmp_x) < ((__gmp_n)))) { (__gmp_c) = 1; for (__gmp_i = 1; __gmp_i < (__gmp_size);) { __gmp_x = (__gmp_src)[__gmp_i]; __gmp_r = __gmp_x - 1; (__gmp_dst)[__gmp_i] = __gmp_r; ++__gmp_i; if (!((__gmp_x) < (1))) { if ((__gmp_src) != (__gmp_dst)) do { mp_size_t __gmp_j; for (__gmp_j = (__gmp_i); __gmp_j < (__gmp_size); __gmp_j++) (__gmp_dst)[__gmp_j] = (__gmp_src)[__gmp_j]; } while (0); (__gmp_c) = 0; break; } } } else { if ((__gmp_src) != (__gmp_dst)) do { mp_size_t __gmp_j; for (__gmp_j = (1); __gmp_j < (__gmp_size); __gmp_j++) (__gmp_dst)[__gmp_j] = (__gmp_src)[__gmp_j]; } while (0); (__gmp_c) = 0; } } while (0);
  return __gmp_c;
}



}
#2328 "C:/Xilinx/Vivado/2018.3/include/gmp.h"
 std::ostream& operator<< (std::ostream &, mpz_srcptr);
 std::ostream& operator<< (std::ostream &, mpq_srcptr);
 std::ostream& operator<< (std::ostream &, mpf_srcptr);
 std::istream& operator>> (std::istream &, mpz_ptr);
 std::istream& operator>> (std::istream &, mpq_ptr);
 std::istream& operator>> (std::istream &, mpf_ptr);
#2348 "C:/Xilinx/Vivado/2018.3/include/gmp.h"
typedef __mpz_struct MP_INT;
typedef __mpq_struct MP_RAT;
#2358 "C:/Xilinx/Vivado/2018.3/include/gmp.h"
enum
{
  GMP_ERROR_NONE = 0,
  GMP_ERROR_UNSUPPORTED_ARGUMENT = 1,
  GMP_ERROR_DIVISION_BY_ZERO = 2,
  GMP_ERROR_SQRT_OF_NEGATIVE = 4,
  GMP_ERROR_INVALID_ARGUMENT = 8
};
#144 "C:/Xilinx/Vivado/2018.3/include/floating_point_v7_0_bitacc_cmodel.h" 2




#1 "C:/Xilinx/Vivado/2018.3/include/mpfr.h" 1
#73 "C:/Xilinx/Vivado/2018.3/include/mpfr.h"
typedef void mpfr_void;
typedef int mpfr_int;
typedef unsigned int mpfr_uint;
typedef long mpfr_long;
typedef unsigned long mpfr_ulong;
typedef size_t mpfr_size_t;
#95 "C:/Xilinx/Vivado/2018.3/include/mpfr.h"
typedef enum {
  MPFR_RNDN=0,
  MPFR_RNDZ,
  MPFR_RNDU,
  MPFR_RNDD,
  MPFR_RNDA,
  MPFR_RNDF,
  MPFR_RNDNA=-1
} mpfr_rnd_t;
#130 "C:/Xilinx/Vivado/2018.3/include/mpfr.h"
typedef long mpfr_prec_t;
typedef unsigned long mpfr_uprec_t;
#143 "C:/Xilinx/Vivado/2018.3/include/mpfr.h"
typedef int mpfr_sign_t;


typedef mp_exp_t mpfr_exp_t;






typedef struct {
  mpfr_prec_t _mpfr_prec;
  mpfr_sign_t _mpfr_sign;
  mpfr_exp_t _mpfr_exp;
  mp_limb_t *_mpfr_d;
} __mpfr_struct;
#179 "C:/Xilinx/Vivado/2018.3/include/mpfr.h"
typedef __mpfr_struct mpfr_t[1];
typedef __mpfr_struct *mpfr_ptr;
typedef const __mpfr_struct *mpfr_srcptr;
#192 "C:/Xilinx/Vivado/2018.3/include/mpfr.h"
typedef enum {
  MPFR_NAN_KIND = 0,
  MPFR_INF_KIND = 1, MPFR_ZERO_KIND = 2, MPFR_REGULAR_KIND = 3
} mpfr_kind_t;
#241 "C:/Xilinx/Vivado/2018.3/include/mpfr.h"
extern "C" {


 const char * mpfr_get_version (void);
 const char * mpfr_get_patches (void);
 int mpfr_buildopt_tls_p (void);
 int mpfr_buildopt_decimal_p (void);

 mpfr_exp_t mpfr_get_emin (void);
 int mpfr_set_emin (mpfr_exp_t);
 mpfr_exp_t mpfr_get_emin_min (void);
 mpfr_exp_t mpfr_get_emin_max (void);
 mpfr_exp_t mpfr_get_emax (void);
 int mpfr_set_emax (mpfr_exp_t);
 mpfr_exp_t mpfr_get_emax_min (void);
 mpfr_exp_t mpfr_get_emax_max (void);

 void mpfr_set_default_rounding_mode (mpfr_rnd_t);
 mpfr_rnd_t mpfr_get_default_rounding_mode (void);
 const char *
   mpfr_print_rnd_mode (mpfr_rnd_t);

 void mpfr_clear_flags (void);
 void mpfr_clear_underflow (void);
 void mpfr_clear_overflow (void);
 void mpfr_clear_nanflag (void);
 void mpfr_clear_inexflag (void);
 void mpfr_clear_erangeflag (void);

 void mpfr_set_underflow (void);
 void mpfr_set_overflow (void);
 void mpfr_set_nanflag (void);
 void mpfr_set_inexflag (void);
 void mpfr_set_erangeflag (void);

 int mpfr_underflow_p (void);
 int mpfr_overflow_p (void);
 int mpfr_nanflag_p (void);
 int mpfr_inexflag_p (void);
 int mpfr_erangeflag_p (void);

 int
  mpfr_check_range (mpfr_ptr, int, mpfr_rnd_t);

 void mpfr_init2 (mpfr_ptr, mpfr_prec_t);
 void mpfr_init (mpfr_ptr);
 void mpfr_clear (mpfr_ptr);

 void
  mpfr_inits2 (mpfr_prec_t, mpfr_ptr, ...) __attribute__ ((sentinel));
 void
  mpfr_inits (mpfr_ptr, ...) __attribute__ ((sentinel));
 void
  mpfr_clears (mpfr_ptr, ...) __attribute__ ((sentinel));

 int
  mpfr_prec_round (mpfr_ptr, mpfr_prec_t, mpfr_rnd_t);
 int
  mpfr_can_round (mpfr_srcptr, mpfr_exp_t, mpfr_rnd_t, mpfr_rnd_t, mpfr_prec_t)
                                            ;
 mpfr_prec_t mpfr_min_prec (mpfr_srcptr);

 mpfr_exp_t mpfr_get_exp (mpfr_srcptr);
 int mpfr_set_exp (mpfr_ptr, mpfr_exp_t);
 mpfr_prec_t mpfr_get_prec (mpfr_srcptr);
 void mpfr_set_prec (mpfr_ptr, mpfr_prec_t);
 void mpfr_set_prec_raw (mpfr_ptr, mpfr_prec_t);
 void mpfr_set_default_prec (mpfr_prec_t);
 mpfr_prec_t mpfr_get_default_prec (void);

 int mpfr_set_d (mpfr_ptr, double, mpfr_rnd_t);
 int mpfr_set_flt (mpfr_ptr, float, mpfr_rnd_t);




 int
  mpfr_set_ld (mpfr_ptr, long double, mpfr_rnd_t);
 int
  mpfr_set_z (mpfr_ptr, mpz_srcptr, mpfr_rnd_t);
 int
  mpfr_set_z_2exp (mpfr_ptr, mpz_srcptr, mpfr_exp_t, mpfr_rnd_t);
 void mpfr_set_nan (mpfr_ptr);
 void mpfr_set_inf (mpfr_ptr, int);
 void mpfr_set_zero (mpfr_ptr, int);
 int
  mpfr_set_f (mpfr_ptr, mpf_srcptr, mpfr_rnd_t);
 int
  mpfr_get_f (mpf_ptr, mpfr_srcptr, mpfr_rnd_t);
 int mpfr_set_si (mpfr_ptr, long, mpfr_rnd_t);
 int
  mpfr_set_ui (mpfr_ptr, unsigned long, mpfr_rnd_t);
 int
  mpfr_set_si_2exp (mpfr_ptr, long, mpfr_exp_t, mpfr_rnd_t);
 int
  mpfr_set_ui_2exp (mpfr_ptr,unsigned long,mpfr_exp_t,mpfr_rnd_t);
 int
  mpfr_set_q (mpfr_ptr, mpq_srcptr, mpfr_rnd_t);
 int
  mpfr_set_str (mpfr_ptr, const char *, int, mpfr_rnd_t);
 int
  mpfr_init_set_str (mpfr_ptr, const char *, int, mpfr_rnd_t)
                                              ;
 int
  mpfr_set4 (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t, int);
 int
  mpfr_abs (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
 int
  mpfr_set (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
 int mpfr_neg (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
 int mpfr_signbit (mpfr_srcptr);
 int
  mpfr_setsign (mpfr_ptr, mpfr_srcptr, int, mpfr_rnd_t);
 int
  mpfr_copysign (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t);
#364 "C:/Xilinx/Vivado/2018.3/include/mpfr.h"
 int __gmpfr_set_sj (mpfr_t, intmax_t, mpfr_rnd_t);
 int
  __gmpfr_set_sj_2exp (mpfr_t, intmax_t, intmax_t, mpfr_rnd_t);
 int __gmpfr_set_uj (mpfr_t, uintmax_t, mpfr_rnd_t);
 int
  __gmpfr_set_uj_2exp (mpfr_t, uintmax_t, intmax_t, mpfr_rnd_t);
 intmax_t __gmpfr_mpfr_get_sj (mpfr_srcptr, mpfr_rnd_t);
 uintmax_t __gmpfr_mpfr_get_uj (mpfr_srcptr, mpfr_rnd_t);


 mpfr_exp_t mpfr_get_z_2exp (mpz_ptr, mpfr_srcptr);
 float mpfr_get_flt (mpfr_srcptr, mpfr_rnd_t);
 double mpfr_get_d (mpfr_srcptr, mpfr_rnd_t);




 long double mpfr_get_ld (mpfr_srcptr, mpfr_rnd_t)
                                                                  ;
 double mpfr_get_d1 (mpfr_srcptr);
 double mpfr_get_d_2exp (long*, mpfr_srcptr, mpfr_rnd_t)
                                                                 ;
 long double mpfr_get_ld_2exp (long*, mpfr_srcptr, mpfr_rnd_t)
                                                                       ;
 long mpfr_get_si (mpfr_srcptr, mpfr_rnd_t);
 unsigned long mpfr_get_ui (mpfr_srcptr, mpfr_rnd_t)
                                                                    ;
 char*mpfr_get_str (char*, mpfr_exp_t*, int, size_t, mpfr_srcptr, mpfr_rnd_t)
                                                                         ;
 int mpfr_get_z (mpz_ptr z, mpfr_srcptr f, mpfr_rnd_t)
                                                         ;

 void mpfr_free_str (char *);

 int mpfr_urandom (mpfr_ptr, gmp_randstate_t, mpfr_rnd_t)
                                                           ;
 int mpfr_urandomb (mpfr_ptr, gmp_randstate_t);

 void mpfr_nextabove (mpfr_ptr);
 void mpfr_nextbelow (mpfr_ptr);
 void mpfr_nexttoward (mpfr_ptr, mpfr_srcptr);




 size_t __gmpfr_inp_str (mpfr_ptr, FILE*, int, mpfr_rnd_t)
                                                              ;
 size_t __gmpfr_out_str (FILE*, int, size_t, mpfr_srcptr, mpfr_rnd_t)
                                                                           ;

 int __gmpfr_fprintf (FILE*, const char*, ...)
                                                    ;

 int mpfr_printf (const char*, ...);
 int mpfr_asprintf (char**, const char*, ...)
                                                     ;
 int mpfr_sprintf (char*, const char*, ...)
                                                    ;
 int mpfr_snprintf (char*, size_t, const char*, ...)
                                                                        ;
#444 "C:/Xilinx/Vivado/2018.3/include/mpfr.h"
 int mpfr_pow (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                    ;
 int mpfr_pow_si (mpfr_ptr, mpfr_srcptr, long int, mpfr_rnd_t)
                                                                    ;
 int mpfr_pow_ui (mpfr_ptr, mpfr_srcptr, unsigned long int, mpfr_rnd_t)
                                                                             ;
 int mpfr_ui_pow_ui (mpfr_ptr, unsigned long int, unsigned long int, mpfr_rnd_t)
                                                                            ;
 int mpfr_ui_pow (mpfr_ptr, unsigned long int, mpfr_srcptr, mpfr_rnd_t)
                                                                       ;
 int mpfr_pow_z (mpfr_ptr, mpfr_srcptr, mpz_srcptr, mpfr_rnd_t)
                                                                     ;

 int mpfr_sqrt (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                        ;
 int mpfr_sqrt_ui (mpfr_ptr, unsigned long, mpfr_rnd_t)
                                                           ;
 int mpfr_rec_sqrt (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                            ;

 int mpfr_add (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                    ;
 int mpfr_sub (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                    ;
 int mpfr_mul (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                    ;
 int mpfr_div (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                    ;

 int mpfr_add_ui (mpfr_ptr, mpfr_srcptr, unsigned long, mpfr_rnd_t)
                                                                         ;
 int mpfr_sub_ui (mpfr_ptr, mpfr_srcptr, unsigned long, mpfr_rnd_t)
                                                                         ;
 int mpfr_ui_sub (mpfr_ptr, unsigned long, mpfr_srcptr, mpfr_rnd_t)
                                                                       ;
 int mpfr_mul_ui (mpfr_ptr, mpfr_srcptr, unsigned long, mpfr_rnd_t)
                                                                         ;
 int mpfr_div_ui (mpfr_ptr, mpfr_srcptr, unsigned long, mpfr_rnd_t)
                                                                         ;
 int mpfr_ui_div (mpfr_ptr, unsigned long, mpfr_srcptr, mpfr_rnd_t)
                                                                       ;

 int mpfr_add_si (mpfr_ptr, mpfr_srcptr, long int, mpfr_rnd_t)
                                                                    ;
 int mpfr_sub_si (mpfr_ptr, mpfr_srcptr, long int, mpfr_rnd_t)
                                                                    ;
 int mpfr_si_sub (mpfr_ptr, long int, mpfr_srcptr, mpfr_rnd_t)
                                                                       ;
 int mpfr_mul_si (mpfr_ptr, mpfr_srcptr, long int, mpfr_rnd_t)
                                                                    ;
 int mpfr_div_si (mpfr_ptr, mpfr_srcptr, long int, mpfr_rnd_t)
                                                                    ;
 int mpfr_si_div (mpfr_ptr, long int, mpfr_srcptr, mpfr_rnd_t)
                                                                       ;

 int mpfr_add_d (mpfr_ptr, mpfr_srcptr, double, mpfr_rnd_t)
                                                                  ;
 int mpfr_sub_d (mpfr_ptr, mpfr_srcptr, double, mpfr_rnd_t)
                                                                  ;
 int mpfr_d_sub (mpfr_ptr, double, mpfr_srcptr, mpfr_rnd_t)
                                                                       ;
 int mpfr_mul_d (mpfr_ptr, mpfr_srcptr, double, mpfr_rnd_t)
                                                                  ;
 int mpfr_div_d (mpfr_ptr, mpfr_srcptr, double, mpfr_rnd_t)
                                                                  ;
 int mpfr_d_div (mpfr_ptr, double, mpfr_srcptr, mpfr_rnd_t)
                                                                       ;

 int mpfr_sqr (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);

 int mpfr_const_pi (mpfr_ptr, mpfr_rnd_t);
 int mpfr_const_log2 (mpfr_ptr, mpfr_rnd_t);
 int mpfr_const_euler (mpfr_ptr, mpfr_rnd_t);
 int mpfr_const_catalan (mpfr_ptr, mpfr_rnd_t);

 int mpfr_agm (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                       ;

 int mpfr_log (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_log2 (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_log10 (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                         ;
 int mpfr_log1p (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                         ;

 int mpfr_exp (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_exp2 (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_exp10 (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                         ;
 int mpfr_expm1 (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                         ;
 int mpfr_eint (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_li2 (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);

 int mpfr_cmp (mpfr_srcptr, mpfr_srcptr);
 int mpfr_cmp3 (mpfr_srcptr, mpfr_srcptr, int);
 int mpfr_cmp_d (mpfr_srcptr, double);
 int mpfr_cmp_ld (mpfr_srcptr, long double);
 int mpfr_cmpabs (mpfr_srcptr, mpfr_srcptr);
 int mpfr_cmp_ui (mpfr_srcptr, unsigned long);
 int mpfr_cmp_si (mpfr_srcptr, long);
 int mpfr_cmp_ui_2exp (mpfr_srcptr, unsigned long, mpfr_exp_t)
                                                               ;
 int mpfr_cmp_si_2exp (mpfr_srcptr, long, mpfr_exp_t)
                                                               ;
 void mpfr_reldiff (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                         ;
 int mpfr_eq (mpfr_srcptr, mpfr_srcptr, unsigned long)
                                                        ;
 int mpfr_sgn (mpfr_srcptr);

 int mpfr_mul_2exp (mpfr_ptr, mpfr_srcptr, unsigned long, mpfr_rnd_t)
                                                                           ;
 int mpfr_div_2exp (mpfr_ptr, mpfr_srcptr, unsigned long, mpfr_rnd_t)
                                                                           ;
 int mpfr_mul_2ui (mpfr_ptr, mpfr_srcptr, unsigned long, mpfr_rnd_t)
                                                                          ;
 int mpfr_div_2ui (mpfr_ptr, mpfr_srcptr, unsigned long, mpfr_rnd_t)
                                                                          ;
 int mpfr_mul_2si (mpfr_ptr, mpfr_srcptr, long, mpfr_rnd_t)
                                                                 ;
 int mpfr_div_2si (mpfr_ptr, mpfr_srcptr, long, mpfr_rnd_t)
                                                                 ;

 int mpfr_rint (mpfr_ptr,mpfr_srcptr, mpfr_rnd_t);
 int mpfr_round (mpfr_ptr, mpfr_srcptr);
 int mpfr_trunc (mpfr_ptr, mpfr_srcptr);
 int mpfr_ceil (mpfr_ptr, mpfr_srcptr);
 int mpfr_floor (mpfr_ptr, mpfr_srcptr);
 int mpfr_rint_round (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                              ;
 int mpfr_rint_trunc (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                              ;
 int mpfr_rint_ceil (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                             ;
 int mpfr_rint_floor (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                              ;
 int mpfr_frac (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_modf (mpfr_ptr, mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                              ;
 int mpfr_remquo (mpfr_ptr, long*, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                       ;
 int mpfr_remainder (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                          ;
 int mpfr_fmod (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                          ;

 int mpfr_fits_ulong_p (mpfr_srcptr, mpfr_rnd_t);
 int mpfr_fits_slong_p (mpfr_srcptr, mpfr_rnd_t);
 int mpfr_fits_uint_p (mpfr_srcptr, mpfr_rnd_t);
 int mpfr_fits_sint_p (mpfr_srcptr, mpfr_rnd_t);
 int mpfr_fits_ushort_p (mpfr_srcptr, mpfr_rnd_t);
 int mpfr_fits_sshort_p (mpfr_srcptr, mpfr_rnd_t);
 int mpfr_fits_uintmax_p (mpfr_srcptr,mpfr_rnd_t);
 int mpfr_fits_intmax_p (mpfr_srcptr, mpfr_rnd_t);

 void mpfr_extract (mpz_ptr, mpfr_srcptr, unsigned int)
                                                              ;
 void mpfr_swap (mpfr_ptr, mpfr_ptr);
 void mpfr_dump (mpfr_srcptr);

 int mpfr_nan_p (mpfr_srcptr);
 int mpfr_inf_p (mpfr_srcptr);
 int mpfr_number_p (mpfr_srcptr);
 int mpfr_integer_p (mpfr_srcptr);
 int mpfr_zero_p (mpfr_srcptr);
 int mpfr_regular_p (mpfr_srcptr);

 int mpfr_greater_p (mpfr_srcptr, mpfr_srcptr);
 int mpfr_greaterequal_p (mpfr_srcptr, mpfr_srcptr)
                                                                   ;
 int mpfr_less_p (mpfr_srcptr, mpfr_srcptr);
 int mpfr_lessequal_p (mpfr_srcptr, mpfr_srcptr);
 int mpfr_lessgreater_p (mpfr_srcptr,mpfr_srcptr);
 int mpfr_equal_p (mpfr_srcptr, mpfr_srcptr);
 int mpfr_unordered_p (mpfr_srcptr, mpfr_srcptr);

 int mpfr_atanh (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_acosh (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_asinh (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_cosh (mpfr_ptr,mpfr_srcptr, mpfr_rnd_t);
 int mpfr_sinh (mpfr_ptr,mpfr_srcptr, mpfr_rnd_t);
 int mpfr_tanh (mpfr_ptr,mpfr_srcptr, mpfr_rnd_t);
 int mpfr_sinh_cosh (mpfr_ptr, mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                                        ;

 int mpfr_sech (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_csch (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_coth (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);

 int mpfr_acos (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_asin (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_atan (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_sin (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_sin_cos (mpfr_ptr, mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                                        ;
 int mpfr_cos (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_tan (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_atan2 (mpfr_ptr,mpfr_srcptr,mpfr_srcptr, mpfr_rnd_t)
                                                         ;
 int mpfr_sec (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_csc (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_cot (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);

 int mpfr_hypot (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                      ;
 int mpfr_erf (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_erfc (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_cbrt (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_root (mpfr_ptr,mpfr_srcptr,unsigned long,mpfr_rnd_t);
 int mpfr_gamma (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_lngamma (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_lgamma (mpfr_ptr,int*,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_digamma (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_zeta (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_zeta_ui (mpfr_ptr,unsigned long,mpfr_rnd_t);
 int mpfr_fac_ui (mpfr_ptr, unsigned long int, mpfr_rnd_t)
                                                          ;
 int mpfr_j0 (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
 int mpfr_j1 (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
 int mpfr_jn (mpfr_ptr, long, mpfr_srcptr, mpfr_rnd_t)
                                                      ;
 int mpfr_y0 (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
 int mpfr_y1 (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
 int mpfr_yn (mpfr_ptr, long, mpfr_srcptr, mpfr_rnd_t)
                                                      ;

 int mpfr_ai (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);

 int mpfr_min (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                       ;
 int mpfr_max (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                       ;
 int mpfr_dim (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                       ;

 int mpfr_mul_z (mpfr_ptr, mpfr_srcptr, mpz_srcptr, mpfr_rnd_t)
                                                                     ;
 int mpfr_div_z (mpfr_ptr, mpfr_srcptr, mpz_srcptr, mpfr_rnd_t)
                                                                     ;
 int mpfr_add_z (mpfr_ptr, mpfr_srcptr, mpz_srcptr, mpfr_rnd_t)
                                                                     ;
 int mpfr_sub_z (mpfr_ptr, mpfr_srcptr, mpz_srcptr, mpfr_rnd_t)
                                                                     ;
 int mpfr_cmp_z (mpfr_srcptr, mpz_srcptr);

 int mpfr_mul_q (mpfr_ptr, mpfr_srcptr, mpq_srcptr, mpfr_rnd_t)
                                                                     ;
 int mpfr_div_q (mpfr_ptr, mpfr_srcptr, mpq_srcptr, mpfr_rnd_t)
                                                                     ;
 int mpfr_add_q (mpfr_ptr, mpfr_srcptr, mpq_srcptr, mpfr_rnd_t)
                                                                     ;
 int mpfr_sub_q (mpfr_ptr, mpfr_srcptr, mpq_srcptr, mpfr_rnd_t)
                                                                     ;
 int mpfr_cmp_q (mpfr_srcptr, mpq_srcptr);

 int mpfr_cmp_f (mpfr_srcptr, mpf_srcptr);

 int mpfr_fma (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                    ;
 int mpfr_fms (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                    ;
 int mpfr_sum (mpfr_ptr, mpfr_ptr *const, unsigned long, mpfr_rnd_t)
                                                                      ;

 void mpfr_free_cache (void);

 int mpfr_subnormalize (mpfr_ptr, int, mpfr_rnd_t)
                                                                 ;

 int mpfr_strtofr (mpfr_ptr, const char *, char **, int, mpfr_rnd_t)
                                                                          ;

 size_t mpfr_custom_get_size (mpfr_prec_t);
 void mpfr_custom_init (void *, mpfr_prec_t);
 void * mpfr_custom_get_significand (mpfr_srcptr);
 mpfr_exp_t mpfr_custom_get_exp (mpfr_srcptr);
 void mpfr_custom_move (mpfr_ptr, void *);
 void mpfr_custom_init_set (mpfr_ptr, int, mpfr_exp_t, mpfr_prec_t, void *)
                                                                              ;
 int mpfr_custom_get_kind (mpfr_srcptr);


}
#149 "C:/Xilinx/Vivado/2018.3/include/floating_point_v7_0_bitacc_cmodel.h" 2



typedef long xip_fpo_prec_t;


typedef int xip_fpo_sign_t;


typedef long xip_fpo_exp_t;


typedef struct {
  xip_fpo_prec_t _xip_fpo_exp_prec;
  xip_fpo_prec_t _xip_fpo_mant_prec;
  xip_fpo_sign_t _xip_fpo_sign;
  xip_fpo_exp_t _xip_fpo_exp;
  mp_limb_t *_xip_fpo_d;
} __xip_fpo_struct;


typedef struct {
  xip_fpo_prec_t _xip_fpo_i_prec;
  xip_fpo_prec_t _xip_fpo_frac_prec;
  xint64 _xip_fpo_i;
  xint64 _xip_fpo_frac;
} __xip_fpo_fix_struct;


typedef __xip_fpo_struct xip_fpo_t[1];
typedef __xip_fpo_fix_struct xip_fpo_fix_t[1];


typedef __xip_fpo_struct *xip_fpo_ptr;
typedef const __xip_fpo_struct *xip_fpo_srcptr;
typedef __xip_fpo_fix_struct *xip_fpo_fix_ptr;
typedef const __xip_fpo_fix_struct *xip_fpo_fix_srcptr;
#197 "C:/Xilinx/Vivado/2018.3/include/floating_point_v7_0_bitacc_cmodel.h"
typedef int xip_fpo_exc_t;


extern "C" {


typedef struct xil_fpo_accum_state xil_fpo_accum_state;


 const char * xip_fpo_get_version (void);


 void xip_fpo_init2 (xip_fpo_ptr, xip_fpo_prec_t, xip_fpo_prec_t);
 void xip_fpo_fix_init2 (xip_fpo_fix_ptr, xip_fpo_prec_t, xip_fpo_prec_t);
 void xip_fpo_inits2 (xip_fpo_prec_t, xip_fpo_prec_t, xip_fpo_ptr, ...) __attribute__ ((sentinel));
 void xip_fpo_fix_inits2 (xip_fpo_prec_t, xip_fpo_prec_t, xip_fpo_fix_ptr, ...) __attribute__ ((sentinel));
 void xip_fpo_clear (xip_fpo_ptr);
 void xip_fpo_fix_clear (xip_fpo_fix_ptr);
 void xip_fpo_clears (xip_fpo_ptr, ...) __attribute__ ((sentinel));
 void xip_fpo_fix_clears (xip_fpo_fix_ptr, ...) __attribute__ ((sentinel));
 void xip_fpo_set_prec (xip_fpo_ptr, xip_fpo_prec_t, xip_fpo_prec_t);
 void xip_fpo_fix_set_prec (xip_fpo_fix_ptr, xip_fpo_prec_t, xip_fpo_prec_t);
 xip_fpo_prec_t xip_fpo_get_prec_mant (xip_fpo_ptr);
 xip_fpo_prec_t xip_fpo_get_prec_exp (xip_fpo_ptr);
 xip_fpo_prec_t xip_fpo_fix_get_prec_frac (xip_fpo_fix_ptr);
 xip_fpo_prec_t xip_fpo_fix_get_prec_int (xip_fpo_fix_ptr);


 xip_fpo_exc_t xip_fpo_set (xip_fpo_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_fix_set (xip_fpo_fix_ptr, xip_fpo_fix_srcptr);
 xip_fpo_exc_t xip_fpo_set_ui (xip_fpo_ptr, unsigned long);
 xip_fpo_exc_t xip_fpo_fix_set_ui (xip_fpo_fix_ptr, unsigned long);
 xip_fpo_exc_t xip_fpo_set_si (xip_fpo_ptr, long);
 xip_fpo_exc_t xip_fpo_fix_set_si (xip_fpo_fix_ptr, long);
 xip_fpo_exc_t xip_fpo_set_uj (xip_fpo_ptr, uintmax_t);
 xip_fpo_exc_t xip_fpo_fix_set_uj (xip_fpo_fix_ptr, uintmax_t);
 xip_fpo_exc_t xip_fpo_set_sj (xip_fpo_ptr, intmax_t);
 xip_fpo_exc_t xip_fpo_fix_set_sj (xip_fpo_fix_ptr, intmax_t);
 xip_fpo_exc_t xip_fpo_set_flt (xip_fpo_ptr, float);
 xip_fpo_exc_t xip_fpo_fix_set_flt (xip_fpo_fix_ptr, float);
 xip_fpo_exc_t xip_fpo_set_d (xip_fpo_ptr, double);
 xip_fpo_exc_t xip_fpo_fix_set_d (xip_fpo_fix_ptr, double);
 xip_fpo_exc_t xip_fpo_set_z (xip_fpo_ptr, mpz_srcptr);
 xip_fpo_exc_t xip_fpo_fix_set_z (xip_fpo_fix_ptr, mpz_srcptr);
 xip_fpo_exc_t xip_fpo_set_q (xip_fpo_ptr, mpq_srcptr);
 xip_fpo_exc_t xip_fpo_fix_set_q (xip_fpo_fix_ptr, mpq_srcptr);
 xip_fpo_exc_t xip_fpo_set_f (xip_fpo_ptr, mpf_srcptr);
 xip_fpo_exc_t xip_fpo_fix_set_f (xip_fpo_fix_ptr, mpf_srcptr);
 xip_fpo_exc_t xip_fpo_set_fr (xip_fpo_ptr, mpfr_srcptr);
 xip_fpo_exc_t xip_fpo_fix_set_fr (xip_fpo_fix_ptr, mpfr_srcptr);
 xip_fpo_exc_t xip_fpo_set_ui_2exp (xip_fpo_ptr, unsigned long, xip_fpo_exp_t);
 xip_fpo_exc_t xip_fpo_set_si_2exp (xip_fpo_ptr, long, xip_fpo_exp_t);
 xip_fpo_exc_t xip_fpo_set_uj_2exp (xip_fpo_ptr, uintmax_t, intmax_t);
 xip_fpo_exc_t xip_fpo_set_sj_2exp (xip_fpo_ptr, intmax_t, intmax_t);
 xip_fpo_exc_t xip_fpo_set_str (xip_fpo_ptr, const char *, int);
 xip_fpo_exc_t xip_fpo_fix_set_str (xip_fpo_fix_ptr, const char *, int);
 void xip_fpo_set_nan (xip_fpo_ptr);
 void xip_fpo_set_inf (xip_fpo_ptr, int);
 void xip_fpo_set_zero (xip_fpo_ptr, int);


 unsigned long xip_fpo_get_ui (xip_fpo_srcptr);
 unsigned long xip_fpo_fix_get_ui (xip_fpo_fix_srcptr);
 long xip_fpo_get_si (xip_fpo_srcptr);
 long xip_fpo_fix_get_si (xip_fpo_fix_srcptr);
 uintmax_t xip_fpo_get_uj (xip_fpo_srcptr);
 uintmax_t xip_fpo_fix_get_uj (xip_fpo_fix_srcptr);
 intmax_t xip_fpo_get_sj (xip_fpo_srcptr);
 intmax_t xip_fpo_fix_get_sj (xip_fpo_fix_srcptr);
 float xip_fpo_get_flt (xip_fpo_srcptr);
 float xip_fpo_fix_get_flt (xip_fpo_fix_srcptr);
 double xip_fpo_get_d (xip_fpo_srcptr);
 double xip_fpo_fix_get_d (xip_fpo_fix_srcptr);
 double xip_fpo_get_d_2exp (long *, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_get_z (mpz_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_fix_get_z (mpz_ptr, xip_fpo_fix_srcptr);
 xip_fpo_exc_t xip_fpo_get_f (mpf_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_fix_get_f (mpf_ptr, xip_fpo_fix_srcptr);
 xip_fpo_exc_t xip_fpo_get_fr (mpfr_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_fix_get_fr (mpfr_ptr, xip_fpo_fix_srcptr);
 char * xip_fpo_get_str (char *, xip_fpo_exp_t *, int, int, xip_fpo_srcptr);
 char * xip_fpo_fix_get_str (char *, int, xip_fpo_fix_srcptr);
 void xip_fpo_free_str (char *);
 void xip_fpo_fix_free_str (char *);
 int xip_fpo_sizeinbase (xip_fpo_srcptr, int);
 int xip_fpo_fix_sizeinbase (xip_fpo_fix_srcptr, int);


 xip_fpo_exc_t xip_fpo_add (xip_fpo_ptr, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_add_flt (float *, float, float);
 xip_fpo_exc_t xip_fpo_add_d (double *, double, double);
 xip_fpo_exc_t xip_fpo_sub (xip_fpo_ptr, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_sub_flt (float *, float, float);
 xip_fpo_exc_t xip_fpo_sub_d (double *, double, double);
 xip_fpo_exc_t xip_fpo_mul (xip_fpo_ptr, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_mul_flt (float *, float, float);
 xip_fpo_exc_t xip_fpo_mul_d (double *, double, double);
 xip_fpo_exc_t xip_fpo_fma (xip_fpo_ptr, xip_fpo_srcptr, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_fma_flt (float *, float, float, float);
 xip_fpo_exc_t xip_fpo_fma_d (double *, double, double, double);
 xip_fpo_exc_t xip_fpo_fms (xip_fpo_ptr, xip_fpo_srcptr, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_fms_flt (float *, float, float, float);
 xip_fpo_exc_t xip_fpo_fms_d (double *, double, double, double);
 xip_fpo_exc_t xip_fpo_div (xip_fpo_ptr, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_div_flt (float *, float, float);
 xip_fpo_exc_t xip_fpo_div_d (double *, double, double);
 xip_fpo_exc_t xip_fpo_rec (xip_fpo_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_rec_flt (float *, float);
 xip_fpo_exc_t xip_fpo_rec_d (double *, double);
 xip_fpo_exc_t xip_fpo_abs (xip_fpo_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_abs_flt (float *, float);
 xip_fpo_exc_t xip_fpo_abs_d (double *, double);
 xip_fpo_exc_t xip_fpo_log (xip_fpo_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_log_flt (float *, float);
 xip_fpo_exc_t xip_fpo_log_d (double *, double);
 int xip_fpo_exp_array (xip_fpo_t * , xip_fpo_t * , xip_fpo_exc_t *, unsigned long long);
 void xip_fpo_exp_flt_array (float * , float * , xip_fpo_exc_t *, unsigned long long);
 void xip_fpo_exp_d_array (double * , double * , xip_fpo_exc_t *, unsigned long long);
 xip_fpo_exc_t xip_fpo_exp (xip_fpo_ptr , xip_fpo_srcptr );
 xip_fpo_exc_t xip_fpo_exp_flt (float * , float );
 xip_fpo_exc_t xip_fpo_exp_d (double * , double );
 struct xil_fpo_accum_state * xip_fpo_accum_create_state (int , int , int , int , int);
 void xip_fpo_accum_reset_state (struct xil_fpo_accum_state *);
 void xip_fpo_accum_destroy_state (struct xil_fpo_accum_state *);
 xip_fpo_exc_t xip_fpo_accum_sample (xip_fpo_t, xip_fpo_t, bool, struct xil_fpo_accum_state *);
 xip_fpo_exc_t xip_fpo_accum_sample_flt (float *, float , bool, struct xil_fpo_accum_state *);
 xip_fpo_exc_t xip_fpo_accum_sample_d (double *, double , bool, struct xil_fpo_accum_state *);
 xip_fpo_exc_t xip_fpo_sqrt (xip_fpo_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_sqrt_flt (float *, float);
 xip_fpo_exc_t xip_fpo_sqrt_d (double *, double);
 xip_fpo_exc_t xip_fpo_recsqrt (xip_fpo_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_recsqrt_flt (float *, float);
 xip_fpo_exc_t xip_fpo_recsqrt_d (double *, double);
 xip_fpo_exc_t xip_fpo_unordered (int *, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_unordered_flt (int *, float, float);
 xip_fpo_exc_t xip_fpo_unordered_d (int *, double, double);
 xip_fpo_exc_t xip_fpo_equal (int *, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_equal_flt (int *, float, float);
 xip_fpo_exc_t xip_fpo_equal_d (int *, double, double);
 xip_fpo_exc_t xip_fpo_less (int *, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_less_flt (int *, float, float);
 xip_fpo_exc_t xip_fpo_less_d (int *, double, double);
 xip_fpo_exc_t xip_fpo_lessequal (int *, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_lessequal_flt (int *, float, float);
 xip_fpo_exc_t xip_fpo_lessequal_d (int *, double, double);
 xip_fpo_exc_t xip_fpo_greater (int *, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_greater_flt (int *, float, float);
 xip_fpo_exc_t xip_fpo_greater_d (int *, double, double);
 xip_fpo_exc_t xip_fpo_greaterequal (int *, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_greaterequal_flt (int *, float, float);
 xip_fpo_exc_t xip_fpo_greaterequal_d (int *, double, double);
 xip_fpo_exc_t xip_fpo_notequal (int *, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_notequal_flt (int *, float, float);
 xip_fpo_exc_t xip_fpo_notequal_d (int *, double, double);
 xip_fpo_exc_t xip_fpo_condcode (int *, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_condcode_flt (int *, float, float);
 xip_fpo_exc_t xip_fpo_condcode_d (int *, double, double);
 xip_fpo_exc_t xip_fpo_flttofix (xip_fpo_fix_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_flttofix_int_flt (int *, float);
 xip_fpo_exc_t xip_fpo_flttofix_int_d (int *, double);
 xip_fpo_exc_t xip_fpo_fixtoflt (xip_fpo_ptr, xip_fpo_fix_srcptr);
 xip_fpo_exc_t xip_fpo_fixtoflt_flt_int (float *, int);
 xip_fpo_exc_t xip_fpo_fixtoflt_d_int (double *, int);
 xip_fpo_exc_t xip_fpo_flttoflt (xip_fpo_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_flttoflt_flt_flt (float *, float);
 xip_fpo_exc_t xip_fpo_flttoflt_flt_d (float *, double);
 xip_fpo_exc_t xip_fpo_flttoflt_d_flt (double *, float);
 xip_fpo_exc_t xip_fpo_flttoflt_d_d (double *, double);


}
#187 "C:/Xilinx/Vivado/2018.3/include/hls_fpo.h" 2
#1 "C:/Xilinx/Vivado/2018.3/include/gmp.h" 1
#188 "C:/Xilinx/Vivado/2018.3/include/hls_fpo.h" 2
#1 "C:/Xilinx/Vivado/2018.3/include/mpfr.h" 1
#189 "C:/Xilinx/Vivado/2018.3/include/hls_fpo.h" 2





inline float xil_fpo_add_flt(float a, float b)
{
  float res_flt = 0.0f;


  xip_fpo_add_flt(&res_flt, a, b);
  return res_flt;
}

inline double xil_fpo_add_d(double a, double b)
{
  double res_d = 0.0;


  xip_fpo_add_d(&res_d, a, b);
  return res_d;
}





inline float xil_fpo_sub_flt(float a, float b)
{
  float res_flt = 0.0f;


  xip_fpo_sub_flt(&res_flt, a, b);
  return res_flt;
}

inline double xil_fpo_sub_d(double a, double b)
{
  double res_d = 0.0;


  xip_fpo_sub_d(&res_d, a, b);
  return res_d;
}





inline float xil_fpo_mul_flt(float a, float b)
{
  float res_flt = 0.0f;


  xip_fpo_mul_flt(&res_flt, a, b);
  return res_flt;
}

inline double xil_fpo_mul_d(double a, double b)
{
  double res_d = 0.0;


  xip_fpo_mul_d(&res_d, a, b);
  return res_d;
}





inline float xil_fpo_div_flt(float a, float b)
{
  float res_flt = 0.0f;


  xip_fpo_div_flt(&res_flt, a, b);
  return res_flt;
}

inline double xil_fpo_div_d(double a, double b)
{
  double res_d = 0.0;


  xip_fpo_div_d(&res_d, a, b);
  return res_d;
}





inline float xil_fpo_rec_flt(float a)
{
  float res_flt = 0.0f;


  xip_fpo_rec_flt(&res_flt, a);
  return res_flt;
}

inline double xil_fpo_rec_d(double a)
{
  double res_d = 0.0;


  xip_fpo_rec_d(&res_d, a);
  return res_d;
}





inline float xil_fpo_sqrt_flt(float a)
{

  float res_flt = 0.0f;


  xip_fpo_sqrt_flt(&res_flt, a);

  return res_flt;
}

inline double xil_fpo_sqrt_d(double a)
{
  double res_d = 0.0;


  xip_fpo_sqrt_d(&res_d, a);

  return res_d;
}





inline float xil_fpo_recsqrt_flt(float a)
{
  float res_flt = 0.0f;


  xip_fpo_recsqrt_flt(&res_flt, a);
  return res_flt;
}

inline double xil_fpo_recsqrt_d(double a)
{
  double res_d = 0.0;


  xip_fpo_recsqrt_d(&res_d, a);
  return res_d;
}





inline float xil_fpo_abs_flt(float a)
{
  float res_flt = 0.0f;

  xip_fpo_abs_flt(&res_flt, a);
  return res_flt;
}

inline double xil_fpo_abs_d(double a)
{
  double res_d = 0.0;

  xip_fpo_abs_d(&res_d, a);
  return res_d;
}





inline float xil_fpo_log_flt(float a)
{
  float res_flt = 0.0f;


  xip_fpo_log_flt(&res_flt, a);
  return res_flt;
}

inline double xil_fpo_log_d(double a)
{
  double res_d = 0.0;


  xip_fpo_log_d(&res_d, a);
  return res_d;
}





inline float xil_fpo_exp_flt(float a)
{
  float res_flt = 0.0f;


  xip_fpo_exp_flt(&res_flt, a);
  return res_flt;
}

inline double xil_fpo_exp_d(double a)
{
  double res_d = 0.0;


  xip_fpo_exp_d(&res_d, a);
  return res_d;
}





inline int xil_fpo_unordered_flt(float a, float b)
{
  int res_int = 0;


  xip_fpo_unordered_flt(&res_int, a, b);
  return res_int;
}

inline int xil_fpo_unordered_d(double a, double b)
{
  int res_int = 0;


  xip_fpo_unordered_d(&res_int, a, b);
  return res_int;
}






inline int xil_fpo_equal_flt(float a, float b)
{
  int res_int = 0;


  xip_fpo_equal_flt(&res_int, a, b);
  return res_int;
}

inline int xil_fpo_equal_d(double a, double b)
{
  int res_int = 0;


  xip_fpo_equal_d(&res_int, a, b);
  return res_int;
}





inline int xil_fpo_less_flt(float a, float b)
{
  int res_int = 0;


  xip_fpo_less_flt(&res_int, a, b);
  return res_int;
}

inline int xil_fpo_less_d(double a, double b)
{
  int res_int = 0;


  xip_fpo_less_d(&res_int, a, b);
  return res_int;
}





inline int xil_fpo_lessequal_flt(float a, float b)
{
  int res_int = 0;


  xip_fpo_lessequal_flt(&res_int, a, b);
  return res_int;
}

inline int xil_fpo_lessequal_d(double a, double b)
{
  int res_int = 0;


  xip_fpo_lessequal_d(&res_int, a, b);
  return res_int;
}





inline int xil_fpo_greater_flt(float a, float b)
{
  int res_int = 0;


  xip_fpo_greater_flt(&res_int, a, b);
  return res_int;
}

inline int xil_fpo_greater_d(double a, double b)
{
  int res_int = 0;


  xip_fpo_greater_d(&res_int, a, b);
  return res_int;
}





inline int xil_fpo_greaterequal_flt(float a, float b)
{
  int res_int = 0;


  xip_fpo_greaterequal_flt(&res_int, a, b);
  return res_int;
}

inline int xil_fpo_greaterequal_d(double a, double b)
{
  int res_int = 0;


  xip_fpo_greaterequal_d(&res_int, a, b);
  return res_int;
}





inline int xil_fpo_notequal_flt(float a, float b)
{
  int res_int = 0;


  xip_fpo_notequal_flt(&res_int, a, b);
  return res_int;
}

inline int xil_fpo_notequal_d(double a, double b)
{
  int res_int = 0;

  xip_fpo_notequal_d(&res_int, a, b);
  return res_int;
}





inline int xil_fpo_condcode_flt(float a, float b)
{
  int res_int = 0;


  xip_fpo_condcode_flt(&res_int, a, b);
  return res_int;
}

inline int xil_fpo_condcode_d(double a, double b)
{
  int res_int = 0;


  xip_fpo_condcode_d(&res_int, a, b);
  return res_int;
}




inline int xil_fpo_flttofix_int_flt(float a)
{
  int res_int = 0;


  xip_fpo_flttofix_int_flt(&res_int, a);
  return res_int;
}

inline int xil_fpo_flttofix_int_d(double a)
{
  int res_int = 0;


  xip_fpo_flttofix_int_d(&res_int, a);
  return res_int;
}

inline float xil_fpo_fixtoflt_flt_int(int a)
{
  float res_flt = 0.0f;


  xip_fpo_fixtoflt_flt_int(&res_flt, a);
  return res_flt;
}

inline double xil_fpo_fixtoflt_d_int(int a)
{
  double res_d = 0.0;


  xip_fpo_fixtoflt_d_int(&res_d, a);
  return res_d;
}

inline float xil_fpo_flttoflt_flt_flt(float a)
{
  float res_flt = 0.0f;


  xip_fpo_flttoflt_flt_flt(&res_flt, a);
  return res_flt;
}

inline float xil_fpo_flttoflt_flt_d(double a)
{
  float res_flt = 0.0f;


  xip_fpo_flttoflt_flt_d(&res_flt, a);
  return res_flt;
}

inline double xil_fpo_flttoflt_d_flt(float a)
{
  double res_d = 0.0;


  xip_fpo_flttoflt_d_flt(&res_d, a);
  return res_d;
}

inline double xil_fpo_flttoflt_d_d(double a)
{
  double res_d = 0.0;


  xip_fpo_flttoflt_d_d(&res_d, a);
  return res_d;
}
#45 "C:/Xilinx/Vivado/2018.3/include/hls_half.h" 2


#1 "C:/Xilinx/Vivado/2018.3/include/ap_decl.h" 1
#100 "C:/Xilinx/Vivado/2018.3/include/ap_decl.h"
enum ap_q_mode {
  AP_RND,
  AP_RND_ZERO,
  AP_RND_MIN_INF,
  AP_RND_INF,
  AP_RND_CONV,
  AP_TRN,
  AP_TRN_ZERO,
};
#122 "C:/Xilinx/Vivado/2018.3/include/ap_decl.h"
enum ap_o_mode {
  AP_SAT,
  AP_SAT_ZERO,
  AP_SAT_SYM,
  AP_WRAP,
  AP_WRAP_SM,
};
#179 "C:/Xilinx/Vivado/2018.3/include/ap_decl.h"
template <int _AP_W, bool _AP_S>
struct ap_int_base;

template <int _AP_W>
struct ap_int;

template <int _AP_W>
struct ap_uint;

template <int _AP_W, bool _AP_S>
struct ap_range_ref;

template <int _AP_W, bool _AP_S>
struct ap_bit_ref;

template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2>
struct ap_concat_ref;

template <int _AP_W, int _AP_I, bool _AP_S = true, ap_q_mode _AP_Q = AP_TRN,
          ap_o_mode _AP_O = AP_WRAP, int _AP_N = 0>
struct ap_fixed_base;

template <int _AP_W, int _AP_I, ap_q_mode _AP_Q = AP_TRN,
          ap_o_mode _AP_O = AP_WRAP, int _AP_N = 0>
struct ap_fixed;

template <int _AP_W, int _AP_I, ap_q_mode _AP_Q = AP_TRN,
          ap_o_mode _AP_O = AP_WRAP, int _AP_N = 0>
struct ap_ufixed;

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct af_range_ref;

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct af_bit_ref;


enum BaseMode { AP_BIN = 2, AP_OCT = 8, AP_DEC = 10, AP_HEX = 16 };
#232 "C:/Xilinx/Vivado/2018.3/include/ap_decl.h"
typedef signed long long ap_slong;
typedef unsigned long long ap_ulong;


enum {
  _AP_SIZE_char = 8,
  _AP_SIZE_short = sizeof(short) * 8,
  _AP_SIZE_int = sizeof(int) * 8,
  _AP_SIZE_long = sizeof(long) * 8,
  _AP_SIZE_ap_slong = sizeof(ap_slong) * 8
};
#48 "C:/Xilinx/Vivado/2018.3/include/hls_half.h" 2
#129 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/utility" 1 3
#58 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/utility" 3

#59 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/utility" 3
#69 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/utility" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_relops.h" 1 3
#67 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_relops.h" 3

#67 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_relops.h" 3
namespace std
{
  namespace rel_ops
  {

#85 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
#98 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
#111 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
#124 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }


  }

}
#70 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/utility" 2 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_pair.h" 1 3
#59 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_pair.h" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/move.h" 1 3
#34 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/move.h" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/concept_check.h" 1 3
#33 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/concept_check.h" 3

#34 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/concept_check.h" 3
#35 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/move.h" 2 3

namespace std
{







  template<typename _Tp>
    inline _Tp*
    __addressof(_Tp& __r) noexcept
    {
      return reinterpret_cast<_Tp*>
 (&const_cast<char&>(reinterpret_cast<const volatile char&>(__r)));
    }


}


#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/type_traits" 1 3
#32 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/type_traits" 3

#33 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/type_traits" 3
#42 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/type_traits" 3
namespace std
{
  typedef short unsigned int uint_least16_t;
  typedef unsigned int uint_least32_t;
}





namespace std
{

#68 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/type_traits" 3
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static constexpr _Tp value = __v;
      typedef _Tp value_type;
      typedef integral_constant<_Tp, __v> type;
      constexpr operator value_type() const { return value; }




      constexpr value_type operator()() const { return value; }

    };

  template<typename _Tp, _Tp __v>
    constexpr _Tp integral_constant<_Tp, __v>::value;


  typedef integral_constant<bool, true> true_type;


  typedef integral_constant<bool, false> false_type;

  template<bool __v>
    using __bool_constant = integral_constant<bool, __v>;
#103 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/type_traits" 3
  template<bool, typename, typename>
    struct conditional;

  template<typename...>
    struct __or_;

  template<>
    struct __or_<>
    : public false_type
    { };

  template<typename _B1>
    struct __or_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __or_<_B1, _B2>
    : public conditional<_B1::value, _B1, _B2>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __or_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type
    { };

  template<typename...>
    struct __and_;

  template<>
    struct __and_<>
    : public true_type
    { };

  template<typename _B1>
    struct __and_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __and_<_B1, _B2>
    : public conditional<_B1::value, _B2, _B1>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __and_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type
    { };

  template<typename _Pp>
    struct __not_
    : public integral_constant<bool, !_Pp::value>
    { };
#182 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/type_traits" 3
  template<typename _Tp>
    struct __success_type
    { typedef _Tp type; };

  struct __failure_type
  { };



  template<typename>
    struct remove_cv;

  template<typename>
    struct __is_void_helper
    : public false_type { };

  template<>
    struct __is_void_helper<void>
    : public true_type { };


  template<typename _Tp>
    struct is_void
    : public __is_void_helper<typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_integral_helper
    : public false_type { };

  template<>
    struct __is_integral_helper<bool>
    : public true_type { };

  template<>
    struct __is_integral_helper<char>
    : public true_type { };

  template<>
    struct __is_integral_helper<signed char>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned char>
    : public true_type { };


  template<>
    struct __is_integral_helper<wchar_t>
    : public true_type { };


  template<>
    struct __is_integral_helper<char16_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<char32_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<short>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned short>
    : public true_type { };

  template<>
    struct __is_integral_helper<int>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned int>
    : public true_type { };

  template<>
    struct __is_integral_helper<long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long>
    : public true_type { };

  template<>
    struct __is_integral_helper<long long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long long>
    : public true_type { };




  template<>
    struct __is_integral_helper<__int128>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned __int128>
    : public true_type { };
#314 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/type_traits" 3
  template<typename _Tp>
    struct is_integral
    : public __is_integral_helper<typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_floating_point_helper
    : public false_type { };

  template<>
    struct __is_floating_point_helper<float>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<double>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<long double>
    : public true_type { };


  template<>
    struct __is_floating_point_helper<__float128>
    : public true_type { };



  template<typename _Tp>
    struct is_floating_point
    : public __is_floating_point_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename>
    struct is_array
    : public false_type { };

  template<typename _Tp, std::size_t _Size>
    struct is_array<_Tp[_Size]>
    : public true_type { };

  template<typename _Tp>
    struct is_array<_Tp[]>
    : public true_type { };

  template<typename>
    struct __is_pointer_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_pointer_helper<_Tp*>
    : public true_type { };


  template<typename _Tp>
    struct is_pointer
    : public __is_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename>
    struct is_lvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };


  template<typename>
    struct is_rvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };

  template<typename>
    struct is_function;

  template<typename>
    struct __is_member_object_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_object_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, !is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_object_pointer
    : public __is_member_object_pointer_helper<
    typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_member_function_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_function_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_function_pointer
    : public __is_member_function_pointer_helper<
    typename remove_cv<_Tp>::type>::type
    { };


  template<typename _Tp>
    struct is_enum
    : public integral_constant<bool, __is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public integral_constant<bool, __is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public integral_constant<bool, __is_class(_Tp)>
    { };


  template<typename>
    struct is_function
    : public false_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) volatile &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) volatile &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) volatile &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) volatile &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const volatile &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const volatile &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const volatile &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const volatile &&>
    : public true_type { };



  template<typename>
    struct __is_null_pointer_helper
    : public false_type { };

  template<>
    struct __is_null_pointer_helper<std::nullptr_t>
    : public true_type { };


  template<typename _Tp>
    struct is_null_pointer
    : public __is_null_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename _Tp>
    struct __is_nullptr_t
    : public is_null_pointer<_Tp>
    { };




  template<typename _Tp>
    struct is_reference
    : public __or_<is_lvalue_reference<_Tp>,
                   is_rvalue_reference<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_arithmetic
    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_fundamental
    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,
     is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_object
    : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,
                          is_void<_Tp>>>::type
    { };

  template<typename>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                   is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_compound
    : public integral_constant<bool, !is_fundamental<_Tp>::value> { };

  template<typename _Tp>
    struct __is_member_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_pointer_helper<_Tp _Cp::*>
    : public true_type { };


  template<typename _Tp>
    struct is_member_pointer
    : public __is_member_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };



  template<typename _Tp>
    struct __is_referenceable
    : public __or_<is_object<_Tp>, is_reference<_Tp>>::type
    { };

  template<typename _Res, typename... _Args>
    struct __is_referenceable<_Res(_Args...)>
    : public true_type
    { };

  template<typename _Res, typename... _Args>
    struct __is_referenceable<_Res(_Args......)>
    : public true_type
    { };




  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_trivial
    : public integral_constant<bool, __is_trivial(_Tp)>
    { };


  template<typename _Tp>
    struct is_trivially_copyable
    : public integral_constant<bool, __is_trivially_copyable(_Tp)>
    { };


  template<typename _Tp>
    struct is_standard_layout
    : public integral_constant<bool, __is_standard_layout(_Tp)>
    { };



  template<typename _Tp>
    struct is_pod
    : public integral_constant<bool, __is_pod(_Tp)>
    { };


  template<typename _Tp>
    struct is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)>
    { };


  template<typename _Tp>
    struct is_empty
    : public integral_constant<bool, __is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)>
    { };




  template<typename _Tp>
    struct is_final
    : public integral_constant<bool, __is_final(_Tp)>
    { };



  template<typename _Tp>
    struct is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)>
    { };

  template<typename _Tp,
    bool = is_arithmetic<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, true>
    : public integral_constant<bool, _Tp(-1) < _Tp(0)>
    { };


  template<typename _Tp>
    struct is_signed
    : public __is_signed_helper<_Tp>::type
    { };


  template<typename _Tp>
    struct is_unsigned
    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>
    { };




  template<typename>
    struct add_rvalue_reference;





  template<typename _Tp>
    typename add_rvalue_reference<_Tp>::type declval() noexcept;

  template<typename, unsigned = 0>
    struct extent;

  template<typename>
    struct remove_all_extents;

  template<typename _Tp>
    struct __is_array_known_bounds
    : public integral_constant<bool, (extent<_Tp>::value > 0)>
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds
    : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>
    { };






  struct __do_is_destructible_impl
  {
    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_destructible_impl
    : public __do_is_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_destructible_safe;

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, false>
    : public __is_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_destructible
    : public __is_destructible_safe<_Tp>::type
    { };





  struct __do_is_nt_destructible_impl
  {
    template<typename _Tp>
      static integral_constant<bool, noexcept(declval<_Tp&>().~_Tp())>
        __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_nt_destructible_impl
    : public __do_is_nt_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_nt_destructible_safe;

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, false>
    : public __is_nt_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_nothrow_destructible
    : public __is_nt_destructible_safe<_Tp>::type
    { };

  struct __do_is_default_constructible_impl
  {
    template<typename _Tp, typename = decltype(_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_default_constructible_impl
    : public __do_is_default_constructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_default_constructible_atom
    : public __and_<__not_<is_void<_Tp>>,
                    __is_default_constructible_impl<_Tp>>
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_default_constructible_safe;






  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>
    { };

  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, false>
    : public __is_default_constructible_atom<_Tp>::type
    { };


  template<typename _Tp>
    struct is_default_constructible
    : public __is_default_constructible_safe<_Tp>::type
    { };
#926 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/type_traits" 3
  struct __do_is_static_castable_impl
  {
    template<typename _From, typename _To, typename
             = decltype(static_cast<_To>(declval<_From>()))>
      static true_type __test(int);

    template<typename, typename>
      static false_type __test(...);
  };

  template<typename _From, typename _To>
    struct __is_static_castable_impl
    : public __do_is_static_castable_impl
    {
      typedef decltype(__test<_From, _To>(0)) type;
    };

  template<typename _From, typename _To>
    struct __is_static_castable_safe
    : public __is_static_castable_impl<_From, _To>::type
    { };


  template<typename _From, typename _To>
    struct __is_static_castable
    : public integral_constant<bool, (__is_static_castable_safe<
          _From, _To>::value)>
    { };






  struct __do_is_direct_constructible_impl
  {
    template<typename _Tp, typename _Arg, typename
      = decltype(::new _Tp(declval<_Arg>()))>
      static true_type __test(int);

    template<typename, typename>
      static false_type __test(...);
  };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_impl
    : public __do_is_direct_constructible_impl
    {
      typedef decltype(__test<_Tp, _Arg>(0)) type;
    };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_new_safe
    : public __and_<is_destructible<_Tp>,
                    __is_direct_constructible_impl<_Tp, _Arg>>
    { };

  template<typename, typename>
    struct is_same;

  template<typename, typename>
    struct is_base_of;

  template<typename>
    struct remove_reference;

  template<typename _From, typename _To, bool
           = __not_<__or_<is_void<_From>,
                          is_function<_From>>>::value>
    struct __is_base_to_derived_ref;



  template<typename _From, typename _To>
    struct __is_base_to_derived_ref<_From, _To, true>
    {
      typedef typename remove_cv<typename remove_reference<_From
        >::type>::type __src_t;
      typedef typename remove_cv<typename remove_reference<_To
        >::type>::type __dst_t;
      typedef __and_<__not_<is_same<__src_t, __dst_t>>,
       is_base_of<__src_t, __dst_t>> type;
      static constexpr bool value = type::value;
    };

  template<typename _From, typename _To>
    struct __is_base_to_derived_ref<_From, _To, false>
    : public false_type
    { };

  template<typename _From, typename _To, bool
           = __and_<is_lvalue_reference<_From>,
                    is_rvalue_reference<_To>>::value>
    struct __is_lvalue_to_rvalue_ref;



  template<typename _From, typename _To>
    struct __is_lvalue_to_rvalue_ref<_From, _To, true>
    {
      typedef typename remove_cv<typename remove_reference<
        _From>::type>::type __src_t;
      typedef typename remove_cv<typename remove_reference<
        _To>::type>::type __dst_t;
      typedef __and_<__not_<is_function<__src_t>>,
        __or_<is_same<__src_t, __dst_t>,
      is_base_of<__dst_t, __src_t>>> type;
      static constexpr bool value = type::value;
    };

  template<typename _From, typename _To>
    struct __is_lvalue_to_rvalue_ref<_From, _To, false>
    : public false_type
    { };







  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_ref_cast
    : public __and_<__is_static_castable<_Arg, _Tp>,
                    __not_<__or_<__is_base_to_derived_ref<_Arg, _Tp>,
                                 __is_lvalue_to_rvalue_ref<_Arg, _Tp>
                   >>>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_new
    : public conditional<is_reference<_Tp>::value,
    __is_direct_constructible_ref_cast<_Tp, _Arg>,
    __is_direct_constructible_new_safe<_Tp, _Arg>
    >::type
    { };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible
    : public __is_direct_constructible_new<_Tp, _Arg>::type
    { };






  struct __do_is_nary_constructible_impl
  {
    template<typename _Tp, typename... _Args, typename
             = decltype(_Tp(declval<_Args>()...))>
      static true_type __test(int);

    template<typename, typename...>
      static false_type __test(...);
  };

  template<typename _Tp, typename... _Args>
    struct __is_nary_constructible_impl
    : public __do_is_nary_constructible_impl
    {
      typedef decltype(__test<_Tp, _Args...>(0)) type;
    };

  template<typename _Tp, typename... _Args>
    struct __is_nary_constructible
    : public __is_nary_constructible_impl<_Tp, _Args...>::type
    {
      static_assert(sizeof...(_Args) > 1,
                    "Only useful for > 1 arguments");
    };

  template<typename _Tp, typename... _Args>
    struct __is_constructible_impl
    : public __is_nary_constructible<_Tp, _Args...>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_constructible_impl<_Tp, _Arg>
    : public __is_direct_constructible<_Tp, _Arg>
    { };

  template<typename _Tp>
    struct __is_constructible_impl<_Tp>
    : public is_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_constructible
    : public __is_constructible_impl<_Tp, _Args...>::type
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_constructible_impl;

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, true>
    : public is_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_constructible
    : public __is_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_constructible_impl;

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, true>
    : public is_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_constructible
    : public __is_move_constructible_impl<_Tp>
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_atom
    : public integral_constant<bool, noexcept(_Tp())>
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_nt_default_constructible_impl;

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_nt_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, false>
    : public __is_nt_default_constructible_atom<_Tp>
    { };


  template<typename _Tp>
    struct is_nothrow_default_constructible
    : public __and_<is_default_constructible<_Tp>,
                    __is_nt_default_constructible_impl<_Tp>>
    { };

  template<typename _Tp, typename... _Args>
    struct __is_nt_constructible_impl
    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_nt_constructible_impl<_Tp, _Arg>
    : public integral_constant<bool,
                               noexcept(static_cast<_Tp>(declval<_Arg>()))>
    { };

  template<typename _Tp>
    struct __is_nt_constructible_impl<_Tp>
    : public is_nothrow_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_nothrow_constructible
    : public __and_<is_constructible<_Tp, _Args...>,
      __is_nt_constructible_impl<_Tp, _Args...>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_copy_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, true>
    : public is_nothrow_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_constructible
    : public __is_nothrow_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_move_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, true>
    : public is_nothrow_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_constructible
    : public __is_nothrow_move_constructible_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    class __is_assignable_helper
    {
      template<typename _Tp1, typename _Up1,
        typename = decltype(declval<_Tp1>() = declval<_Up1>())>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_Tp, _Up>(0)) type;
    };


  template<typename _Tp, typename _Up>
    struct is_assignable
      : public __is_assignable_helper<_Tp, _Up>::type
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_assignable_impl;

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, true>
    : public is_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_assignable
    : public __is_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_assignable_impl;

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, true>
    : public is_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_assignable
    : public __is_move_assignable_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    struct __is_nt_assignable_impl
    : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())>
    { };


  template<typename _Tp, typename _Up>
    struct is_nothrow_assignable
    : public __and_<is_assignable<_Tp, _Up>,
      __is_nt_assignable_impl<_Tp, _Up>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_copy_assignable_impl;

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, true>
    : public is_nothrow_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_assignable
    : public __is_nt_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_move_assignable_impl;

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, true>
    : public is_nothrow_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_assignable
    : public __is_nt_move_assignable_impl<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_trivially_constructible
    : public __and_<is_constructible<_Tp, _Args...>, integral_constant<bool,
   __is_trivially_constructible(_Tp, _Args...)>>
    { };


  template<typename _Tp>
    struct is_trivially_default_constructible
    : public is_trivially_constructible<_Tp>::type
    { };

  struct __do_is_implicitly_default_constructible_impl
  {
    template <typename _Tp>
    static void __helper(const _Tp&);

    template <typename _Tp>
    static true_type __test(const _Tp&,
                            decltype(__helper<const _Tp&>({}))* = 0);

    static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_impl
      : public __do_is_implicitly_default_constructible_impl
  {
    typedef decltype(__test(declval<_Tp>())) type;
  };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_safe
      : public __is_implicitly_default_constructible_impl<_Tp>::type
  { };

  template <typename _Tp>
    struct __is_implicitly_default_constructible
      : public __and_<is_default_constructible<_Tp>,
                      __is_implicitly_default_constructible_safe<_Tp>>
  { };


  template<typename _Tp>
    struct is_trivially_copy_constructible
    : public __and_<is_copy_constructible<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, const _Tp&)>>
    { };


  template<typename _Tp>
    struct is_trivially_move_constructible
    : public __and_<is_move_constructible<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, _Tp&&)>>
    { };


  template<typename _Tp, typename _Up>
    struct is_trivially_assignable
    : public __and_<is_assignable<_Tp, _Up>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp, _Up)>>
    { };


  template<typename _Tp>
    struct is_trivially_copy_assignable
    : public __and_<is_copy_assignable<_Tp>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp&, const _Tp&)>>
    { };


  template<typename _Tp>
    struct is_trivially_move_assignable
    : public __and_<is_move_assignable<_Tp>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp&, _Tp&&)>>
    { };


  template<typename _Tp>
    struct is_trivially_destructible
    : public __and_<is_destructible<_Tp>, integral_constant<bool,
         __has_trivial_destructor(_Tp)>>
    { };


  template<typename _Tp>
    struct has_trivial_default_constructor
    : public integral_constant<bool, __has_trivial_constructor(_Tp)>
    { } __attribute__ ((__deprecated__));


  template<typename _Tp>
    struct has_trivial_copy_constructor
    : public integral_constant<bool, __has_trivial_copy(_Tp)>
    { } __attribute__ ((__deprecated__));


  template<typename _Tp>
    struct has_trivial_copy_assign
    : public integral_constant<bool, __has_trivial_assign(_Tp)>
    { } __attribute__ ((__deprecated__));


  template<typename _Tp>
    struct has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)>
    { };





  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, __alignof__(_Tp)> { };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint>
    struct extent
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, unsigned _Uint, std::size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? _Size : extent<_Tp,
          _Uint - 1>::value>
    { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? 0 : extent<_Tp,
             _Uint - 1>::value>
    { };





  template<typename, typename>
    struct is_same
    : public false_type { };

  template<typename _Tp>
    struct is_same<_Tp, _Tp>
    : public true_type { };


  template<typename _Base, typename _Derived>
    struct is_base_of
    : public integral_constant<bool, __is_base_of(_Base, _Derived)>
    { };

  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_convertible_helper
    { typedef typename is_void<_To>::type type; };

  template<typename _From, typename _To>
    class __is_convertible_helper<_From, _To, false>
    {
       template<typename _To1>
 static void __test_aux(_To1);

      template<typename _From1, typename _To1,
        typename = decltype(__test_aux<_To1>(std::declval<_From1>()))>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_From, _To>(0)) type;
    };



  template<typename _From, typename _To>
    struct is_convertible
    : public __is_convertible_helper<_From, _To>::type
    { };





  template<typename _Tp>
    struct remove_const
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_volatile
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_cv
    {
      typedef typename
      remove_const<typename remove_volatile<_Tp>::type>::type type;
    };


  template<typename _Tp>
    struct add_const
    { typedef _Tp const type; };


  template<typename _Tp>
    struct add_volatile
    { typedef _Tp volatile type; };


  template<typename _Tp>
    struct add_cv
    {
      typedef typename
      add_const<typename add_volatile<_Tp>::type>::type type;
    };






  template<typename _Tp>
    using remove_const_t = typename remove_const<_Tp>::type;


  template<typename _Tp>
    using remove_volatile_t = typename remove_volatile<_Tp>::type;


  template<typename _Tp>
    using remove_cv_t = typename remove_cv<_Tp>::type;


  template<typename _Tp>
    using add_const_t = typename add_const<_Tp>::type;


  template<typename _Tp>
    using add_volatile_t = typename add_volatile<_Tp>::type;


  template<typename _Tp>
    using add_cv_t = typename add_cv<_Tp>::type;





  template<typename _Tp>
    struct remove_reference
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&&>
    { typedef _Tp type; };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_lvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, true>
    { typedef _Tp& type; };


  template<typename _Tp>
    struct add_lvalue_reference
    : public __add_lvalue_reference_helper<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_rvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, true>
    { typedef _Tp&& type; };


  template<typename _Tp>
    struct add_rvalue_reference
    : public __add_rvalue_reference_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_reference_t = typename remove_reference<_Tp>::type;


  template<typename _Tp>
    using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;


  template<typename _Tp>
    using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;





  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { typedef _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { typedef volatile _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { typedef const _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { typedef const volatile _Unqualified __type; };

  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    class __match_cv_qualifiers
    {
      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;

    public:
      typedef typename __match::__type __type;
    };


  template<typename _Tp>
    struct __make_unsigned
    { typedef _Tp __type; };

  template<>
    struct __make_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __make_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __make_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __make_unsigned<long long>
    { typedef unsigned long long __type; };
#1753 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/type_traits" 3
  template<>
    struct __make_unsigned<__int128>
    { typedef unsigned __int128 __type; };
#1774 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_unsigned_selector;

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, true, false>
    {
      typedef __make_unsigned<typename remove_cv<_Tp>::type> __unsignedt;
      typedef typename __unsignedt::__type __unsigned_type;
      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;

    public:
      typedef typename __cv_unsigned::__type __type;
    };

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, false, true>
    {

      typedef unsigned char __smallest;
      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);
      static const bool __b1 = sizeof(_Tp) <= sizeof(unsigned short);
      static const bool __b2 = sizeof(_Tp) <= sizeof(unsigned int);
      static const bool __b3 = sizeof(_Tp) <= sizeof(unsigned long);
      typedef conditional<__b3, unsigned long, unsigned long long> __cond3;
      typedef typename __cond3::type __cond3_type;
      typedef conditional<__b2, unsigned int, __cond3_type> __cond2;
      typedef typename __cond2::type __cond2_type;
      typedef conditional<__b1, unsigned short, __cond2_type> __cond1;
      typedef typename __cond1::type __cond1_type;

      typedef typename conditional<__b0, __smallest, __cond1_type>::type
 __unsigned_type;
      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;

    public:
      typedef typename __cv_unsigned::__type __type;
    };





  template<typename _Tp>
    struct make_unsigned
    { typedef typename __make_unsigned_selector<_Tp>::__type type; };


  template<>
    struct make_unsigned<bool>;



  template<typename _Tp>
    struct __make_signed
    { typedef _Tp __type; };

  template<>
    struct __make_signed<char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned short>
    { typedef signed short __type; };

  template<>
    struct __make_signed<unsigned int>
    { typedef signed int __type; };

  template<>
    struct __make_signed<unsigned long>
    { typedef signed long __type; };

  template<>
    struct __make_signed<unsigned long long>
    { typedef signed long long __type; };


  template<>
    struct __make_signed<wchar_t> : __make_signed<short unsigned int>
    { };



  template<>
    struct __make_signed<char16_t> : __make_signed<uint_least16_t>
    { };
  template<>
    struct __make_signed<char32_t> : __make_signed<uint_least32_t>
    { };



  template<>
    struct __make_signed<unsigned __int128>
    { typedef __int128 __type; };
#1893 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_signed_selector;

  template<typename _Tp>
    class __make_signed_selector<_Tp, true, false>
    {
      typedef __make_signed<typename remove_cv<_Tp>::type> __signedt;
      typedef typename __signedt::__type __signed_type;
      typedef __match_cv_qualifiers<_Tp, __signed_type> __cv_signed;

    public:
      typedef typename __cv_signed::__type __type;
    };

  template<typename _Tp>
    class __make_signed_selector<_Tp, false, true>
    {
      typedef typename __make_unsigned_selector<_Tp>::__type __unsigned_type;

    public:
      typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    };





  template<typename _Tp>
    struct make_signed
    { typedef typename __make_signed_selector<_Tp>::__type type; };


  template<>
    struct make_signed<bool>;



  template<typename _Tp>
    using make_signed_t = typename make_signed<_Tp>::type;


  template<typename _Tp>
    using make_unsigned_t = typename make_unsigned<_Tp>::type;





  template<typename _Tp>
    struct remove_extent
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_all_extents
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { typedef typename remove_all_extents<_Tp>::type type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { typedef typename remove_all_extents<_Tp>::type type; };



  template<typename _Tp>
    using remove_extent_t = typename remove_extent<_Tp>::type;


  template<typename _Tp>
    using remove_all_extents_t = typename remove_all_extents<_Tp>::type;




  template<typename _Tp, typename>
    struct __remove_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp, typename _Up>
    struct __remove_pointer_helper<_Tp, _Up*>
    { typedef _Up type; };


  template<typename _Tp>
    struct remove_pointer
    : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>
    { };


  template<typename _Tp, bool = __or_<__is_referenceable<_Tp>,
          is_void<_Tp>>::value>
    struct __add_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_pointer_helper<_Tp, true>
    { typedef typename remove_reference<_Tp>::type* type; };

  template<typename _Tp>
    struct add_pointer
    : public __add_pointer_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_pointer_t = typename remove_pointer<_Tp>::type;


  template<typename _Tp>
    using add_pointer_t = typename add_pointer<_Tp>::type;


  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
#2039 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/type_traits" 3
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };

  template <typename... _Types>
    struct __strictest_alignment
    {
      static const size_t _S_alignment = 0;
      static const size_t _S_size = 0;
    };

  template <typename _Tp, typename... _Types>
    struct __strictest_alignment<_Tp, _Types...>
    {
      static const size_t _S_alignment =
        alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment
 ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;
      static const size_t _S_size =
        sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size
 ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;
    };
#2078 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/type_traits" 3
  template <size_t _Len, typename... _Types>
    struct aligned_union
    {
    private:
      static_assert(sizeof...(_Types) != 0, "At least one type is required");

      using __strictest = __strictest_alignment<_Types...>;
      static const size_t _S_len = _Len > __strictest::_S_size
 ? _Len : __strictest::_S_size;
    public:

      static const size_t alignment_value = __strictest::_S_alignment;

      typedef typename aligned_storage<_S_len, alignment_value>::type type;
    };

  template <size_t _Len, typename... _Types>
    const size_t aligned_union<_Len, _Types...>::alignment_value;



  template<typename _Up,
    bool _IsArray = is_array<_Up>::value,
    bool _IsFunction = is_function<_Up>::value>
    struct __decay_selector;


  template<typename _Up>
    struct __decay_selector<_Up, false, false>
    { typedef typename remove_cv<_Up>::type __type; };

  template<typename _Up>
    struct __decay_selector<_Up, true, false>
    { typedef typename remove_extent<_Up>::type* __type; };

  template<typename _Up>
    struct __decay_selector<_Up, false, true>
    { typedef typename add_pointer<_Up>::type __type; };


  template<typename _Tp>
    class decay
    {
      typedef typename remove_reference<_Tp>::type __remove_type;

    public:
      typedef typename __decay_selector<__remove_type>::__type type;
    };

  template<typename _Tp>
    class reference_wrapper;


  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };

  template<typename _Tp>
    struct __decay_and_strip
    {
      typedef typename __strip_reference_wrapper<
 typename decay<_Tp>::type>::__type __type;
    };




  template<bool, typename _Tp = void>
    struct enable_if
    { };


  template<typename _Tp>
    struct enable_if<true, _Tp>
    { typedef _Tp type; };

  template<typename... _Cond>
    using _Require = typename enable_if<__and_<_Cond...>::value>::type;



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { typedef _Iftrue type; };


  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { typedef _Iffalse type; };


  template<typename... _Tp>
    struct common_type;



  struct __do_common_type_impl
  {
    template<typename _Tp, typename _Up>
      static __success_type<typename decay<decltype
       (true ? std::declval<_Tp>()
        : std::declval<_Up>())>::type> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp, typename _Up>
    struct __common_type_impl
    : private __do_common_type_impl
    {
      typedef decltype(_S_test<_Tp, _Up>(0)) type;
    };

  struct __do_member_type_wrapper
  {
    template<typename _Tp>
      static __success_type<typename _Tp::type> _S_test(int);

    template<typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp>
    struct __member_type_wrapper
    : private __do_member_type_wrapper
    {
      typedef decltype(_S_test<_Tp>(0)) type;
    };

  template<typename _CTp, typename... _Args>
    struct __expanded_common_type_wrapper
    {
      typedef common_type<typename _CTp::type, _Args...> type;
    };

  template<typename... _Args>
    struct __expanded_common_type_wrapper<__failure_type, _Args...>
    { typedef __failure_type type; };

  template<typename _Tp>
    struct common_type<_Tp>
    { typedef typename decay<_Tp>::type type; };

  template<typename _Tp, typename _Up>
    struct common_type<_Tp, _Up>
    : public __common_type_impl<_Tp, _Up>::type
    { };

  template<typename _Tp, typename _Up, typename... _Vp>
    struct common_type<_Tp, _Up, _Vp...>
    : public __expanded_common_type_wrapper<typename __member_type_wrapper<
               common_type<_Tp, _Up>>::type, _Vp...>::type
    { };


  template<typename _Tp>
    struct underlying_type
    {
      typedef __underlying_type(_Tp) type;
    };

  template<typename _Tp>
    struct __declval_protector
    {
      static const bool __stop = false;
      static typename add_rvalue_reference<_Tp>::type __delegate();
    };

  template<typename _Tp>
    inline typename add_rvalue_reference<_Tp>::type
    declval() noexcept
    {
      static_assert(__declval_protector<_Tp>::__stop,
      "declval() must not be used!");
      return __declval_protector<_Tp>::__delegate();
    }


  template<typename _Signature>
    class result_of;





  struct __invoke_memfun_ref { };
  struct __invoke_memfun_deref { };
  struct __invoke_memobj_ref { };
  struct __invoke_memobj_deref { };
  struct __invoke_other { };


  template<typename _Tp, typename _Tag>
    struct __result_of_success : __success_type<_Tp>
    { using __invoke_type = _Tag; };


  struct __result_of_memfun_ref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_ref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_ref
    : private __result_of_memfun_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memfun_deref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_deref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_deref
    : private __result_of_memfun_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memobj_ref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      std::declval<_Tp1>().*std::declval<_Fp>()
      ), __invoke_memobj_ref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_ref
    : private __result_of_memobj_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };


  struct __result_of_memobj_deref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      (*std::declval<_Tp1>()).*std::declval<_Fp>()
      ), __invoke_memobj_deref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_deref
    : private __result_of_memobj_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj;

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, _Arg>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memobj_ref<_MemPtr, _Arg>,
        __result_of_memobj_deref<_MemPtr, _Arg>
      >::type::type type;
    };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun;

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>
      >::type::type type;
    };





  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, reference_wrapper<_Arg>>
    : __result_of_memobj_ref<_Res _Class::*, _Arg&>
    { };

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, reference_wrapper<_Arg>&>
    : __result_of_memobj_ref<_Res _Class::*, _Arg&>
    { };

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, const reference_wrapper<_Arg>&>
    : __result_of_memobj_ref<_Res _Class::*, _Arg&>
    { };

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, reference_wrapper<_Arg>&&>
    : __result_of_memobj_ref<_Res _Class::*, _Arg&>
    { };

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, const reference_wrapper<_Arg>&&>
    : __result_of_memobj_ref<_Res _Class::*, _Arg&>
    { };

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, reference_wrapper<_Arg>, _Args...>
    : __result_of_memfun_ref<_Res _Class::*, _Arg&, _Args...>
    { };

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, reference_wrapper<_Arg>&,
         _Args...>
    : __result_of_memfun_ref<_Res _Class::*, _Arg&, _Args...>
    { };

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, const reference_wrapper<_Arg>&,
         _Args...>
    : __result_of_memfun_ref<_Res _Class::*, _Arg&, _Args...>
    { };

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, reference_wrapper<_Arg>&&,
         _Args...>
    : __result_of_memfun_ref<_Res _Class::*, _Arg&, _Args...>
    { };

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, const reference_wrapper<_Arg>&&,
         _Args...>
    : __result_of_memfun_ref<_Res _Class::*, _Arg&, _Args...>
    { };

  template<bool, bool, typename _Functor, typename... _ArgTypes>
    struct __result_of_impl
    {
      typedef __failure_type type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_impl<true, false, _MemPtr, _Arg>
    : public __result_of_memobj<typename decay<_MemPtr>::type, _Arg>
    { };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
    : public __result_of_memfun<typename decay<_MemPtr>::type, _Arg, _Args...>
    { };


  struct __result_of_other_impl
  {
    template<typename _Fn, typename... _Args>
      static __result_of_success<decltype(
      std::declval<_Fn>()(std::declval<_Args>()...)
      ), __invoke_other> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _Functor, typename... _ArgTypes>
    struct __result_of_impl<false, false, _Functor, _ArgTypes...>
    : private __result_of_other_impl
    {
      typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
    };

  template<typename _Functor, typename... _ArgTypes>
    struct result_of<_Functor(_ArgTypes...)>
    : public __result_of_impl<
        is_member_object_pointer<
          typename remove_reference<_Functor>::type
        >::value,
        is_member_function_pointer<
          typename remove_reference<_Functor>::type
        >::value,
     _Functor, _ArgTypes...
      >::type
    { };



  template<size_t _Len, size_t _Align =
     __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

  template <size_t _Len, typename... _Types>
    using aligned_union_t = typename aligned_union<_Len, _Types...>::type;


  template<typename _Tp>
    using decay_t = typename decay<_Tp>::type;


  template<bool _Cond, typename _Tp = void>
    using enable_if_t = typename enable_if<_Cond, _Tp>::type;


  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    using conditional_t = typename conditional<_Cond, _Iftrue, _Iffalse>::type;


  template<typename... _Tp>
    using common_type_t = typename common_type<_Tp...>::type;


  template<typename _Tp>
    using underlying_type_t = typename underlying_type<_Tp>::type;


  template<typename _Tp>
    using result_of_t = typename result_of<_Tp>::type;


  template<typename...> using __void_t = void;




  template<typename...> using void_t = void;



  template<typename _Default, typename _AlwaysVoid,
    template<typename...> class _Op, typename... _Args>
    struct __detector
    {
      using value_t = false_type;
      using type = _Default;
    };


  template<typename _Default, template<typename...> class _Op,
     typename... _Args>
    struct __detector<_Default, __void_t<_Op<_Args...>>, _Op, _Args...>
    {
      using value_t = true_type;
      using type = _Op<_Args...>;
    };


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or = __detector<_Default, void, _Op, _Args...>;


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or_t
      = typename __detected_or<_Default, _Op, _Args...>::type;


  template<template<typename...> class _Default,
    template<typename...> class _Op, typename... _Args>
    using __detected_or_t_ =
      __detected_or_t<_Default<_Args...>, _Op, _Args...>;
#2590 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/type_traits" 3
  template <typename _Tp>
    struct __is_swappable;

  template <typename _Tp>
    struct __is_nothrow_swappable;

  template<typename _Tp>
    inline
    typename enable_if<__and_<is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type
    swap(_Tp&, _Tp&)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value);

  template<typename _Tp, size_t _Nm>
    inline
    typename enable_if<__is_swappable<_Tp>::value>::type
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value);

  namespace __swappable_details {
    using std::swap;

    struct __do_is_swappable_impl
    {
      template<typename _Tp, typename
               = decltype(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))>
        static true_type __test(int);

      template<typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_impl
    {
      template<typename _Tp>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))
        > __test(int);

      template<typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp>
    struct __is_swappable_impl
    : public __swappable_details::__do_is_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_nothrow_swappable_impl
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_swappable
    : public __is_swappable_impl<_Tp>::type
    { };

  template<typename _Tp>
    struct __is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    { };


}
#58 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/move.h" 2 3

namespace std
{

#74 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/move.h" 3
  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Tp&&>(__t); }







  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
    {
      static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
      " substituting _Tp is an lvalue reference type");
      return static_cast<_Tp&&>(__t);
    }






  template<typename _Tp>
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }


  template<typename _Tp>
    struct __move_if_noexcept_cond
    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                    is_copy_constructible<_Tp>>::type { };
#118 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/move.h" 3
  template<typename _Tp>
    constexpr typename
    conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type
    move_if_noexcept(_Tp& __x) noexcept
    { return std::move(__x); }
#133 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/move.h" 3
  template<typename _Tp>
    inline _Tp*
    addressof(_Tp& __r) noexcept
    { return std::__addressof(__r); }


  template <typename _Tp, typename _Up = _Tp>
    inline _Tp
    __exchange(_Tp& __obj, _Up&& __new_val)
    {
      _Tp __old_val = std::move(__obj);
      __obj = std::forward<_Up>(__new_val);
      return __old_val;
    }



}
#159 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/move.h" 3
namespace std
{

#174 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/move.h" 3
  template<typename _Tp>
    inline

    typename enable_if<__and_<is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type
    swap(_Tp& __a, _Tp& __b)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value)




    {



      _Tp __tmp = std::move(__a);
      __a = std::move(__b);
      __b = std::move(__tmp);
    }




  template<typename _Tp, size_t _Nm>
    inline

    typename enable_if<__is_swappable<_Tp>::value>::type
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value)




    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }



}
#60 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_pair.h" 2 3





namespace std
{

#76 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_pair.h" 3
  struct piecewise_construct_t { explicit piecewise_construct_t() = default; };


  constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();


  template<typename...>
    class tuple;

  template<std::size_t...>
    struct _Index_tuple;






  template <typename _T1, typename _T2, typename _U1, typename _U2>
  constexpr bool _ConstructiblePair()
  {
    return __and_<__or_<is_same<typename decay<_T1>::type,
    typename decay<_U1>::type>,
   is_constructible<_T1, const _U1&>>,
    __or_<is_same<typename decay<_T2>::type,
    typename decay<_U2>::type>,
   is_constructible<_T2, const _U2&>>>::value;
  }

  template <typename _T1, typename _T2, typename _U1, typename _U2>
  constexpr bool _ImplicitlyConvertiblePair()
  {
    return __and_<__or_<is_same<typename decay<_T1>::type,
    typename decay<_U1>::type>,
   is_convertible<const _U1&, _T1>>,
    __or_<is_same<typename decay<_T2>::type,
    typename decay<_U2>::type>,
         is_convertible<const _U2&, _T2>>>::value;
  }

  template <typename _T1, typename _T2, typename _U1, typename _U2>
  constexpr bool _MoveConstructiblePair()
  {
    return __and_<__or_<is_same<typename decay<_T1>::type,
    typename decay<_U1>::type>,
   is_constructible<_T1, _U1&&>>,
    __or_<is_same<typename decay<_T2>::type,
    typename decay<_U2>::type>,
   is_constructible<_T2, _U2&&>>>::value;
  }

  template <typename _T1, typename _T2, typename _U1, typename _U2>
  constexpr bool _ImplicitlyMoveConvertiblePair()
  {
    return __and_<__or_<is_same<typename decay<_T1>::type,
    typename decay<_U1>::type>,
   is_convertible<_U1&&, _T1>>,
    __or_<is_same<typename decay<_T2>::type,
    typename decay<_U2>::type>,
         is_convertible<_U2&&, _T2>>>::value;
  }
#146 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;






      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                                     __is_implicitly_default_constructible<_U1>,
                                     __is_implicitly_default_constructible<_U2>>
                                   ::value, bool>::type = true>

      constexpr pair()
      : first(), second() { }


      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                       is_default_constructible<_U1>,
                       is_default_constructible<_U2>,
                       __not_<
                         __and_<__is_implicitly_default_constructible<_U1>,
                                __is_implicitly_default_constructible<_U2>>>>
                                   ::value, bool>::type = false>
      explicit constexpr pair()
      : first(), second() { }







      template<typename _U1 = _T1, typename _U2=_T2, typename
                enable_if<_ConstructiblePair<_T1, _T2, _U1, _U2>()
                         && _ImplicitlyConvertiblePair<_T1, _T2, _U1, _U2>(),
                         bool>::type=true>
      constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }

       template<typename _U1 = _T1, typename _U2=_T2, typename
        enable_if<_ConstructiblePair<_T1, _T2, _U1, _U2>()
                         && !_ImplicitlyConvertiblePair<_T1, _T2, _U1, _U2>(),
                         bool>::type=false>
      explicit constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }
#210 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_pair.h" 3
      template<typename _U1, typename _U2, typename
        enable_if<_ConstructiblePair<_T1, _T2, _U1, _U2>()
                         && _ImplicitlyConvertiblePair<_T1, _T2, _U1, _U2>(),
                         bool>::type=true>
        constexpr pair(const pair<_U1, _U2>& __p)
        : first(__p.first), second(__p.second) { }

      template<typename _U1, typename _U2, typename
               enable_if<_ConstructiblePair<_T1, _T2, _U1, _U2>()
                         && !_ImplicitlyConvertiblePair<_T1, _T2, _U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }

      constexpr pair(const pair&) = default;
      constexpr pair(pair&&) = default;


      template<typename _U1, typename
               enable_if<_ConstructiblePair<_T2, _T2, _T2, _T2>()
                         && _MoveConstructiblePair<_T1, _T2, _U1, _T2>()
                         && _ImplicitlyConvertiblePair<_T2, _T2, _T2, _T2>()
                         && _ImplicitlyMoveConvertiblePair<_T1, _T2,
         _U1, _T2>(),
                         bool>::type=true>
       constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U1, typename
               enable_if<_ConstructiblePair<_T2, _T2, _T2, _T2>()
                         && _MoveConstructiblePair<_T1, _T2, _U1, _T2>()
                         && (!_ImplicitlyConvertiblePair<_T2, _T2, _T2, _T2>()
                             || !_ImplicitlyMoveConvertiblePair<_T1, _T2,
                                                                _U1, _T2>()),
                         bool>::type=false>
       explicit constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U2, typename
               enable_if<_ConstructiblePair<_T1, _T1, _T1, _T1>()
                         && _MoveConstructiblePair<_T1, _T2, _T1, _U2>()
                         && _ImplicitlyConvertiblePair<_T1, _T1, _T1, _T1>()
                         && _ImplicitlyMoveConvertiblePair<_T1, _T2,
                                                           _T1, _U2>(),
                         bool>::type=true>
       constexpr pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U2, typename
               enable_if<_ConstructiblePair<_T1, _T1, _T1, _T1>()
                         && _MoveConstructiblePair<_T1, _T2, _T1, _U2>()
                         && (!_ImplicitlyConvertiblePair<_T1, _T1, _T1, _T1>()
                             || !_ImplicitlyMoveConvertiblePair<_T1, _T2,
                                                                _T1, _U2>()),
                         bool>::type=false>
       explicit pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_MoveConstructiblePair<_T1, _T2, _U1, _U2>()
                         && _ImplicitlyMoveConvertiblePair<_T1, _T2,
          _U1, _U2>(),
                         bool>::type=true>
 constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_MoveConstructiblePair<_T1, _T2, _U1, _U2>()
                         && !_ImplicitlyMoveConvertiblePair<_T1, _T2,
           _U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }


      template<typename _U1, typename _U2, typename
        enable_if<_MoveConstructiblePair<_T1, _T2, _U1, _U2>()
                         && _ImplicitlyMoveConvertiblePair<_T1, _T2,
          _U1, _U2>(),
                         bool>::type=true>
 constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_MoveConstructiblePair<_T1, _T2, _U1, _U2>()
                         && !_ImplicitlyMoveConvertiblePair<_T1, _T2,
          _U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename... _Args1, typename... _Args2>
        pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);

      pair&
      operator=(const pair& __p)
      {
 first = __p.first;
 second = __p.second;
 return *this;
      }

      pair&
      operator=(pair&& __p)
      noexcept(__and_<is_nothrow_move_assignable<_T1>,
               is_nothrow_move_assignable<_T2>>::value)
      {
 first = std::forward<first_type>(__p.first);
 second = std::forward<second_type>(__p.second);
 return *this;
      }

      template<typename _U1, typename _U2>
 pair&
 operator=(const pair<_U1, _U2>& __p)
 {
   first = __p.first;
   second = __p.second;
   return *this;
 }

      template<typename _U1, typename _U2>
 pair&
 operator=(pair<_U1, _U2>&& __p)
 {
   first = std::forward<_U1>(__p.first);
   second = std::forward<_U2>(__p.second);
   return *this;
 }

      void
      swap(pair& __p)
      noexcept(__is_nothrow_swappable<_T1>::value
               && __is_nothrow_swappable<_T2>::value)
      {
 using std::swap;
 swap(first, __p.first);
 swap(second, __p.second);
      }

    private:
      template<typename... _Args1, std::size_t... _Indexes1,
               typename... _Args2, std::size_t... _Indexes2>
        pair(tuple<_Args1...>&, tuple<_Args2...>&,
             _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);

    };


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }





  template<typename _T1, typename _T2>
    inline void
    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }
#422 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    constexpr pair<typename __decay_and_strip<_T1>::__type,
                   typename __decay_and_strip<_T2>::__type>
    make_pair(_T1&& __x, _T2&& __y)
    {
      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
      typedef pair<__ds_type1, __ds_type2> __pair_type;
      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
#441 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_pair.h" 3

}
#71 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/utility" 2 3





#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/initializer_list" 1 3
#33 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/initializer_list" 3

#34 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/initializer_list" 3





#pragma GCC visibility push(default)



namespace std
{

  template<class _E>
    class initializer_list
    {
    public:
      typedef _E value_type;
      typedef const _E& reference;
      typedef const _E& const_reference;
      typedef size_t size_type;
      typedef const _E* iterator;
      typedef const _E* const_iterator;

    private:
      iterator _M_array;
      size_type _M_len;


      constexpr initializer_list(const_iterator __a, size_type __l)
      : _M_array(__a), _M_len(__l) { }

    public:
      constexpr initializer_list() noexcept
      : _M_array(0), _M_len(0) { }


      constexpr size_type
      size() const noexcept { return _M_len; }


      constexpr const_iterator
      begin() const noexcept { return _M_array; }


      constexpr const_iterator
      end() const noexcept { return begin() + size(); }
    };






  template<class _Tp>
    constexpr const _Tp*
    begin(initializer_list<_Tp> __ils) noexcept
    { return __ils.begin(); }






  template<class _Tp>
    constexpr const _Tp*
    end(initializer_list<_Tp> __ils) noexcept
    { return __ils.end(); }
}

#pragma GCC visibility pop
#77 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/utility" 2 3

namespace std
{



  template<typename _Tp>
    struct tuple_size;



  template<typename _Tp>
    struct tuple_size<const _Tp>
    : integral_constant<size_t, tuple_size<_Tp>::value> { };

  template<typename _Tp>
    struct tuple_size<volatile _Tp>
    : integral_constant<size_t, tuple_size<_Tp>::value> { };

  template<typename _Tp>
    struct tuple_size<const volatile _Tp>
    : integral_constant<size_t, tuple_size<_Tp>::value> { };


  template<std::size_t __i, typename _Tp>
    struct tuple_element;


  template<std::size_t __i, typename _Tp>
    using __tuple_element_t = typename tuple_element<__i, _Tp>::type;

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const _Tp>
    {
      typedef typename add_const<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, volatile _Tp>
    {
      typedef typename add_volatile<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const volatile _Tp>
    {
      typedef typename add_cv<__tuple_element_t<__i, _Tp>>::type type;
    };




  template<std::size_t __i, typename _Tp>
    using tuple_element_t = typename tuple_element<__i, _Tp>::type;


  template<typename>
    struct __is_tuple_like_impl : false_type
    { };




  template<typename _T1, typename _T2>
    struct __is_tuple_like_impl<std::pair<_T1, _T2>> : true_type
    { };


  template<class _Tp1, class _Tp2>
    struct tuple_size<std::pair<_Tp1, _Tp2>>
    : public integral_constant<std::size_t, 2> { };


  template<class _Tp1, class _Tp2>
    struct tuple_element<0, std::pair<_Tp1, _Tp2>>
    { typedef _Tp1 type; };


  template<class _Tp1, class _Tp2>
    struct tuple_element<1, std::pair<_Tp1, _Tp2>>
    { typedef _Tp2 type; };

  template<std::size_t _Int>
    struct __pair_get;

  template<>
    struct __pair_get<0>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp1>(__pair.first); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp1&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }
    };

  template<>
    struct __pair_get<1>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp2>(__pair.second); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp2&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }
    };

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__get(__in); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&&
    get(std::pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__move_get(std::move(__in)); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(const std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__const_get(__in); }





  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Tp, _Up>&& __p) noexcept
    { return std::move(__p.first); }

  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Up, _Tp>&& __p) noexcept
    { return std::move(__p.second); }




  template <typename _Tp, typename _Up = _Tp>
    inline _Tp
    exchange(_Tp& __obj, _Up&& __new_val)
    { return std::__exchange(__obj, std::forward<_Up>(__new_val)); }




  template<size_t... _Indexes> struct _Index_tuple { };


  template<typename _Itup1, typename _Itup2> struct _Itup_cat;

  template<size_t... _Ind1, size_t... _Ind2>
    struct _Itup_cat<_Index_tuple<_Ind1...>, _Index_tuple<_Ind2...>>
    {
      using __type = _Index_tuple<_Ind1..., (_Ind2 + sizeof...(_Ind1))...>;
    };


  template<size_t _Num>
    struct _Build_index_tuple
    : _Itup_cat<typename _Build_index_tuple<_Num / 2>::__type,
  typename _Build_index_tuple<_Num - _Num / 2>::__type>
    { };

  template<>
    struct _Build_index_tuple<1>
    {
      typedef _Index_tuple<0> __type;
    };

  template<>
    struct _Build_index_tuple<0>
    {
      typedef _Index_tuple<> __type;
    };






  template<typename _Tp, _Tp... _Idx>
    struct integer_sequence
    {
      typedef _Tp value_type;
      static constexpr size_t size() { return sizeof...(_Idx); }
    };

  template<typename _Tp, _Tp _Num,
    typename _ISeq = typename _Build_index_tuple<_Num>::__type>
    struct _Make_integer_sequence;

  template<typename _Tp, _Tp _Num, size_t... _Idx>
    struct _Make_integer_sequence<_Tp, _Num, _Index_tuple<_Idx...>>
    {
      static_assert( _Num >= 0,
       "Cannot make integer sequence of negative length" );

      typedef integer_sequence<_Tp, static_cast<_Tp>(_Idx)...> __type;
    };


  template<typename _Tp, _Tp _Num>
    using make_integer_sequence
      = typename _Make_integer_sequence<_Tp, _Num>::__type;


  template<size_t... _Idx>
    using index_sequence = integer_sequence<size_t, _Idx...>;


  template<size_t _Num>
    using make_index_sequence = make_integer_sequence<size_t, _Num>;


  template<typename... _Types>
    using index_sequence_for = make_index_sequence<sizeof...(_Types)>;



}
#130 "C:/Xilinx/Vivado/2018.3/include/hls_half.h" 2
#210 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/algorithm" 1 3
#58 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/algorithm" 3

#59 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/algorithm" 3


#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 1 3
#60 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/functexcept.h" 1 3
#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/functexcept.h" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/exception_defines.h" 1 3
#41 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/functexcept.h" 2 3

namespace std
{



  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range_fmt(const char*, ...) __attribute__((__noreturn__))
    __attribute__((__format__(__gnu_printf__, 1, 2)));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_system_error(int) __attribute__((__noreturn__));

  void
  __throw_future_error(int) __attribute__((__noreturn__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__));


}
#61 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 2 3


#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ext/numeric_traits.h" 1 3
#32 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ext/numeric_traits.h" 3

#33 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ext/numeric_traits.h" 3




namespace __gnu_cxx
{

#54 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_integer
    {

      static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);
      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);



      static const bool __is_signed = ((_Value)(-1) < 0);
      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
#99 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;

  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };


}
#64 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 2 3

#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_types.h" 1 3
#62 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_types.h" 3

#63 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_types.h" 3







namespace std
{

#89 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
#116 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
#143 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_types.h" 3
  template<typename _Iterator, typename = __void_t<>>
    struct __iterator_traits { };

  template<typename _Iterator>
    struct __iterator_traits<_Iterator,
        __void_t<typename _Iterator::iterator_category,
          typename _Iterator::value_type,
          typename _Iterator::difference_type,
          typename _Iterator::pointer,
          typename _Iterator::reference>>
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };

  template<typename _Iterator>
    struct iterator_traits
    : public __iterator_traits<_Iterator> { };
#177 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_types.h" 3
  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };


  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };





  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }
#230 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_types.h" 3
  template<typename _InIter>
    using _RequireInputIter = typename
      enable_if<is_convertible<typename
  iterator_traits<_InIter>::iterator_category,
          input_iterator_tag>::value>::type;



}
#66 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 2 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_funcs.h" 1 3
#62 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_funcs.h" 3

#63 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_funcs.h" 3


#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/debug/assertions.h" 1 3
#66 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_funcs.h" 2 3

namespace std
{


  template <typename> struct _List_iterator;
  template <typename> struct _List_const_iterator;




  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {



      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {



      return __last - __first;
    }



  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_iterator<_Tp>,
        std::_List_iterator<_Tp>,
        input_iterator_tag);

  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_const_iterator<_Tp>,
        std::_List_const_iterator<_Tp>,
        input_iterator_tag);
#133 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {


      ;
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {



      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {



      __i += __n;
    }
#192 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }



  template<typename _ForwardIterator>
    inline _ForwardIterator
    next(_ForwardIterator __x, typename
  iterator_traits<_ForwardIterator>::difference_type __n = 1)
    {



      std::advance(__x, __n);
      return __x;
    }

  template<typename _BidirectionalIterator>
    inline _BidirectionalIterator
    prev(_BidirectionalIterator __x, typename
  iterator_traits<_BidirectionalIterator>::difference_type __n = 1)
    {



      std::advance(__x, -__n);
      return __x;
    }




}
#67 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 2 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 1 3
#66 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/ptr_traits.h" 1 3
#37 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/ptr_traits.h" 3
namespace std
{


  class __undefined;


  template<typename _Tp>
    struct __get_first_arg
    { using type = __undefined; };

  template<template<typename, typename...> class _Template, typename _Tp,
           typename... _Types>
    struct __get_first_arg<_Template<_Tp, _Types...>>
    { using type = _Tp; };

  template<typename _Tp>
    using __get_first_arg_t = typename __get_first_arg<_Tp>::type;


  template<typename _Tp, typename _Up>
    struct __replace_first_arg
    { using type = __undefined; };

  template<template<typename, typename...> class _Template, typename _Up,
           typename _Tp, typename... _Types>
    struct __replace_first_arg<_Template<_Tp, _Types...>, _Up>
    { using type = _Template<_Up, _Types...>; };

  template<typename _Tp, typename _Up>
    using __replace_first_arg_t = typename __replace_first_arg<_Tp, _Up>::type;

  template<typename _Tp>
    using __make_not_void
      = typename conditional<is_void<_Tp>::value, __undefined, _Tp>::type;





  template<typename _Ptr>
    struct pointer_traits
    {
    private:
      template<typename _Tp>
 using __element_type = typename _Tp::element_type;

      template<typename _Tp>
 using __difference_type = typename _Tp::difference_type;

      template<typename _Tp, typename _Up>
 using __rebind = typename _Tp::template rebind<_Up>;

    public:

      using pointer = _Ptr;


      using element_type
 = __detected_or_t_<__get_first_arg_t, __element_type, _Ptr>;


      using difference_type
 = __detected_or_t<ptrdiff_t, __difference_type, _Ptr>;


      template<typename _Up>
        using rebind
   = __detected_or_t_<__replace_first_arg_t, __rebind, _Ptr, _Up>;

      static _Ptr
      pointer_to(__make_not_void<element_type>& __e)
      { return _Ptr::pointer_to(__e); }

      static_assert(!is_same<element_type, __undefined>::value,
   "pointer type defines element_type or is like SomePointer<T, Args>");
      static_assert(!is_same<rebind<element_type>, __undefined>::value,
   "pointer type defines rebind<U> or is like SomePointer<T, Args>");
    };





  template<typename _Tp>
    struct pointer_traits<_Tp*>
    {

      typedef _Tp* pointer;

      typedef _Tp element_type;

      typedef ptrdiff_t difference_type;

      template<typename _Up>
        using rebind = _Up*;






      static pointer
      pointer_to(__make_not_void<element_type>& __r) noexcept
      { return std::addressof(__r); }
    };


  template<typename _Ptr, typename _Tp>
    using __ptr_rebind = typename pointer_traits<_Ptr>::template rebind<_Tp>;


}
#67 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 2 3

namespace std
{

#96 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::pointer pointer;
      typedef typename __traits_type::reference reference;







      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }
#160 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      pointer
      operator->() const
      { return &(operator*()); }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }







      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }







      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
#290 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }

  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _IteratorL, typename _IteratorR>


    inline auto
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    -> decltype(__y.base() - __x.base())





    { return __y.base() - __x.base(); }




  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    __make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }







  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }




  template<typename _Iterator>
    auto
    __niter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__niter_base(__it.base())))
    { return __make_reverse_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<reverse_iterator<_Iterator> >
      : __is_move_iterator<_Iterator>
    { };

  template<typename _Iterator>
    auto
    __miter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__miter_base(__it.base())))
    { return __make_reverse_iterator(__miter_base(__it.base())); }
#441 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
#476 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_back(__value);
 return *this;
      }

      back_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_back(std::move(__value));
 return *this;
      }



      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
#518 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
#533 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
#567 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_front(__value);
 return *this;
      }

      front_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_front(std::move(__value));
 return *this;
      }



      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
#609 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
#628 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(std::__addressof(__x)), iter(__i) {}
#679 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }

      insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 iter = container->insert(iter, std::move(__value));
 ++iter;
 return *this;
      }



      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
#723 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }




}

namespace __gnu_cxx
{

#747 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;

      constexpr __normal_iterator() noexcept
      : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) noexcept
      : _M_current(__i) { }


      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i) noexcept
        : _M_current(__i.base()) { }


      reference
      operator*() const noexcept
      { return *_M_current; }

      pointer
      operator->() const noexcept
      { return _M_current; }

      __normal_iterator&
      operator++() noexcept
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int) noexcept
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--() noexcept
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int) noexcept
      { return __normal_iterator(_M_current--); }


      reference
      operator[](difference_type __n) const noexcept
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(difference_type __n) noexcept
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(difference_type __n) const noexcept
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(difference_type __n) noexcept
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(difference_type __n) const noexcept
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const noexcept
      { return _M_current; }
    };
#847 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>


    inline auto
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs) noexcept
    -> decltype(__lhs.base() - __rhs.base())





    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    noexcept
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }


}

namespace std
{


  template<typename _Iterator, typename _Container>
    _Iterator
    __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it)
    { return __it.base(); }


}



namespace std
{

#999 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class move_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;
      typedef typename __traits_type::reference __base_ref;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;

      typedef _Iterator pointer;


      typedef typename conditional<is_reference<__base_ref>::value,
    typename remove_reference<__base_ref>::type&&,
    __base_ref>::type reference;

      move_iterator()
      : _M_current() { }

      explicit
      move_iterator(iterator_type __i)
      : _M_current(__i) { }

      template<typename _Iter>
 move_iterator(const move_iterator<_Iter>& __i)
 : _M_current(__i.base()) { }

      iterator_type
      base() const
      { return _M_current; }

      reference
      operator*() const
      { return static_cast<reference>(*_M_current); }

      pointer
      operator->() const
      { return _M_current; }

      move_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      move_iterator
      operator++(int)
      {
 move_iterator __tmp = *this;
 ++_M_current;
 return __tmp;
      }

      move_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      move_iterator
      operator--(int)
      {
 move_iterator __tmp = *this;
 --_M_current;
 return __tmp;
      }

      move_iterator
      operator+(difference_type __n) const
      { return move_iterator(_M_current + __n); }

      move_iterator&
      operator+=(difference_type __n)
      {
 _M_current += __n;
 return *this;
      }

      move_iterator
      operator-(difference_type __n) const
      { return move_iterator(_M_current - __n); }

      move_iterator&
      operator-=(difference_type __n)
      {
 _M_current -= __n;
 return *this;
      }

      reference
      operator[](difference_type __n) const
      { return std::move(_M_current[__n]); }
    };




  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator==(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator!=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __x.base() < __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator<=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator>(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline bool
    operator>=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x < __y); }


  template<typename _IteratorL, typename _IteratorR>
    inline auto
    operator-(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    inline auto
    operator-(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    operator+(typename move_iterator<_Iterator>::difference_type __n,
       const move_iterator<_Iterator>& __x)
    { return __x + __n; }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    make_move_iterator(_Iterator __i)
    { return move_iterator<_Iterator>(__i); }

  template<typename _Iterator, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond
      <typename iterator_traits<_Iterator>::value_type>::value,
                _Iterator, move_iterator<_Iterator>>::type>
    inline _ReturnType
    __make_move_if_noexcept_iterator(_Iterator __i)
    { return _ReturnType(__i); }



  template<typename _Tp, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond<_Tp>::value,
      const _Tp*, move_iterator<_Tp*>>::type>
    inline _ReturnType
    __make_move_if_noexcept_iterator(_Tp* __i)
    { return _ReturnType(__i); }



  template<typename _Iterator>
    auto
    __niter_base(move_iterator<_Iterator> __it)
    -> decltype(make_move_iterator(__niter_base(__it.base())))
    { return make_move_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<move_iterator<_Iterator> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<typename _Iterator>
    auto
    __miter_base(move_iterator<_Iterator> __it)
    -> decltype(__miter_base(__it.base()))
    { return __miter_base(__it.base()); }


}
#68 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 2 3

#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/debug/debug.h" 1 3
#48 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;
}
#70 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 2 3

#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/predefined_ops.h" 1 3
#33 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/predefined_ops.h" 3
namespace __gnu_cxx
{
namespace __ops
{
  struct _Iter_less_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      constexpr
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 < *__it2; }
  };
  constexpr
  inline _Iter_less_iter
  __iter_less_iter()
  { return _Iter_less_iter(); }

  struct _Iter_less_val
  {
    template<typename _Iterator, typename _Value>
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it < __val; }
    };

  inline _Iter_less_val
  __iter_less_val()
  { return _Iter_less_val(); }

  inline _Iter_less_val
  __iter_comp_val(_Iter_less_iter)
  { return _Iter_less_val(); }

  struct _Val_less_iter
  {
    template<typename _Value, typename _Iterator>
      bool
      operator()(_Value& __val, _Iterator __it) const
      { return __val < *__it; }
    };

  inline _Val_less_iter
  __val_less_iter()
  { return _Val_less_iter(); }

  inline _Val_less_iter
  __val_comp_iter(_Iter_less_iter)
  { return _Val_less_iter(); }

  struct _Iter_equal_to_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 == *__it2; }
    };

  inline _Iter_equal_to_iter
  __iter_equal_to_iter()
  { return _Iter_equal_to_iter(); }

  struct _Iter_equal_to_val
  {
    template<typename _Iterator, typename _Value>
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it == __val; }
    };

  inline _Iter_equal_to_val
  __iter_equal_to_val()
  { return _Iter_equal_to_val(); }

  inline _Iter_equal_to_val
  __iter_comp_val(_Iter_equal_to_iter)
  { return _Iter_equal_to_val(); }

  template<typename _Compare>
    struct _Iter_comp_iter
    {
      _Compare _M_comp;
      constexpr
      _Iter_comp_iter(_Compare __comp)
 : _M_comp(__comp)
      { }

      template<typename _Iterator1, typename _Iterator2>
        constexpr
        bool
        operator()(_Iterator1 __it1, _Iterator2 __it2)
        { return bool(_M_comp(*__it1, *__it2)); }
    };

  template<typename _Compare>
    constexpr
    inline _Iter_comp_iter<_Compare>
    __iter_comp_iter(_Compare __comp)
    { return _Iter_comp_iter<_Compare>(__comp); }

  template<typename _Compare>
    struct _Iter_comp_val
    {
      _Compare _M_comp;

      _Iter_comp_val(_Compare __comp)
 : _M_comp(__comp)
      { }

      template<typename _Iterator, typename _Value>
 bool
 operator()(_Iterator __it, _Value& __val)
 { return bool(_M_comp(*__it, __val)); }
    };

  template<typename _Compare>
   inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Compare __comp)
    { return _Iter_comp_val<_Compare>(__comp); }

  template<typename _Compare>
    inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Iter_comp_iter<_Compare> __comp)
    { return _Iter_comp_val<_Compare>(__comp._M_comp); }

  template<typename _Compare>
    struct _Val_comp_iter
    {
      _Compare _M_comp;

      _Val_comp_iter(_Compare __comp)
 : _M_comp(__comp)
      { }

      template<typename _Value, typename _Iterator>
 bool
 operator()(_Value& __val, _Iterator __it)
 { return bool(_M_comp(__val, *__it)); }
    };

  template<typename _Compare>
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Compare __comp)
    { return _Val_comp_iter<_Compare>(__comp); }

  template<typename _Compare>
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Iter_comp_iter<_Compare> __comp)
    { return _Val_comp_iter<_Compare>(__comp._M_comp); }

  template<typename _Value>
    struct _Iter_equals_val
    {
      _Value& _M_value;

      _Iter_equals_val(_Value& __value)
 : _M_value(__value)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return *__it == _M_value; }
    };

  template<typename _Value>
    inline _Iter_equals_val<_Value>
    __iter_equals_val(_Value& __val)
    { return _Iter_equals_val<_Value>(__val); }

  template<typename _Iterator1>
    struct _Iter_equals_iter
    {
      typename std::iterator_traits<_Iterator1>::reference _M_ref;

      _Iter_equals_iter(_Iterator1 __it1)
 : _M_ref(*__it1)
      { }

      template<typename _Iterator2>
 bool
 operator()(_Iterator2 __it2)
 { return *__it2 == _M_ref; }
    };

  template<typename _Iterator>
    inline _Iter_equals_iter<_Iterator>
    __iter_comp_iter(_Iter_equal_to_iter, _Iterator __it)
    { return _Iter_equals_iter<_Iterator>(__it); }

  template<typename _Predicate>
    struct _Iter_pred
    {
      _Predicate _M_pred;

      _Iter_pred(_Predicate __pred)
 : _M_pred(__pred)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
    inline _Iter_pred<_Predicate>
    __pred_iter(_Predicate __pred)
    { return _Iter_pred<_Predicate>(__pred); }

  template<typename _Compare, typename _Value>
    struct _Iter_comp_to_val
    {
      _Compare _M_comp;
      _Value& _M_value;

      _Iter_comp_to_val(_Compare __comp, _Value& __value)
 : _M_comp(__comp), _M_value(__value)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return bool(_M_comp(*__it, _M_value)); }
    };

  template<typename _Compare, typename _Value>
    _Iter_comp_to_val<_Compare, _Value>
    __iter_comp_val(_Compare __comp, _Value &__val)
    { return _Iter_comp_to_val<_Compare, _Value>(__comp, __val); }

  template<typename _Compare, typename _Iterator1>
    struct _Iter_comp_to_iter
    {
      _Compare _M_comp;
      typename std::iterator_traits<_Iterator1>::reference _M_ref;

      _Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)
 : _M_comp(__comp), _M_ref(*__it1)
      { }

      template<typename _Iterator2>
 bool
 operator()(_Iterator2 __it2)
 { return bool(_M_comp(*__it2, _M_ref)); }
    };

  template<typename _Compare, typename _Iterator>
    inline _Iter_comp_to_iter<_Compare, _Iterator>
    __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it)
    { return _Iter_comp_to_iter<_Compare, _Iterator>(__comp._M_comp, __it); }

  template<typename _Predicate>
    struct _Iter_negate
    {
      _Predicate _M_pred;

      _Iter_negate(_Predicate __pred)
 : _M_pred(__pred)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return !bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
    inline _Iter_negate<_Predicate>
    __negate(_Iter_pred<_Predicate> __pred)
    { return _Iter_negate<_Predicate>(__pred._M_pred); }

}
}
#72 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 2 3

namespace std
{

#118 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {




#148 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
      swap(*__a, *__b);

    }
#164 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {





      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
#192 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _Tp>
    constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {



      if (__b < __a)
 return __b;
      return __a;
    }
#216 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _Tp>
    constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {



      if (__a < __b)
 return __b;
      return __a;
    }
#240 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
#262 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }



  template<typename _Iterator>
    inline _Iterator
    __niter_base(_Iterator __it)
    { return __it; }







  template<bool, bool, typename>
    struct __copy_move
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = *__first;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move<true, false, _Category>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = std::move(*__first);
   return __result;
 }
    };


  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<>
    struct __copy_move<true, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = std::move(*__first);
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {

   using __assignable = conditional<_IsMove,
        is_move_assignable<_Tp>,
        is_copy_assignable<_Tp>>;

   static_assert( __assignable::type::value, "type is not assignable" );

   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   return __result + _Num;
 }
    };

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueTypeI)
                      && __is_pointer<_II>::__value
                      && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy_move<_IsMove, __simple,
                       _Category>::__copy_m(__first, __last, __result);
    }



  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }
#444 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {




      ;

      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
#477 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    move(_II __first, _II __last, _OI __result)
    {




      ;

      return std::__copy_move_a2<true>(std::__miter_base(__first),
           std::__miter_base(__last), __result);
    }






  template<bool, bool, typename>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move_backward<true, false, _Category>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<true, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {

   using __assignable = conditional<_IsMove,
        is_move_assignable<_Tp>,
        is_copy_assignable<_Tp>>;

   static_assert( __assignable::type::value, "type is not assignable" );

   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueType1)
                      && __is_pointer<_BI1>::__value
                      && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_move_backward<_IsMove, __simple,
                                _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      return _BI2(std::__copy_move_backward_a<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }
#620 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {






      ;

      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
#656 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {






      ;

      return std::__copy_move_backward_a2<true>(std::__miter_base(__first),
      std::__miter_base(__last),
      __result);
    }






  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
      if (const size_t __len = __last - __first)
 __builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
    }
#722 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {



      ;

      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),
      __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
    {
      std::__fill_a(__first, __first + __n, __c);
      return __first + __n;
    }
#782 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {



      return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
        static bool
        equal(_II1 __first1, _II1 __last1, _II2 __first2)
        {
   for (; __first1 != __last1; ++__first1, (void)++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
        static bool
        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
        {
   if (const size_t __len = (__last1 - __first1))
     return !__builtin_memcmp(__first1, __first2, sizeof(_Tp) * __len);
   return true;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple = ((__is_integer<_ValueType1>::__value
         || __is_pointer<_ValueType1>::__value)
                      && __is_pointer<_II1>::__value
                      && __is_pointer<_II2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }

  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
        static _II1
        __newlast1(_II1, _II1 __last1, _II2, _II2)
        { return __last1; }

      template<typename _II>
        static bool
        __cnd2(_II __first, _II __last)
        { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
        static _RAI1
        __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
        {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
        static bool
        __cnd2(_RAI, _RAI)
        { return true; }
    };

  template<typename _II1, typename _II2, typename _Compare>
    bool
    __lexicographical_compare_impl(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2,
       _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, (void)++__first2)
 {
   if (__comp(__first1, __first2))
     return true;
   if (__comp(__first2, __first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
        static bool __lc(_II1, _II1, _II2, _II2);
    };

  template<bool _BoolType>
    template<typename _II1, typename _II2>
      bool
      __lexicographical_compare<_BoolType>::
      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
      {
 return std::__lexicographical_compare_impl(__first1, __last1,
         __first2, __last2,
     __gnu_cxx::__ops::__iter_less_iter());
      }

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
        static bool
        __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   if (const size_t __len = std::min(__len1, __len2))
     if (int __result = __builtin_memcmp(__first1, __first2, __len))
       return __result < 0;
   return __len1 < __len2;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value);

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    __lower_bound(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
#982 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {




      ;

      return std::__lower_bound(__first, __last, __val,
    __gnu_cxx::__ops::__iter_less_val());
    }



  inline constexpr int
  __lg(int __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr unsigned
  __lg(unsigned __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr long
  __lg(long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr unsigned long
  __lg(unsigned long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr long long
  __lg(long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }

  inline constexpr unsigned long long
  __lg(unsigned long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }




#1039 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {






      ;

      return std::__equal_aux(std::__niter_base(__first1),
         std::__niter_base(__last1),
         std::__niter_base(__first2));
    }
#1071 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {



      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }
#1104 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {






      ;
      ;

      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!(*__first1 == *__first2))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }
#1153 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _IIter2 __last2, _BinaryPredicate __binary_pred)
    {



      ;
      ;

      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_IIter1>::iterator_category;
      using _Cat2 = typename iterator_traits<_IIter2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2,
           __binary_pred);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }
#1201 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {









      ;
      ;

      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
      std::__niter_base(__last1),
      std::__niter_base(__first2),
      std::__niter_base(__last2));
    }
#1237 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {



      ;
      ;

      return std::__lexicographical_compare_impl
 (__first1, __last1, __first2, __last2,
  __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __binary_pred(__first1, __first2))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
#1280 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {






      ;

      return std::__mismatch(__first1, __last1, __first2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
#1313 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {



      ;

      return std::__mismatch(__first1, __last1, __first2,
 __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }



  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __first2 != __last2
      && __binary_pred(__first1, __first2))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
#1360 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {






      ;
      ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
#1395 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _BinaryPredicate __binary_pred)
    {



      ;
      ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }



}
#62 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/algorithm" 2 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 1 3
#59 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdlib" 1 3
#39 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdlib" 3

#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
#60 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 2 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/algorithmfwd.h" 1 3
#33 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/algorithmfwd.h" 3

#34 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/algorithmfwd.h" 3
#42 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/algorithmfwd.h" 3
namespace std
{

#194 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/algorithmfwd.h" 3
  template<typename _IIter, typename _Predicate>
    bool
    all_of(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Predicate>
    bool
    any_of(_IIter, _IIter, _Predicate);


  template<typename _FIter, typename _Tp>
    bool
    binary_search(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    bool
    binary_search(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _IIter, typename _OIter>
    _OIter
    copy(_IIter, _IIter, _OIter);

  template<typename _BIter1, typename _BIter2>
    _BIter2
    copy_backward(_BIter1, _BIter1, _BIter2);


  template<typename _IIter, typename _OIter, typename _Predicate>
    _OIter
    copy_if(_IIter, _IIter, _OIter, _Predicate);

  template<typename _IIter, typename _Size, typename _OIter>
    _OIter
    copy_n(_IIter, _Size, _OIter);





  template<typename _FIter, typename _Tp>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _FIter, typename _Tp>
    void
    fill(_FIter, _FIter, const _Tp&);

  template<typename _OIter, typename _Size, typename _Tp>
    _OIter
    fill_n(_OIter, _Size, const _Tp&);



  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);





  template<typename _IIter, typename _Predicate>
    _IIter
    find_if_not(_IIter, _IIter, _Predicate);






  template<typename _IIter1, typename _IIter2>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _BIter>
    void
    inplace_merge(_BIter, _BIter, _BIter);

  template<typename _BIter, typename _Compare>
    void
    inplace_merge(_BIter, _BIter, _BIter, _Compare);


  template<typename _RAIter>
    bool
    is_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    bool
    is_heap(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    _RAIter
    is_heap_until(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    _RAIter
    is_heap_until(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _Predicate>
    bool
    is_partitioned(_IIter, _IIter, _Predicate);

  template<typename _FIter1, typename _FIter2>
    bool
    is_permutation(_FIter1, _FIter1, _FIter2);

  template<typename _FIter1, typename _FIter2,
    typename _BinaryPredicate>
    bool
    is_permutation(_FIter1, _FIter1, _FIter2, _BinaryPredicate);

  template<typename _FIter>
    bool
    is_sorted(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    bool
    is_sorted(_FIter, _FIter, _Compare);

  template<typename _FIter>
    _FIter
    is_sorted_until(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    _FIter
    is_sorted_until(_FIter, _FIter, _Compare);


  template<typename _FIter1, typename _FIter2>
    void
    iter_swap(_FIter1, _FIter2);

  template<typename _FIter, typename _Tp>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _RAIter>
    void
    make_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    make_heap(_RAIter, _RAIter, _Compare);

  template<typename _Tp>
    constexpr
    const _Tp&
    max(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    constexpr
    const _Tp&
    max(const _Tp&, const _Tp&, _Compare);




  template<typename _Tp>
    constexpr
    const _Tp&
    min(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    constexpr
    const _Tp&
    min(const _Tp&, const _Tp&, _Compare);




  template<typename _Tp>
    constexpr
    pair<const _Tp&, const _Tp&>
    minmax(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    constexpr
    pair<const _Tp&, const _Tp&>
    minmax(const _Tp&, const _Tp&, _Compare);

  template<typename _FIter>
    constexpr
    pair<_FIter, _FIter>
    minmax_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    constexpr
    pair<_FIter, _FIter>
    minmax_element(_FIter, _FIter, _Compare);

  template<typename _Tp>
    constexpr
    _Tp
    min(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    constexpr
    _Tp
    min(initializer_list<_Tp>, _Compare);

  template<typename _Tp>
    constexpr
    _Tp
    max(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    constexpr
    _Tp
    max(initializer_list<_Tp>, _Compare);

  template<typename _Tp>
    constexpr
    pair<_Tp, _Tp>
    minmax(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    constexpr
    pair<_Tp, _Tp>
    minmax(initializer_list<_Tp>, _Compare);




  template<typename _BIter>
    bool
    next_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    next_permutation(_BIter, _BIter, _Compare);


  template<typename _IIter, typename _Predicate>
    bool
    none_of(_IIter, _IIter, _Predicate);





  template<typename _IIter, typename _RAIter>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter);

  template<typename _IIter, typename _RAIter, typename _Compare>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter, _Compare);




  template<typename _IIter, typename _OIter1,
    typename _OIter2, typename _Predicate>
    pair<_OIter1, _OIter2>
    partition_copy(_IIter, _IIter, _OIter1, _OIter2, _Predicate);

  template<typename _FIter, typename _Predicate>
    _FIter
    partition_point(_FIter, _FIter, _Predicate);


  template<typename _RAIter>
    void
    pop_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    pop_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter>
    bool
    prev_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    prev_permutation(_BIter, _BIter, _Compare);

  template<typename _RAIter>
    void
    push_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    push_heap(_RAIter, _RAIter, _Compare);



  template<typename _FIter, typename _Tp>
    _FIter
    remove(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Predicate>
    _FIter
    remove_if(_FIter, _FIter, _Predicate);

  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    remove_copy(_IIter, _IIter, _OIter, const _Tp&);

  template<typename _IIter, typename _OIter, typename _Predicate>
    _OIter
    remove_copy_if(_IIter, _IIter, _OIter, _Predicate);



  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    replace_copy(_IIter, _IIter, _OIter, const _Tp&, const _Tp&);

  template<typename _Iter, typename _OIter, typename _Predicate, typename _Tp>
    _OIter
    replace_copy_if(_Iter, _Iter, _OIter, _Predicate, const _Tp&);



  template<typename _BIter>
    void
    reverse(_BIter, _BIter);

  template<typename _BIter, typename _OIter>
    _OIter
    reverse_copy(_BIter, _BIter, _OIter);

  inline namespace _V2
  {
    template<typename _FIter>
      _FIter
      rotate(_FIter, _FIter, _FIter);
  }

  template<typename _FIter, typename _OIter>
    _OIter
    rotate_copy(_FIter, _FIter, _FIter, _OIter);
#552 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/algorithmfwd.h" 3
  template<typename _RAIter, typename _UGenerator>
    void
    shuffle(_RAIter, _RAIter, _UGenerator&&);


  template<typename _RAIter>
    void
    sort_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    stable_partition(_BIter, _BIter, _Predicate);
#581 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/algorithmfwd.h" 3
  template<typename _FIter1, typename _FIter2>
    _FIter2
    swap_ranges(_FIter1, _FIter1, _FIter2);



  template<typename _FIter>
    _FIter
    unique(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    unique(_FIter, _FIter, _BinaryPredicate);



  template<typename _FIter, typename _Tp>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&, _Compare);





  template<typename _FIter>
    _FIter
    adjacent_find(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    adjacent_find(_FIter, _FIter, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    typename iterator_traits<_IIter>::difference_type
    count(_IIter, _IIter, const _Tp&);

  template<typename _IIter, typename _Predicate>
    typename iterator_traits<_IIter>::difference_type
    count_if(_IIter, _IIter, _Predicate);

  template<typename _IIter1, typename _IIter2>
    bool
    equal(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    bool
    equal(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    _IIter
    find(_IIter, _IIter, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _IIter, typename _Predicate>
    _IIter
    find_if(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Funct>
    _Funct
    for_each(_IIter, _IIter, _Funct);

  template<typename _FIter, typename _Generator>
    void
    generate(_FIter, _FIter, _Generator);

  template<typename _OIter, typename _Size, typename _Generator>
    _OIter
    generate_n(_OIter, _Size, _Generator);

  template<typename _IIter1, typename _IIter2>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _FIter>
    constexpr
    _FIter
    max_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    constexpr
    _FIter
    max_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _FIter>
    constexpr
    _FIter
    min_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    constexpr
    _FIter
    min_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _RAIter>
    void
    nth_element(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    nth_element(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    partial_sort(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    partial_sort(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    partition(_BIter, _BIter, _Predicate);

  template<typename _RAIter>
    void
    random_shuffle(_RAIter, _RAIter);

  template<typename _RAIter, typename _Generator>
    void
    random_shuffle(_RAIter, _RAIter,

     _Generator&&);




  template<typename _FIter, typename _Tp>
    void
    replace(_FIter, _FIter, const _Tp&, const _Tp&);

  template<typename _FIter, typename _Predicate, typename _Tp>
    void
    replace_if(_FIter, _FIter, _Predicate, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _FIter, typename _Size, typename _Tp>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&);

  template<typename _FIter, typename _Size, typename _Tp,
    typename _BinaryPredicate>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&, _BinaryPredicate);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2,
        _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _RAIter>
    void
    sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    stable_sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    stable_sort(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _OIter, typename _UnaryOperation>
    _OIter
    transform(_IIter, _IIter, _OIter, _UnaryOperation);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _BinaryOperation>
    _OIter
    transform(_IIter1, _IIter1, _IIter2, _OIter, _BinaryOperation);

  template<typename _IIter, typename _OIter>
    _OIter
    unique_copy(_IIter, _IIter, _OIter);

  template<typename _IIter, typename _OIter, typename _BinaryPredicate>
    _OIter
    unique_copy(_IIter, _IIter, _OIter, _BinaryPredicate);


}
#61 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 2 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 1 3
#62 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 3
namespace std
{







  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    _Distance
    __is_heap_until(_RandomAccessIterator __first, _Distance __n,
      _Compare __comp)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__comp(__first + __parent, __first + __child))
     return __child;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return __n;
    }



  template<typename _RandomAccessIterator, typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Distance __n)
    {
      return std::__is_heap_until(__first, __n,
   __gnu_cxx::__ops::__iter_less_iter()) == __n;
    }

  template<typename _RandomAccessIterator, typename _Compare,
    typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Compare __comp, _Distance __n)
    {
      return std::__is_heap_until(__first, __n,
 __gnu_cxx::__ops::__iter_comp_iter(__comp)) == __n;
    }

  template<typename _RandomAccessIterator>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::__is_heap(__first, std::distance(__first, __last)); }

  template<typename _RandomAccessIterator, typename _Compare>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    { return std::__is_heap(__first, __comp, std::distance(__first, __last)); }




  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,
    typename _Compare>
    void
    __push_heap(_RandomAccessIterator __first,
  _Distance __holeIndex, _Distance __topIndex, _Tp __value,
  _Compare __comp)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex && __comp(__first + __parent, __value))
 {
   *(__first + __holeIndex) = std::move(*(__first + __parent));
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = std::move(__value);
    }
#148 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;





      ;
      ;
      ;

      _ValueType __value = std::move(*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), std::move(__value),
         __gnu_cxx::__ops::__iter_less_val());
    }
#183 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;




      ;
      ;
      ;

      _ValueType __value = std::move(*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), std::move(__value),
         __gnu_cxx::__ops::__iter_comp_val(__comp));
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Tp, typename _Compare>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value, _Compare __comp)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = __holeIndex;
      while (__secondChild < (__len - 1) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   if (__comp(__first + __secondChild,
       __first + (__secondChild - 1)))
     __secondChild--;
   *(__first + __holeIndex) = std::move(*(__first + __secondChild));
   __holeIndex = __secondChild;
 }
      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   *(__first + __holeIndex) = std::move(*(__first + (__secondChild - 1)))
                                  ;
   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex,
         std::move(__value),
         __gnu_cxx::__ops::__iter_comp_val(__comp));
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      _ValueType __value = std::move(*__result);
      *__result = std::move(*__first);
      std::__adjust_heap(__first, _DistanceType(0),
    _DistanceType(__last - __first),
    std::move(__value), __comp);
    }
#263 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {





      ;
      ;
      ;
      ;

      if (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last,
     __gnu_cxx::__ops::__iter_less_iter());
 }
    }
#296 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    pop_heap(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {



      ;
      ;
      ;
      ;

      if (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last,
     __gnu_cxx::__ops::__iter_comp_iter(__comp));
 }
    }

  template<typename _RandomAccessIterator, typename _Compare>
    void
    __make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   _ValueType __value = std::move(*(__first + __parent));
   std::__adjust_heap(__first, __parent, __len, std::move(__value),
        __comp);
   if (__parent == 0)
     return;
   __parent--;
 }
    }
#351 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {





      ;
      ;

      std::__make_heap(__first, __last,
         __gnu_cxx::__ops::__iter_less_iter());
    }
#377 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {



      ;
      ;

      std::__make_heap(__first, __last,
         __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _RandomAccessIterator, typename _Compare>
    void
    __sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      while (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last, __comp);
 }
    }
#412 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {





      ;
      ;
      ;

      std::__sort_heap(__first, __last,
         __gnu_cxx::__ops::__iter_less_iter());
    }
#439 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {



      ;
      ;
      ;

      std::__sort_heap(__first, __last,
         __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
#466 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline _RandomAccessIterator
    is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {





      ;
      ;

      return __first +
 std::__is_heap_until(__first, std::distance(__first, __last),
        __gnu_cxx::__ops::__iter_less_iter());
    }
#494 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline _RandomAccessIterator
    is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {



      ;
      ;

      return __first
 + std::__is_heap_until(__first, std::distance(__first, __last),
          __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
#517 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline bool
    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::is_heap_until(__first, __last) == __last; }
#530 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline bool
    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _Compare __comp)
    { return std::is_heap_until(__first, __last, __comp) == __last; }



}
#62 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 2 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_tempbuf.h" 1 3
#60 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_tempbuf.h" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_construct.h" 1 3
#59 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_construct.h" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/new" 1 3
#37 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/new" 3

#38 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/new" 3


#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/exception" 1 3
#33 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/exception" 3

#34 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/exception" 3

#pragma GCC visibility push(default)


#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/atomic_lockfree_defines.h" 1 3
#33 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/atomic_lockfree_defines.h" 3

#34 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/atomic_lockfree_defines.h" 3
#39 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/exception" 2 3

extern "C++" {

namespace std
{
#60 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/exception" 3
  class exception
  {
  public:
    exception() noexcept { }
    virtual ~exception() noexcept;



    virtual const char*
    what() const noexcept;
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() noexcept { }



    virtual ~bad_exception() noexcept;


    virtual const char*
    what() const noexcept;
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) noexcept;



  terminate_handler get_terminate() noexcept;




  void terminate() noexcept __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) noexcept;



  unexpected_handler get_unexpected() noexcept;




  void unexpected() __attribute__ ((__noreturn__));
#129 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/exception" 3
  bool uncaught_exception() noexcept __attribute__ ((__pure__));




  int uncaught_exceptions() noexcept __attribute__ ((__pure__));



}

namespace __gnu_cxx
{

#160 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/exception" 3
  void __verbose_terminate_handler();


}

}

#pragma GCC visibility pop


#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/exception_ptr.h" 1 3
#34 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/exception_ptr.h" 3
#pragma GCC visibility push(default)
#43 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/exception_ptr.h" 3
extern "C++" {

namespace std
{
  class type_info;





  namespace __exception_ptr
  {
    class exception_ptr;
  }

  using __exception_ptr::exception_ptr;





  exception_ptr current_exception() noexcept;


  void rethrow_exception(exception_ptr) __attribute__ ((__noreturn__));

  namespace __exception_ptr
  {
    using std::rethrow_exception;





    class exception_ptr
    {
      void* _M_exception_object;

      explicit exception_ptr(void* __e) noexcept;

      void _M_addref() noexcept;
      void _M_release() noexcept;

      void *_M_get() const noexcept __attribute__ ((__pure__));

      friend exception_ptr std::current_exception() noexcept;
      friend void std::rethrow_exception(exception_ptr);

    public:
      exception_ptr() noexcept;

      exception_ptr(const exception_ptr&) noexcept;


      exception_ptr(nullptr_t) noexcept
      : _M_exception_object(0)
      { }

      exception_ptr(exception_ptr&& __o) noexcept
      : _M_exception_object(__o._M_exception_object)
      { __o._M_exception_object = 0; }
#113 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/exception_ptr.h" 3
      exception_ptr&
      operator=(const exception_ptr&) noexcept;


      exception_ptr&
      operator=(exception_ptr&& __o) noexcept
      {
        exception_ptr(static_cast<exception_ptr&&>(__o)).swap(*this);
        return *this;
      }


      ~exception_ptr() noexcept;

      void
      swap(exception_ptr&) noexcept;
#140 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/exception_ptr.h" 3
      explicit operator bool() const
      { return _M_exception_object; }


      friend bool
      operator==(const exception_ptr&, const exception_ptr&)
 noexcept __attribute__ ((__pure__));

      const class std::type_info*
      __cxa_exception_type() const noexcept
 __attribute__ ((__pure__));
    };

    bool
    operator==(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    bool
    operator!=(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    inline void
    swap(exception_ptr& __lhs, exception_ptr& __rhs)
    { __lhs.swap(__rhs); }

  }



  template<typename _Ex>
    exception_ptr
    make_exception_ptr(_Ex __ex) noexcept
    {

      try
 {
   throw __ex;
 }
      catch(...)
 {
   return current_exception();
 }



    }





  template<typename _Ex>
    exception_ptr
    copy_exception(_Ex __ex) noexcept __attribute__ ((__deprecated__));

  template<typename _Ex>
    exception_ptr
    copy_exception(_Ex __ex) noexcept
    { return std::make_exception_ptr<_Ex>(__ex); }


}

}

#pragma GCC visibility pop
#171 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/exception" 2 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/nested_exception.h" 1 3
#33 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/nested_exception.h" 3
#pragma GCC visibility push(default)
#46 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/nested_exception.h" 3
extern "C++" {

namespace std
{






  class nested_exception
  {
    exception_ptr _M_ptr;

  public:
    nested_exception() noexcept : _M_ptr(current_exception()) { }

    nested_exception(const nested_exception&) noexcept = default;

    nested_exception& operator=(const nested_exception&) noexcept = default;

    virtual ~nested_exception() noexcept;

    [[noreturn]]
    void
    rethrow_nested() const
    {
      if (_M_ptr)
 rethrow_exception(_M_ptr);
      std::terminate();
    }

    exception_ptr
    nested_ptr() const noexcept
    { return _M_ptr; }
  };

  template<typename _Except>
    struct _Nested_exception : public _Except, public nested_exception
    {
      explicit _Nested_exception(const _Except& __ex)
      : _Except(__ex)
      { }

      explicit _Nested_exception(_Except&& __ex)
      : _Except(static_cast<_Except&&>(__ex))
      { }
    };

  template<typename _Tp,
    bool __with_nested = !__is_base_of(nested_exception, _Tp)>
    struct _Throw_with_nested_impl
    {
      template<typename _Up>
 static void _S_throw(_Up&& __t)
 { throw _Nested_exception<_Tp>{static_cast<_Up&&>(__t)}; }
    };

  template<typename _Tp>
    struct _Throw_with_nested_impl<_Tp, false>
    {
      template<typename _Up>
 static void _S_throw(_Up&& __t)
 { throw static_cast<_Up&&>(__t); }
    };

  template<typename _Tp, bool = __is_class(_Tp) && !__is_final(_Tp)>
    struct _Throw_with_nested_helper : _Throw_with_nested_impl<_Tp>
    { };

  template<typename _Tp>
    struct _Throw_with_nested_helper<_Tp, false>
    : _Throw_with_nested_impl<_Tp, false>
    { };

  template<typename _Tp>
    struct _Throw_with_nested_helper<_Tp&, false>
    : _Throw_with_nested_helper<_Tp>
    { };

  template<typename _Tp>
    struct _Throw_with_nested_helper<_Tp&&, false>
    : _Throw_with_nested_helper<_Tp>
    { };



  template<typename _Tp>
    [[noreturn]]
    inline void
    throw_with_nested(_Tp&& __t)
    {
      _Throw_with_nested_helper<_Tp>::_S_throw(static_cast<_Tp&&>(__t));
    }

  template<typename _Tp, bool = __is_polymorphic(_Tp)>
    struct _Rethrow_if_nested_impl
    {
      static void _S_rethrow(const _Tp& __t)
      {
 if (auto __tp =
            dynamic_cast<const nested_exception*>(std::__addressof(__t)))
   __tp->rethrow_nested();
      }
    };

  template<typename _Tp>
    struct _Rethrow_if_nested_impl<_Tp, false>
    {
      static void _S_rethrow(const _Tp&) { }
    };


  template<typename _Ex>
    inline void
    rethrow_if_nested(const _Ex& __ex)
    {
      _Rethrow_if_nested_impl<_Ex>::_S_rethrow(__ex);
    }


}

}



#pragma GCC visibility pop
#172 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/exception" 2 3
#41 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/new" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }



    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };


  class bad_array_new_length : public bad_alloc
  {
  public:
    bad_array_new_length() throw() { };



    virtual ~bad_array_new_length() throw();


    virtual const char* what() const throw();
  };


  struct nothrow_t
  {

    explicit nothrow_t() = default;

  };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();



  new_handler get_new_handler() noexcept;

}
#116 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/new" 3
void* operator new(std::size_t)
  __attribute__((__externally_visible__));
void* operator new[](std::size_t)
  __attribute__((__externally_visible__));
void operator delete(void*) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*) noexcept
  __attribute__((__externally_visible__));

void operator delete(void*, std::size_t) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, std::size_t) noexcept
  __attribute__((__externally_visible__));

void* operator new(std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void* operator new[](std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete(void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));

void operator delete(void*, std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));



inline void* operator new(std::size_t, void* __p) noexcept
{ return __p; }
inline void* operator new[](std::size_t, void* __p) noexcept
{ return __p; }


inline void operator delete (void*, void*) noexcept { }
inline void operator delete[](void*, void*) noexcept { }

}

#pragma GCC visibility pop
#60 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_construct.h" 2 3

#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ext/alloc_traits.h" 1 3
#32 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ext/alloc_traits.h" 3

#33 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ext/alloc_traits.h" 3



#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 1 3
#41 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 3
namespace std
{


  struct __allocator_traits_base
  {
    template<typename _Alloc, typename _Up>
      using __rebind = typename _Alloc::template rebind<_Up>::other;

  protected:
    template<typename _Tp>
      using __pointer = typename _Tp::pointer;
    template<typename _Tp>
      using __c_pointer = typename _Tp::const_pointer;
    template<typename _Tp>
      using __v_pointer = typename _Tp::void_pointer;
    template<typename _Tp>
      using __cv_pointer = typename _Tp::const_void_pointer;
    template<typename _Tp>
      using __diff_type = typename _Tp::difference_type;
    template<typename _Tp>
      using __size_type = typename _Tp::size_type;
    template<typename _Tp>
      using __pocca = typename _Tp::propagate_on_container_copy_assignment;
    template<typename _Tp>
      using __pocma = typename _Tp::propagate_on_container_move_assignment;
    template<typename _Tp>
      using __pocs = typename _Tp::propagate_on_container_swap;
    template<typename _Tp>
      using __equal = typename _Tp::is_always_equal;
  };

  template<typename _Alloc, typename _Up>
    using __alloc_rebind = __detected_or_t_<__replace_first_arg_t,
         __allocator_traits_base::__rebind,
         _Alloc, _Up>;





  template<typename _Alloc>
    struct allocator_traits : __allocator_traits_base
    {

      typedef _Alloc allocator_type;

      typedef typename _Alloc::value_type value_type;






      using pointer = __detected_or_t<value_type*, __pointer, _Alloc>;







      using const_pointer
 = __detected_or_t<__ptr_rebind<pointer, const value_type>,
     __c_pointer, _Alloc>;







      using void_pointer
 = __detected_or_t<__ptr_rebind<pointer, void>, __v_pointer, _Alloc>;







      using const_void_pointer
 = __detected_or_t<__ptr_rebind<pointer, const void>, __cv_pointer,
     _Alloc>;







      using difference_type
 = __detected_or_t<typename pointer_traits<pointer>::difference_type,
     __diff_type, _Alloc>;







      using size_type
 = __detected_or_t<typename make_unsigned<difference_type>::type,
     __size_type, _Alloc>;







      using propagate_on_container_copy_assignment
 = __detected_or_t<false_type, __pocca, _Alloc>;







      using propagate_on_container_move_assignment
 = __detected_or_t<false_type, __pocma, _Alloc>;







      using propagate_on_container_swap
 = __detected_or_t<false_type, __pocs, _Alloc>;







      using is_always_equal
 = __detected_or_t<typename is_empty<_Alloc>::type, __equal, _Alloc>;

      template<typename _Tp>
 using rebind_alloc = __alloc_rebind<_Alloc, _Tp>;
      template<typename _Tp>
 using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;

      static_assert(!is_same<rebind_alloc<value_type>, __undefined>::value,
   "allocator defines rebind or is like Alloc<T, Args>");

    private:
      template<typename _Alloc2>
 static auto
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint, int)
 -> decltype(__a.allocate(__n, __hint))
 { return __a.allocate(__n, __hint); }

      template<typename _Alloc2>
 static pointer
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer, ...)
 { return __a.allocate(__n); }

      template<typename _Tp, typename... _Args>
 struct __construct_helper
 {
   template<typename _Alloc2,
     typename = decltype(std::declval<_Alloc2*>()->construct(
    std::declval<_Tp*>(), std::declval<_Args>()...))>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   using type = decltype(__test<_Alloc>(0));
 };

      template<typename _Tp, typename... _Args>
 using __has_construct
   = typename __construct_helper<_Tp, _Args...>::type;

      template<typename _Tp, typename... _Args>
 static _Require<__has_construct<_Tp, _Args...>>
 _S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 { __a.construct(__p, std::forward<_Args>(__args)...); }

      template<typename _Tp, typename... _Args>
 static
 _Require<__and_<__not_<__has_construct<_Tp, _Args...>>,
          is_constructible<_Tp, _Args...>>>
 _S_construct(_Alloc&, _Tp* __p, _Args&&... __args)
 { ::new((void*)__p) _Tp(std::forward<_Args>(__args)...); }

      template<typename _Alloc2, typename _Tp>
 static auto
 _S_destroy(_Alloc2& __a, _Tp* __p, int)
 -> decltype(__a.destroy(__p))
 { __a.destroy(__p); }

      template<typename _Alloc2, typename _Tp>
 static void
 _S_destroy(_Alloc2&, _Tp* __p, ...)
 { __p->~_Tp(); }

      template<typename _Alloc2>
 static auto
 _S_max_size(_Alloc2& __a, int)
 -> decltype(__a.max_size())
 { return __a.max_size(); }

      template<typename _Alloc2>
 static size_type
 _S_max_size(_Alloc2&, ...)
 {


   return __gnu_cxx::__numeric_traits<size_type>::__max
     / sizeof(value_type);
 }

      template<typename _Alloc2>
 static auto
 _S_select(_Alloc2& __a, int)
 -> decltype(__a.select_on_container_copy_construction())
 { return __a.select_on_container_copy_construction(); }

      template<typename _Alloc2>
 static _Alloc2
 _S_select(_Alloc2& __a, ...)
 { return __a; }

    public:
#279 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 3
      static pointer
      allocate(_Alloc& __a, size_type __n)
      { return __a.allocate(__n); }
#294 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 3
      static pointer
      allocate(_Alloc& __a, size_type __n, const_void_pointer __hint)
      { return _S_allocate(__a, __n, __hint, 0); }
#306 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 3
      static void
      deallocate(_Alloc& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
#321 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 3
      template<typename _Tp, typename... _Args>
 static auto construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 -> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...))
 { _S_construct(__a, __p, std::forward<_Args>(__args)...); }
#334 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 3
      template<typename _Tp>
 static void destroy(_Alloc& __a, _Tp* __p)
 { _S_destroy(__a, __p, 0); }
#346 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 3
      static size_type max_size(const _Alloc& __a) noexcept
      { return _S_max_size(__a, 0); }
#357 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 3
      static _Alloc
      select_on_container_copy_construction(const _Alloc& __rhs)
      { return _S_select(__rhs, 0); }
    };


  template<typename _Tp>
    struct allocator_traits<allocator<_Tp>>
    {

      using allocator_type = allocator<_Tp>;

      using value_type = _Tp;


      using pointer = _Tp*;


      using const_pointer = const _Tp*;


      using void_pointer = void*;


      using const_void_pointer = const void*;


      using difference_type = std::ptrdiff_t;


      using size_type = std::size_t;


      using propagate_on_container_copy_assignment = false_type;


      using propagate_on_container_move_assignment = true_type;


      using propagate_on_container_swap = false_type;


      using is_always_equal = true_type;

      template<typename _Up>
 using rebind_alloc = allocator<_Up>;

      template<typename _Up>
 using rebind_traits = allocator_traits<allocator<_Up>>;
#414 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 3
      static pointer
      allocate(allocator_type& __a, size_type __n)
      { return __a.allocate(__n); }
#428 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 3
      static pointer
      allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)
      { return __a.allocate(__n, __hint); }
#440 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 3
      static void
      deallocate(allocator_type& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
#452 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 3
      template<typename _Up, typename... _Args>
 static void
 construct(allocator_type& __a, _Up* __p, _Args&&... __args)
 { __a.construct(__p, std::forward<_Args>(__args)...); }
#464 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 3
      template<typename _Up>
 static void
 destroy(allocator_type& __a, _Up* __p)
 { __a.destroy(__p); }






      static size_type
      max_size(const allocator_type& __a) noexcept
      { return __a.max_size(); }






      static allocator_type
      select_on_container_copy_construction(const allocator_type& __rhs)
      { return __rhs; }
    };


  template<typename _Alloc>
    inline void
    __do_alloc_on_copy(_Alloc& __one, const _Alloc& __two, true_type)
    { __one = __two; }

  template<typename _Alloc>
    inline void
    __do_alloc_on_copy(_Alloc&, const _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_copy(_Alloc& __one, const _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_copy_assignment __pocca;
      __do_alloc_on_copy(__one, __two, __pocca());
    }

  template<typename _Alloc>
    inline _Alloc __alloc_on_copy(const _Alloc& __a)
    {
      typedef allocator_traits<_Alloc> __traits;
      return __traits::select_on_container_copy_construction(__a);
    }

  template<typename _Alloc>
    inline void __do_alloc_on_move(_Alloc& __one, _Alloc& __two, true_type)
    { __one = std::move(__two); }

  template<typename _Alloc>
    inline void __do_alloc_on_move(_Alloc&, _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_move(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_move_assignment __pocma;
      __do_alloc_on_move(__one, __two, __pocma());
    }

  template<typename _Alloc>
    inline void __do_alloc_on_swap(_Alloc& __one, _Alloc& __two, true_type)
    {
      using std::swap;
      swap(__one, __two);
    }

  template<typename _Alloc>
    inline void __do_alloc_on_swap(_Alloc&, _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_swap(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_swap __pocs;
      __do_alloc_on_swap(__one, __two, __pocs());
    }

  template<typename _Alloc>
    class __is_copy_insertable_impl
    {
      typedef allocator_traits<_Alloc> _Traits;

      template<typename _Up, typename
        = decltype(_Traits::construct(std::declval<_Alloc&>(),
          std::declval<_Up*>(),
          std::declval<const _Up&>()))>
 static true_type
 _M_select(int);

      template<typename _Up>
 static false_type
 _M_select(...);

    public:
      typedef decltype(_M_select<typename _Alloc::value_type>(0)) type;
    };


  template<typename _Alloc>
    struct __is_copy_insertable
    : __is_copy_insertable_impl<_Alloc>::type
    { };


  template<typename _Tp>
    struct __is_copy_insertable<allocator<_Tp>>
    : is_copy_constructible<_Tp>
    { };


}
#37 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ext/alloc_traits.h" 2 3




namespace __gnu_cxx
{






template<typename _Alloc>
  struct __alloc_traits

  : std::allocator_traits<_Alloc>

  {
    typedef _Alloc allocator_type;

    typedef std::allocator_traits<_Alloc> _Base_type;
    typedef typename _Base_type::value_type value_type;
    typedef typename _Base_type::pointer pointer;
    typedef typename _Base_type::const_pointer const_pointer;
    typedef typename _Base_type::size_type size_type;
    typedef typename _Base_type::difference_type difference_type;

    typedef value_type& reference;
    typedef const value_type& const_reference;
    using _Base_type::allocate;
    using _Base_type::deallocate;
    using _Base_type::construct;
    using _Base_type::destroy;
    using _Base_type::max_size;

  private:
    template<typename _Ptr>
      using __is_custom_pointer
 = std::__and_<std::is_same<pointer, _Ptr>,
        std::__not_<std::is_pointer<_Ptr>>>;

  public:

    template<typename _Ptr, typename... _Args>
      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
      construct(_Alloc& __a, _Ptr __p, _Args&&... __args)
      {
 _Base_type::construct(__a, std::addressof(*__p),
         std::forward<_Args>(__args)...);
      }


    template<typename _Ptr>
      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
      destroy(_Alloc& __a, _Ptr __p)
      { _Base_type::destroy(__a, std::addressof(*__p)); }

    static _Alloc _S_select_on_copy(const _Alloc& __a)
    { return _Base_type::select_on_container_copy_construction(__a); }

    static void _S_on_swap(_Alloc& __a, _Alloc& __b)
    { std::__alloc_on_swap(__a, __b); }

    static constexpr bool _S_propagate_on_copy_assign()
    { return _Base_type::propagate_on_container_copy_assignment::value; }

    static constexpr bool _S_propagate_on_move_assign()
    { return _Base_type::propagate_on_container_move_assignment::value; }

    static constexpr bool _S_propagate_on_swap()
    { return _Base_type::propagate_on_container_swap::value; }

    static constexpr bool _S_always_equal()
    { return _Base_type::is_always_equal::value; }

    static constexpr bool _S_nothrow_move()
    { return _S_propagate_on_move_assign() || _S_always_equal(); }

    template<typename _Tp>
      struct rebind
      { typedef typename _Base_type::template rebind_alloc<_Tp> other; };
#158 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ext/alloc_traits.h" 3
  };


}
#62 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_construct.h" 2 3

namespace std
{







  template<typename _T1, typename... _Args>
    inline void
    _Construct(_T1* __p, _Args&&... __args)
    { ::new(static_cast<void*>(__p)) _T1(std::forward<_Args>(__args)...); }
#90 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_construct.h" 3
  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }

  template<bool>
    struct _Destroy_aux
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator __first, _ForwardIterator __last)
 {
   for (; __first != __last; ++__first)
     std::_Destroy(std::__addressof(*__first));
 }
    };

  template<>
    struct _Destroy_aux<true>
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator, _ForwardIterator) { }
    };






  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;
      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
 __destroy(__first, __last);
    }







  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator& __alloc)
    {
      typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
      for (; __first != __last; ++__first)
 __traits::destroy(__alloc, std::__addressof(*__first));
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>&)
    {
      _Destroy(__first, __last);
    }


}
#61 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_tempbuf.h" 2 3

namespace std
{

#83 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    pair<_Tp*, ptrdiff_t>
    get_temporary_buffer(ptrdiff_t __len) noexcept
    {
      const ptrdiff_t __max =
 __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
      if (__len > __max)
 __len = __max;

      while (__len > 0)
 {
   _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp),
       std::nothrow));
   if (__tmp != 0)
     return std::pair<_Tp*, ptrdiff_t>(__tmp, __len);
   __len /= 2;
 }
      return std::pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);
    }
#110 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    inline void
    return_temporary_buffer(_Tp* __p)
    { ::operator delete(__p, std::nothrow); }







  template<typename _ForwardIterator, typename _Tp>
    class _Temporary_buffer
    {



    public:
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef pointer iterator;
      typedef ptrdiff_t size_type;

    protected:
      size_type _M_original_len;
      size_type _M_len;
      pointer _M_buffer;

    public:

      size_type
      size() const
      { return _M_len; }


      size_type
      requested_size() const
      { return _M_original_len; }


      iterator
      begin()
      { return _M_buffer; }


      iterator
      end()
      { return _M_buffer + _M_len; }





      _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);

      ~_Temporary_buffer()
      {
 std::_Destroy(_M_buffer, _M_buffer + _M_len);
 std::return_temporary_buffer(_M_buffer);
      }

    private:

      _Temporary_buffer(const _Temporary_buffer&);

      void
      operator=(const _Temporary_buffer&);
    };


  template<bool>
    struct __uninitialized_construct_buf_dispatch
    {
      template<typename _Pointer, typename _ForwardIterator>
        static void
        __ucr(_Pointer __first, _Pointer __last,
       _ForwardIterator __seed)
        {
   if(__first == __last)
     return;

   _Pointer __cur = __first;
   try
     {
       std::_Construct(std::__addressof(*__first),
         std::move(*__seed));
       _Pointer __prev = __cur;
       ++__cur;
       for(; __cur != __last; ++__cur, ++__prev)
  std::_Construct(std::__addressof(*__cur),
    std::move(*__prev));
       *__seed = std::move(*__prev);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_construct_buf_dispatch<true>
    {
      template<typename _Pointer, typename _ForwardIterator>
        static void
        __ucr(_Pointer, _Pointer, _ForwardIterator) { }
    };
#229 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_tempbuf.h" 3
  template<typename _Pointer, typename _ForwardIterator>
    inline void
    __uninitialized_construct_buf(_Pointer __first, _Pointer __last,
      _ForwardIterator __seed)
    {
      typedef typename std::iterator_traits<_Pointer>::value_type
 _ValueType;

      std::__uninitialized_construct_buf_dispatch<
        __has_trivial_constructor(_ValueType)>::
   __ucr(__first, __last, __seed);
    }

  template<typename _ForwardIterator, typename _Tp>
    _Temporary_buffer<_ForwardIterator, _Tp>::
    _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _M_original_len(std::distance(__first, __last)),
      _M_len(0), _M_buffer(0)
    {
      try
 {
   std::pair<pointer, size_type> __p(std::get_temporary_buffer<
         value_type>(_M_original_len));
   _M_buffer = __p.first;
   _M_len = __p.second;
   if (_M_buffer)
     std::__uninitialized_construct_buf(_M_buffer, _M_buffer + _M_len,
            __first);
 }
      catch(...)
 {
   std::return_temporary_buffer(_M_buffer);
   _M_buffer = 0;
   _M_len = 0;
   throw;
 }
    }


}
#63 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 2 3



#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/uniform_int_dist.h" 1 3
#35 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/uniform_int_dist.h" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/limits" 1 3
#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/limits" 3

#41 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/limits" 3
#158 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/limits" 3
namespace std
{







  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
#202 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/limits" 3
  struct __numeric_limits_base
  {


    static constexpr bool is_specialized = false;




    static constexpr int digits = 0;


    static constexpr int digits10 = 0;




    static constexpr int max_digits10 = 0;



    static constexpr bool is_signed = false;


    static constexpr bool is_integer = false;




    static constexpr bool is_exact = false;



    static constexpr int radix = 0;



    static constexpr int min_exponent = 0;



    static constexpr int min_exponent10 = 0;




    static constexpr int max_exponent = 0;



    static constexpr int max_exponent10 = 0;


    static constexpr bool has_infinity = false;



    static constexpr bool has_quiet_NaN = false;



    static constexpr bool has_signaling_NaN = false;


    static constexpr float_denorm_style has_denorm = denorm_absent;



    static constexpr bool has_denorm_loss = false;



    static constexpr bool is_iec559 = false;




    static constexpr bool is_bounded = false;
#288 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/limits" 3
    static constexpr bool is_modulo = false;


    static constexpr bool traps = false;


    static constexpr bool tinyness_before = false;




    static constexpr float_round_style round_style =
          round_toward_zero;
  };
#314 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static constexpr _Tp
      min() noexcept { return _Tp(); }


      static constexpr _Tp
      max() noexcept { return _Tp(); }




      static constexpr _Tp
      lowest() noexcept { return _Tp(); }




      static constexpr _Tp
      epsilon() noexcept { return _Tp(); }


      static constexpr _Tp
      round_error() noexcept { return _Tp(); }


      static constexpr _Tp
      infinity() noexcept { return _Tp(); }



      static constexpr _Tp
      quiet_NaN() noexcept { return _Tp(); }



      static constexpr _Tp
      signaling_NaN() noexcept { return _Tp(); }




      static constexpr _Tp
      denorm_min() noexcept { return _Tp(); }
    };


  template<typename _Tp>
    struct numeric_limits<const _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<volatile _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<const volatile _Tp>
    : public numeric_limits<_Tp> { };






  template<>
    struct numeric_limits<bool>
    {
      static constexpr bool is_specialized = true;

      static constexpr bool
      min() noexcept { return false; }

      static constexpr bool
      max() noexcept { return true; }


      static constexpr bool
      lowest() noexcept { return min(); }

      static constexpr int digits = 1;
      static constexpr int digits10 = 0;

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr bool
      epsilon() noexcept { return false; }

      static constexpr bool
      round_error() noexcept { return false; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr bool
      infinity() noexcept { return false; }

      static constexpr bool
      quiet_NaN() noexcept { return false; }

      static constexpr bool
      signaling_NaN() noexcept { return false; }

      static constexpr bool
      denorm_min() noexcept { return false; }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;




      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static constexpr bool is_specialized = true;

      static constexpr char
      min() noexcept { return (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0) - 1 : (char)0); }

      static constexpr char
      max() noexcept { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }


      static constexpr char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((char)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char
      epsilon() noexcept { return 0; }

      static constexpr char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr
      char infinity() noexcept { return char(); }

      static constexpr char
      quiet_NaN() noexcept { return char(); }

      static constexpr char
      signaling_NaN() noexcept { return char(); }

      static constexpr char
      denorm_min() noexcept { return static_cast<char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static constexpr bool is_specialized = true;

      static constexpr signed char
      min() noexcept { return -0x7f - 1; }

      static constexpr signed char
      max() noexcept { return 0x7f; }


      static constexpr signed char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr signed char
      epsilon() noexcept { return 0; }

      static constexpr signed char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr signed char
      infinity() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      quiet_NaN() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      signaling_NaN() noexcept
      { return static_cast<signed char>(0); }

      static constexpr signed char
      denorm_min() noexcept
      { return static_cast<signed char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned char
      min() noexcept { return 0; }

      static constexpr unsigned char
      max() noexcept { return 0x7f * 2U + 1; }


      static constexpr unsigned char
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned char
      epsilon() noexcept { return 0; }

      static constexpr unsigned char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned char
      infinity() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      quiet_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      signaling_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      denorm_min() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr wchar_t
      min() noexcept { return (((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0) - 1 : (wchar_t)0); }

      static constexpr wchar_t
      max() noexcept { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }


      static constexpr wchar_t
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((wchar_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr wchar_t
      epsilon() noexcept { return 0; }

      static constexpr wchar_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr wchar_t
      infinity() noexcept { return wchar_t(); }

      static constexpr wchar_t
      quiet_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      signaling_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      denorm_min() noexcept { return wchar_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };



  template<>
    struct numeric_limits<char16_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char16_t
      min() noexcept { return (((char16_t)(-1) < 0) ? -(((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0) - 1 : (char16_t)0); }

      static constexpr char16_t
      max() noexcept { return (((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0); }

      static constexpr char16_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char16_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char16_t
      epsilon() noexcept { return 0; }

      static constexpr char16_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char16_t
      infinity() noexcept { return char16_t(); }

      static constexpr char16_t
      quiet_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      signaling_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      denorm_min() noexcept { return char16_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char32_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char32_t
      min() noexcept { return (((char32_t)(-1) < 0) ? -(((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0) - 1 : (char32_t)0); }

      static constexpr char32_t
      max() noexcept { return (((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0); }

      static constexpr char32_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char32_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char32_t
      epsilon() noexcept { return 0; }

      static constexpr char32_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char32_t
      infinity() noexcept { return char32_t(); }

      static constexpr char32_t
      quiet_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      signaling_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      denorm_min() noexcept { return char32_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };



  template<>
    struct numeric_limits<short>
    {
      static constexpr bool is_specialized = true;

      static constexpr short
      min() noexcept { return -0x7fff - 1; }

      static constexpr short
      max() noexcept { return 0x7fff; }


      static constexpr short
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static constexpr int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr short
      epsilon() noexcept { return 0; }

      static constexpr short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr short
      infinity() noexcept { return short(); }

      static constexpr short
      quiet_NaN() noexcept { return short(); }

      static constexpr short
      signaling_NaN() noexcept { return short(); }

      static constexpr short
      denorm_min() noexcept { return short(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned short
      min() noexcept { return 0; }

      static constexpr unsigned short
      max() noexcept { return 0x7fff * 2U + 1; }


      static constexpr unsigned short
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned short
      epsilon() noexcept { return 0; }

      static constexpr unsigned short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned short
      infinity() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      quiet_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      signaling_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      denorm_min() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static constexpr bool is_specialized = true;

      static constexpr int
      min() noexcept { return -0x7fffffff - 1; }

      static constexpr int
      max() noexcept { return 0x7fffffff; }


      static constexpr int
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static constexpr int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr int
      epsilon() noexcept { return 0; }

      static constexpr int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr int
      infinity() noexcept { return static_cast<int>(0); }

      static constexpr int
      quiet_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      signaling_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      denorm_min() noexcept { return static_cast<int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned int
      min() noexcept { return 0; }

      static constexpr unsigned int
      max() noexcept { return 0x7fffffff * 2U + 1; }


      static constexpr unsigned int
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned int
      epsilon() noexcept { return 0; }

      static constexpr unsigned int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned int
      infinity() noexcept { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      quiet_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      signaling_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      denorm_min() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long
      min() noexcept { return -0x7fffffffL - 1; }

      static constexpr long
      max() noexcept { return 0x7fffffffL; }


      static constexpr long
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static constexpr int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long
      epsilon() noexcept { return 0; }

      static constexpr long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long
      infinity() noexcept { return static_cast<long>(0); }

      static constexpr long
      quiet_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      signaling_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      denorm_min() noexcept { return static_cast<long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long
      min() noexcept { return 0; }

      static constexpr unsigned long
      max() noexcept { return 0x7fffffffL * 2UL + 1; }


      static constexpr unsigned long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long
      infinity() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      quiet_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      signaling_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      denorm_min() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long long
      min() noexcept { return -0x7fffffffffffffffLL - 1; }

      static constexpr long long
      max() noexcept { return 0x7fffffffffffffffLL; }


      static constexpr long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long long
      epsilon() noexcept { return 0; }

      static constexpr long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long long
      infinity() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      quiet_NaN() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      signaling_NaN() noexcept
      { return static_cast<long long>(0); }

      static constexpr long long
      denorm_min() noexcept { return static_cast<long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long long
      min() noexcept { return 0; }

      static constexpr unsigned long long
      max() noexcept { return 0x7fffffffffffffffLL * 2ULL + 1; }


      static constexpr unsigned long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long long
      infinity() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      quiet_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      signaling_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      denorm_min() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };
#1569 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/limits" 3
  template<> struct numeric_limits<__int128> { static constexpr bool is_specialized = true; static constexpr __int128 min() noexcept { return (((__int128)(-1) < 0) ? -(((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0) - 1 : (__int128)0); } static constexpr __int128 max() noexcept { return (((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0); } static constexpr int digits = 128 - 1; static constexpr int digits10 = (128 - 1) * 643L / 2136; static constexpr bool is_signed = true; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr __int128 epsilon() noexcept { return 0; } static constexpr __int128 round_error() noexcept { return 0; } static constexpr __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr __int128 infinity() noexcept { return static_cast<__int128>(0); } static constexpr __int128 quiet_NaN() noexcept { return static_cast<__int128>(0); } static constexpr __int128 signaling_NaN() noexcept { return static_cast<__int128>(0); } static constexpr __int128 denorm_min() noexcept { return static_cast<__int128>(0); } static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = false; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; }; template<> struct numeric_limits<unsigned __int128> { static constexpr bool is_specialized = true; static constexpr unsigned __int128 min() noexcept { return 0; } static constexpr unsigned __int128 max() noexcept { return (((unsigned __int128)(-1) < 0) ? (((((unsigned __int128)1 << ((128 - ((unsigned __int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(unsigned __int128)0); } static constexpr unsigned __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int digits = 128; static constexpr int digits10 = 128 * 643L / 2136; static constexpr bool is_signed = false; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr unsigned __int128 epsilon() noexcept { return 0; } static constexpr unsigned __int128 round_error() noexcept { return 0; } static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr unsigned __int128 infinity() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 quiet_NaN() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 signaling_NaN() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 denorm_min() noexcept { return static_cast<unsigned __int128>(0); } static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = true; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; };
#1592 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/limits" 3
  template<>
    struct numeric_limits<float>
    {
      static constexpr bool is_specialized = true;

      static constexpr float
      min() noexcept { return 1.17549435082228750797e-38F; }

      static constexpr float
      max() noexcept { return 3.40282346638528859812e+38F; }


      static constexpr float
      lowest() noexcept { return -3.40282346638528859812e+38F; }


      static constexpr int digits = 24;
      static constexpr int digits10 = 6;

      static constexpr int max_digits10
  = (2 + (24) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr float
      epsilon() noexcept { return 1.19209289550781250000e-7F; }

      static constexpr float
      round_error() noexcept { return 0.5F; }

      static constexpr int min_exponent = (-125);
      static constexpr int min_exponent10 = (-37);
      static constexpr int max_exponent = 128;
      static constexpr int max_exponent10 = 38;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
       = false;

      static constexpr float
      infinity() noexcept { return __builtin_huge_valf(); }

      static constexpr float
      quiet_NaN() noexcept { return __builtin_nanf(""); }

      static constexpr float
      signaling_NaN() noexcept { return __builtin_nansf(""); }

      static constexpr float
      denorm_min() noexcept { return 1.40129846432481707092e-45F; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static constexpr bool is_specialized = true;

      static constexpr double
      min() noexcept { return double(2.22507385850720138309e-308L); }

      static constexpr double
      max() noexcept { return double(1.79769313486231570815e+308L); }


      static constexpr double
      lowest() noexcept { return -double(1.79769313486231570815e+308L); }


      static constexpr int digits = 53;
      static constexpr int digits10 = 15;

      static constexpr int max_digits10
  = (2 + (53) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr double
      epsilon() noexcept { return double(2.22044604925031308085e-16L); }

      static constexpr double
      round_error() noexcept { return 0.5; }

      static constexpr int min_exponent = (-1021);
      static constexpr int min_exponent10 = (-307);
      static constexpr int max_exponent = 1024;
      static constexpr int max_exponent10 = 308;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
        = false;

      static constexpr double
      infinity() noexcept { return __builtin_huge_val(); }

      static constexpr double
      quiet_NaN() noexcept { return __builtin_nan(""); }

      static constexpr double
      signaling_NaN() noexcept { return __builtin_nans(""); }

      static constexpr double
      denorm_min() noexcept { return double(4.94065645841246544177e-324L); }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static constexpr bool is_specialized = true;

      static constexpr long double
      min() noexcept { return 3.36210314311209350626e-4932L; }

      static constexpr long double
      max() noexcept { return 1.18973149535723176502e+4932L; }


      static constexpr long double
      lowest() noexcept { return -1.18973149535723176502e+4932L; }


      static constexpr int digits = 64;
      static constexpr int digits10 = 18;

      static constexpr int max_digits10
  = (2 + (64) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr long double
      epsilon() noexcept { return 1.08420217248550443401e-19L; }

      static constexpr long double
      round_error() noexcept { return 0.5L; }

      static constexpr int min_exponent = (-16381);
      static constexpr int min_exponent10 = (-4931);
      static constexpr int max_exponent = 16384;
      static constexpr int max_exponent10 = 4932;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
 = false;

      static constexpr long double
      infinity() noexcept { return __builtin_huge_vall(); }

      static constexpr long double
      quiet_NaN() noexcept { return __builtin_nanl(""); }

      static constexpr long double
      signaling_NaN() noexcept { return __builtin_nansl(""); }

      static constexpr long double
      denorm_min() noexcept { return 3.64519953188247460253e-4951L; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before =
      false;
      static constexpr float_round_style round_style =
            round_to_nearest;
    };






}
#36 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/uniform_int_dist.h" 2 3

namespace std
{


  namespace __detail
  {

    template<typename _Tp>
      inline bool
      _Power_of_2(_Tp __x)
      {
 return ((__x - 1) & __x) == 0;
      };
  }






  template<typename _IntType = int>
    class uniform_int_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
      "template argument not an integral type");

    public:

      typedef _IntType result_type;

      struct param_type
      {
 typedef uniform_int_distribution<_IntType> distribution_type;

 explicit
 param_type(_IntType __a = 0,
     _IntType __b = std::numeric_limits<_IntType>::max())
 : _M_a(__a), _M_b(__b)
 {
   ;
 }

 result_type
 a() const
 { return _M_a; }

 result_type
 b() const
 { return _M_b; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }

      private:
 _IntType _M_a;
 _IntType _M_b;
      };

    public:



      explicit
      uniform_int_distribution(_IntType __a = 0,
      _IntType __b = std::numeric_limits<_IntType>::max())
      : _M_param(__a, __b)
      { }

      explicit
      uniform_int_distribution(const param_type& __p)
      : _M_param(__p)
      { }






      void
      reset() { }

      result_type
      a() const
      { return _M_param.a(); }

      result_type
      b() const
      { return _M_param.b(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return this->a(); }




      result_type
      max() const
      { return this->b(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
        { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }





      friend bool
      operator==(const uniform_int_distribution& __d1,
   const uniform_int_distribution& __d2)
      { return __d1._M_param == __d2._M_param; }

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;
    };

  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename uniform_int_distribution<_IntType>::result_type
      uniform_int_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 typedef typename _UniformRandomNumberGenerator::result_type
   _Gresult_type;
 typedef typename std::make_unsigned<result_type>::type __utype;
 typedef typename std::common_type<_Gresult_type, __utype>::type
   __uctype;

 const __uctype __urngmin = __urng.min();
 const __uctype __urngmax = __urng.max();
 const __uctype __urngrange = __urngmax - __urngmin;
 const __uctype __urange
   = __uctype(__param.b()) - __uctype(__param.a());

 __uctype __ret;

 if (__urngrange > __urange)
   {

     const __uctype __uerange = __urange + 1;
     const __uctype __scaling = __urngrange / __uerange;
     const __uctype __past = __uerange * __scaling;
     do
       __ret = __uctype(__urng()) - __urngmin;
     while (__ret >= __past);
     __ret /= __scaling;
   }
 else if (__urngrange < __urange)
   {
#260 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/uniform_int_dist.h" 3
     __uctype __tmp;
     do
       {
  const __uctype __uerngrange = __urngrange + 1;
  __tmp = (__uerngrange * operator()
    (__urng, param_type(0, __urange / __uerngrange)));
  __ret = __tmp + (__uctype(__urng()) - __urngmin);
       }
     while (__ret > __urange || __ret < __tmp);
   }
 else
   __ret = __uctype(__urng()) - __urngmin;

 return __ret + __param.a();
      }


  template<typename _IntType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      uniform_int_distribution<_IntType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __param)
      {

 typedef typename _UniformRandomNumberGenerator::result_type
   _Gresult_type;
 typedef typename std::make_unsigned<result_type>::type __utype;
 typedef typename std::common_type<_Gresult_type, __utype>::type
   __uctype;

 const __uctype __urngmin = __urng.min();
 const __uctype __urngmax = __urng.max();
 const __uctype __urngrange = __urngmax - __urngmin;
 const __uctype __urange
   = __uctype(__param.b()) - __uctype(__param.a());

 __uctype __ret;

 if (__urngrange > __urange)
   {
     if (__detail::_Power_of_2(__urngrange + 1)
  && __detail::_Power_of_2(__urange + 1))
       {
  while (__f != __t)
    {
      __ret = __uctype(__urng()) - __urngmin;
      *__f++ = (__ret & __urange) + __param.a();
    }
       }
     else
       {

  const __uctype __uerange = __urange + 1;
  const __uctype __scaling = __urngrange / __uerange;
  const __uctype __past = __uerange * __scaling;
  while (__f != __t)
    {
      do
        __ret = __uctype(__urng()) - __urngmin;
      while (__ret >= __past);
      *__f++ = __ret / __scaling + __param.a();
    }
       }
   }
 else if (__urngrange < __urange)
   {
#344 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/uniform_int_dist.h" 3
     __uctype __tmp;
     while (__f != __t)
       {
  do
    {
      const __uctype __uerngrange = __urngrange + 1;
      __tmp = (__uerngrange * operator()
        (__urng, param_type(0, __urange / __uerngrange)));
      __ret = __tmp + (__uctype(__urng()) - __urngmin);
    }
  while (__ret > __urange || __ret < __tmp);
  *__f++ = __ret;
       }
   }
 else
   while (__f != __t)
     *__f++ = __uctype(__urng()) - __urngmin + __param.a();
      }


}
#67 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 2 3




namespace std
{



  template<typename _Iterator, typename _Compare>
    void
    __move_median_to_first(_Iterator __result,_Iterator __a, _Iterator __b,
      _Iterator __c, _Compare __comp)
    {
      if (__comp(__a, __b))
 {
   if (__comp(__b, __c))
     std::iter_swap(__result, __b);
   else if (__comp(__a, __c))
     std::iter_swap(__result, __c);
   else
     std::iter_swap(__result, __a);
 }
      else if (__comp(__a, __c))
 std::iter_swap(__result, __a);
      else if (__comp(__b, __c))
 std::iter_swap(__result, __c);
      else
 std::iter_swap(__result, __b);
    }


  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
       _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !__pred(__first))
 ++__first;
      return __first;
    }


  template<typename _RandomAccessIterator, typename _Predicate>
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (__pred(__first))
     return __first;
   ++__first;
 case 2:
   if (__pred(__first))
     return __first;
   ++__first;
 case 1:
   if (__pred(__first))
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }

  template<typename _Iterator, typename _Predicate>
    inline _Iterator
    __find_if(_Iterator __first, _Iterator __last, _Predicate __pred)
    {
      return __find_if(__first, __last, __pred,
         std::__iterator_category(__first));
    }


  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if_not(_InputIterator __first, _InputIterator __last,
    _Predicate __pred)
    {
      return std::__find_if(__first, __last,
       __gnu_cxx::__ops::__negate(__pred),
       std::__iterator_category(__first));
    }




  template<typename _InputIterator, typename _Predicate, typename _Distance>
    _InputIterator
    __find_if_not_n(_InputIterator __first, _Distance& __len, _Predicate __pred)
    {
      for (; __len; --__len, ++__first)
 if (!__pred(__first))
   break;
      return __first;
    }
#202 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __predicate)
    {

      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
 return std::__find_if(__first1, __last1,
  __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));


      _ForwardIterator2 __p;
      _ForwardIterator1 __current = __first1;

      for (;;)
 {
   __first1 =
     std::__find_if(__first1, __last1,
  __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));

   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (__predicate(__current, __p))
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }






  template<typename _ForwardIterator, typename _Integer,
    typename _UnaryPredicate>
    _ForwardIterator
    __search_n_aux(_ForwardIterator __first, _ForwardIterator __last,
     _Integer __count, _UnaryPredicate __unary_pred,
     std::forward_iterator_tag)
    {
      __first = std::__find_if(__first, __last, __unary_pred);
      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && __unary_pred(__i))
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = std::__find_if(++__i, __last, __unary_pred);
 }
      return __last;
    }





  template<typename _RandomAccessIter, typename _Integer,
    typename _UnaryPredicate>
    _RandomAccessIter
    __search_n_aux(_RandomAccessIter __first, _RandomAccessIter __last,
     _Integer __count, _UnaryPredicate __unary_pred,
     std::random_access_iterator_tag)
    {
      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;

      _DistanceType __tailSize = __last - __first;
      _DistanceType __remainder = __count;

      while (__remainder <= __tailSize)
 {
   __first += __remainder;
   __tailSize -= __remainder;


   _RandomAccessIter __backTrack = __first;
   while (__unary_pred(--__backTrack))
     {
       if (--__remainder == 0)
  return (__first - __count);
     }
   __remainder = __count + 1 - (__first - __backTrack);
 }
      return __last;
    }

  template<typename _ForwardIterator, typename _Integer,
    typename _UnaryPredicate>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count,
        _UnaryPredicate __unary_pred)
    {
      if (__count <= 0)
 return __first;

      if (__count == 1)
 return std::__find_if(__first, __last, __unary_pred);

      return std::__search_n_aux(__first, __last, __count, __unary_pred,
     std::__iterator_category(__first));
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag,
        _BinaryPredicate __comp)
    {
      if (__first2 == __last2)
 return __last1;

      _ForwardIterator1 __result = __last1;
      while (1)
 {
   _ForwardIterator1 __new_result
     = std::__search(__first1, __last1, __first2, __last2, __comp);
   if (__new_result == __last1)
     return __result;
   else
     {
       __result = __new_result;
       __first1 = __new_result;
       ++__first1;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BinaryPredicate>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag,
        _BinaryPredicate __comp)
    {






      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::__search(_RevIterator1(__last1), __rlast1,
           _RevIterator2(__last2), __rlast2,
           __comp);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }
#423 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {






      ;
      ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
#471 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __comp)
    {






      ;
      ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
#506 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return __last == std::find_if_not(__first, __last, __pred); }
#523 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return __last == std::find_if(__first, __last, __pred); }
#541 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return !std::none_of(__first, __last, __pred); }
#556 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if_not(_InputIterator __first, _InputIterator __last,
  _Predicate __pred)
    {




      ;
      return std::__find_if_not(__first, __last,
    __gnu_cxx::__ops::__pred_iter(__pred));
    }
#580 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    is_partitioned(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {
      __first = std::find_if_not(__first, __last, __pred);
      return std::none_of(__first, __last, __pred);
    }
#598 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    partition_point(_ForwardIterator __first, _ForwardIterator __last,
      _Predicate __pred)
    {






      ;

      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__pred(*__middle))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }


  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    __remove_copy_if(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _Predicate __pred)
    {
      for (; __first != __last; ++__first)
 if (!__pred(__first))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
#665 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    inline _OutputIterator
    remove_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, const _Tp& __value)
    {






      ;

      return std::__remove_copy_if(__first, __last, __result,
 __gnu_cxx::__ops::__iter_equals_val(__value));
    }
#697 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    inline _OutputIterator
    remove_copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {






      ;

      return std::__remove_copy_if(__first, __last, __result,
       __gnu_cxx::__ops::__pred_iter(__pred));
    }
#731 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {






      ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }

  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    _OutputIterator
    __copy_n(_InputIterator __first, _Size __n,
      _OutputIterator __result, input_iterator_tag)
    {
      if (__n > 0)
 {
   while (true)
     {
       *__result = *__first;
       ++__result;
       if (--__n > 0)
  ++__first;
       else
  break;
     }
 }
      return __result;
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _OutputIterator>
    inline _OutputIterator
    __copy_n(_RandomAccessIterator __first, _Size __n,
      _OutputIterator __result, random_access_iterator_tag)
    { return std::copy(__first, __first + __n, __result); }
#794 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    inline _OutputIterator
    copy_n(_InputIterator __first, _Size __n, _OutputIterator __result)
    {





      return std::__copy_n(__first, __n, __result,
      std::__iterator_category(__first));
    }
#822 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator1,
    typename _OutputIterator2, typename _Predicate>
    pair<_OutputIterator1, _OutputIterator2>
    partition_copy(_InputIterator __first, _InputIterator __last,
     _OutputIterator1 __out_true, _OutputIterator2 __out_false,
     _Predicate __pred)
    {








      ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   {
     *__out_true = *__first;
     ++__out_true;
   }
 else
   {
     *__out_false = *__first;
     ++__out_false;
   }

      return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
    }


  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __remove_if(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred)
    {
      __first = std::__find_if(__first, __last, __pred);
      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for (; __first != __last; ++__first)
 if (!__pred(__first))
   {
     *__result = std::move(*__first);
     ++__result;
   }
      return __result;
    }
#891 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    remove(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __value)
    {





      ;

      return std::__remove_if(__first, __last,
  __gnu_cxx::__ops::__iter_equals_val(__value));
    }
#924 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    remove_if(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {





      ;

      return std::__remove_if(__first, __last,
         __gnu_cxx::__ops::__pred_iter(__pred));
    }

  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    __adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
      _BinaryPredicate __binary_pred)
    {
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while (++__next != __last)
 {
   if (__binary_pred(__first, __next))
     return __first;
   __first = __next;
 }
      return __last;
    }

  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    __unique(_ForwardIterator __first, _ForwardIterator __last,
      _BinaryPredicate __binary_pred)
    {

      __first = std::__adjacent_find(__first, __last, __binary_pred);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!__binary_pred(__dest, __first))
   *++__dest = std::move(*__first);
      return ++__dest;
    }
#990 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last)
    {





      ;

      return std::__unique(__first, __last,
      __gnu_cxx::__ops::__iter_equal_to_iter());
    }
#1020 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    inline _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {






      ;

      return std::__unique(__first, __last,
      __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }







  template<typename _ForwardIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    forward_iterator_tag, output_iterator_tag)
    {





      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!__binary_pred(__first, __next))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, output_iterator_tag)
    {





      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      __decltype(__gnu_cxx::__ops::__iter_comp_val(__binary_pred))
 __rebound_pred
 = __gnu_cxx::__ops::__iter_comp_val(__binary_pred);
      *__result = __value;
      while (++__first != __last)
 if (!__rebound_pred(__first, __value))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, forward_iterator_tag)
    {




      *__result = *__first;
      while (++__first != __last)
 if (!__binary_pred(__result, __first))
   *++__result = *__first;
      return ++__result;
    }






  template<typename _BidirectionalIterator>
    void
    __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {
      while (true)
 if (__first == __last || __first == --__last)
   return;
 else
   {
     std::iter_swap(__first, __last);
     ++__first;
   }
    }






  template<typename _RandomAccessIterator>
    void
    __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
       random_access_iterator_tag)
    {
      if (__first == __last)
 return;
      --__last;
      while (__first < __last)
 {
   std::iter_swap(__first, __last);
   ++__first;
   --__last;
 }
    }
#1175 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline void
    reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
    {



      ;
      std::__reverse(__first, __last, std::__iterator_category(__first));
    }
#1202 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _OutputIterator>
    _OutputIterator
    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
   _OutputIterator __result)
    {





      ;

      while (__first != __last)
 {
   --__last;
   *__result = *__last;
   ++__result;
 }
      return __result;
    }





  template<typename _EuclideanRingElement>
    _EuclideanRingElement
    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
    {
      while (__n != 0)
 {
   _EuclideanRingElement __t = __m % __n;
   __m = __n;
   __n = __t;
 }
      return __m;
    }

  inline namespace _V2
  {


  template<typename _ForwardIterator>
    _ForwardIterator
    __rotate(_ForwardIterator __first,
      _ForwardIterator __middle,
      _ForwardIterator __last,
      forward_iterator_tag)
    {
      if (__first == __middle)
 return __last;
      else if (__last == __middle)
 return __first;

      _ForwardIterator __first2 = __middle;
      do
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
 }
      while (__first2 != __last);

      _ForwardIterator __ret = __first;

      __first2 = __middle;

      while (__first2 != __last)
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
   else if (__first2 == __last)
     __first2 = __middle;
 }
      return __ret;
    }


  template<typename _BidirectionalIterator>
    _BidirectionalIterator
    __rotate(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {




      if (__first == __middle)
 return __last;
      else if (__last == __middle)
 return __first;

      std::__reverse(__first, __middle, bidirectional_iterator_tag());
      std::__reverse(__middle, __last, bidirectional_iterator_tag());

      while (__first != __middle && __middle != __last)
 {
   std::iter_swap(__first, --__last);
   ++__first;
 }

      if (__first == __middle)
 {
   std::__reverse(__middle, __last, bidirectional_iterator_tag());
   return __last;
 }
      else
 {
   std::__reverse(__first, __middle, bidirectional_iterator_tag());
   return __first;
 }
    }


  template<typename _RandomAccessIterator>
    _RandomAccessIterator
    __rotate(_RandomAccessIterator __first,
      _RandomAccessIterator __middle,
      _RandomAccessIterator __last,
      random_access_iterator_tag)
    {




      if (__first == __middle)
 return __last;
      else if (__last == __middle)
 return __first;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      _Distance __n = __last - __first;
      _Distance __k = __middle - __first;

      if (__k == __n - __k)
 {
   std::swap_ranges(__first, __middle, __middle);
   return __middle;
 }

      _RandomAccessIterator __p = __first;
      _RandomAccessIterator __ret = __first + (__last - __middle);

      for (;;)
 {
   if (__k < __n - __k)
     {
       if (__is_pod(_ValueType) && __k == 1)
  {
    _ValueType __t = std::move(*__p);
    std::move(__p + 1, __p + __n, __p);
    *(__p + __n - 1) = std::move(__t);
    return __ret;
  }
       _RandomAccessIterator __q = __p + __k;
       for (_Distance __i = 0; __i < __n - __k; ++ __i)
  {
    std::iter_swap(__p, __q);
    ++__p;
    ++__q;
  }
       __n %= __k;
       if (__n == 0)
  return __ret;
       std::swap(__n, __k);
       __k = __n - __k;
     }
   else
     {
       __k = __n - __k;
       if (__is_pod(_ValueType) && __k == 1)
  {
    _ValueType __t = std::move(*(__p + __n - 1));
    std::move_backward(__p, __p + __n - 1, __p + __n);
    *__p = std::move(__t);
    return __ret;
  }
       _RandomAccessIterator __q = __p + __n;
       __p = __q - __k;
       for (_Distance __i = 0; __i < __n - __k; ++ __i)
  {
    --__p;
    --__q;
    std::iter_swap(__p, __q);
  }
       __n %= __k;
       if (__n == 0)
  return __ret;
       std::swap(__n, __k);
     }
 }
    }
#1429 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline _ForwardIterator
    rotate(_ForwardIterator __first, _ForwardIterator __middle,
    _ForwardIterator __last)
    {



      ;
      ;

      return std::__rotate(__first, __middle, __last,
      std::__iterator_category(__first));
    }

  }
#1466 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _OutputIterator>
    inline _OutputIterator
    rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
  _ForwardIterator __last, _OutputIterator __result)
    {




      ;
      ;

      return std::copy(__first, __middle,
         std::copy(__middle, __last, __result));
    }


  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __partition(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred, forward_iterator_tag)
    {
      if (__first == __last)
 return __first;

      while (__pred(*__first))
 if (++__first == __last)
   return __first;

      _ForwardIterator __next = __first;

      while (++__next != __last)
 if (__pred(*__next))
   {
     std::iter_swap(__first, __next);
     ++__first;
   }

      return __first;
    }


  template<typename _BidirectionalIterator, typename _Predicate>
    _BidirectionalIterator
    __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
  _Predicate __pred, bidirectional_iterator_tag)
    {
      while (true)
 {
   while (true)
     if (__first == __last)
       return __first;
     else if (__pred(*__first))
       ++__first;
     else
       break;
   --__last;
   while (true)
     if (__first == __last)
       return __first;
     else if (!bool(__pred(*__last)))
       --__last;
     else
       break;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }
#1543 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Pointer, typename _Predicate,
    typename _Distance>
    _ForwardIterator
    __stable_partition_adaptive(_ForwardIterator __first,
    _ForwardIterator __last,
    _Predicate __pred, _Distance __len,
    _Pointer __buffer,
    _Distance __buffer_size)
    {
      if (__len == 1)
 return __first;

      if (__len <= __buffer_size)
 {
   _ForwardIterator __result1 = __first;
   _Pointer __result2 = __buffer;




   *__result2 = std::move(*__first);
   ++__result2;
   ++__first;
   for (; __first != __last; ++__first)
     if (__pred(__first))
       {
  *__result1 = std::move(*__first);
  ++__result1;
       }
     else
       {
  *__result2 = std::move(*__first);
  ++__result2;
       }

   std::move(__buffer, __result2, __result1);
   return __result1;
 }

      _ForwardIterator __middle = __first;
      std::advance(__middle, __len / 2);
      _ForwardIterator __left_split =
 std::__stable_partition_adaptive(__first, __middle, __pred,
      __len / 2, __buffer,
      __buffer_size);



      _Distance __right_len = __len - __len / 2;
      _ForwardIterator __right_split =
 std::__find_if_not_n(__middle, __right_len, __pred);

      if (__right_len)
 __right_split =
   std::__stable_partition_adaptive(__right_split, __last, __pred,
        __right_len,
        __buffer, __buffer_size);

      std::rotate(__left_split, __middle, __right_split);
      std::advance(__left_split, std::distance(__middle, __right_split));
      return __left_split;
    }

  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __stable_partition(_ForwardIterator __first, _ForwardIterator __last,
         _Predicate __pred)
    {
      __first = std::__find_if_not(__first, __last, __pred);

      if (__first == __last)
 return __first;

      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _Temporary_buffer<_ForwardIterator, _ValueType> __buf(__first, __last);
      return
 std::__stable_partition_adaptive(__first, __last, __pred,
      _DistanceType(__buf.requested_size()),
      __buf.begin(),
      _DistanceType(__buf.size()));
    }
#1646 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    stable_partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {





      ;

      return std::__stable_partition(__first, __last,
         __gnu_cxx::__ops::__pred_iter(__pred));
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last, _Compare __comp)
    {
      std::__make_heap(__first, __middle, __comp);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (__comp(__i, __first))
   std::__pop_heap(__first, __middle, __i, __comp);
    }



  template<typename _InputIterator, typename _RandomAccessIterator,
    typename _Compare>
    _RandomAccessIterator
    __partial_sort_copy(_InputIterator __first, _InputIterator __last,
   _RandomAccessIterator __result_first,
   _RandomAccessIterator __result_last,
   _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef iterator_traits<_RandomAccessIterator> _RItTraits;
      typedef typename _RItTraits::difference_type _DistanceType;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while (__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }

      std::__make_heap(__result_first, __result_real_last, __comp);
      while (__first != __last)
 {
   if (__comp(__first, __result_first))
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first), __comp);
   ++__first;
 }
      std::__sort_heap(__result_first, __result_real_last, __comp);
      return __result_real_last;
    }
#1732 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator>
    inline _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last)
    {
#1746 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3






      ;
      ;
      ;

      return std::__partial_sort_copy(__first, __last,
          __result_first, __result_last,
          __gnu_cxx::__ops::__iter_less_iter());
    }
#1781 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator,
    typename _Compare>
    inline _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last,
        _Compare __comp)
    {
#1797 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3









      ;
      ;
      ;

      return std::__partial_sort_copy(__first, __last,
          __result_first, __result_last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last,
         _Compare __comp)
    {
      typename iterator_traits<_RandomAccessIterator>::value_type
 __val = std::move(*__last);
      _RandomAccessIterator __next = __last;
      --__next;
      while (__comp(__val, __next))
 {
   *__last = std::move(*__next);
   __last = __next;
   --__next;
 }
      *__last = std::move(__val);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last, _Compare __comp)
    {
      if (__first == __last) return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   if (__comp(__i, __first))
     {
       typename iterator_traits<_RandomAccessIterator>::value_type
  __val = std::move(*__i);
       std::move_backward(__first, __i, __i + 1);
       *__first = std::move(__val);
     }
   else
     std::__unguarded_linear_insert(__i,
    __gnu_cxx::__ops::__val_comp_iter(__comp));
 }
    }


  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp)
    {
      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i,
    __gnu_cxx::__ops::__val_comp_iter(__comp));
    }





  enum { _S_threshold = 16 };


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
       __comp);
 }
      else
 std::__insertion_sort(__first, __last, __comp);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last,
     _RandomAccessIterator __pivot, _Compare __comp)
    {
      while (true)
 {
   while (__comp(__first, __pivot))
     ++__first;
   --__last;
   while (__comp(__pivot, __last))
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }


  template<typename _RandomAccessIterator, typename _Compare>
    inline _RandomAccessIterator
    __unguarded_partition_pivot(_RandomAccessIterator __first,
    _RandomAccessIterator __last, _Compare __comp)
    {
      _RandomAccessIterator __mid = __first + (__last - __first) / 2;
      std::__move_median_to_first(__first, __first + 1, __mid, __last - 1,
      __comp);
      return std::__unguarded_partition(__first + 1, __last, __first, __comp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __partial_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __middle,
     _RandomAccessIterator __last,
     _Compare __comp)
    {
      std::__heap_select(__first, __middle, __last, __comp);
      std::__sort_heap(__first, __middle, __comp);
    }


  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit, _Compare __comp)
    {
      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::__partial_sort(__first, __last, __last, __comp);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last, __comp);
   std::__introsort_loop(__cut, __last, __depth_limit, __comp);
   __last = __cut;
 }
    }



  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {
      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2,
    __comp);
   std::__final_insertion_sort(__first, __last, __comp);
 }
    }

  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit,
    _Compare __comp)
    {
      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last, __comp);

       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last, __comp);
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last, __comp);
    }
#2018 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {





                    ;

      return std::__lower_bound(__first, __last, __val,
    __gnu_cxx::__ops::__iter_comp_val(__comp));
    }

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    __upper_bound(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__val, __middle))
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
#2072 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {




      ;

      return std::__upper_bound(__first, __last, __val,
    __gnu_cxx::__ops::__val_less_iter());
    }
#2102 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    inline _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {





                    ;

      return std::__upper_bound(__first, __last, __val,
    __gnu_cxx::__ops::__val_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Tp,
    typename _CompareItTp, typename _CompareTpIt>
    pair<_ForwardIterator, _ForwardIterator>
    __equal_range(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val,
    _CompareItTp __comp_it_val, _CompareTpIt __comp_val_it)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp_it_val(__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__comp_val_it(__val, __middle))
     __len = __half;
   else
     {
       _ForwardIterator __left
  = std::__lower_bound(__first, __middle, __val, __comp_it_val);
       std::advance(__first, __len);
       _ForwardIterator __right
  = std::__upper_bound(++__middle, __first, __val, __comp_val_it);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
#2173 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {






      ;
      ;

      return std::__equal_range(__first, __last, __val,
    __gnu_cxx::__ops::__iter_less_val(),
    __gnu_cxx::__ops::__val_less_iter());
    }
#2209 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    inline pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {







                    ;

                    ;

      return std::__equal_range(__first, __last, __val,
    __gnu_cxx::__ops::__iter_comp_val(__comp),
    __gnu_cxx::__ops::__val_comp_iter(__comp));
    }
#2242 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val)
    {




      ;
      ;

      _ForwardIterator __i
 = std::__lower_bound(__first, __last, __val,
        __gnu_cxx::__ops::__iter_less_val());
      return __i != __last && !(__val < *__i);
    }
#2275 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {





                    ;

                    ;

      _ForwardIterator __i
 = std::__lower_bound(__first, __last, __val,
        __gnu_cxx::__ops::__iter_comp_val(__comp));
      return __i != __last && !bool(__comp(__val, *__i));
    }




  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    void
    __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first2, __first1))
     {
       *__result = std::move(*__first2);
       ++__first2;
     }
   else
     {
       *__result = std::move(*__first1);
       ++__first1;
     }
   ++__result;
 }
      if (__first1 != __last1)
 std::move(__first1, __last1, __result);
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3, typename _Compare>
    void
    __move_merge_adaptive_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result,
       _Compare __comp)
    {
      if (__first1 == __last1)
 {
   std::move_backward(__first2, __last2, __result);
   return;
 }
      else if (__first2 == __last2)
 return;

      --__last1;
      --__last2;
      while (true)
 {
   if (__comp(__last2, __last1))
     {
       *--__result = std::move(*__last1);
       if (__first1 == __last1)
  {
    std::move_backward(__first2, ++__last2, __result);
    return;
  }
       --__last1;
     }
   else
     {
       *--__result = std::move(*__last2);
       if (__first2 == __last2)
  return;
       --__last2;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _Distance>
    _BidirectionalIterator1
    __rotate_adaptive(_BidirectionalIterator1 __first,
        _BidirectionalIterator1 __middle,
        _BidirectionalIterator1 __last,
        _Distance __len1, _Distance __len2,
        _BidirectionalIterator2 __buffer,
        _Distance __buffer_size)
    {
      _BidirectionalIterator2 __buffer_end;
      if (__len1 > __len2 && __len2 <= __buffer_size)
 {
   if (__len2)
     {
       __buffer_end = std::move(__middle, __last, __buffer);
       std::move_backward(__first, __middle, __last);
       return std::move(__buffer, __buffer_end, __first);
     }
   else
     return __first;
 }
      else if (__len1 <= __buffer_size)
 {
   if (__len1)
     {
       __buffer_end = std::move(__first, __middle, __buffer);
       std::move(__middle, __last, __first);
       return std::move_backward(__buffer, __buffer_end, __last);
     }
   else
     return __last;
 }
      else
 {
   std::rotate(__first, __middle, __last);
   std::advance(__first, std::distance(__middle, __last));
   return __first;
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer, typename _Compare>
    void
    __merge_adaptive(_BidirectionalIterator __first,
       _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size,
       _Compare __comp)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::move(__first, __middle, __buffer);
   std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last,
         __first, __comp);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::move(__middle, __last, __buffer);
   std::__move_merge_adaptive_backward(__first, __middle, __buffer,
           __buffer_end, __last, __comp);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut
  = std::__lower_bound(__middle, __last, *__first_cut,
         __gnu_cxx::__ops::__iter_comp_val(__comp));
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut
  = std::__upper_bound(__first, __middle, *__second_cut,
         __gnu_cxx::__ops::__val_comp_iter(__comp));
       __len11 = std::distance(__first, __first_cut);
     }

   _BidirectionalIterator __new_middle
     = std::__rotate_adaptive(__first_cut, __middle, __second_cut,
         __len1 - __len11, __len22, __buffer,
         __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size, __comp);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer,
    __buffer_size, __comp);
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Compare>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2,
      _Compare __comp)
    {
      if (__len1 == 0 || __len2 == 0)
 return;

      if (__len1 + __len2 == 2)
 {
   if (__comp(__middle, __first))
     std::iter_swap(__first, __middle);
   return;
 }

      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut
     = std::__lower_bound(__middle, __last, *__first_cut,
     __gnu_cxx::__ops::__iter_comp_val(__comp));
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut
     = std::__upper_bound(__first, __middle, *__second_cut,
     __gnu_cxx::__ops::__val_comp_iter(__comp));
   __len11 = std::distance(__first, __first_cut);
 }

      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22, __comp);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22, __comp);
    }

  template<typename _BidirectionalIterator, typename _Compare>
    void
    __inplace_merge(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Compare __comp)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
   _DistanceType;

      if (__first == __middle || __middle == __last)
 return;

      const _DistanceType __len1 = std::distance(__first, __middle);
      const _DistanceType __len2 = std::distance(__middle, __last);

      typedef _Temporary_buffer<_BidirectionalIterator, _ValueType> _TmpBuf;
      _TmpBuf __buf(__first, __last);

      if (__buf.begin() == 0)
 std::__merge_without_buffer
   (__first, __middle, __last, __len1, __len2, __comp);
      else
 std::__merge_adaptive
   (__first, __middle, __last, __len1, __len2, __buf.begin(),
    _DistanceType(__buf.size()), __comp);
    }
#2569 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last)
    {





      ;
      ;
      ;

      std::__inplace_merge(__first, __middle, __last,
      __gnu_cxx::__ops::__iter_less_iter());
    }
#2610 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    inline void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare __comp)
    {






      ;
      ;
      ;

      std::__inplace_merge(__first, __middle, __last,
      __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }



  template<typename _InputIterator, typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __move_merge(_InputIterator __first1, _InputIterator __last1,
   _InputIterator __first2, _InputIterator __last2,
   _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first2, __first1))
     {
       *__result = std::move(*__first2);
       ++__first2;
     }
   else
     {
       *__result = std::move(*__first1);
       ++__first1;
     }
   ++__result;
 }
      return std::move(__first2, __last2, std::move(__first1, __last1, __result))

                  ;
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance, typename _Compare>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result, _Distance __step_size,
        _Compare __comp)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::__move_merge(__first, __first + __step_size,
           __first + __step_size,
           __first + __two_step,
           __result, __comp);
   __first += __two_step;
 }
      __step_size = std::min(_Distance(__last - __first), __step_size);

      std::__move_merge(__first, __first + __step_size,
   __first + __step_size, __last, __result, __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size, _Compare __comp)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size, __comp);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last, __comp);
    }

  enum { _S_chunk_size = 7 };

  template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
        _Pointer __buffer, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size, __comp);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer,
     __step_size, __comp);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first,
     __step_size, __comp);
   __step_size *= 2;
 }
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance, typename _Compare>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Pointer __buffer, _Distance __buffer_size,
      _Compare __comp)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle, __buffer,
          __buffer_size, __comp);
   std::__stable_sort_adaptive(__middle, __last, __buffer,
          __buffer_size, __comp);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
   std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size,
       __comp);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last, __comp);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle, __comp);
      std::__inplace_stable_sort(__middle, __last, __comp);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle,
      __comp);
    }
#2782 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    bool
    __includes(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first2, __first1))
   return false;
 else if (__comp(__first1, __first2))
   ++__first1;
 else
   {
     ++__first1;
     ++__first2;
   }

      return __first2 == __last2;
    }
#2821 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    inline bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {









      ;
      ;
      ;
      ;

      return std::__includes(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_less_iter());
    }
#2865 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    inline bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _Compare __comp)
    {









      ;
      ;
      ;
      ;

      return std::__includes(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
#2900 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    __next_permutation(_BidirectionalIterator __first,
         _BidirectionalIterator __last, _Compare __comp)
    {
      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(__i, __ii))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(__i, --__j))
  {}
       std::iter_swap(__i, __j);
       std::__reverse(__ii, __last,
        std::__iterator_category(__first));
       return true;
     }
   if (__i == __first)
     {
       std::__reverse(__first, __last,
        std::__iterator_category(__first));
       return false;
     }
 }
    }
#2949 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {





      ;
      ;

      return std::__next_permutation
 (__first, __last, __gnu_cxx::__ops::__iter_less_iter());
    }
#2981 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    inline bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {






      ;
      ;

      return std::__next_permutation
 (__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _BidirectionalIterator, typename _Compare>
    bool
    __prev_permutation(_BidirectionalIterator __first,
         _BidirectionalIterator __last, _Compare __comp)
    {
      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(__ii, __i))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(--__j, __i))
  {}
       std::iter_swap(__i, __j);
       std::__reverse(__ii, __last,
        std::__iterator_category(__first));
       return true;
     }
   if (__i == __first)
     {
       std::__reverse(__first, __last,
        std::__iterator_category(__first));
       return false;
     }
 }
    }
#3049 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {





      ;
      ;

      return std::__prev_permutation(__first, __last,
         __gnu_cxx::__ops::__iter_less_iter());
    }
#3081 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    inline bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {






      ;
      ;

      return std::__prev_permutation(__first, __last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }




  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    _OutputIterator
    __replace_copy_if(_InputIterator __first, _InputIterator __last,
        _OutputIterator __result,
        _Predicate __pred, const _Tp& __new_value)
    {
      for (; __first != __last; ++__first, (void)++__result)
 if (__pred(__first))
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
#3131 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    inline _OutputIterator
    replace_copy(_InputIterator __first, _InputIterator __last,
   _OutputIterator __result,
   const _Tp& __old_value, const _Tp& __new_value)
    {






      ;

      return std::__replace_copy_if(__first, __last, __result,
   __gnu_cxx::__ops::__iter_equals_val(__old_value),
           __new_value);
    }
#3165 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    inline _OutputIterator
    replace_copy_if(_InputIterator __first, _InputIterator __last,
      _OutputIterator __result,
      _Predicate __pred, const _Tp& __new_value)
    {






      ;

      return std::__replace_copy_if(__first, __last, __result,
    __gnu_cxx::__ops::__pred_iter(__pred),
           __new_value);
    }

  template<typename _InputIterator, typename _Predicate>
    typename iterator_traits<_InputIterator>::difference_type
    __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (__pred(__first))
   ++__n;
      return __n;
    }
#3204 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last)
    { return std::is_sorted_until(__first, __last) == __last; }
#3218 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    inline bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last,
       _Compare __comp)
    { return std::is_sorted_until(__first, __last, __comp) == __last; }

  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    __is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
        _Compare __comp)
    {
      if (__first == __last)
 return __last;

      _ForwardIterator __next = __first;
      for (++__next; __next != __last; __first = __next, (void)++__next)
 if (__comp(__next, __first))
   return __next;
      return __next;
    }
#3247 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline _ForwardIterator
    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last)
    {




      ;
      ;

      return std::__is_sorted_until(__first, __last,
        __gnu_cxx::__ops::__iter_less_iter());
    }
#3271 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    inline _ForwardIterator
    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
      _Compare __comp)
    {





      ;
      ;

      return std::__is_sorted_until(__first, __last,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
#3296 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _Tp>
    constexpr
    inline pair<const _Tp&, const _Tp&>
    minmax(const _Tp& __a, const _Tp& __b)
    {



      return __b < __a ? pair<const _Tp&, const _Tp&>(__b, __a)
         : pair<const _Tp&, const _Tp&>(__a, __b);
    }
#3317 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _Tp, typename _Compare>
    constexpr
    inline pair<const _Tp&, const _Tp&>
    minmax(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {
      return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a)
         : pair<const _Tp&, const _Tp&>(__a, __b);
    }

  template<typename _ForwardIterator, typename _Compare>
    constexpr
    pair<_ForwardIterator, _ForwardIterator>
    __minmax_element(_ForwardIterator __first, _ForwardIterator __last,
       _Compare __comp)
    {
      _ForwardIterator __next = __first;
      if (__first == __last
   || ++__next == __last)
 return std::make_pair(__first, __first);

      _ForwardIterator __min{}, __max{};
      if (__comp(__next, __first))
 {
   __min = __next;
   __max = __first;
 }
      else
 {
   __min = __first;
   __max = __next;
 }

      __first = __next;
      ++__first;

      while (__first != __last)
 {
   __next = __first;
   if (++__next == __last)
     {
       if (__comp(__first, __min))
  __min = __first;
       else if (!__comp(__first, __max))
  __max = __first;
       break;
     }

   if (__comp(__next, __first))
     {
       if (__comp(__next, __min))
  __min = __next;
       if (!__comp(__first, __max))
  __max = __first;
     }
   else
     {
       if (__comp(__first, __min))
  __min = __first;
       if (!__comp(__next, __max))
  __max = __next;
     }

   __first = __next;
   ++__first;
 }

      return std::make_pair(__min, __max);
    }
#3397 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    constexpr
    inline pair<_ForwardIterator, _ForwardIterator>
    minmax_element(_ForwardIterator __first, _ForwardIterator __last)
    {




      ;
      ;

      return std::__minmax_element(__first, __last,
       __gnu_cxx::__ops::__iter_less_iter());
    }
#3425 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    constexpr
    inline pair<_ForwardIterator, _ForwardIterator>
    minmax_element(_ForwardIterator __first, _ForwardIterator __last,
     _Compare __comp)
    {





      ;
      ;

      return std::__minmax_element(__first, __last,
       __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }


  template<typename _Tp>
    constexpr
    inline _Tp
    min(initializer_list<_Tp> __l)
    { return *std::min_element(__l.begin(), __l.end()); }

  template<typename _Tp, typename _Compare>
    constexpr
    inline _Tp
    min(initializer_list<_Tp> __l, _Compare __comp)
    { return *std::min_element(__l.begin(), __l.end(), __comp); }

  template<typename _Tp>
    constexpr
    inline _Tp
    max(initializer_list<_Tp> __l)
    { return *std::max_element(__l.begin(), __l.end()); }

  template<typename _Tp, typename _Compare>
    constexpr
    inline _Tp
    max(initializer_list<_Tp> __l, _Compare __comp)
    { return *std::max_element(__l.begin(), __l.end(), __comp); }

  template<typename _Tp>
    constexpr
    inline pair<_Tp, _Tp>
    minmax(initializer_list<_Tp> __l)
    {
      pair<const _Tp*, const _Tp*> __p =
 std::minmax_element(__l.begin(), __l.end());
      return std::make_pair(*__p.first, *__p.second);
    }

  template<typename _Tp, typename _Compare>
    constexpr
    inline pair<_Tp, _Tp>
    minmax(initializer_list<_Tp> __l, _Compare __comp)
    {
      pair<const _Tp*, const _Tp*> __p =
 std::minmax_element(__l.begin(), __l.end(), __comp);
      return std::make_pair(*__p.first, *__p.second);
    }

  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    bool
    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {


      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!__pred(__first1, __first2))
   break;

      if (__first1 == __last1)
 return true;



      _ForwardIterator2 __last2 = __first2;
      std::advance(__last2, std::distance(__first1, __last1));
      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
 {
   if (__scan != std::__find_if(__first1, __scan,
     __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
     continue;

   auto __matches
     = std::__count_if(__first2, __last2,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
   if (0 == __matches ||
       std::__count_if(__scan, __last1,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
       != __matches)
     return false;
 }
      return true;
    }
#3537 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2)
    {






      ;

      return std::__is_permutation(__first1, __last1, __first2,
       __gnu_cxx::__ops::__iter_equal_to_iter());
    }
#3568 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {






      ;

      return std::__is_permutation(__first1, __last1, __first2,
       __gnu_cxx::__ops::__iter_comp_iter(__pred));
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    bool
    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _ForwardIterator2 __last2,
       _BinaryPredicate __pred)
    {
      using _Cat1
 = typename iterator_traits<_ForwardIterator1>::iterator_category;
      using _Cat2
 = typename iterator_traits<_ForwardIterator2>::iterator_category;
      using _It1_is_RA = is_same<_Cat1, random_access_iterator_tag>;
      using _It2_is_RA = is_same<_Cat2, random_access_iterator_tag>;
      constexpr bool __ra_iters = _It1_is_RA() && _It2_is_RA();
      if (__ra_iters)
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
 }



      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!__pred(__first1, __first2))
   break;

      if (__ra_iters)
 {
   if (__first1 == __last1)
     return true;
 }
      else
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 == 0 && __d2 == 0)
     return true;
   if (__d1 != __d2)
     return false;
 }

      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
 {
   if (__scan != std::__find_if(__first1, __scan,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
     continue;

   auto __matches = std::__count_if(__first2, __last2,
  __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
   if (0 == __matches
       || std::__count_if(__scan, __last1,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
       != __matches)
     return false;
 }
      return true;
    }
#3661 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {
      ;
      ;

      return
 std::__is_permutation(__first1, __last1, __first2, __last2,
         __gnu_cxx::__ops::__iter_equal_to_iter());
    }
#3688 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2, _ForwardIterator2 __last2,
     _BinaryPredicate __pred)
    {
      ;
      ;

      return std::__is_permutation(__first1, __last1, __first2, __last2,
       __gnu_cxx::__ops::__iter_comp_iter(__pred));
    }
#3716 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator,
    typename _UniformRandomNumberGenerator>
    void
    shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _UniformRandomNumberGenerator&& __g)
    {



      ;

      if (__first == __last)
 return;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      typedef typename std::make_unsigned<_DistanceType>::type __ud_type;
      typedef typename std::uniform_int_distribution<__ud_type> __distr_type;
      typedef typename __distr_type::param_type __p_type;
      __distr_type __d;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 std::iter_swap(__i, __first + __d(__g, __p_type(0, __i - __first)));
    }







#3761 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Function>
    _Function
    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
    {


      ;
      for (; __first != __last; ++__first)
 __f(*__first);
      return std::move(__f);
    }
#3782 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    find(_InputIterator __first, _InputIterator __last,
  const _Tp& __val)
    {




      ;
      return std::__find_if(__first, __last,
       __gnu_cxx::__ops::__iter_equals_val(__val));
    }
#3806 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {




      ;

      return std::__find_if(__first, __last,
       __gnu_cxx::__ops::__pred_iter(__pred));
    }
#3837 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2)
    {






      ;
      ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (*__first1 == *__iter)
     return __first1;
      return __last1;
    }
#3877 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2,
    _BinaryPredicate __comp)
    {






      ;
      ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (__comp(*__first1, *__iter))
     return __first1;
      return __last1;
    }
#3909 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
    {




      ;

      return std::__adjacent_find(__first, __last,
      __gnu_cxx::__ops::__iter_equal_to_iter());
    }
#3934 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    inline _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {





      ;

      return std::__adjacent_find(__first, __last,
   __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }
#3959 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    inline typename iterator_traits<_InputIterator>::difference_type
    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
    {




      ;

      return std::__count_if(__first, __last,
        __gnu_cxx::__ops::__iter_equals_val(__value));
    }
#3982 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline typename iterator_traits<_InputIterator>::difference_type
    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {




      ;

      return std::__count_if(__first, __last,
        __gnu_cxx::__ops::__pred_iter(__pred));
    }
#4022 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {






      ;
      ;

      return std::__search(__first1, __last1, __first2, __last2,
      __gnu_cxx::__ops::__iter_equal_to_iter());
    }
#4061 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _BinaryPredicate __predicate)
    {






      ;
      ;

      return std::__search(__first1, __last1, __first2, __last2,
      __gnu_cxx::__ops::__iter_comp_iter(__predicate));
    }
#4096 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    inline _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val)
    {




      ;

      return std::__search_n(__first, __last, __count,
        __gnu_cxx::__ops::__iter_equals_val(__val));
    }
#4129 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
    typename _BinaryPredicate>
    inline _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val,
      _BinaryPredicate __binary_pred)
    {




      ;

      return std::__search_n(__first, __last, __count,
  __gnu_cxx::__ops::__iter_comp_val(__binary_pred, __val));
    }
#4163 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _UnaryOperation>
    _OutputIterator
    transform(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _UnaryOperation __unary_op)
    {





      ;

      for (; __first != __last; ++__first, (void)++__result)
 *__result = __unary_op(*__first);
      return __result;
    }
#4200 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _BinaryOperation>
    _OutputIterator
    transform(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _OutputIterator __result,
       _BinaryOperation __binary_op)
    {






      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2, ++__result)
 *__result = __binary_op(*__first1, *__first2);
      return __result;
    }
#4233 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    void
    replace(_ForwardIterator __first, _ForwardIterator __last,
     const _Tp& __old_value, const _Tp& __new_value)
    {







      ;

      for (; __first != __last; ++__first)
 if (*__first == __old_value)
   *__first = __new_value;
    }
#4265 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate, typename _Tp>
    void
    replace_if(_ForwardIterator __first, _ForwardIterator __last,
        _Predicate __pred, const _Tp& __new_value)
    {







      ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   *__first = __new_value;
    }
#4297 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Generator>
    void
    generate(_ForwardIterator __first, _ForwardIterator __last,
      _Generator __gen)
    {




      ;

      for (; __first != __last; ++__first)
 *__first = __gen();
    }
#4328 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _OutputIterator, typename _Size, typename _Generator>
    _OutputIterator
    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
    {





      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __gen();
      return __first;
    }
#4364 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {






      ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
    __gnu_cxx::__ops::__iter_equal_to_iter(),
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
#4404 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result,
  _BinaryPredicate __binary_pred)
    {




      ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
   __gnu_cxx::__ops::__iter_comp_iter(__binary_pred),
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
#4437 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {



      ;

      if (__first != __last)
 for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
   {

     _RandomAccessIterator __j = __first
     + std::rand() % ((__i - __first) + 1);
     if (__i != __j)
       std::iter_swap(__i, __j);
   }
    }
#4472 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _RandomNumberGenerator>
    void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,

     _RandomNumberGenerator&& __rand)



    {



      ;

      if (__first == __last)
 return;
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   _RandomAccessIterator __j = __first + __rand((__i - __first) + 1);
   if (__i != __j)
     std::iter_swap(__i, __j);
 }
    }
#4512 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {





      ;

      return std::__partition(__first, __last, __pred,
         std::__iterator_category(__first));
    }
#4545 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last)
    {





      ;
      ;
      ;

      std::__partial_sort(__first, __middle, __last,
     __gnu_cxx::__ops::__iter_less_iter());
    }
#4583 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last,
   _Compare __comp)
    {






      ;
      ;
      ;

      std::__partial_sort(__first, __middle, __last,
     __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
#4619 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last)
    {





      ;
      ;
      ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2,
    __gnu_cxx::__ops::__iter_less_iter());
    }
#4658 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last, _Compare __comp)
    {






      ;
      ;
      ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
#4695 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {





      ;
      ;

      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
    }
#4725 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {






      ;
      ;

      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    __merge(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first2, __first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
#4786 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result)
    {










      ;
      ;
      ;
      ;

      return std::__merge(__first1, __last1,
         __first2, __last2, __result,
         __gnu_cxx::__ops::__iter_less_iter());
    }
#4836 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result, _Compare __comp)
    {










      ;
      ;
      ;
      ;

      return std::__merge(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      typedef _Temporary_buffer<_RandomAccessIterator, _ValueType> _TmpBuf;
      _TmpBuf __buf(__first, __last);

      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last, __comp);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()), __comp);
    }
#4900 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {





      ;
      ;

      std::__stable_sort(__first, __last,
        __gnu_cxx::__ops::__iter_less_iter());
    }
#4934 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {






      ;
      ;

      std::__stable_sort(__first, __last,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_union(_InputIterator1 __first1, _InputIterator1 __last1,
  _InputIterator2 __first2, _InputIterator2 __last2,
  _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first1, __first2))
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (__comp(__first2, __first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
#5002 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {













      ;
      ;
      ;
      ;

      return std::__set_union(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_less_iter());
    }
#5051 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {













      ;
      ;
      ;
      ;

      return std::__set_union(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _InputIterator2 __last2,
         _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first1, __first2))
   ++__first1;
 else if (__comp(__first2, __first1))
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
#5121 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {











      ;
      ;
      ;
      ;

      return std::__set_intersection(__first1, __last1,
         __first2, __last2, __result,
         __gnu_cxx::__ops::__iter_less_iter());
    }
#5169 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {











      ;
      ;
      ;
      ;

      return std::__set_intersection(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first1, __first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(__first2, __first1))
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
#5241 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result)
    {











      ;
      ;
      ;
      ;

      return std::__set_difference(__first1, __last1,
       __first2, __last2, __result,
       __gnu_cxx::__ops::__iter_less_iter());
    }
#5291 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {











      ;
      ;
      ;
      ;

      return std::__set_difference(__first1, __last1,
       __first2, __last2, __result,
       __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_symmetric_difference(_InputIterator1 __first1,
          _InputIterator1 __last1,
          _InputIterator2 __first2,
          _InputIterator2 __last2,
          _OutputIterator __result,
          _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first1, __first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(__first2, __first1))
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
#5369 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result)
    {













      ;
      ;
      ;
      ;

      return std::__set_symmetric_difference(__first1, __last1,
     __first2, __last2, __result,
     __gnu_cxx::__ops::__iter_less_iter());
    }
#5419 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result,
        _Compare __comp)
    {













      ;
      ;
      ;
      ;

      return std::__set_symmetric_difference(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Compare>
    constexpr
    _ForwardIterator
    __min_element(_ForwardIterator __first, _ForwardIterator __last,
    _Compare __comp)
    {
      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(__first, __result))
   __result = __first;
      return __result;
    }
#5472 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    constexpr
    _ForwardIterator
    inline min_element(_ForwardIterator __first, _ForwardIterator __last)
    {




      ;
      ;

      return std::__min_element(__first, __last,
    __gnu_cxx::__ops::__iter_less_iter());
    }
#5497 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    constexpr
    inline _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {





      ;
      ;

      return std::__min_element(__first, __last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Compare>
    constexpr
    _ForwardIterator
    __max_element(_ForwardIterator __first, _ForwardIterator __last,
    _Compare __comp)
    {
      if (__first == __last) return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(__result, __first))
   __result = __first;
      return __result;
    }
#5536 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    constexpr
    inline _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last)
    {




      ;
      ;

      return std::__max_element(__first, __last,
    __gnu_cxx::__ops::__iter_less_iter());
    }
#5561 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    constexpr
    inline _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {





      ;
      ;

      return std::__max_element(__first, __last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }


}
#63 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/algorithm" 2 3
#211 "C:/Xilinx/Vivado/2018.3/include/hls_half.h" 2
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/iostream" 1 3
#36 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/iostream" 3

#37 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/iostream" 3


#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ostream" 1 3
#36 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ostream" 3

#37 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ostream" 3

#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ios" 1 3
#36 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ios" 3

#37 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ios" 3



#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/char_traits.h" 1 3
#37 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/char_traits.h" 3

#38 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/char_traits.h" 3



#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cwchar" 1 3
#39 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cwchar" 3

#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cwchar" 3
#42 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/char_traits.h" 2 3

namespace __gnu_cxx
{

#57 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/char_traits.h" 3
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
#82 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static std::size_t
      length(const char_type* __s);

      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static constexpr char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static constexpr int_type
      eof()
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
          __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {

      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {

      std::fill_n(__s, __n, __a);
      return __s;
    }


}

namespace std
{

#226 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      {

 return (static_cast<unsigned char>(__c1)
  < static_cast<unsigned char>(__c2));
      }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return 0;
 return __builtin_memcmp(__s1, __s2, __n);
      }

      static size_t
      length(const char_type* __s)
      { return __builtin_strlen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 if (__n == 0)
   return 0;
 return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n));
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 if (__n == 0)
   return __s;
 return static_cast<char_type*>(__builtin_memset(__s, __a, __n));
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return static_cast<char_type>(__c); }



      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return 0;
 return wmemcmp(__s1, __s2, __n);
      }

      static size_t
      length(const char_type* __s)
      { return wcslen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 if (__n == 0)
   return 0;
 return wmemchr(__s, __a, __n);
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return wmemmove(__s1, __s2, __n);
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return wmemcpy(__s1, __s2, __n);
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 if (__n == 0)
   return __s;
 return wmemset(__s, __a, __n);
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>((wint_t)(0xFFFF)); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };



}




#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdint" 1 3
#32 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdint" 3

#33 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdint" 3
#46 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdint" 3
namespace std
{
  using ::int8_t;
  using ::int16_t;
  using ::int32_t;
  using ::int64_t;

  using ::int_fast8_t;
  using ::int_fast16_t;
  using ::int_fast32_t;
  using ::int_fast64_t;

  using ::int_least8_t;
  using ::int_least16_t;
  using ::int_least32_t;
  using ::int_least64_t;

  using ::intmax_t;
  using ::intptr_t;

  using ::uint8_t;
  using ::uint16_t;
  using ::uint32_t;
  using ::uint64_t;

  using ::uint_fast8_t;
  using ::uint_fast16_t;
  using ::uint_fast32_t;
  using ::uint_fast64_t;

  using ::uint_least8_t;
  using ::uint_least16_t;
  using ::uint_least32_t;
  using ::uint_least64_t;

  using ::uintmax_t;
  using ::uintptr_t;
}
#421 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/char_traits.h" 2 3

namespace std
{


  template<>
    struct char_traits<char16_t>
    {
      typedef char16_t char_type;
      typedef uint_least16_t int_type;
      typedef streamoff off_type;
      typedef u16streampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };

  template<>
    struct char_traits<char32_t>
    {
      typedef char32_t char_type;
      typedef uint_least32_t int_type;
      typedef streamoff off_type;
      typedef u32streampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };


}
#41 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ios" 2 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/localefwd.h" 1 3
#37 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/localefwd.h" 3

#38 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/localefwd.h" 3


#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++locale.h" 1 3
#39 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++locale.h" 3

#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++locale.h" 3

#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/clocale" 1 3
#39 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/clocale" 3

#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/clocale" 3


#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/locale.h" 1 3
#15 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/locale.h" 3
#pragma pack(push,_CRT_PACKING)


extern "C" {
#45 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/locale.h" 3
  struct lconv {
    char *decimal_point;
    char *thousands_sep;
    char *grouping;
    char *int_curr_symbol;
    char *currency_symbol;
    char *mon_decimal_point;
    char *mon_thousands_sep;
    char *mon_grouping;
    char *positive_sign;
    char *negative_sign;
    char int_frac_digits;
    char frac_digits;
    char p_cs_precedes;
    char p_sep_by_space;
    char n_cs_precedes;
    char n_sep_by_space;
    char p_sign_posn;
    char n_sign_posn;
  };
#79 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/locale.h" 3
  int __attribute__((__cdecl__)) _configthreadlocale(int _Flag);
  char *__attribute__((__cdecl__)) setlocale(int _Category,const char *_Locale);
  __attribute__ ((__dllimport__)) struct lconv *__attribute__((__cdecl__)) localeconv(void);
  _locale_t __attribute__((__cdecl__)) _get_current_locale(void);
  _locale_t __attribute__((__cdecl__)) _create_locale(int _Category,const char *_Locale);
  void __attribute__((__cdecl__)) _free_locale(_locale_t _Locale);
  _locale_t __attribute__((__cdecl__)) __get_current_locale(void);
  _locale_t __attribute__((__cdecl__)) __create_locale(int _Category,const char *_Locale);
  void __attribute__((__cdecl__)) __free_locale(_locale_t _Locale);







}


#pragma pack(pop)
#43 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/clocale" 2 3
#51 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/clocale" 3
namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
#42 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++locale.h" 2 3



namespace std
{


  typedef int* __c_locale;





  inline int
  __convert_from_v(const __c_locale&, char* __out,
     const int __size __attribute__((__unused__)),
     const char* __fmt, ...)
  {
    char* __old = std::setlocale(4, 0);
    char* __sav = 0;
    if (__builtin_strcmp(__old, "C"))
      {
 const size_t __len = __builtin_strlen(__old) + 1;
 __sav = new char[__len];
 __builtin_memcpy(__sav, __old, __len);
 std::setlocale(4, "C");
      }

    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);


    const int __ret = __mingw_vsnprintf(__out, __size, __fmt, __args);




    __builtin_va_end(__args);

    if (__sav)
      {
 std::setlocale(4, __sav);
 delete [] __sav;
      }
    return __ret;
  }


}
#41 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/localefwd.h" 2 3

#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cctype" 1 3
#39 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cctype" 3

#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cctype" 3


#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/ctype.h" 1 3
#12 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/ctype.h" 3
extern "C" {
#72 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/ctype.h" 3
  extern const unsigned char __newclmap[];
  extern const unsigned char __newcumap[];
  extern pthreadlocinfo __ptlocinfo;
  extern pthreadmbcinfo __ptmbcinfo;
  extern int __globallocalestatus;
  extern int __locale_changed;
  extern struct threadlocaleinfostruct __initiallocinfo;
  extern _locale_tstruct __initiallocalestructinfo;
  pthreadlocinfo __attribute__((__cdecl__)) __updatetlocinfo(void);
  pthreadmbcinfo __attribute__((__cdecl__)) __updatetmbcinfo(void);
#100 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/ctype.h" 3
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isctype(int _C,int _Type);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isctype_l(int _C,int _Type,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) isalpha(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isalpha_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) isupper(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isupper_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) islower(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _islower_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) isdigit(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isdigit_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) isxdigit(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isxdigit_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) isspace(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isspace_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) ispunct(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _ispunct_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) isalnum(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isalnum_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) isprint(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isprint_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) isgraph(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isgraph_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) iscntrl(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iscntrl_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) toupper(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) tolower(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _tolower(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _tolower_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _toupper(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _toupper_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __isascii(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __toascii(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __iscsymf(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __iscsym(int _C);


int __attribute__((__cdecl__)) isblank(int _C);
#276 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/ctype.h" 3
}
#43 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cctype" 2 3
#62 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cctype" 3
namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
}







namespace std
{
  using ::isblank;
}
#43 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/localefwd.h" 2 3

namespace std
{

#55 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/localefwd.h" 3
  class locale;

  template<typename _Facet>
    bool
    has_facet(const locale&) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);


  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);


  template<typename _CharT>
    bool
    isblank(_CharT, const locale&);


  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;

  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;



  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

namespace __cxx11 {
  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;
}

namespace __cxx11 {

  template<typename _CharT>
    class collate;
  template<typename _CharT>
    class collate_byname;
}


  class time_base;
namespace __cxx11 {
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
}
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;
namespace __cxx11 {
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;
}
namespace __cxx11 {
  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;
}


  class messages_base;
namespace __cxx11 {
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;
}


}
#42 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ios" 2 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 1 3
#37 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3

#38 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3

#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ext/atomicity.h" 1 3
#32 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ext/atomicity.h" 3

#33 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ext/atomicity.h" 3


#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/gthr.h" 1 3
#30 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/gthr.h" 3
#pragma GCC visibility push(default)
#148 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/gthr.h" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/gthr-default.h" 1 3
#35 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/gthr-default.h" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 1 3
#62 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include/stddef.h" 1 3 4
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/stddef.h" 1 3 4
#2 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include/stddef.h" 2 3 4
#63 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 2 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/errno.h" 1 3
#12 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/errno.h" 3
extern "C" {
#239 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/errno.h" 3
}
#64 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 2 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/sys/types.h" 1 3
#62 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/sys/types.h" 3
__extension__
typedef long long _pid_t;




typedef _pid_t pid_t;





typedef unsigned short _mode_t;


typedef _mode_t mode_t;






typedef unsigned int useconds_t;




struct timespec {
  time_t tv_sec;
  long tv_nsec;
};

struct itimerspec {
  struct timespec it_interval;
  struct timespec it_value;
};





__extension__
typedef unsigned long long _sigset_t;
#65 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 2 3

#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/process.h" 1 3
#16 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/process.h" 3
extern "C" {
#31 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/process.h" 3
  __attribute__ ((__dllimport__)) uintptr_t __attribute__((__cdecl__)) _beginthread(void (__attribute__((__cdecl__)) *_StartAddress) (void *),unsigned _StackSize,void *_ArgList);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _endthread(void) __attribute__ ((__noreturn__));
  __attribute__ ((__dllimport__)) uintptr_t __attribute__((__cdecl__)) _beginthreadex(void *_Security,unsigned _StackSize,unsigned ( *_StartAddress) (void *),void *_ArgList,unsigned _InitFlag,unsigned *_ThrdAddr);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _endthreadex(unsigned _Retval) __attribute__ ((__noreturn__));
#57 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/process.h" 3
  void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _cexit(void);
  void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _c_exit(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _getpid(void);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _cwait(int *_TermStat,intptr_t _ProcHandle,int _Action);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _execl(const char *_Filename,const char *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _execle(const char *_Filename,const char *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _execlp(const char *_Filename,const char *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _execlpe(const char *_Filename,const char *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _execv(const char *_Filename,const char *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _execve(const char *_Filename,const char *const *_ArgList,const char *const *_Env);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _execvp(const char *_Filename,const char *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _execvpe(const char *_Filename,const char *const *_ArgList,const char *const *_Env);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnl(int _Mode,const char *_Filename,const char *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnle(int _Mode,const char *_Filename,const char *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnlp(int _Mode,const char *_Filename,const char *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnlpe(int _Mode,const char *_Filename,const char *_ArgList,...);
#116 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/process.h" 3
  void __attribute__((__cdecl__)) __security_init_cookie(void);




  void __attribute__((__cdecl__)) __security_check_cookie(uintptr_t _StackCookie);
  __attribute__((noreturn)) void __attribute__((__cdecl__)) __report_gsfailure(uintptr_t _StackCookie);

  extern uintptr_t __security_cookie;

  intptr_t __attribute__((__cdecl__)) _loaddll(char *_Filename);
  int __attribute__((__cdecl__)) _unloaddll(intptr_t _Handle);
  int (__attribute__((__cdecl__)) *__attribute__((__cdecl__)) _getdllprocaddr(intptr_t _Handle,char *_ProcedureName,intptr_t _Ordinal))(void);
#154 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/process.h" 3
  intptr_t __attribute__((__cdecl__)) cwait(int *_TermStat,intptr_t _ProcHandle,int _Action) ;

  int __attribute__((__cdecl__)) execl(const char *_Filename,const char *_ArgList,...) ;
  int __attribute__((__cdecl__)) execle(const char *_Filename,const char *_ArgList,...) ;
  int __attribute__((__cdecl__)) execlp(const char *_Filename,const char *_ArgList,...) ;
  int __attribute__((__cdecl__)) execlpe(const char *_Filename,const char *_ArgList,...) ;






  intptr_t __attribute__((__cdecl__)) spawnl(int,const char *_Filename,const char *_ArgList,...) ;
  intptr_t __attribute__((__cdecl__)) spawnle(int,const char *_Filename,const char *_ArgList,...) ;
  intptr_t __attribute__((__cdecl__)) spawnlp(int,const char *_Filename,const char *_ArgList,...) ;
  intptr_t __attribute__((__cdecl__)) spawnlpe(int,const char *_Filename,const char *_ArgList,...) ;


  int __attribute__((__cdecl__)) getpid(void) ;






  int __attribute__((__cdecl__)) execv(const char *_Filename,char *const _ArgList[]) ;
  int __attribute__((__cdecl__)) execve(const char *_Filename,char *const _ArgList[],char *const _Env[]) ;
  int __attribute__((__cdecl__)) execvp(const char *_Filename,char *const _ArgList[]) ;
  int __attribute__((__cdecl__)) execvpe(const char *_Filename,char *const _ArgList[],char *const _Env[]) ;






  intptr_t __attribute__((__cdecl__)) spawnv(int,const char *_Filename,char *const _ArgList[]) ;
  intptr_t __attribute__((__cdecl__)) spawnve(int,const char *_Filename,char *const _ArgList[],char *const _Env[]) ;
  intptr_t __attribute__((__cdecl__)) spawnvp(int,const char *_Filename,char *const _ArgList[]) ;
  intptr_t __attribute__((__cdecl__)) spawnvpe(int,const char *_Filename,char *const _ArgList[],char *const _Env[]) ;



}
#67 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 2 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include-fixed/limits.h" 1 3 4
#68 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 2 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/signal.h" 1 3
#10 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/signal.h" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/pthread_signal.h" 1 3
#11 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/signal.h" 2 3


extern "C" {




  typedef int sig_atomic_t;
#48 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/signal.h" 3
  typedef void (*__p_sig_fn_t)(int);
#57 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/signal.h" 3
  extern void **__attribute__((__cdecl__)) __pxcptinfoptrs(void);


  __p_sig_fn_t __attribute__((__cdecl__)) signal(int _SigNum,__p_sig_fn_t _Func);
  int __attribute__((__cdecl__)) raise(int _SigNum);


}
#69 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 2 3

#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/sys/timeb.h" 1 3
#15 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/sys/timeb.h" 3
#pragma pack(push,_CRT_PACKING)


extern "C" {
#53 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/sys/timeb.h" 3
  struct __timeb32 {
    __time32_t time;
    unsigned short millitm;
    short timezone;
    short dstflag;
  };


  struct timeb {
    time_t time;
    unsigned short millitm;
    short timezone;
    short dstflag;
  };


  struct __timeb64 {
    __time64_t time;
    unsigned short millitm;
    short timezone;
    short dstflag;
  };



  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _ftime64(struct __timeb64 *_Time);



  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _ftime(struct __timeb64 *);
#102 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/sys/timeb.h" 3
  void __attribute__((__cdecl__)) ftime (struct timeb *);
#119 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/sys/timeb.h" 3
}


#pragma pack(pop)

#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/sys/timeb_s.h" 1 3
#10 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/sys/timeb_s.h" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/sys/timeb.h" 1 3
#11 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/sys/timeb_s.h" 2 3


extern "C" {




  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ftime_s(struct __timeb32 *_Time);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ftime64_s(struct __timeb64 *_Time);







}
#125 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/sys/timeb.h" 2 3
#71 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 2 3

#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/pthread_compat.h" 1 3
#73 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 2 3


extern "C" {
#160 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 3
void * pthread_timechange_handler_np(void * dummy);
int pthread_delay_np (const struct timespec *interval);
int pthread_num_processors_np(void);
int pthread_set_num_processors_np(int n);
#180 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 3
typedef long pthread_once_t;
typedef unsigned pthread_mutexattr_t;
typedef unsigned pthread_key_t;
typedef void *pthread_barrierattr_t;
typedef int pthread_condattr_t;
typedef int pthread_rwlockattr_t;
#196 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 3
typedef uintptr_t pthread_t;

typedef struct _pthread_cleanup _pthread_cleanup;
struct _pthread_cleanup
{
    void (*func)(void *);
    void *arg;
    _pthread_cleanup *next;
};
#239 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 3
struct sched_param {
  int sched_priority;
};

int sched_yield(void);
int sched_get_priority_min(int pol);
int sched_get_priority_max(int pol);
int sched_getscheduler(pid_t pid);
int sched_setscheduler(pid_t pid, int pol, const struct sched_param *param);



typedef struct pthread_attr_t pthread_attr_t;
struct pthread_attr_t
{
    unsigned p_state;
    void *stack;
    size_t s_size;
    struct sched_param param;
};

int pthread_attr_setschedparam(pthread_attr_t *attr, const struct sched_param *param);
int pthread_attr_getschedparam(const pthread_attr_t *attr, struct sched_param *param);
int pthread_getschedparam(pthread_t thread, int *pol, struct sched_param *param);
int pthread_setschedparam(pthread_t thread, int pol, const struct sched_param *param);
int pthread_attr_setschedpolicy (pthread_attr_t *attr, int pol);
int pthread_attr_getschedpolicy (pthread_attr_t *attr, int *pol);


typedef void *pthread_spinlock_t;
typedef void *pthread_mutex_t;
typedef void *pthread_cond_t;
typedef void *pthread_rwlock_t;
typedef void *pthread_barrier_t;
#291 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 3
extern void (**_pthread_key_dest)(void *);
int pthread_key_create(pthread_key_t *key, void (* dest)(void *));
int pthread_key_delete(pthread_key_t key);
void * pthread_getspecific(pthread_key_t key);
int pthread_setspecific(pthread_key_t key, const void *value);

pthread_t pthread_self(void);
int pthread_once(pthread_once_t *o, void (*func)(void));
void pthread_testcancel(void);
int pthread_equal(pthread_t t1, pthread_t t2);
void pthread_tls_init(void);
void _pthread_cleanup_dest(pthread_t t);
int pthread_get_concurrency(int *val);
int pthread_set_concurrency(int val);
void pthread_exit(void *res);
void _pthread_invoke_cancel(void);
int pthread_cancel(pthread_t t);
int pthread_kill(pthread_t t, int sig);
unsigned _pthread_get_state(const pthread_attr_t *attr, unsigned flag);
int _pthread_set_state(pthread_attr_t *attr, unsigned flag, unsigned val);
int pthread_setcancelstate(int state, int *oldstate);
int pthread_setcanceltype(int type, int *oldtype);
int pthread_create_wrapper(void *args);
int pthread_create(pthread_t *th, const pthread_attr_t *attr, void *(* func)(void *), void *arg);
int pthread_join(pthread_t t, void **res);
int pthread_detach(pthread_t t);
int pthread_setname_np(pthread_t thread, const char *name);
int pthread_getname_np(pthread_t thread, char *name, size_t len);


int pthread_rwlock_init(pthread_rwlock_t *rwlock_, const pthread_rwlockattr_t *attr);
int pthread_rwlock_wrlock(pthread_rwlock_t *l);
int pthread_rwlock_timedwrlock(pthread_rwlock_t *rwlock, const struct timespec *ts);
int pthread_rwlock_rdlock(pthread_rwlock_t *l);
int pthread_rwlock_timedrdlock(pthread_rwlock_t *l, const struct timespec *ts);
int pthread_rwlock_unlock(pthread_rwlock_t *l);
int pthread_rwlock_tryrdlock(pthread_rwlock_t *l);
int pthread_rwlock_trywrlock(pthread_rwlock_t *l);
int pthread_rwlock_destroy (pthread_rwlock_t *l);

int pthread_cond_init(pthread_cond_t *cv, const pthread_condattr_t *a);
int pthread_cond_destroy(pthread_cond_t *cv);
int pthread_cond_signal (pthread_cond_t *cv);
int pthread_cond_broadcast (pthread_cond_t *cv);
int pthread_cond_wait (pthread_cond_t *cv, pthread_mutex_t *external_mutex);
int pthread_cond_timedwait(pthread_cond_t *cv, pthread_mutex_t *external_mutex, const struct timespec *t);
int pthread_cond_timedwait_relative_np(pthread_cond_t *cv, pthread_mutex_t *external_mutex, const struct timespec *t);

int pthread_mutex_lock(pthread_mutex_t *m);
int pthread_mutex_timedlock(pthread_mutex_t *m, const struct timespec *ts);
int pthread_mutex_unlock(pthread_mutex_t *m);
int pthread_mutex_trylock(pthread_mutex_t *m);
int pthread_mutex_init(pthread_mutex_t *m, const pthread_mutexattr_t *a);
int pthread_mutex_destroy(pthread_mutex_t *m);

int pthread_barrier_destroy(pthread_barrier_t *b);
int pthread_barrier_init(pthread_barrier_t *b, const void *attr, unsigned int count);
int pthread_barrier_wait(pthread_barrier_t *b);

int pthread_spin_init(pthread_spinlock_t *l, int pshared);
int pthread_spin_destroy(pthread_spinlock_t *l);

int pthread_spin_lock(pthread_spinlock_t *l);
int pthread_spin_trylock(pthread_spinlock_t *l);
int pthread_spin_unlock(pthread_spinlock_t *l);

int pthread_attr_init(pthread_attr_t *attr);
int pthread_attr_destroy(pthread_attr_t *attr);
int pthread_attr_setdetachstate(pthread_attr_t *a, int flag);
int pthread_attr_getdetachstate(const pthread_attr_t *a, int *flag);
int pthread_attr_setinheritsched(pthread_attr_t *a, int flag);
int pthread_attr_getinheritsched(const pthread_attr_t *a, int *flag);
int pthread_attr_setscope(pthread_attr_t *a, int flag);
int pthread_attr_getscope(const pthread_attr_t *a, int *flag);
int pthread_attr_getstackaddr(pthread_attr_t *attr, void **stack);
int pthread_attr_setstackaddr(pthread_attr_t *attr, void *stack);
int pthread_attr_getstacksize(const pthread_attr_t *attr, size_t *size);
int pthread_attr_setstacksize(pthread_attr_t *attr, size_t size);

int pthread_mutexattr_init(pthread_mutexattr_t *a);
int pthread_mutexattr_destroy(pthread_mutexattr_t *a);
int pthread_mutexattr_gettype(const pthread_mutexattr_t *a, int *type);
int pthread_mutexattr_settype(pthread_mutexattr_t *a, int type);
int pthread_mutexattr_getpshared(const pthread_mutexattr_t *a, int *type);
int pthread_mutexattr_setpshared(pthread_mutexattr_t * a, int type);
int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *a, int *type);
int pthread_mutexattr_setprotocol(pthread_mutexattr_t *a, int type);
int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *a, int * prio);
int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *a, int prio);
int pthread_getconcurrency(void);
int pthread_setconcurrency(int new_level);

int pthread_condattr_destroy(pthread_condattr_t *a);
int pthread_condattr_init(pthread_condattr_t *a);
int pthread_condattr_getpshared(const pthread_condattr_t *a, int *s);
int pthread_condattr_setpshared(pthread_condattr_t *a, int s);


typedef int clockid_t;



int pthread_condattr_getclock (const pthread_condattr_t *attr,
       clockid_t *clock_id);
int pthread_condattr_setclock(pthread_condattr_t *attr,
       clockid_t clock_id);
int __pthread_clock_nanosleep(clockid_t clock_id, int flags, const struct timespec *rqtp, struct timespec *rmtp);

int pthread_barrierattr_init(void **attr);
int pthread_barrierattr_destroy(void **attr);
int pthread_barrierattr_setpshared(void **attr, int s);
int pthread_barrierattr_getpshared(void **attr, int *s);


struct _pthread_cleanup ** pthread_getclean (void);
void * pthread_gethandle (pthread_t t);
void * pthread_getevent ();

unsigned long long _pthread_rel_time_in_ms(const struct timespec *ts);
unsigned long long _pthread_time_in_ms(void);
unsigned long long _pthread_time_in_ms_from_timespec(const struct timespec *ts);
int _pthread_tryjoin (pthread_t t, void **res);
int pthread_rwlockattr_destroy(pthread_rwlockattr_t *a);
int pthread_rwlockattr_getpshared(pthread_rwlockattr_t *a, int *s);
int pthread_rwlockattr_init(pthread_rwlockattr_t *a);
int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *a, int s);
#428 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/pthread_unistd.h" 1 3
#429 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 2 3
#689 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 3
}
#36 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/gthr-default.h" 2 3
#47 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/gthr-default.h" 3
typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
#101 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/gthr-default.h" 3



































#298 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
  return 1;
}
#658 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/gthr-default.h" 3
static inline int
__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),
    void *__args)
{
  return pthread_create (__threadid, __null, __func, __args);
}

static inline int
__gthread_join (__gthread_t __threadid, void **__value_ptr)
{
  return pthread_join (__threadid, __value_ptr);
}

static inline int
__gthread_detach (__gthread_t __threadid)
{
  return pthread_detach (__threadid);
}

static inline int
__gthread_equal (__gthread_t __t1, __gthread_t __t2)
{
  return pthread_equal (__t1, __t2);
}

static inline __gthread_t
__gthread_self (void)
{
  return pthread_self ();
}

static inline int
__gthread_yield (void)
{
  return sched_yield ();
}

static inline int
__gthread_once (__gthread_once_t *__once, void (*__func) (void))
{
  if (__gthread_active_p ())
    return pthread_once (__once, __func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
{
  return pthread_key_create (__key, __dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t __key)
{
  return pthread_key_delete (__key);
}

static inline void *
__gthread_getspecific (__gthread_key_t __key)
{
  return pthread_getspecific (__key);
}

static inline int
__gthread_setspecific (__gthread_key_t __key, const void *__ptr)
{
  return pthread_setspecific (__key, __ptr);
}

static inline void
__gthread_mutex_init_function (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    pthread_mutex_init (__mutex, __null);
}

static inline int
__gthread_mutex_destroy (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_destroy (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_lock (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_trylock (__mutex);
  else
    return 0;
}


static inline int
__gthread_mutex_timedlock (__gthread_mutex_t *__mutex,
      const __gthread_time_t *__abs_timeout)
{
  if (__gthread_active_p ())
    return pthread_mutex_timedlock (__mutex, __abs_timeout);
  else
    return 0;
}


static inline int
__gthread_mutex_unlock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_unlock (__mutex);
  else
    return 0;
}



static inline int
__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    {
      pthread_mutexattr_t __attr;
      int __r;

      __r = pthread_mutexattr_init (&__attr);
      if (!__r)
 __r = pthread_mutexattr_settype (&__attr,
         2);
      if (!__r)
 __r = pthread_mutex_init (__mutex, &__attr);
      if (!__r)
 __r = pthread_mutexattr_destroy (&__attr);
      return __r;
    }
  return 0;
}


static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_lock (__mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_trylock (__mutex);
}


static inline int
__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *__mutex,
         const __gthread_time_t *__abs_timeout)
{
  return __gthread_mutex_timedlock (__mutex, __abs_timeout);
}


static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_unlock (__mutex);
}

static inline int
__gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_destroy (__mutex);
}
#849 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/gthr-default.h" 3
static inline int
__gthread_cond_broadcast (__gthread_cond_t *__cond)
{
  return pthread_cond_broadcast (__cond);
}

static inline int
__gthread_cond_signal (__gthread_cond_t *__cond)
{
  return pthread_cond_signal (__cond);
}

static inline int
__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)
{
  return pthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
     const __gthread_time_t *__abs_timeout)
{
  return pthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_wait_recursive (__gthread_cond_t *__cond,
          __gthread_recursive_mutex_t *__mutex)
{
  return __gthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_destroy (__gthread_cond_t* __cond)
{
  return pthread_cond_destroy (__cond);
}
#149 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/gthr.h" 2 3


#pragma GCC visibility pop
#36 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ext/atomicity.h" 2 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/atomic_word.h" 1 3
#32 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/atomic_word.h" 3
typedef int _Atomic_word;
#37 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ext/atomicity.h" 2 3

namespace __gnu_cxx
{







  static inline _Atomic_word
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, 4); }

  static inline void
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __atomic_fetch_add(__mem, __val, 4); }
#64 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ext/atomicity.h" 3
  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  static inline void
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);



  }

  static inline void
  __attribute__ ((__unused__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      __atomic_add(__mem, __val);
    else
      __atomic_add_single(__mem, __val);



  }


}
#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 2 3

#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 1 3
#37 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3

#38 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3


#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/string" 1 3
#36 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/string" 3

#37 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/string" 3




#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/allocator.h" 1 3
#46 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/allocator.h" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++allocator.h" 1 3
#33 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++allocator.h" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ext/new_allocator.h" 1 3
#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ext/new_allocator.h" 3
namespace __gnu_cxx
{


  using std::size_t;
  using std::ptrdiff_t;
#57 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };




      typedef std::true_type propagate_on_container_move_assignment;


      new_allocator() noexcept { }

      new_allocator(const new_allocator&) noexcept { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) noexcept { }

      ~new_allocator() noexcept { }

      pointer
      address(reference __x) const noexcept
      { return std::__addressof(__x); }

      const_pointer
      address(const_reference __x) const noexcept
      { return std::__addressof(__x); }



      pointer
      allocate(size_type __n, const void* = 0)
      {
 if (__n > this->max_size())
   std::__throw_bad_alloc();

 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }

      size_type
      max_size() const noexcept
      { return size_t(-1) / sizeof(_Tp); }


      template<typename _Up, typename... _Args>
        void
        construct(_Up* __p, _Args&&... __args)
 { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }

      template<typename _Up>
        void
        destroy(_Up* __p) { __p->~_Up(); }
#135 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ext/new_allocator.h" 3
    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }


}
#34 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++allocator.h" 2 3


namespace std
{
#47 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++allocator.h" 3
  template<typename _Tp>
    using __allocator_base = __gnu_cxx::new_allocator<_Tp>;
}
#47 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/allocator.h" 2 3







namespace std
{








  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };




      typedef true_type propagate_on_container_move_assignment;


      typedef true_type is_always_equal;

    };
#96 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/allocator.h" 3
  template<typename _Tp>
    class allocator: public __allocator_base<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };




      typedef true_type propagate_on_container_move_assignment;


      allocator() throw() { }

      allocator(const allocator& __a) throw()
      : __allocator_base<_Tp>(__a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }


    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    noexcept
    { return true; }

  template<typename _Tp>
    inline bool
    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
    noexcept
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    noexcept
    { return false; }

  template<typename _Tp>
    inline bool
    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
    noexcept
    { return false; }






  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) noexcept { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two) noexcept
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };


  template<typename _Tp, bool
    = __or_<is_copy_constructible<typename _Tp::value_type>,
            is_nothrow_move_constructible<typename _Tp::value_type>>::value>
    struct __shrink_to_fit_aux
    { static bool _S_do_it(_Tp&) noexcept { return false; } };

  template<typename _Tp>
    struct __shrink_to_fit_aux<_Tp, true>
    {
      static bool
      _S_do_it(_Tp& __c) noexcept
      {

 try
   {
     _Tp(__make_move_if_noexcept_iterator(__c.begin()),
  __make_move_if_noexcept_iterator(__c.end()),
  __c.get_allocator()).swap(__c);
     return true;
   }
 catch(...)
   { return false; }



      }
    };



}
#42 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/string" 2 3


#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/ostream_insert.h" 1 3
#33 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/ostream_insert.h" 3

#34 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/ostream_insert.h" 3


#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/cxxabi_forced.h" 1 3
#34 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/cxxabi_forced.h" 3

#35 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/cxxabi_forced.h" 3

#pragma GCC visibility push(default)


namespace __cxxabiv1
{







  class __forced_unwind
  {
    virtual ~__forced_unwind() throw();


    virtual void __pure_dummy() = 0;
  };
}


#pragma GCC visibility pop
#37 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/ostream_insert.h" 2 3

namespace std
{


  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }




  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);


  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);




}
#45 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/string" 2 3



#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_function.h" 1 3
#63 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_function.h" 3
namespace std
{

#104 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    struct unary_function
    {

      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {

      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;


      typedef _Result result_type;
    };
#144 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_function.h" 3
  struct __is_transparent;

  template<typename _Tp = void>
    struct plus;

  template<typename _Tp = void>
    struct minus;

  template<typename _Tp = void>
    struct multiplies;

  template<typename _Tp = void>
    struct divides;

  template<typename _Tp = void>
    struct modulus;

  template<typename _Tp = void>
    struct negate;



  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };





  template<>
    struct plus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) + std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) + std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) + std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct minus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) - std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) - std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) - std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct multiplies<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) * std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) * std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) * std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct divides<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) / std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) / std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) / std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct modulus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) % std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) % std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) % std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct negate<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(-std::forward<_Tp>(__t)))
 -> decltype(-std::forward<_Tp>(__t))
 { return -std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };
#330 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_function.h" 3
  template<typename _Tp = void>
    struct equal_to;

  template<typename _Tp = void>
    struct not_equal_to;

  template<typename _Tp = void>
    struct greater;

  template<typename _Tp = void>
    struct less;

  template<typename _Tp = void>
    struct greater_equal;

  template<typename _Tp = void>
    struct less_equal;



  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };



  template<>
    struct equal_to<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) == std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) == std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct not_equal_to<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) != std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) != std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) != std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct greater<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) > std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) > std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) > std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct less<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) < std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) < std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) < std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct greater_equal<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) >= std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) >= std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) >= std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct less_equal<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) <= std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) <= std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) <= std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };
#512 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_function.h" 3
  template<typename _Tp = void>
    struct logical_and;

  template<typename _Tp = void>
    struct logical_or;

  template<typename _Tp = void>
    struct logical_not;



  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };



  template<>
    struct logical_and<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) && std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) && std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) && std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct logical_or<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) || std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) || std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) || std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct logical_not<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(!std::forward<_Tp>(__t)))
 -> decltype(!std::forward<_Tp>(__t))
 { return !std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };




  template<typename _Tp = void>
    struct bit_and;

  template<typename _Tp = void>
    struct bit_or;

  template<typename _Tp = void>
    struct bit_xor;

  template<typename _Tp = void>
    struct bit_not;




  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };

  template<typename _Tp>
    struct bit_not : public unary_function<_Tp, _Tp>
    {
    constexpr
      _Tp
      operator()(const _Tp& __x) const
      { return ~__x; }
    };


  template <>
    struct bit_and<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) & std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) & std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) & std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_or<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) | std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) | std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) | std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_xor<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) ^ std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_not<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(~std::forward<_Tp>(__t)))
 -> decltype(~std::forward<_Tp>(__t))
 { return ~std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };
#740 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_function.h" 3
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      constexpr
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

      constexpr
      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>
    constexpr
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      constexpr
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

      constexpr
      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>
    constexpr
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
#817 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity
    : public unary_function<_Tp,_Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };

  template<typename _Pair>
    struct _Select1st
    : public unary_function<_Pair, typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }


      template<typename _Pair2>
        typename _Pair2::first_type&
        operator()(_Pair2& __x) const
        { return __x.first; }

      template<typename _Pair2>
        const typename _Pair2::first_type&
        operator()(const _Pair2& __x) const
        { return __x.first; }

    };

  template<typename _Pair>
    struct _Select2nd
    : public unary_function<_Pair, typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
#937 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
  };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }




}


#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/backward/binders.h" 1 3
#60 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/backward/binders.h" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

namespace std
{

#107 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/backward/binders.h" 3
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }



}

#pragma GCC diagnostic pop
#1128 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stl_function.h" 2 3
#49 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/string" 2 3


#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/range_access.h" 1 3
#33 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/range_access.h" 3

#34 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/range_access.h" 3



namespace std
{







  template<typename _Container>
    inline auto
    begin(_Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    inline auto
    begin(const _Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    inline auto
    end(_Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }






  template<typename _Container>
    inline auto
    end(const _Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }





  template<typename _Tp, size_t _Nm>
    inline constexpr _Tp*
    begin(_Tp (&__arr)[_Nm])
    { return __arr; }






  template<typename _Tp, size_t _Nm>
    inline constexpr _Tp*
    end(_Tp (&__arr)[_Nm])
    { return __arr + _Nm; }



  template<typename _Tp> class valarray;

  template<typename _Tp> _Tp* begin(valarray<_Tp>&);
  template<typename _Tp> const _Tp* begin(const valarray<_Tp>&);
  template<typename _Tp> _Tp* end(valarray<_Tp>&);
  template<typename _Tp> const _Tp* end(const valarray<_Tp>&);






  template<typename _Container>
    inline constexpr auto
    cbegin(const _Container& __cont) noexcept(noexcept(std::begin(__cont)))
      -> decltype(std::begin(__cont))
    { return std::begin(__cont); }






  template<typename _Container>
    inline constexpr auto
    cend(const _Container& __cont) noexcept(noexcept(std::end(__cont)))
      -> decltype(std::end(__cont))
    { return std::end(__cont); }






  template<typename _Container>
    inline auto
    rbegin(_Container& __cont) -> decltype(__cont.rbegin())
    { return __cont.rbegin(); }






  template<typename _Container>
    inline auto
    rbegin(const _Container& __cont) -> decltype(__cont.rbegin())
    { return __cont.rbegin(); }






  template<typename _Container>
    inline auto
    rend(_Container& __cont) -> decltype(__cont.rend())
    { return __cont.rend(); }






  template<typename _Container>
    inline auto
    rend(const _Container& __cont) -> decltype(__cont.rend())
    { return __cont.rend(); }






  template<typename _Tp, size_t _Nm>
    inline reverse_iterator<_Tp*>
    rbegin(_Tp (&__arr)[_Nm])
    { return reverse_iterator<_Tp*>(__arr + _Nm); }






  template<typename _Tp, size_t _Nm>
    inline reverse_iterator<_Tp*>
    rend(_Tp (&__arr)[_Nm])
    { return reverse_iterator<_Tp*>(__arr); }






  template<typename _Tp>
    inline reverse_iterator<const _Tp*>
    rbegin(initializer_list<_Tp> __il)
    { return reverse_iterator<const _Tp*>(__il.end()); }






  template<typename _Tp>
    inline reverse_iterator<const _Tp*>
    rend(initializer_list<_Tp> __il)
    { return reverse_iterator<const _Tp*>(__il.begin()); }






  template<typename _Container>
    inline auto
    crbegin(const _Container& __cont) -> decltype(std::rbegin(__cont))
    { return std::rbegin(__cont); }






  template<typename _Container>
    inline auto
    crend(const _Container& __cont) -> decltype(std::rend(__cont))
    { return std::rend(__cont); }
#319 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/range_access.h" 3

}
#52 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/string" 2 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 1 3
#37 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3

#38 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
#47 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
namespace std
{



namespace __cxx11 {
#71 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_CharT>::other _Char_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;


    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Char_alloc_type allocator_type;
      typedef typename _Alloc_traits::size_type size_type;
      typedef typename _Alloc_traits::difference_type difference_type;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
       const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;


      static const size_type npos = static_cast<size_type>(-1);

    private:




      typedef const_iterator __const_iterator;



      struct _Alloc_hider : allocator_type
      {
 _Alloc_hider(pointer __dat, const _Alloc& __a = _Alloc())
 : allocator_type(__a), _M_p(__dat) { }

 pointer _M_p;
      };

      _Alloc_hider _M_dataplus;
      size_type _M_string_length;

      enum { _S_local_capacity = 15 / sizeof(_CharT) };

      union
      {
 _CharT _M_local_buf[_S_local_capacity + 1];
 size_type _M_allocated_capacity;
      };

      void
      _M_data(pointer __p)
      { _M_dataplus._M_p = __p; }

      void
      _M_length(size_type __length)
      { _M_string_length = __length; }

      pointer
      _M_data() const
      { return _M_dataplus._M_p; }

      pointer
      _M_local_data()
      {

 return std::pointer_traits<pointer>::pointer_to(*_M_local_buf);



      }

      const_pointer
      _M_local_data() const
      {

 return std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);



      }

      void
      _M_capacity(size_type __capacity)
      { _M_allocated_capacity = __capacity; }

      void
      _M_set_length(size_type __n)
      {
 _M_length(__n);
 traits_type::assign(_M_data()[__n], _CharT());
      }

      bool
      _M_is_local() const
      { return _M_data() == _M_local_data(); }


      pointer
      _M_create(size_type&, size_type);

      void
      _M_dispose()
      {
 if (!_M_is_local())
   _M_destroy(_M_allocated_capacity);
      }

      void
      _M_destroy(size_type __size) throw()
      { _Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1); }



      template<typename _InIterator>
        void
        _M_construct_aux(_InIterator __beg, _InIterator __end,
    std::__false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          _M_construct(__beg, __end, _Tag());
 }



      template<typename _Integer>
        void
        _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type)
 { _M_construct_aux_2(static_cast<size_type>(__beg), __end); }

      void
      _M_construct_aux_2(size_type __req, _CharT __c)
      { _M_construct(__req, __c); }

      template<typename _InIterator>
        void
        _M_construct(_InIterator __beg, _InIterator __end)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   _M_construct_aux(__beg, __end, _Integral());
        }


      template<typename _InIterator>
        void
        _M_construct(_InIterator __beg, _InIterator __end,
       std::input_iterator_tag);



      template<typename _FwdIterator>
        void
        _M_construct(_FwdIterator __beg, _FwdIterator __end,
       std::forward_iterator_tag);

      void
      _M_construct(size_type __req, _CharT __c);

      allocator_type&
      _M_get_allocator()
      { return _M_dataplus; }

      const allocator_type&
      _M_get_allocator() const
      { return _M_dataplus; }

    private:
#258 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range_fmt(("%s: __pos (which is %zu) > " "this->size() (which is %zu)")
                                         ,
       __s, __pos, this->size());
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }



      size_type
      _M_limit(size_type __pos, size_type __off) const noexcept
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


      bool
      _M_disjunct(const _CharT* __s) const noexcept
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      static void
      _S_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _S_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _S_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, (void)++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2) noexcept
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      noexcept
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2) noexcept
      { _S_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      noexcept
      { _S_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) noexcept
      {
 const difference_type __d = difference_type(__n1 - __n2);

 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }

      void
      _M_assign(const basic_string& __rcs);

      void
      _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
  size_type __len2);

      void
      _M_erase(size_type __pos, size_type __n);

    public:







      basic_string()
      noexcept(is_nothrow_default_constructible<_Alloc>::value)
      : _M_dataplus(_M_local_data())
      { _M_set_length(0); }




      explicit
      basic_string(const _Alloc& __a) noexcept
      : _M_dataplus(_M_local_data(), __a)
      { _M_set_length(0); }





      basic_string(const basic_string& __str)
      : _M_dataplus(_M_local_data(),
      _Alloc_traits::_S_select_on_copy(__str._M_get_allocator()))
      { _M_construct(__str._M_data(), __str._M_data() + __str.length()); }
#410 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string(const basic_string& __str, size_type __pos,
     size_type __n = npos)
      : _M_dataplus(_M_local_data())
      {
 const _CharT* __start = __str._M_data()
   + __str._M_check(__pos, "basic_string::basic_string");
 _M_construct(__start, __start + __str._M_limit(__pos, __n));
      }
#426 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      {
 const _CharT* __start
   = __str._M_data() + __str._M_check(__pos, "string::string");
 _M_construct(__start, __start + __str._M_limit(__pos, __n));
      }
#444 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__s, __s + __n); }






      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__s, __s ? __s + traits_type::length(__s) : __s+npos); }







      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__n, __c); }
#476 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string(basic_string&& __str) noexcept
      : _M_dataplus(_M_local_data(), std::move(__str._M_get_allocator()))
      {
 if (__str._M_is_local())
   {
     traits_type::copy(_M_local_buf, __str._M_local_buf,
         _S_local_capacity + 1);
   }
 else
   {
     _M_data(__str._M_data());
     _M_capacity(__str._M_allocated_capacity);
   }




 _M_length(__str.length());
 __str._M_data(__str._M_local_data());
 __str._M_set_length(0);
      }






      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__l.begin(), __l.end()); }

      basic_string(const basic_string& __str, const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__str.begin(), __str.end()); }

      basic_string(basic_string&& __str, const _Alloc& __a)
      noexcept(_Alloc_traits::_S_always_equal())
      : _M_dataplus(_M_local_data(), __a)
      {
 if (__str._M_is_local())
   {
     traits_type::copy(_M_local_buf, __str._M_local_buf,
         _S_local_capacity + 1);
     _M_length(__str.length());
     __str._M_set_length(0);
   }
 else if (_Alloc_traits::_S_always_equal()
     || __str.get_allocator() == __a)
   {
     _M_data(__str._M_data());
     _M_length(__str.length());
     _M_capacity(__str._M_allocated_capacity);
     __str._M_data(__str._M_local_buf);
     __str._M_set_length(0);
   }
 else
   _M_construct(__str.begin(), __str.end());
      }
#544 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc())
 : _M_dataplus(_M_local_data(), __a)
 { _M_construct(__beg, __end); }




      ~basic_string()
      { _M_dispose(); }





      basic_string&
      operator=(const basic_string& __str)
      {

 if (_Alloc_traits::_S_propagate_on_copy_assign())
   {
     if (!_Alloc_traits::_S_always_equal() && !_M_is_local()
  && _M_get_allocator() != __str._M_get_allocator())
       {

  _M_destroy(_M_allocated_capacity);
  _M_data(_M_local_data());
  _M_set_length(0);
       }
     std::__alloc_on_copy(_M_get_allocator(), __str._M_get_allocator());
   }

 return this->assign(__str);
      }





      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
#599 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }
#617 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      operator=(basic_string&& __str)
      noexcept(_Alloc_traits::_S_nothrow_move())
      {
 if (!_M_is_local() && _Alloc_traits::_S_propagate_on_move_assign()
     && !_Alloc_traits::_S_always_equal()
     && _M_get_allocator() != __str._M_get_allocator())
   {

     _M_destroy(_M_allocated_capacity);
     _M_data(_M_local_data());
     _M_set_length(0);
   }

 std::__alloc_on_move(_M_get_allocator(), __str._M_get_allocator());

 if (!__str._M_is_local()
     && (_Alloc_traits::_S_propagate_on_move_assign()
       || _Alloc_traits::_S_always_equal()))
   {
     pointer __data = nullptr;
     size_type __capacity;
     if (!_M_is_local())
       {
  if (_Alloc_traits::_S_always_equal())
    {
      __data = _M_data();
      __capacity = _M_allocated_capacity;
    }
  else
    _M_destroy(_M_allocated_capacity);
       }

     _M_data(__str._M_data());
     _M_length(__str.length());
     _M_capacity(__str._M_allocated_capacity);
     if (__data)
       {
  __str._M_data(__data);
  __str._M_capacity(__capacity);
       }
     else
       __str._M_data(__str._M_local_buf);
   }
 else
     assign(__str);
 __str.clear();
 return *this;
      }





      basic_string&
      operator=(initializer_list<_CharT> __l)
      {
 this->assign(__l.begin(), __l.size());
 return *this;
      }







      iterator
      begin() noexcept
      { return iterator(_M_data()); }





      const_iterator
      begin() const noexcept
      { return const_iterator(_M_data()); }





      iterator
      end() noexcept
      { return iterator(_M_data() + this->size()); }





      const_iterator
      end() const noexcept
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(this->begin()); }






      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_data()); }





      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_data() + this->size()); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(this->begin()); }


    public:



      size_type
      size() const noexcept
      { return _M_string_length; }



      size_type
      length() const noexcept
      { return _M_string_length; }


      size_type
      max_size() const noexcept
      { return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2; }
#813 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
#826 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }



      void
      shrink_to_fit() noexcept
      {

 if (capacity() > size())
   {
     try
       { reserve(0); }
     catch(...)
       { }
   }

      }






      size_type
      capacity() const noexcept
      {
 return _M_is_local() ? size_type(_S_local_capacity)
                      : _M_allocated_capacity;
      }
#875 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      void
      reserve(size_type __res_arg = 0);




      void
      clear() noexcept
      { _M_set_length(0); }





      bool
      empty() const noexcept
      { return this->size() == 0; }
#904 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const noexcept
      {
 ;
 return _M_data()[__pos];
      }
#921 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {


 ;

 ;
 return _M_data()[__pos];
      }
#942 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
 return _M_data()[__n];
      }
#963 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range_fmt(("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
 return _M_data()[__n];
      }






      reference
      front() noexcept
      {
 ;
 return operator[](0);
      }





      const_reference
      front() const noexcept
      {
 ;
 return operator[](0);
      }





      reference
      back() noexcept
      {
 ;
 return operator[](this->size() - 1);
      }





      const_reference
      back() const noexcept
      {
 ;
 return operator[](this->size() - 1);
      }
#1026 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }







      basic_string&
      operator+=(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }







      basic_string&
      append(const basic_string& __str)
      { return _M_append(__str._M_data(), __str.size()); }
#1084 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n)
      { return _M_append(__str._M_data()
    + __str._M_check(__pos, "basic_string::append"),
    __str._M_limit(__pos, __n)); }







      basic_string&
      append(const _CharT* __s, size_type __n)
      {
 ;
 _M_check_length(size_type(0), __n, "basic_string::append");
 return _M_append(__s, __n);
      }






      basic_string&
      append(const _CharT* __s)
      {
 ;
 const size_type __n = traits_type::length(__s);
 _M_check_length(size_type(0), __n, "basic_string::append");
 return _M_append(__s, __n);
      }
#1126 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c)
      { return _M_replace_aux(this->size(), size_type(0), __n, __c); }







      basic_string&
      append(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
#1150 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(end(), end(), __first, __last); }





      void
      push_back(_CharT __c)
      {
 const size_type __size = this->size();
 if (__size + 1 > this->capacity())
   this->_M_mutate(__size, size_type(0), 0, size_type(1));
 traits_type::assign(this->_M_data()[__size], __c);
 this->_M_set_length(__size + 1);
      }






      basic_string&
      assign(const basic_string& __str)
      {
 this->_M_assign(__str);
 return *this;
      }
#1194 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      assign(basic_string&& __str)
      noexcept(_Alloc_traits::_S_nothrow_move())
      {


 return *this = std::move(__str);
      }
#1217 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n)
      { return _M_replace(size_type(0), this->size(), __str._M_data()
     + __str._M_check(__pos, "basic_string::assign"),
     __str._M_limit(__pos, __n)); }
#1233 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n)
      {
 ;
 return _M_replace(size_type(0), this->size(), __s, __n);
      }
#1249 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
 ;
 return _M_replace(size_type(0), this->size(), __s,
     traits_type::length(__s));
      }
#1266 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
#1279 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(begin(), end(), __first, __last); }







      basic_string&
      assign(initializer_list<_CharT> __l)
      { return this->assign(__l.begin(), __l.size()); }
#1315 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      iterator
      insert(const_iterator __p, size_type __n, _CharT __c)
      {
 ;
 const size_type __pos = __p - begin();
 this->replace(__p, __p, __n, __c);
 return iterator(this->_M_data() + __pos);
      }
#1357 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
        insert(const_iterator __p, _InputIterator __beg, _InputIterator __end)
        {
   ;
   const size_type __pos = __p - begin();
   this->replace(__p, __p, __beg, __end);
   return iterator(this->_M_data() + __pos);
 }
#1393 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      void
      insert(iterator __p, initializer_list<_CharT> __l)
      {
 ;
 this->insert(__p - begin(), __l.begin(), __l.size());
      }
#1413 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->replace(__pos1, size_type(0),
        __str._M_data(), __str.size()); }
#1436 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n)
      { return this->replace(__pos1, size_type(0), __str._M_data()
        + __str._M_check(__pos2, "basic_string::insert"),
        __str._M_limit(__pos2, __n)); }
#1459 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n)
      { return this->replace(__pos, size_type(0), __s, __n); }
#1478 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
 ;
 return this->replace(__pos, size_type(0), __s,
        traits_type::length(__s));
      }
#1502 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
#1520 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      iterator
      insert(__const_iterator __p, _CharT __c)
      {
 ;
 const size_type __pos = __p - begin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 return iterator(_M_data() + __pos);
      }
#1544 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 this->_M_erase(_M_check(__pos, "basic_string::erase"),
         _M_limit(__pos, __n));
 return *this;
      }
#1560 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      iterator
      erase(__const_iterator __position)
      {

                           ;
 const size_type __pos = __position - begin();
 this->_M_erase(__pos, size_type(1));
 return iterator(_M_data() + __pos);
      }
#1579 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      iterator
      erase(__const_iterator __first, __const_iterator __last)
      {

                        ;
        const size_type __pos = __first - begin();
 this->_M_erase(__pos, __last - __first);
 return iterator(this->_M_data() + __pos);
      }







      void
      pop_back() noexcept
      {
 ;
 _M_erase(size() - 1, 1);
      }
#1620 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
#1642 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
#1667 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2)
      {
 ;
 return _M_replace(_M_check(__pos, "basic_string::replace"),
     _M_limit(__pos, __n1), __s, __n2);
      }
#1692 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
 ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
#1716 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
#1734 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
#1754 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const _CharT* __s, size_type __n)
      {

                      ;
 return this->replace(__i1 - begin(), __i2 - __i1, __s, __n);
      }
#1776 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2, const _CharT* __s)
      {
 ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
#1797 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2, size_type __n,
       _CharT __c)
      {

                      ;
 return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __c);
      }
#1822 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        basic_string&
        replace(const_iterator __i1, const_iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {

                        ;
   ;
   return this->_M_replace_dispatch(__i1, __i2, __k1, __k2,
        std::__false_type());
 }
#1854 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       _CharT* __k1, _CharT* __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       iterator __k1, iterator __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
#1913 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string& replace(const_iterator __i1, const_iterator __i2,
       initializer_list<_CharT> __l)
      { return this->replace(__i1, __i2, __l.begin(), __l.end()); }


    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
       _Integer __n, _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
       _InputIterator __k1, _InputIterator __k2,
       __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
   const size_type __len2);

      basic_string&
      _M_append(const _CharT* __s, size_type __n);

    public:
#1956 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
#1966 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      void
      swap(basic_string& __s) noexcept;
#1976 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      const _CharT*
      c_str() const noexcept
      { return _M_data(); }







      const _CharT*
      data() const noexcept
      { return _M_data(); }




      allocator_type
      get_allocator() const noexcept
      { return _M_get_allocator(); }
#2009 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;
#2022 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
 noexcept
      { return this->find(__str.data(), __pos, __str.size()); }
#2037 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
#2054 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const noexcept;
#2067 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
 noexcept
      { return this->rfind(__str.data(), __pos, __str.size()); }
#2084 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
#2097 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
#2114 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const noexcept;
#2128 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
 noexcept
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
#2145 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
#2158 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
#2177 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const noexcept
      { return this->find(__c, __pos); }
#2192 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
 noexcept
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
#2209 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
#2222 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
#2241 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const noexcept
      { return this->rfind(__c, __pos); }
#2255 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
 noexcept
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
#2272 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const;
#2286 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
#2303 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const
 noexcept;
#2318 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
 noexcept
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
#2335 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const;
#2349 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
#2366 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const
 noexcept;
#2382 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
#2401 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }
#2433 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
#2459 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2) const;
#2477 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const;
#2501 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
#2528 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;
  };
}
#4927 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    {
      const auto __size = __lhs.size() + __rhs.size();
      const bool __cond = (__size > __lhs.capacity()
      && __size <= __rhs.capacity());
      return __cond ? std::move(__rhs.insert(0, __lhs))
             : std::move(__lhs.append(__rhs));
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, 1, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const _CharT* __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       _CharT __rhs)
    { return std::move(__lhs.append(1, __rhs)); }
#5048 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
        const basic_string<_CharT>& __rhs) noexcept
    { return (__lhs.size() == __rhs.size()
       && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
          __lhs.size())); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
#5095 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return !(__lhs == __rhs); }
#5133 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
#5171 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
#5209 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
#5247 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
#5285 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept(noexcept(__lhs.swap(__rhs)))
    { __lhs.swap(__rhs); }
#5305 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
#5323 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {


      return __ostream_insert(__os, __str.data(), __str.size());
    }
#5346 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
#5363 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str, __is.widen('\n')); }



  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>&& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    { return std::getline(__is, __str, __delim); }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>&& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str); }


  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);



}



#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ext/string_conversions.h" 1 3
#32 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ext/string_conversions.h" 3

#33 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ext/string_conversions.h" 3
#41 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ext/string_conversions.h" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdlib" 1 3
#39 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdlib" 3

#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
#42 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ext/string_conversions.h" 2 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cwchar" 1 3
#39 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cwchar" 3

#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cwchar" 3
#43 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ext/string_conversions.h" 2 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdio" 1 3
#39 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdio" 3

#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdio" 3
#44 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ext/string_conversions.h" 2 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cerrno" 1 3
#39 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cerrno" 3

#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cerrno" 3
#45 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ext/string_conversions.h" 2 3

namespace __gnu_cxx
{



  template<typename _TRet, typename _Ret = _TRet, typename _CharT,
    typename... _Base>
    _Ret
    __stoa(_TRet (*__convf) (const _CharT*, _CharT**, _Base...),
    const char* __name, const _CharT* __str, std::size_t* __idx,
    _Base... __base)
    {
      _Ret __ret;

      _CharT* __endptr;

      struct _Save_errno {
 _Save_errno() : _M_errno((*_errno())) { (*_errno()) = 0; }
 ~_Save_errno() { if ((*_errno()) == 0) (*_errno()) = _M_errno; }
 int _M_errno;
      } const __save_errno;

      const _TRet __tmp = __convf(__str, &__endptr, __base...);

      if (__endptr == __str)
 std::__throw_invalid_argument(__name);
      else if ((*_errno()) == 34
        || (std::__are_same<_Ret, int>::__value
     && (__tmp < __numeric_traits<int>::__min
         || __tmp > __numeric_traits<int>::__max)))
 std::__throw_out_of_range(__name);
      else
 __ret = __tmp;

      if (__idx)
 *__idx = __endptr - __str;

      return __ret;
    }


  template<typename _String, typename _CharT = typename _String::value_type>
    _String
    __to_xstring(int (*__convf) (_CharT*, std::size_t, const _CharT*,
     __builtin_va_list), std::size_t __n,
   const _CharT* __fmt, ...)
    {


      _CharT* __s = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
         * __n));

      __builtin_va_list __args;
      __builtin_va_start(__args, __fmt);

      const int __len = __convf(__s, __n, __fmt, __args);

      __builtin_va_end(__args);

      return _String(__s, __s + __len);
    }


}
#5403 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 2 3

namespace std
{

namespace __cxx11 {



  inline int
  stoi(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::strtol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx); }






  inline string
  to_string(int __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(int),
        "%d", __val); }

  inline string
  to_string(unsigned __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned),
        "%u", __val); }

  inline string
  to_string(long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(long),
        "%ld", __val); }

  inline string
  to_string(unsigned long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned long),
        "%lu", __val); }

  inline string
  to_string(long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(long long),
        "%lld", __val); }

  inline string
  to_string(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned long long),
        "%llu", __val); }

  inline string
  to_string(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%Lf", __val);
  }



  inline int
  stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::wcstol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx); }



  inline wstring
  to_wstring(int __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(int),
         L"%d", __val); }

  inline wstring
  to_wstring(unsigned __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned),
         L"%u", __val); }

  inline wstring
  to_wstring(long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(long),
         L"%ld", __val); }

  inline wstring
  to_wstring(unsigned long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long),
         L"%lu", __val); }

  inline wstring
  to_wstring(long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(long long),
         L"%lld", __val); }

  inline wstring
  to_wstring(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long long),
         L"%llu", __val); }

  inline wstring
  to_wstring(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%Lf", __val);
  }



}

}





#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/functional_hash.h" 1 3
#33 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/functional_hash.h" 3

#34 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/functional_hash.h" 3

#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/hash_bytes.h" 1 3
#33 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/hash_bytes.h" 3

#34 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/hash_bytes.h" 3



namespace std
{







  size_t
  _Hash_bytes(const void* __ptr, size_t __len, size_t __seed);





  size_t
  _Fnv_hash_bytes(const void* __ptr, size_t __len, size_t __seed);


}
#36 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/functional_hash.h" 2 3

namespace std
{

#49 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/functional_hash.h" 3
  template<typename _Result, typename _Arg>
    struct __hash_base
    {
      typedef _Result result_type;
      typedef _Arg argument_type;
    };


  template<typename _Tp>
    struct hash;


  template<typename _Tp, bool = is_enum<_Tp>::value>
    struct __hash_enum
    {
    private:

      __hash_enum(__hash_enum&&);
      ~__hash_enum();
    };


  template<typename _Tp>
    struct __hash_enum<_Tp, true> : public __hash_base<size_t, _Tp>
    {
      size_t
      operator()(_Tp __val) const noexcept
      {
       using __type = typename underlying_type<_Tp>::type;
       return hash<__type>{}(static_cast<__type>(__val));
      }
    };



  template<typename _Tp>
    struct hash : __hash_enum<_Tp>
    { };


  template<typename _Tp>
    struct hash<_Tp*> : public __hash_base<size_t, _Tp*>
    {
      size_t
      operator()(_Tp* __p) const noexcept
      { return reinterpret_cast<size_t>(__p); }
    };
#108 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/functional_hash.h" 3
  template<> struct hash<bool> : public __hash_base<size_t, bool> { size_t operator()(bool __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char> : public __hash_base<size_t, char> { size_t operator()(char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<signed char> : public __hash_base<size_t, signed char> { size_t operator()(signed char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned char> : public __hash_base<size_t, unsigned char> { size_t operator()(unsigned char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<wchar_t> : public __hash_base<size_t, wchar_t> { size_t operator()(wchar_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char16_t> : public __hash_base<size_t, char16_t> { size_t operator()(char16_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char32_t> : public __hash_base<size_t, char32_t> { size_t operator()(char32_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<short> : public __hash_base<size_t, short> { size_t operator()(short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<int> : public __hash_base<size_t, int> { size_t operator()(int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long> : public __hash_base<size_t, long> { size_t operator()(long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long long> : public __hash_base<size_t, long long> { size_t operator()(long long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned short> : public __hash_base<size_t, unsigned short> { size_t operator()(unsigned short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned int> : public __hash_base<size_t, unsigned int> { size_t operator()(unsigned int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long> : public __hash_base<size_t, unsigned long> { size_t operator()(unsigned long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long long> : public __hash_base<size_t, unsigned long long> { size_t operator()(unsigned long long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<__int128> : public __hash_base<size_t, __int128> { size_t operator()(__int128 __val) const noexcept { return static_cast<size_t>(__val); } };
  template<> struct hash<__int128 unsigned> : public __hash_base<size_t, __int128 unsigned> { size_t operator()(__int128 unsigned __val) const noexcept { return static_cast<size_t>(__val); } };
#171 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/functional_hash.h" 3
  struct _Hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(0xc70f6907UL))
    { return _Hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };

  struct _Fnv_hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(2166136261UL))
    { return _Fnv_hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  template<>
    struct hash<float> : public __hash_base<size_t, float>
    {
      size_t
      operator()(float __val) const noexcept
      {

 return __val != 0.0f ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<double> : public __hash_base<size_t, double>
    {
      size_t
      operator()(double __val) const noexcept
      {

 return __val != 0.0 ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<long double>
    : public __hash_base<size_t, long double>
    {
      __attribute__ ((__pure__)) size_t
      operator()(long double __val) const noexcept;
    };







  template<typename _Hash>
    struct __is_fast_hash : public std::true_type
    { };

  template<>
    struct __is_fast_hash<hash<long double>> : public std::false_type
    { };


}
#5629 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 2 3

namespace std
{






  template<>
    struct hash<string>
    : public __hash_base<size_t, string>
    {
      size_t
      operator()(const string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(), __s.length()); }
    };

  template<>
    struct __is_fast_hash<hash<string>> : std::false_type
    { };



  template<>
    struct hash<wstring>
    : public __hash_base<size_t, wstring>
    {
      size_t
      operator()(const wstring& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(wchar_t)); }
    };

  template<>
    struct __is_fast_hash<hash<wstring>> : std::false_type
    { };





  template<>
    struct hash<u16string>
    : public __hash_base<size_t, u16string>
    {
      size_t
      operator()(const u16string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char16_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u16string>> : std::false_type
    { };


  template<>
    struct hash<u32string>
    : public __hash_base<size_t, u32string>
    {
      size_t
      operator()(const u32string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char32_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u32string>> : std::false_type
    { };






  inline namespace literals
  {
  inline namespace string_literals
  {

    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<char>
    operator""s(const char* __str, size_t __len)
    { return basic_string<char>{__str, __len}; }


    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<wchar_t>
    operator""s(const wchar_t* __str, size_t __len)
    { return basic_string<wchar_t>{__str, __len}; }



    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<char16_t>
    operator""s(const char16_t* __str, size_t __len)
    { return basic_string<char16_t>{__str, __len}; }

    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<char32_t>
    operator""s(const char32_t* __str, size_t __len)
    { return basic_string<char32_t>{__str, __len}; }


  }
  }




}
#53 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/string" 2 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.tcc" 1 3
#42 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.tcc" 3

#43 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.tcc" 3



namespace std
{




  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s) noexcept
    {
      if (this == &__s)
 return;

      _Alloc_traits::_S_on_swap(_M_get_allocator(), __s._M_get_allocator());

      if (_M_is_local())
 if (__s._M_is_local())
   {
     if (length() && __s.length())
       {
  _CharT __tmp_data[_S_local_capacity + 1];
  traits_type::copy(__tmp_data, __s._M_local_buf,
      _S_local_capacity + 1);
  traits_type::copy(__s._M_local_buf, _M_local_buf,
      _S_local_capacity + 1);
  traits_type::copy(_M_local_buf, __tmp_data,
      _S_local_capacity + 1);
       }
     else if (__s.length())
       {
  traits_type::copy(_M_local_buf, __s._M_local_buf,
      _S_local_capacity + 1);
  _M_length(__s.length());
  __s._M_set_length(0);
  return;
       }
     else if (length())
       {
  traits_type::copy(__s._M_local_buf, _M_local_buf,
      _S_local_capacity + 1);
  __s._M_length(length());
  _M_set_length(0);
  return;
       }
   }
 else
   {
     const size_type __tmp_capacity = __s._M_allocated_capacity;
     traits_type::copy(__s._M_local_buf, _M_local_buf,
         _S_local_capacity + 1);
     _M_data(__s._M_data());
     __s._M_data(__s._M_local_buf);
     _M_capacity(__tmp_capacity);
   }
      else
 {
   const size_type __tmp_capacity = _M_allocated_capacity;
   if (__s._M_is_local())
     {
       traits_type::copy(_M_local_buf, __s._M_local_buf,
    _S_local_capacity + 1);
       __s._M_data(_M_data());
       _M_data(_M_local_buf);
     }
   else
     {
       pointer __tmp_ptr = _M_data();
       _M_data(__s._M_data());
       __s._M_data(__tmp_ptr);
       _M_capacity(__s._M_allocated_capacity);
     }
   __s._M_capacity(__tmp_capacity);
 }

      const size_type __tmp_length = length();
      _M_length(__s.length());
      __s._M_length(__tmp_length);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::pointer
    basic_string<_CharT, _Traits, _Alloc>::
    _M_create(size_type& __capacity, size_type __old_capacity)
    {


      if (__capacity > max_size())
 std::__throw_length_error(("basic_string::_M_create"));




      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 {
   __capacity = 2 * __old_capacity;

   if (__capacity > max_size())
     __capacity = max_size();
 }



      return _Alloc_traits::allocate(_M_get_allocator(), __capacity + 1);
    }





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      void
      basic_string<_CharT, _Traits, _Alloc>::
      _M_construct(_InIterator __beg, _InIterator __end,
     std::input_iterator_tag)
      {
 size_type __len = 0;
 size_type __capacity = size_type(_S_local_capacity);

 while (__beg != __end && __len < __capacity)
   {
     _M_data()[__len++] = *__beg;
     ++__beg;
   }

 try
   {
     while (__beg != __end)
       {
  if (__len == __capacity)
    {

      __capacity = __len + 1;
      pointer __another = _M_create(__capacity, __len);
      this->_S_copy(__another, _M_data(), __len);
      _M_dispose();
      _M_data(__another);
      _M_capacity(__capacity);
    }
  _M_data()[__len++] = *__beg;
  ++__beg;
       }
   }
 catch(...)
   {
     _M_dispose();
     throw;
   }

 _M_set_length(__len);
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      void
      basic_string<_CharT, _Traits, _Alloc>::
      _M_construct(_InIterator __beg, _InIterator __end,
     std::forward_iterator_tag)
      {

 if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
   std::__throw_logic_error(("basic_string::" "_M_construct null not valid")
                                         );

 size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));

 if (__dnew > size_type(_S_local_capacity))
   {
     _M_data(_M_create(__dnew, size_type(0)));
     _M_capacity(__dnew);
   }


 try
   { this->_S_copy_chars(_M_data(), __beg, __end); }
 catch(...)
   {
     _M_dispose();
     throw;
   }

 _M_set_length(__dnew);
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_construct(size_type __n, _CharT __c)
    {
      if (__n > size_type(_S_local_capacity))
 {
   _M_data(_M_create(__n, size_type(0)));
   _M_capacity(__n);
 }

      if (__n)
 this->_S_assign(_M_data(), __n, __c);

      _M_set_length(__n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_assign(const basic_string& __str)
    {
      if (this != &__str)
 {
   const size_type __rsize = __str.length();
   const size_type __capacity = capacity();

   if (__rsize > __capacity)
     {
       size_type __new_capacity = __rsize;
       pointer __tmp = _M_create(__new_capacity, __capacity);
       _M_dispose();
       _M_data(__tmp);
       _M_capacity(__new_capacity);
     }

   if (__rsize)
     this->_S_copy(_M_data(), __str._M_data(), __rsize);

   _M_set_length(__rsize);
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {

      if (__res < length())
 __res = length();

      const size_type __capacity = capacity();
      if (__res != __capacity)
 {
   if (__res > __capacity
       || __res > size_type(_S_local_capacity))
     {
       pointer __tmp = _M_create(__res, __capacity);
       this->_S_copy(__tmp, _M_data(), length() + 1);
       _M_dispose();
       _M_data(__tmp);
       _M_capacity(__res);
     }
   else if (!_M_is_local())
     {
       this->_S_copy(_M_local_data(), _M_data(), length() + 1);
       _M_destroy(__capacity);
       _M_data(_M_local_data());
     }
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
       size_type __len2)
    {
      const size_type __how_much = length() - __pos - __len1;

      size_type __new_capacity = length() + __len2 - __len1;
      pointer __r = _M_create(__new_capacity, capacity());

      if (__pos)
 this->_S_copy(__r, _M_data(), __pos);
      if (__s && __len2)
 this->_S_copy(__r + __pos, __s, __len2);
      if (__how_much)
 this->_S_copy(__r + __pos + __len2,
        _M_data() + __pos + __len1, __how_much);

      _M_dispose();
      _M_data(__r);
      _M_capacity(__new_capacity);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_erase(size_type __pos, size_type __n)
    {
      const size_type __how_much = length() - __pos - __n;

      if (__how_much && __n)
 this->_S_move(_M_data() + __pos, _M_data() + __pos + __n, __how_much);

      _M_set_length(length() - __n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->_M_erase(__n, __size - __n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_append(const _CharT* __s, size_type __n)
    {
      const size_type __len = __n + this->size();

      if (__len <= this->capacity())
 {
   if (__n)
     this->_S_copy(this->_M_data() + this->size(), __s, __n);
 }
      else
 this->_M_mutate(this->size(), size_type(0), __s, __n);

      this->_M_set_length(__len);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
     _InputIterator __k1, _InputIterator __k2,
     std::__false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 return _M_replace(__i1 - begin(), __n1, __s._M_data(),
     __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");

      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __n2 - __n1;

      if (__new_size <= this->capacity())
 {
   pointer __p = this->_M_data() + __pos1;

   const size_type __how_much = __old_size - __pos1 - __n1;
   if (__how_much && __n1 != __n2)
     this->_S_move(__p + __n2, __p + __n1, __how_much);
 }
      else
 this->_M_mutate(__pos1, __n1, 0, __n2);

      if (__n2)
 this->_S_assign(this->_M_data() + __pos1, __n2, __c);

      this->_M_set_length(__new_size);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
        const size_type __len2)
    {
      _M_check_length(__len1, __len2, "basic_string::_M_replace");

      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;

      if (__new_size <= this->capacity())
 {
   pointer __p = this->_M_data() + __pos;

   const size_type __how_much = __old_size - __pos - __len1;
   if (_M_disjunct(__s))
     {
       if (__how_much && __len1 != __len2)
  this->_S_move(__p + __len2, __p + __len1, __how_much);
       if (__len2)
  this->_S_copy(__p, __s, __len2);
     }
   else
     {

       if (__len2 && __len2 <= __len1)
  this->_S_move(__p, __s, __len2);
       if (__how_much && __len1 != __len2)
  this->_S_move(__p + __len2, __p + __len1, __how_much);
       if (__len2 > __len1)
  {
    if (__s + __len2 <= __p + __len1)
      this->_S_move(__p, __s, __len2);
    else if (__s >= __p + __len1)
      this->_S_copy(__p, __s + __len2 - __len1, __len2);
    else
      {
        const size_type __nleft = (__p + __len1) - __s;
        this->_S_move(__p, __s, __nleft);
        this->_S_copy(__p + __nleft, __p + __len2,
        __len2 - __nleft);
      }
  }
     }
 }
      else
 this->_M_mutate(__pos, __len1, __s, __len2);

      this->_M_set_length(__new_size);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
      ;
      if (__n)
 _S_copy(__s, _M_data() + __pos, __n);

      return __n;
    }
#1145 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_string.tcc" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      const _CharT* __data = _M_data();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;

      if (__n <= __size)
 {
   for (; __pos <= __size - __n; ++__pos)
     if (traits_type::eq(__data[__pos], __s[0])
  && traits_type::compare(__data + __pos + 1,
     __s + 1, __n - 1) == 0)
       return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const noexcept
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const noexcept
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const
    {
      ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;

      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }




  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);


  extern template class basic_string<wchar_t>;
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);




}
#54 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/string" 2 3
#41 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 2 3


namespace std
{

#62 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
  class locale
  {
  public:


    typedef int category;


    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;
#98 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
#117 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    locale() throw();
#126 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    locale(const locale& __other) throw();
#136 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    explicit
    locale(const char* __s);
#151 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    locale(const locale& __base, const char* __s, category __cat);
#162 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    explicit
    locale(const std::string& __s) : locale(__s.c_str()) { }
#177 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    locale(const locale& __base, const std::string& __s, category __cat)
    : locale(__base, __s.c_str(), __cat) { }
#192 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    locale(const locale& __base, const locale& __add, category __cat);
#205 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);


    ~locale() throw();
#219 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    const locale&
    operator=(const locale& __other) throw();
#234 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    template<typename _Facet>
      locale
      combine(const locale& __other) const;






    __attribute ((__abi_tag__ ("cxx11")))
    string
    name() const;
#254 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    bool
    operator==(const locale& __other) const throw();







    bool
    operator!=(const locale& __other) const throw()
    { return !(this->operator==(__other)); }
#282 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
#298 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    static locale
    global(const locale& __loc);




    static const locale&
    classic();

  private:

    _Impl* _M_impl;


    static _Impl* _S_classic;


    static _Impl* _S_global;





    static const char* const* const _S_categories;
#333 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    enum { _S_categories_size = 6 + 0 };


    static __gthread_once_t _S_once;


    explicit
    locale(_Impl*) throw();

    static void
    _S_initialize();

    static void
    _S_initialize_once() throw();

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);


    static const id* const _S_twinned_facets[];

  };
#371 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    mutable _Atomic_word _M_refcount;


    static __c_locale _S_c_locale;


    static const char _S_c_name[2];


    static __gthread_once_t _S_once;


    static void
    _S_initialize_once();

  protected:
#402 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }


    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc) throw();

    static void
    _S_destroy_c_locale(__c_locale& __cloc);

    static __c_locale
    _S_lc_ctype_c_locale(__c_locale __cloc, const char* __s);



    static __c_locale
    _S_get_c_locale();

    __attribute__ ((__const__)) static const char*
    _S_get_c_name() throw();
#438 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    facet(const facet&) = delete;

    facet&
    operator=(const facet&) = delete;


  private:
    void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() const throw()
    {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
          ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    class __shim;

    const facet* _M_sso_shim(const id*) const;
    const facet* _M_cow_shim(const id*) const;
  };
#482 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();




    mutable size_t _M_index;


    static _Atomic_word _S_refcount;

    void
    operator=(const id&);

    id(const id&);

  public:



    id() { }

    size_t
    _M_id() const throw();
  };



  class locale::_Impl
  {
  public:

    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;

  private:

    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() throw()
    {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
          ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();

   ~_Impl() throw();

    _Impl(const _Impl&);

    void
    operator=(const _Impl&);

    bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])

 for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
   __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, const facet*);

    template<typename _Facet>
      void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }

    template<typename _Facet>
      void
      _M_init_facet_unchecked(_Facet* __facet)
      {
 __facet->_M_add_reference();
 _M_facets[_Facet::id._M_id()] = __facet;
      }

    void
    _M_install_cache(const facet*, size_t);

    void _M_init_extra(facet**);
    void _M_init_extra(void*, void*, const char*, const char*);
  };
#640 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
  template<typename _CharT>
    class __cxx11:: collate : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_collate;

    public:

      static locale::id id;
#667 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
#681 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
#698 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
#717 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
#731 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }


      int
      _M_compare(const _CharT*, const _CharT*) const throw();

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const throw();

  protected:

      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
#760 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
#774 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
#787 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;


  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const throw();

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const throw();


  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const throw();

  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const throw();



  template<typename _CharT>
    class __cxx11:: collate_byname : public collate<_CharT>
    {
    public:


      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }


      explicit
      collate_byname(const string& __s, size_t __refs = 0)
      : collate_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~collate_byname() { }
    };


}

#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.tcc" 1 3
#37 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.tcc" 3

#38 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.tcc" 3

namespace std
{


  template<typename _Facet>
    locale::
    locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);

      try
 { _M_impl->_M_install_facet(&_Facet::id, __f); }
      catch(...)
 {
   _M_impl->_M_remove_reference();
   throw;
 }
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0;
    }

  template<typename _Facet>
    locale
    locale::
    combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      try
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      catch(...)
 {
   __tmp->_M_remove_reference();
   throw;
 }
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::
    operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
        const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }
#102 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.tcc" 3
  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size

       && dynamic_cast<const _Facet*>(__facets[__i]));



    }
#130 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.tcc" 3
  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
        __throw_bad_cast();

      return dynamic_cast<const _Facet&>(*__facets[__i]);



    }



  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const throw ()
    { return 0; }


  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const throw ()
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {


      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();




      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;

   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;

   __p++;
   __q++;
 }
    }

  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      string_type __ret;


      const string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      _CharT* __c = new _CharT[__len];

      try
 {



   for (;;)
     {

       size_t __res = _M_transform(__c, __p, __len);


       if (__res >= __len)
  {
    __len = __res + 1;
    delete [] __c, __c = 0;
    __c = new _CharT[__len];
    __res = _M_transform(__c, __p, __len);
  }

       __ret.append(__c, __res);
       __p += char_traits<_CharT>::length(__p);
       if (__p == __pend)
  break;

       __p++;
       __ret.push_back(_CharT());
     }
 }
      catch(...)
 {
   delete [] __c;
   throw;
 }

      delete [] __c;

      return __ret;
    }

  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val =
   *__lo + ((__val << 7)
     | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::
    __digits - 7)));
      return static_cast<long>(__val);
    }




  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);


  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;

  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);




}
#851 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 2 3
#42 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 2 3




#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/system_error" 1 3
#32 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/system_error" 3

#33 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/system_error" 3






#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/error_constants.h" 1 3
#34 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/error_constants.h" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cerrno" 1 3
#39 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cerrno" 3

#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cerrno" 3
#35 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/error_constants.h" 2 3

namespace std
{




  enum class errc
    {




      argument_list_too_long = 7,
      argument_out_of_domain = 33,
      bad_address = 14,
      bad_file_descriptor = 9,

      broken_pipe = 32,






      device_or_resource_busy = 16,
      directory_not_empty = 41,
      executable_format_error = 8,
      file_exists = 17,
      file_too_large = 27,
      filename_too_long = 38,
      function_not_supported = 40,


      illegal_byte_sequence = 42,
      inappropriate_io_control_operation = 25,
      interrupted = 4,
      invalid_argument = 22,
      invalid_seek = 29,
      io_error = 5,
      is_a_directory = 21,






      no_child_process = 10,


      no_lock_available = 39,




      no_space_on_device = 28,


      no_such_device_or_address = 6,
      no_such_device = 19,
      no_such_file_or_directory = 2,
      no_such_process = 3,
      not_a_directory = 20,



      not_enough_memory = 12,

      not_supported = 129,




      operation_not_permitted = 1,



      operation_would_block = 140,


      permission_denied = 13,


      read_only_file_system = 30,
      resource_deadlock_would_occur = 36,
      resource_unavailable_try_again = 11,
      result_out_of_range = 34,




      timed_out = 138,

      too_many_files_open_in_system = 23,
      too_many_files_open = 24,
      too_many_links = 31


 ,
      value_too_large = 132


   };


}
#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/system_error" 2 3

#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/stdexcept" 1 3
#36 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/stdexcept" 3

#37 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/stdexcept" 3




namespace std
{





  struct __cow_string
  {
    union {
      const char* _M_p;
      char _M_bytes[sizeof(const char*)];
    };

    __cow_string();
    __cow_string(const std::string&);
    __cow_string(const char*, size_t);
    __cow_string(const __cow_string&) noexcept;
    __cow_string& operator=(const __cow_string&) noexcept;
    ~__cow_string();

    __cow_string(__cow_string&&) noexcept;
    __cow_string& operator=(__cow_string&&) noexcept;

  };

  typedef basic_string<char> __sso_string;
#113 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/stdexcept" 3
  class logic_error : public exception
  {
    __cow_string _M_msg;

  public:

    explicit
    logic_error(const string& __arg) ;


    explicit
    logic_error(const char*) ;



    logic_error(const logic_error&) noexcept;
    logic_error& operator=(const logic_error&) noexcept;


    virtual ~logic_error() noexcept;



    virtual const char*
    what() const noexcept;





  };



  class domain_error : public logic_error
  {
  public:
    explicit domain_error(const string& __arg) ;

    explicit domain_error(const char*) ;

    virtual ~domain_error() noexcept;
  };


  class invalid_argument : public logic_error
  {
  public:
    explicit invalid_argument(const string& __arg) ;

    explicit invalid_argument(const char*) ;

    virtual ~invalid_argument() noexcept;
  };



  class length_error : public logic_error
  {
  public:
    explicit length_error(const string& __arg) ;

    explicit length_error(const char*) ;

    virtual ~length_error() noexcept;
  };



  class out_of_range : public logic_error
  {
  public:
    explicit out_of_range(const string& __arg) ;

    explicit out_of_range(const char*) ;

    virtual ~out_of_range() noexcept;
  };






  class runtime_error : public exception
  {
    __cow_string _M_msg;

  public:

    explicit
    runtime_error(const string& __arg) ;


    explicit
    runtime_error(const char*) ;



    runtime_error(const runtime_error&) noexcept;
    runtime_error& operator=(const runtime_error&) noexcept;


    virtual ~runtime_error() noexcept;



    virtual const char*
    what() const noexcept;





  };


  class range_error : public runtime_error
  {
  public:
    explicit range_error(const string& __arg) ;

    explicit range_error(const char*) ;

    virtual ~range_error() noexcept;
  };


  class overflow_error : public runtime_error
  {
  public:
    explicit overflow_error(const string& __arg) ;

    explicit overflow_error(const char*) ;

    virtual ~overflow_error() noexcept;
  };


  class underflow_error : public runtime_error
  {
  public:
    explicit underflow_error(const string& __arg) ;

    explicit underflow_error(const char*) ;

    virtual ~underflow_error() noexcept;
  };




}
#42 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/system_error" 2 3

namespace std
{


  class error_code;
  class error_condition;
  class system_error;


  template<typename _Tp>
    struct is_error_code_enum : public false_type { };


  template<typename _Tp>
    struct is_error_condition_enum : public false_type { };

  template<>
    struct is_error_condition_enum<errc>
    : public true_type { };

  inline namespace _V2 {


  class error_category
  {
  public:
    constexpr error_category() noexcept = default;

    virtual ~error_category();

    error_category(const error_category&) = delete;
    error_category& operator=(const error_category&) = delete;

    virtual const char*
    name() const noexcept = 0;






  private:
    __attribute ((__abi_tag__ ("cxx11")))
    virtual __cow_string
    _M_message(int) const;

  public:
    __attribute ((__abi_tag__ ("cxx11")))
    virtual string
    message(int) const = 0;
#102 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/system_error" 3
  public:
    virtual error_condition
    default_error_condition(int __i) const noexcept;

    virtual bool
    equivalent(int __i, const error_condition& __cond) const noexcept;

    virtual bool
    equivalent(const error_code& __code, int __i) const noexcept;

    bool
    operator<(const error_category& __other) const noexcept
    { return less<const error_category*>()(this, &__other); }

    bool
    operator==(const error_category& __other) const noexcept
    { return this == &__other; }

    bool
    operator!=(const error_category& __other) const noexcept
    { return this != &__other; }
  };


  __attribute__ ((__const__)) const error_category& system_category() noexcept;
  __attribute__ ((__const__)) const error_category& generic_category() noexcept;

  }

  error_code make_error_code(errc) noexcept;

  template<typename _Tp>
    struct hash;



  struct error_code
  {
    error_code() noexcept
    : _M_value(0), _M_cat(&system_category()) { }

    error_code(int __v, const error_category& __cat) noexcept
    : _M_value(__v), _M_cat(&__cat) { }

    template<typename _ErrorCodeEnum, typename = typename
      enable_if<is_error_code_enum<_ErrorCodeEnum>::value>::type>
      error_code(_ErrorCodeEnum __e) noexcept
      { *this = make_error_code(__e); }

    void
    assign(int __v, const error_category& __cat) noexcept
    {
      _M_value = __v;
      _M_cat = &__cat;
    }

    void
    clear() noexcept
    { assign(0, system_category()); }


    template<typename _ErrorCodeEnum>
      typename enable_if<is_error_code_enum<_ErrorCodeEnum>::value,
    error_code&>::type
      operator=(_ErrorCodeEnum __e) noexcept
      { return *this = make_error_code(__e); }

    int
    value() const noexcept { return _M_value; }

    const error_category&
    category() const noexcept { return *_M_cat; }

    error_condition
    default_error_condition() const noexcept;

    __attribute ((__abi_tag__ ("cxx11")))
    string
    message() const
    { return category().message(value()); }

    explicit operator bool() const noexcept
    { return _M_value != 0; }


  private:
    friend class hash<error_code>;

    int _M_value;
    const error_category* _M_cat;
  };


  inline error_code
  make_error_code(errc __e) noexcept
  { return error_code(static_cast<int>(__e), generic_category()); }

  inline bool
  operator<(const error_code& __lhs, const error_code& __rhs) noexcept
  {
    return (__lhs.category() < __rhs.category()
     || (__lhs.category() == __rhs.category()
  && __lhs.value() < __rhs.value()));
  }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __e)
    { return (__os << __e.category().name() << ':' << __e.value()); }

  error_condition make_error_condition(errc) noexcept;



  struct error_condition
  {
    error_condition() noexcept
    : _M_value(0), _M_cat(&generic_category()) { }

    error_condition(int __v, const error_category& __cat) noexcept
    : _M_value(__v), _M_cat(&__cat) { }

    template<typename _ErrorConditionEnum, typename = typename
  enable_if<is_error_condition_enum<_ErrorConditionEnum>::value>::type>
      error_condition(_ErrorConditionEnum __e) noexcept
      { *this = make_error_condition(__e); }

    void
    assign(int __v, const error_category& __cat) noexcept
    {
      _M_value = __v;
      _M_cat = &__cat;
    }


    template<typename _ErrorConditionEnum>
      typename enable_if<is_error_condition_enum
    <_ErrorConditionEnum>::value, error_condition&>::type
      operator=(_ErrorConditionEnum __e) noexcept
      { return *this = make_error_condition(__e); }

    void
    clear() noexcept
    { assign(0, generic_category()); }


    int
    value() const noexcept { return _M_value; }

    const error_category&
    category() const noexcept { return *_M_cat; }

    __attribute ((__abi_tag__ ("cxx11")))
    string
    message() const
    { return category().message(value()); }

    explicit operator bool() const noexcept
    { return _M_value != 0; }


  private:
    int _M_value;
    const error_category* _M_cat;
  };


  inline error_condition
  make_error_condition(errc __e) noexcept
  { return error_condition(static_cast<int>(__e), generic_category()); }

  inline bool
  operator<(const error_condition& __lhs,
     const error_condition& __rhs) noexcept
  {
    return (__lhs.category() < __rhs.category()
     || (__lhs.category() == __rhs.category()
  && __lhs.value() < __rhs.value()));
  }


  inline bool
  operator==(const error_code& __lhs, const error_code& __rhs) noexcept
  { return (__lhs.category() == __rhs.category()
     && __lhs.value() == __rhs.value()); }

  inline bool
  operator==(const error_code& __lhs, const error_condition& __rhs) noexcept
  {
    return (__lhs.category().equivalent(__lhs.value(), __rhs)
     || __rhs.category().equivalent(__lhs, __rhs.value()));
  }

  inline bool
  operator==(const error_condition& __lhs, const error_code& __rhs) noexcept
  {
    return (__rhs.category().equivalent(__rhs.value(), __lhs)
     || __lhs.category().equivalent(__rhs, __lhs.value()));
  }

  inline bool
  operator==(const error_condition& __lhs,
      const error_condition& __rhs) noexcept
  {
    return (__lhs.category() == __rhs.category()
     && __lhs.value() == __rhs.value());
  }

  inline bool
  operator!=(const error_code& __lhs, const error_code& __rhs) noexcept
  { return !(__lhs == __rhs); }

  inline bool
  operator!=(const error_code& __lhs, const error_condition& __rhs) noexcept
  { return !(__lhs == __rhs); }

  inline bool
  operator!=(const error_condition& __lhs, const error_code& __rhs) noexcept
  { return !(__lhs == __rhs); }

  inline bool
  operator!=(const error_condition& __lhs,
      const error_condition& __rhs) noexcept
  { return !(__lhs == __rhs); }







  class system_error : public std::runtime_error
  {
  private:
    error_code _M_code;

  public:
    system_error(error_code __ec = error_code())
    : runtime_error(__ec.message()), _M_code(__ec) { }

    system_error(error_code __ec, const string& __what)
    : runtime_error(__what + ": " + __ec.message()), _M_code(__ec) { }

    system_error(error_code __ec, const char* __what)
    : runtime_error(__what + (": " + __ec.message())), _M_code(__ec) { }

    system_error(int __v, const error_category& __ecat, const char* __what)
    : system_error(error_code(__v, __ecat), __what) { }

    system_error(int __v, const error_category& __ecat)
    : runtime_error(error_code(__v, __ecat).message()),
      _M_code(__v, __ecat) { }

    system_error(int __v, const error_category& __ecat, const string& __what)
    : runtime_error(__what + ": " + error_code(__v, __ecat).message()),
      _M_code(__v, __ecat) { }

    virtual ~system_error() noexcept;

    const error_code&
    code() const noexcept { return _M_code; }
  };


}





namespace std
{




  template<>
    struct hash<error_code>
    : public __hash_base<size_t, error_code>
    {
      size_t
      operator()(const error_code& __e) const noexcept
      {
 const size_t __tmp = std::_Hash_impl::hash(__e._M_value);
 return std::_Hash_impl::__hash_combine(__e._M_cat, __tmp);
      }
    };


}
#47 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 2 3


namespace std
{






  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16,
      _S_ios_fmtflags_max = 0x7fffffff,
      _S_ios_fmtflags_min = ~0x7fffffff
    };

  inline constexpr _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }

  inline const _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline const _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline const _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }


  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_ios_openmode_end = 1L << 16,
      _S_ios_openmode_max = 0x7fffffff,
      _S_ios_openmode_min = ~0x7fffffff
    };

  inline constexpr _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }

  inline const _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline const _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline const _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }


  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16,
      _S_ios_iostate_max = 0x7fffffff,
      _S_ios_iostate_min = ~0x7fffffff
    };

  inline constexpr _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  inline const _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline const _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline const _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }


  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };



  enum class io_errc { stream = 1 };

  template <> struct is_error_code_enum<io_errc> : public true_type { };

  const error_category& iostream_category() noexcept;

  inline error_code
  make_error_code(io_errc e) noexcept
  { return error_code(static_cast<int>(e), iostream_category()); }

  inline error_condition
  make_error_condition(io_errc e) noexcept
  { return error_condition(static_cast<int>(e), iostream_category()); }
#228 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
  class ios_base
  {
#246 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
  public:
#255 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    class __attribute ((__abi_tag__ ("cxx11"))) failure : public system_error
    {
    public:
      explicit
      failure(const string& __str);


      explicit
      failure(const string&, const error_code&);

      explicit
      failure(const char*, const error_code& = io_errc::stream);


      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();
    };
#323 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;


    static const fmtflags boolalpha = _S_boolalpha;


    static const fmtflags dec = _S_dec;


    static const fmtflags fixed = _S_fixed;


    static const fmtflags hex = _S_hex;




    static const fmtflags internal = _S_internal;



    static const fmtflags left = _S_left;


    static const fmtflags oct = _S_oct;



    static const fmtflags right = _S_right;


    static const fmtflags scientific = _S_scientific;



    static const fmtflags showbase = _S_showbase;



    static const fmtflags showpoint = _S_showpoint;


    static const fmtflags showpos = _S_showpos;


    static const fmtflags skipws = _S_skipws;


    static const fmtflags unitbuf = _S_unitbuf;



    static const fmtflags uppercase = _S_uppercase;


    static const fmtflags adjustfield = _S_adjustfield;


    static const fmtflags basefield = _S_basefield;


    static const fmtflags floatfield = _S_floatfield;
#398 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;



    static const iostate badbit = _S_badbit;


    static const iostate eofbit = _S_eofbit;




    static const iostate failbit = _S_failbit;


    static const iostate goodbit = _S_goodbit;
#429 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;


    static const openmode app = _S_app;


    static const openmode ate = _S_ate;




    static const openmode binary = _S_bin;


    static const openmode in = _S_in;


    static const openmode out = _S_out;


    static const openmode trunc = _S_trunc;
#461 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;


    static const seekdir beg = _S_beg;


    static const seekdir cur = _S_cur;


    static const seekdir end = _S_end;


    typedef int io_state;
    typedef int open_mode;
    typedef int seek_dir;

    typedef std::streampos streampos;
    typedef std::streamoff streamoff;
#487 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
#504 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    typedef void (*event_callback) (event __e, ios_base& __b, int __i);
#516 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    void
    register_callback(event_callback __fn, int __index);

  protected:
    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;



    struct _Callback_list
    {

      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }


      int
      _M_remove_reference()
      {

        ;
        int __res = __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1);
        if (__res == 0)
          {
            ;
          }
        return __res;
      }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) throw();

    void
    _M_dispose_callbacks(void) throw();


    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };


    _Words _M_word_zero;



    enum { _S_local_word_size = 8 };
    _Words _M_local_word[_S_local_word_size];


    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index, bool __iword);


    locale _M_ios_locale;

    void
    _M_init() throw();

  public:





    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();

    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };






    fmtflags
    flags() const
    { return _M_flags; }
#629 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
#645 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
#662 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }







    void
    unsetf(fmtflags __mask)
    { _M_flags &= ~__mask; }
#688 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    streamsize
    precision() const
    { return _M_precision; }






    streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }







    streamsize
    width() const
    { return _M_width; }






    streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
#739 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    static bool
    sync_with_stdio(bool __sync = true);
#751 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    locale
    imbue(const locale& __loc) throw();
#762 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    locale
    getloc() const
    { return _M_ios_locale; }
#773 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    const locale&
    _M_getloc() const
    { return _M_ios_locale; }
#792 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    static int
    xalloc() throw();
#808 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    long&
    iword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
#829 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    void*&
    pword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
#846 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    virtual ~ios_base();

  protected:
    ios_base() throw ();
#860 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
  public:
    ios_base(const ios_base&) = delete;

    ios_base&
    operator=(const ios_base&) = delete;

  protected:
    void
    _M_move(ios_base&) noexcept;

    void
    _M_swap(ios_base& __rhs) noexcept;

  };



  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }


  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }



  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }


  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }


  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }



  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }



  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }






  inline ios_base&
  hexfloat(ios_base& __base)
  {
    __base.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  defaultfloat(ios_base& __base)
  {
    __base.unsetf(ios_base::floatfield);
    return __base;
  }



}
#43 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ios" 2 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/streambuf" 1 3
#36 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/streambuf" 3

#37 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/streambuf" 3
#45 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/streambuf" 3
namespace std
{


  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,
     basic_streambuf<_CharT, _Traits>*, bool&);
#119 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/streambuf" 3
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;




      typedef basic_streambuf<char_type, traits_type> __streambuf_type;


      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs_eof<>(basic_streambuf*, basic_streambuf*, bool&);

      template<bool _IsMove, typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
        __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
      istreambuf_iterator<_CharT2> >::__type
        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&,
     basic_string<_CharT2, _Traits2, _Alloc>&);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);

    protected:







      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;


      locale _M_buf_locale;

  public:

      virtual
      ~basic_streambuf()
      { }
#208 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      locale
      pubimbue(const locale& __loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
#225 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      locale
      getloc() const
      { return _M_buf_locale; }
#238 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      basic_streambuf*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }
#250 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }
#262 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }




      int
      pubsync() { return this->sync(); }
#283 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
#297 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
#315 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
#337 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
#356 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
#371 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
#396 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
#423 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
#449 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
#463 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
#481 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }
#497 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      void
      gbump(int __n) { _M_in_cur += __n; }
#508 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
#528 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
#544 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      void
      pbump(int __n) { _M_out_cur += __n; }
#554 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
#575 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      virtual void
      imbue(const locale& __loc)
      { }
#590 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
#601 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
#613 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
#626 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      virtual int
      sync() { return 0; }
#648 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      virtual streamsize
      showmanyc() { return 0; }
#664 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
#686 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      virtual int_type
      underflow()
      { return traits_type::eof(); }
#699 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
#723 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      virtual int_type
      pbackfail(int_type __c = traits_type::eof())
      { return traits_type::eof(); }
#741 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
#767 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      virtual int_type
      overflow(int_type __c = traits_type::eof())
      { return traits_type::eof(); }



    public:
#782 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      void
      stossc()
      {
 if (this->gptr() < this->egptr())
   this->gbump(1);
 else
   this->uflow();
      }



      void
      __safe_gbump(streamsize __n) { _M_in_cur += __n; }

      void
      __safe_pbump(streamsize __n) { _M_out_cur += __n; }




    protected:

      basic_streambuf(const basic_streambuf&);

      basic_streambuf&
      operator=(const basic_streambuf&);


      void
      swap(basic_streambuf& __sb)
      {
 std::swap(_M_in_beg, __sb._M_in_beg);
 std::swap(_M_in_cur, __sb._M_in_cur);
 std::swap(_M_in_end, __sb._M_in_end);
 std::swap(_M_out_beg, __sb._M_out_beg);
 std::swap(_M_out_cur, __sb._M_out_cur);
 std::swap(_M_out_end, __sb._M_out_end);
 std::swap(_M_buf_locale, __sb._M_buf_locale);
      }

    };


  template<typename _CharT, typename _Traits>
    std::basic_streambuf<_CharT, _Traits>::
    basic_streambuf(const basic_streambuf&) = default;

  template<typename _CharT, typename _Traits>
    std::basic_streambuf<_CharT, _Traits>&
    std::basic_streambuf<_CharT, _Traits>::
    operator=(const basic_streambuf&) = default;



  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>* __sbin,
     basic_streambuf<char>* __sbout, bool& __ineof);

  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,
     basic_streambuf<wchar_t>* __sbout, bool& __ineof);



}

#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/streambuf.tcc" 1 3
#37 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/streambuf.tcc" 3

#38 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/streambuf.tcc" 3

namespace std
{


  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->__safe_gbump(__len);
     }

   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->__safe_pbump(__len);
     }

   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,
     basic_streambuf<_CharT, _Traits>* __sbout,
     bool& __ineof)
    {
      streamsize __ret = 0;
      __ineof = true;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   __c = __sbout->sputc(_Traits::to_char_type(__c));
   if (_Traits::eq_int_type(__c, _Traits::eof()))
     {
       __ineof = false;
       break;
     }
   ++__ret;
   __c = __sbin->snextc();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    inline streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      bool __ineof;
      return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }




  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*,
        basic_streambuf<char>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>*,
     basic_streambuf<char>*, bool&);


  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>*,
        basic_streambuf<wchar_t>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>*,
     basic_streambuf<wchar_t>*, bool&);




}
#851 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/streambuf" 2 3
#44 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ios" 2 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 1 3
#33 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3

#34 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3



#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 1 3
#37 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3

#38 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3

#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cwctype" 1 3
#39 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cwctype" 3

#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cwctype" 3
#50 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cwctype" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/wctype.h" 1 3
#15 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/wctype.h" 3
#pragma pack(push,_CRT_PACKING)


extern "C" {
#166 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/wctype.h" 3
  typedef wchar_t wctrans_t;
  wint_t __attribute__((__cdecl__)) towctrans(wint_t,wctrans_t);
  wctrans_t __attribute__((__cdecl__)) wctrans(const char *);
  wctype_t __attribute__((__cdecl__)) wctype(const char *);


}


#pragma pack(pop)
#51 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cwctype" 2 3
#80 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cwctype" 3
namespace std
{
  using ::wctrans_t;
  using ::wctype_t;
  using ::wint_t;

  using ::iswalnum;
  using ::iswalpha;

  using ::iswblank;

  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;
}
#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 2 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cctype" 1 3
#39 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cctype" 3

#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cctype" 3
#41 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 2 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/ctype_base.h" 1 3
#37 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/ctype_base.h" 3
namespace std
{



  struct ctype_base
  {

    typedef const int* __to_type;



    typedef unsigned short mask;
    static const mask upper = 1 << 0;
    static const mask lower = 1 << 1;
    static const mask alpha = 1 << 2;
    static const mask digit = 1 << 3;
    static const mask xdigit = 1 << 4;
    static const mask space = 1 << 5;
    static const mask print = 1 << 6;
    static const mask graph = (1 << 2) | (1 << 3) | (1 << 9);
    static const mask cntrl = 1 << 8;
    static const mask punct = 1 << 9;
    static const mask alnum = (1 << 2) | (1 << 3);

    static const mask blank = 1 << 10;

  };


}
#42 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 2 3






#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/streambuf_iterator.h" 1 3
#33 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/streambuf_iterator.h" 3

#34 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/streambuf_iterator.h" 3




namespace std
{

#49 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/streambuf_iterator.h" 3
  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
                      _CharT*,


        _CharT>



    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

      template<bool _IsMove, typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
 __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
               istreambuf_iterator<_CharT2> >::__type
 find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

    private:







      mutable streambuf_type* _M_sbuf;
      mutable int_type _M_c;

    public:

      constexpr istreambuf_iterator() noexcept
      : _M_sbuf(0), _M_c(traits_type::eof()) { }


      istreambuf_iterator(const istreambuf_iterator&) noexcept = default;

      ~istreambuf_iterator() = default;



      istreambuf_iterator(istream_type& __s) noexcept
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }


      istreambuf_iterator(streambuf_type* __s) noexcept
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }




      char_type
      operator*() const
      {







 return traits_type::to_char_type(_M_get());
      }


      istreambuf_iterator&
      operator++()
      {


                        ;
 if (_M_sbuf)
   {
     _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return *this;
      }


      istreambuf_iterator
      operator++(int)
      {


                        ;

 istreambuf_iterator __old = *this;
 if (_M_sbuf)
   {
     __old._M_c = _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return __old;
      }





      bool
      equal(const istreambuf_iterator& __b) const
      { return _M_at_eof() == __b._M_at_eof(); }

    private:
      int_type
      _M_get() const
      {
 const int_type __eof = traits_type::eof();
 int_type __ret = __eof;
 if (_M_sbuf)
   {
     if (!traits_type::eq_int_type(_M_c, __eof))
       __ret = _M_c;
     else if (!traits_type::eq_int_type((__ret = _M_sbuf->sgetc()),
            __eof))
       _M_c = __ret;
     else
       _M_sbuf = 0;
   }
 return __ret;
      }

      bool
      _M_at_eof() const
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(_M_get(), __eof);
      }
    };

  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }


  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:

      ostreambuf_iterator(ostream_type& __s) noexcept
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator(streambuf_type* __s) noexcept
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }


      ostreambuf_iterator&
      operator*()
      { return *this; }


      ostreambuf_iterator&
      operator++(int)
      { return *this; }


      ostreambuf_iterator&
      operator++()
      { return *this; }


      bool
      failed() const noexcept
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                           ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last,
  ostreambuf_iterator<_CharT> __result)
    {
      if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)
 {
   bool __ineof;
   __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
   if (!__ineof)
     __result._M_failed = true;
 }
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(_CharT* __first, _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(const _CharT* __first, const _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT> __first,
     istreambuf_iterator<_CharT> __last, _CharT* __result)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof()))
     {
       const streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    traits_type::copy(__result, __sb->gptr(), __n);
    __sb->__safe_gbump(__n);
    __result += __n;
    __c = __sb->underflow();
  }
       else
  {
    *__result++ = traits_type::to_char_type(__c);
    __c = __sb->snextc();
  }
     }
 }
      return __result;
    }

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
          istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last, const _CharT& __val)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   const int_type __ival = traits_type::to_int_type(__val);
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof())
   && !traits_type::eq_int_type(__c, __ival))
     {
       streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    const _CharT* __p = traits_type::find(__sb->gptr(),
       __n, __val);
    if (__p)
      __n = __p - __sb->gptr();
    __sb->__safe_gbump(__n);
    __c = __sb->sgetc();
  }
       else
  __c = __sb->snextc();
     }

   if (!traits_type::eq_int_type(__c, traits_type::eof()))
     __first._M_c = __c;
   else
     __first._M_sbuf = 0;
 }
      return __first;
    }




}
#49 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 2 3

namespace std
{

#71 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
  template<typename _Tp>
    void
    __convert_to_v(const char*, _Tp&, ios_base::iostate&,
     const __c_locale&) throw();


  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&) throw();



  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, streamsize __newlen, streamsize __oldlen);
    };






  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);




  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }


  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }
#149 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:


      typedef _CharT char_type;
#168 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
#185 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
#201 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
#217 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
#231 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
#246 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
#260 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
#275 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
#292 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
#311 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
#330 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
#352 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char* __to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }
#377 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const = 0;
#396 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
#415 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
#434 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
#452 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const = 0;
#469 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
#485 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const = 0;
#502 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
#521 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const = 0;
#542 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const = 0;
#563 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const = 0;
#588 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const = 0;
    };
#611 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:

      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;


      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;
#680 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:


      typedef char char_type;

    protected:

      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok;


    public:

      static locale::id id;

      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
#717 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
#730 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
#743 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      inline bool
      is(mask __m, char __c) const;
#758 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
#772 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
#786 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
#801 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
#818 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
#834 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
#851 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
#871 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
#898 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
#929 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
#962 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char* __to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }





      const mask*
      table() const throw()
      { return _M_table; }


      static const mask*
      classic_table() throw();
    protected:







      virtual
      ~ctype();
#1011 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
#1028 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
#1044 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
#1061 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
#1081 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const
      { return __c; }
#1104 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }
#1130 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const
      { return __c; }
#1156 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const
      {
 __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }

    private:
      void _M_narrow_init() const;
      void _M_widen_init() const;
    };
#1181 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:


      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;

    protected:
      __c_locale _M_c_locale_ctype;


      bool _M_narrow_ok;
      char _M_narrow[128];
      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];


      mask _M_bit[16];
      __wmask_type _M_wmask[16];

    public:


      static locale::id id;
#1214 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      explicit
      ctype(size_t __refs = 0);
#1225 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);

    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const throw();


      virtual
      ~ctype();
#1249 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const;
#1268 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
#1286 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
#1304 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
#1321 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
#1338 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
#1354 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
#1371 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
#1391 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const;
#1413 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const;
#1436 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const;
#1462 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;


      void
      _M_initialize_ctype() throw();
    };



  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef typename ctype<_CharT>::mask mask;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0)
      : ctype_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~ctype_byname() { };
    };


  template<>
    class ctype_byname<char> : public ctype<char>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0);


    protected:
      virtual
      ~ctype_byname();
    };


  template<>
    class ctype_byname<wchar_t> : public ctype<wchar_t>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0);


    protected:
      virtual
      ~ctype_byname();
    };



}


#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/ctype_inline.h" 1 3
#37 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/ctype_inline.h" 3
namespace std
{


  bool
  ctype<char>::
  is(mask __m, char __c) const
  { return (_M_table[static_cast<unsigned char>(__c) ] & __m); }


  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }

  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high && !this->is(__m, *__low))
      ++__low;
    return __low;
  }

  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high && this->is(__m, *__low) != 0)
      ++__low;
    return __low;
  }


}
#1535 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 2 3

namespace std
{



  class __num_base
  {
  public:


    enum
      {
 _S_ominus,
 _S_oplus,
 _S_ox,
 _S_oX,
 _S_odigits,
 _S_odigits_end = _S_odigits + 16,
 _S_oudigits = _S_odigits_end,
 _S_oudigits_end = _S_oudigits + 16,
 _S_oe = _S_odigits + 14,
 _S_oE = _S_oudigits + 14,
 _S_oend = _S_oudigits_end
      };






    static const char* _S_atoms_out;



    static const char* _S_atoms_in;

    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };



    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod) throw();
  };

  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;





      _CharT _M_atoms_out[__num_base::_S_oend];





      _CharT _M_atoms_in[__num_base::_S_iend];

      bool _M_allocated;

      __numpunct_cache(size_t __refs = 0)
      : facet(__refs), _M_grouping(0), _M_grouping_size(0),
 _M_use_grouping(false),
 _M_truename(0), _M_truename_size(0), _M_falsename(0),
 _M_falsename_size(0), _M_decimal_point(_CharT()),
 _M_thousands_sep(_CharT()), _M_allocated(false)
 { }

      ~__numpunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);

      explicit
      __numpunct_cache(const __numpunct_cache&);
    };

  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }

namespace __cxx11 {
#1665 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __numpunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;

    public:

      static locale::id id;






      explicit
      numpunct(size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(); }
#1703 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
#1717 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(__cloc); }
#1731 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
#1744 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
#1775 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
#1788 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      string_type
      truename() const
      { return this->do_truename(); }
#1801 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:

      virtual
      ~numpunct();
#1818 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
#1830 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
#1843 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
#1856 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
#1869 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }


      void
      _M_initialize_numpunct(__c_locale __cloc = 0);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);


  template<>
    numpunct<wchar_t>::~numpunct();

  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);



  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }


      explicit
      numpunct_byname(const string& __s, size_t __refs = 0)
      : numpunct_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~numpunct_byname() { }
    };

}


#1947 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
#1968 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
#1994 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
#2031 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
#2091 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
#2134 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:

      virtual ~num_get() { }

      __attribute ((__abi_tag__ ("cxx11")))
      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string&) const;

      template<typename _ValueT>
 __attribute ((__abi_tag__ ("cxx11")))
 iter_type
 _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT&) const;

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
 _M_find(const _CharT2*, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   if (__len <= 10)
     {
       if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
  __ret = __c - _CharT2('0');
     }
   else
     {
       if (__c >= _CharT2('0') && __c <= _CharT2('9'))
  __ret = __c - _CharT2('0');
       else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
  __ret = 10 + (__c - _CharT2('a'));
       else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
  __ret = 10 + (__c - _CharT2('A'));
     }
   return __ret;
 }

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
          int>::__type
 _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);
   if (__q)
     {
       __ret = __q - __zero;
       if (__ret > 15)
  __ret -= 6;
     }
   return __ret;
 }
#2207 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned short& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned int& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      double&) const;







      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      long double&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, void*&) const;
#2270 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
#2288 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
#2309 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
#2327 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
      { return this->do_put(__s, __io, __fill, __v); }
#2369 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __io, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }
#2432 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __io, __fill, __v); }
#2457 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __io, __fill, __v); }

    protected:
      template<typename _ValueT>
 iter_type
 _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;

      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;

      template<typename _ValueT>
 iter_type
 _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;

      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;


      virtual
      ~num_put() { };
#2505 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, double) const;






      virtual iter_type
      do_put(iter_type, ios_base&, char_type, long double) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, const void*) const;







    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;









  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }


  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }


  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }


  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }


  template<typename _CharT>
    inline bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }


  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }


  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }


  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }


  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }


  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }


  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }



  template<typename _CharT>
    inline bool
    isblank(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::blank, __c); }



  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }


  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }


}

#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.tcc" 1 3
#33 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.tcc" 3

#34 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.tcc" 3

namespace std
{




  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };


  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = 0;
     try
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };

  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);

      char* __grouping = 0;
      _CharT* __truename = 0;
      _CharT* __falsename = 0;
      try
 {
   const string& __g = __np.grouping();
   _M_grouping_size = __g.size();
   __grouping = new char[_M_grouping_size];
   __g.copy(__grouping, _M_grouping_size);
   _M_use_grouping = (_M_grouping_size
        && static_cast<signed char>(__grouping[0]) > 0
        && (__grouping[0]
     != __gnu_cxx::__numeric_traits<char>::__max));

   const basic_string<_CharT>& __tn = __np.truename();
   _M_truename_size = __tn.size();
   __truename = new _CharT[_M_truename_size];
   __tn.copy(__truename, _M_truename_size);

   const basic_string<_CharT>& __fn = __np.falsename();
   _M_falsename_size = __fn.size();
   __falsename = new _CharT[_M_falsename_size];
   __fn.copy(__falsename, _M_falsename_size);

   _M_decimal_point = __np.decimal_point();
   _M_thousands_sep = __np.thousands_sep();

   const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
   __ct.widen(__num_base::_S_atoms_out,
       __num_base::_S_atoms_out
       + __num_base::_S_oend, _M_atoms_out);
   __ct.widen(__num_base::_S_atoms_in,
       __num_base::_S_atoms_in
       + __num_base::_S_iend, _M_atoms_in);

   _M_grouping = __grouping;
   _M_truename = __truename;
   _M_falsename = __falsename;
   _M_allocated = true;
 }
      catch(...)
 {
   delete [] __grouping;
   delete [] __truename;
   delete [] __falsename;
   throw;
 }
    }
#139 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.tcc" 3
  __attribute__ ((__pure__)) bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp) throw ();



  template<typename _CharT, typename _InIter>
    __attribute ((__abi_tag__ ("cxx11")))
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();


      bool __testeof = __beg == __end;


      if (!__testeof)
 {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 }


      bool __found_mantissa = false;
      int __sep_pos = 0;
      while (!__testeof)
 {
   if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__sep_pos;

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
   else
     break;
 }


      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      const char_type* __lit_zero = __lit + __num_base::_S_izero;

      if (!__lc->_M_allocated)

 while (!__testeof)
   {
     const int __digit = _M_find(__lit_zero, 10, __c);
     if (__digit != -1)
       {
  __xtrc += '0' + __digit;
  __found_mantissa = true;
       }
     else if (__c == __lc->_M_decimal_point
       && !__found_dec && !__found_sci)
       {
  __xtrc += '.';
  __found_dec = true;
       }
     else if ((__c == __lit[__num_base::_S_ie]
        || __c == __lit[__num_base::_S_iE])
       && !__found_sci && __found_mantissa)
       {

  __xtrc += 'e';
  __found_sci = true;


  if (++__beg != __end)
    {
      __c = *__beg;
      const bool __plus = __c == __lit[__num_base::_S_iplus];
      if (__plus || __c == __lit[__num_base::_S_iminus])
        __xtrc += __plus ? '+' : '-';
      else
        continue;
    }
  else
    {
      __testeof = true;
      break;
    }
       }
     else
       break;

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
      else
 while (!__testeof)
   {


     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       {
  if (!__found_dec && !__found_sci)
    {


      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {


   __xtrc.clear();
   break;
        }
    }
  else
    break;
       }
     else if (__c == __lc->_M_decimal_point)
       {
  if (!__found_dec && !__found_sci)
    {



      if (__found_grouping.size())
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += '.';
      __found_dec = true;
    }
  else
    break;
       }
     else
       {
  const char_type* __q =
    __traits_type::find(__lit_zero, 10, __c);
  if (__q)
    {
      __xtrc += '0' + (__q - __lit_zero);
      __found_mantissa = true;
      ++__sep_pos;
    }
  else if ((__c == __lit[__num_base::_S_ie]
     || __c == __lit[__num_base::_S_iE])
    && !__found_sci && __found_mantissa)
    {

      if (__found_grouping.size() && !__found_dec)
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += 'e';
      __found_sci = true;


      if (++__beg != __end)
        {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping
     && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
        __xtrc += __plus ? '+' : '-';
   else
     continue;
        }
      else
        {
   __testeof = true;
   break;
        }
    }
  else
    break;
       }

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }



      if (__found_grouping.size())
        {

   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);

          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err = ios_base::failbit;
        }

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      __attribute ((__abi_tag__ ("cxx11")))
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;
 char_type __c = char_type();


 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);


 bool __testeof = __beg == __end;


 bool __negative = false;
 if (!__testeof)
   {
     __c = *__beg;
     __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       {
  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }



 bool __found_zero = false;
 int __sep_pos = 0;
 while (!__testeof)
   {
     if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_zero || __base == 10))
       {
  __found_zero = true;
  ++__sep_pos;
  if (__basefield == 0)
    __base = 8;
  if (__base == 8)
    __sep_pos = 0;
       }
     else if (__found_zero
       && (__c == __lit[__num_base::_S_ix]
    || __c == __lit[__num_base::_S_iX]))
       {
  if (__basefield == 0)
    __base = 16;
  if (__base == 16)
    {
      __found_zero = false;
      __sep_pos = 0;
    }
  else
    break;
       }
     else
       break;

     if (++__beg != __end)
       {
  __c = *__beg;
  if (!__found_zero)
    break;
       }
     else
       __testeof = true;
   }



 const size_t __len = (__base == 16 ? __num_base::_S_iend
         - __num_base::_S_izero : __base);


 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 bool __testfail = false;
 bool __testoverflow = false;
 const __unsigned_type __max =
   (__negative && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
   ? -__gnu_cxx::__numeric_traits<_ValueT>::__min
   : __gnu_cxx::__numeric_traits<_ValueT>::__max;
 const __unsigned_type __smax = __max / __base;
 __unsigned_type __result = 0;
 int __digit = 0;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;

 if (!__lc->_M_allocated)

   while (!__testeof)
     {
       __digit = _M_find(__lit_zero, __len, __c);
       if (__digit == -1)
  break;

       if (__result > __smax)
  __testoverflow = true;
       else
  {
    __result *= __base;
    __testoverflow |= __result > __max - __digit;
    __result += __digit;
    ++__sep_pos;
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 else
   while (!__testeof)
     {


       if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  {


    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
      }
    else
      {
        __testfail = true;
        break;
      }
  }
       else if (__c == __lc->_M_decimal_point)
  break;
       else
  {
    const char_type* __q =
      __traits_type::find(__lit_zero, __len, __c);
    if (!__q)
      break;

    __digit = __q - __lit_zero;
    if (__digit > 15)
      __digit -= 6;
    if (__result > __smax)
      __testoverflow = true;
    else
      {
        __result *= __base;
        __testoverflow |= __result > __max - __digit;
        __result += __digit;
        ++__sep_pos;
      }
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }



 if (__found_grouping.size())
   {

     __found_grouping += static_cast<char>(__sep_pos);

     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err = ios_base::failbit;
   }



 if ((!__sep_pos && !__found_zero && !__found_grouping.size())
     || __testfail)
   {
     __v = 0;
     __err = ios_base::failbit;
   }
 else if (__testoverflow)
   {
     if (__negative
  && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__min;
     else
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__max;
     __err = ios_base::failbit;
   }
 else
   __v = __negative ? -__result : __result;

 if (__testeof)
   __err |= ios_base::eofbit;
 return __beg;
      }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {



   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = bool(__l);
   else
     {


       __v = true;
       __err = ios_base::failbit;
       if (__beg == __end)
  __err |= ios_base::eofbit;
     }
        }
      else
        {

   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   bool __testf = true;
   bool __testt = true;
   bool __donef = __lc->_M_falsename_size == 0;
   bool __donet = __lc->_M_truename_size == 0;
   bool __testeof = false;
   size_t __n = 0;
   while (!__donef || !__donet)
     {
       if (__beg == __end)
  {
    __testeof = true;
    break;
  }

       const char_type __c = *__beg;

       if (!__donef)
  __testf = __c == __lc->_M_falsename[__n];

       if (!__testf && __donet)
  break;

       if (!__donet)
  __testt = __c == __lc->_M_truename[__n];

       if (!__testt && __donef)
  break;

       if (!__testt && !__testf)
  break;

       ++__n;
       ++__beg;

       __donef = !__testf || __n >= __lc->_M_falsename_size;
       __donet = !__testt || __n >= __lc->_M_truename_size;
     }
   if (__testf && __n == __lc->_M_falsename_size && __n)
     {
       __v = false;
       if (__testt && __n == __lc->_M_truename_size)
  __err = ios_base::failbit;
       else
  __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else if (__testt && __n == __lc->_M_truename_size && __n)
     {
       __v = true;
       __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else
     {


       __v = false;
       __err = ios_base::failbit;
       if (__testeof)
  __err |= ios_base::eofbit;
     }
 }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
#735 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {

      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags((__fmt & ~ios_base::basefield) | ios_base::hex);

      typedef __gnu_cxx::__conditional_type<(sizeof(void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      _UIntPtrType __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);


      __io.flags(__fmt);

      __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {


      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new,
        __cs, __w, __len);
      __len = static_cast<int>(__w);
    }



  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __dec)
    {
      _CharT* __buf = __bufend;
      if (__builtin_expect(__dec, true))
 {

   do
     {
       *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
 }
      else if ((__flags & ios_base::basefield) == ios_base::oct)
 {

   do
     {
       *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
 }
      else
 {

   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *--__buf = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
 }
      return __bufend - __buf;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base&, _CharT* __new, _CharT* __cs, int& __len) const
    {
      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,
     __grouping_size, __cs, __cs + __len);
      __len = __p - __new;
    }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;
 const ios_base::fmtflags __flags = __io.flags();


 const int __ilen = 5 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));



 const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
 const bool __dec = (__basefield != ios_base::oct
       && __basefield != ios_base::hex);
 const __unsigned_type __u = ((__v > 0 || !__dec)
         ? __unsigned_type(__v)
         : -__unsigned_type(__v));
  int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
 __cs += __ilen - __len;


 if (__lc->_M_use_grouping)
   {


     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * (__len + 1)
          * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
     __cs = __cs2 + 2;
   }


 if (__builtin_expect(__dec, true))
   {

     if (__v >= 0)
       {
  if (bool(__flags & ios_base::showpos)
      && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
    *--__cs = __lit[__num_base::_S_oplus], ++__len;
       }
     else
       *--__cs = __lit[__num_base::_S_ominus], ++__len;
   }
 else if (bool(__flags & ios_base::showbase) && __v)
   {
     if (__basefield == ios_base::oct)
       *--__cs = __lit[__num_base::_S_odigits], ++__len;
     else
       {

  const bool __uppercase = __flags & ios_base::uppercase;
  *--__cs = __lit[__num_base::_S_ox + __uppercase];

  *--__cs = __lit[__num_base::_S_odigits];
  __len += 2;
       }
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);



 return std::__write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {



      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen);


      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
#971 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);


 const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();

 const int __max_digits =
   __gnu_cxx::__numeric_traits<_ValueT>::__digits10;


 int __len;

 char __fbuf[16];
 __num_base::_S_format_float(__io, __fbuf, __mod);



 const bool __use_prec =
   (__io.flags() & ios_base::floatfield) != ios_base::floatfield;



 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
 if (__use_prec)
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     __fbuf, __prec, __v);
 else
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     __fbuf, __v);


 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     if (__use_prec)
       __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
         __fbuf, __prec, __v);
     else
       __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
         __fbuf, __v);
   }
#1044 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.tcc" 3
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __len));
 __ctype.widen(__cs, __cs + __len, __ws);


 _CharT* __wp = 0;
 const char* __p = char_traits<char>::find(__cs, __len, '.');
 if (__p)
   {
     __wp = __ws + (__p - __cs);
     *__wp = __lc->_M_decimal_point;
   }




 if (__lc->_M_use_grouping
     && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'
          && __cs[1] >= '0' && __cs[2] >= '0')))
   {


     _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));

     streamsize __off = 0;
     if (__cs[0] == '-' || __cs[0] == '+')
       {
  __off = 1;
  __ws2[0] = __ws[0];
  __len -= 1;
       }

     _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
      __lc->_M_thousands_sep, __wp, __ws2 + __off,
      __ws + __off, __len);
     __len += __off;

     __ws = __ws2;
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __ws3, __ws, __len);
     __ws = __ws3;
   }
 __io.width(0);



 return std::__write(__s, __ws, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;

   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       const streamsize __plen = __w - __len;
       _CharT* __ps
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __plen));

       char_traits<_CharT>::assign(__ps, __plen, __fill);
       __io.width(0);

       if ((__flags & ios_base::adjustfield) == ios_base::left)
  {
    __s = std::__write(__s, __name, __len);
    __s = std::__write(__s, __ps, __plen);
  }
       else
  {
    __s = std::__write(__s, __ps, __plen);
    __s = std::__write(__s, __name, __len);
  }
       return __s;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }
#1169 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase);
      __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));

      typedef __gnu_cxx::__conditional_type<(sizeof(const void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<_UIntPtrType>(__v));
      __io.flags(__flags);
      return __s;
    }


#1206 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       streamsize __newlen, streamsize __oldlen)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;


      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, __olds, __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }

      size_t __mod = 0;
      if (__adjust == ios_base::internal)
 {



          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

   if (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0])
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }
   else if (__ctype.widen('0') == __olds[0]
     && __oldlen > 1
     && (__ctype.widen('x') == __olds[1]
         || __ctype.widen('X') == __olds[1]))
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }

 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      size_t __idx = 0;
      size_t __ctr = 0;

      while (__last - __first > __gbeg[__idx]
      && static_cast<signed char>(__gbeg[__idx]) > 0
      && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)
 {
   __last -= __gbeg[__idx];
   __idx < __gsize - 1 ? ++__idx : ++__ctr;
 }

      while (__first != __last)
 *__s++ = *__first++;

      while (__ctr--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      while (__idx--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      return __s;
    }




  extern template class __cxx11:: numpunct<char>;
  extern template class __cxx11:: numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class ctype_byname<char>;

  extern template
    const ctype<char>&
    use_facet<ctype<char> >(const locale&);

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);


  extern template class __cxx11:: numpunct<wchar_t>;
  extern template class __cxx11:: numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class ctype_byname<wchar_t>;

  extern template
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale&);

  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);

  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);

  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);

 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);




}
#2652 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 2 3
#38 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 2 3



namespace std
{


  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }
#66 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:






      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;






      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;



    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;


      const __ctype_type* _M_ctype;

      const __num_put_type* _M_num_put;

      const __num_get_type* _M_num_get;

    public:
#117 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      explicit operator bool() const
      { return !this->fail(); }





      bool
      operator!() const
      { return this->fail(); }
#136 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      iostate
      rdstate() const
      { return _M_streambuf_state; }
#147 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      void
      clear(iostate __state = goodbit);







      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }




      void
      _M_setstate(iostate __state)
      {


 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
   throw;
      }







      bool
      good() const
      { return this->rdstate() == 0; }







      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
#200 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }







      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
#221 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      iostate
      exceptions() const
      { return _M_exception; }
#256 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }







      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
 _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }







      virtual
      ~basic_ios() { }
#294 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
#306 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }







      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
#346 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
#360 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      basic_ios&
      copyfmt(const basic_ios& __rhs);







      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
#389 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
#409 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      locale
      imbue(const locale& __loc);
#429 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return __check_facet(_M_ctype).narrow(__c, __dfault); }
#448 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }

    protected:







      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
 _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }







      void
      init(basic_streambuf<_CharT, _Traits>* __sb);


      basic_ios(const basic_ios&) = delete;
      basic_ios& operator=(const basic_ios&) = delete;

      void
      move(basic_ios& __rhs)
      {
 ios_base::_M_move(__rhs);
 _M_cache_locale(_M_ios_locale);
 this->tie(__rhs.tie(nullptr));
 _M_fill = __rhs._M_fill;
 _M_fill_init = __rhs._M_fill_init;
 _M_streambuf = nullptr;
      }

      void
      move(basic_ios&& __rhs)
      { this->move(__rhs); }

      void
      swap(basic_ios& __rhs) noexcept
      {
 ios_base::_M_swap(__rhs);
 _M_cache_locale(_M_ios_locale);
 __rhs._M_cache_locale(__rhs._M_ios_locale);
 std::swap(_M_tie, __rhs._M_tie);
 std::swap(_M_fill, __rhs._M_fill);
 std::swap(_M_fill_init, __rhs._M_fill_init);
      }

      void
      set_rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
      { _M_streambuf = __sb; }


      void
      _M_cache_locale(const locale& __loc);
    };


}

#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.tcc" 1 3
#33 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.tcc" 3

#34 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.tcc" 3

namespace std
{


  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {


      if (this != &__rhs)
 {




   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];


   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();


   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;

   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);

   _M_call_callbacks(copyfmt_event);


   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {

      ios_base::_M_init();


      _M_cache_locale(_M_ios_locale);
#146 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.tcc" 3
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = &use_facet<__ctype_type>(__loc);
      else
 _M_ctype = 0;

      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = &use_facet<__num_put_type>(__loc);
      else
 _M_num_put = 0;

      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = &use_facet<__num_get_type>(__loc);
      else
 _M_num_get = 0;
    }




  extern template class basic_ios<char>;


  extern template class basic_ios<wchar_t>;




}
#517 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 2 3
#45 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ios" 2 3
#39 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ostream" 2 3


namespace std
{

#57 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ostream" 3
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;
#83 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ostream" 3
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }






      virtual
      ~basic_ostream() { }


      class sentry;
      friend class sentry;
#107 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ostream" 3
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&))
      {



 return __pf(*this);
      }

      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&))
      {



 __pf(*this);
 return *this;
      }

      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&))
      {



 __pf(*this);
 return *this;
      }
#165 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ostream" 3
      __ostream_type&
      operator<<(long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(bool __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(short __n);

      __ostream_type&
      operator<<(unsigned short __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }

      __ostream_type&
      operator<<(int __n);

      __ostream_type&
      operator<<(unsigned int __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }


      __ostream_type&
      operator<<(long long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }
#219 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ostream" 3
      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(float __f)
      {


 return _M_insert(static_cast<double>(__f));
      }

      __ostream_type&
      operator<<(long double __f)
      { return _M_insert(__f); }
#244 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ostream" 3
      __ostream_type&
      operator<<(const void* __p)
      { return _M_insert(__p); }
#269 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ostream" 3
      __ostream_type&
      operator<<(__streambuf_type* __sb);
#302 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ostream" 3
      __ostream_type&
      put(char_type __c);






      void
      _M_write(const char_type* __s, streamsize __n)
      {
 const streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }
#334 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ostream" 3
      __ostream_type&
      write(const char_type* __s, streamsize __n);
#347 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ostream" 3
      __ostream_type&
      flush();
#357 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ostream" 3
      pos_type
      tellp();
#368 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ostream" 3
      __ostream_type&
      seekp(pos_type);
#380 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ostream" 3
       __ostream_type&
      seekp(off_type, ios_base::seekdir);

    protected:
      basic_ostream()
      { this->init(0); }



      basic_ostream(basic_iostream<_CharT, _Traits>&) { }

      basic_ostream(const basic_ostream&) = delete;

      basic_ostream(basic_ostream&& __rhs)
      : __ios_type()
      { __ios_type::move(__rhs); }



      basic_ostream& operator=(const basic_ostream&) = delete;

      basic_ostream&
      operator=(basic_ostream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_ostream& __rhs)
      { __ios_type::swap(__rhs); }


      template<typename _ValueT>
 __ostream_type&
 _M_insert(_ValueT __v);
    };
#425 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ostream" 3
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {

      bool _M_ok;
      basic_ostream<_CharT, _Traits>& _M_os;

    public:
#444 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ostream" 3
      explicit
      sentry(basic_ostream<_CharT, _Traits>& __os);
#454 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ostream" 3
      ~sentry()
      {

 if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())
   {

     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
#473 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ostream" 3
      explicit

      operator bool() const
      { return _M_ok; }
    };
#495 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    { return __ostream_insert(__out, &__c, 1); }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }


  template <class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    { return __ostream_insert(__out, &__c, 1); }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
#537 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
#588 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
#600 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }






  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }
#626 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ostream" 3
  template<typename _CharT, typename _Traits, typename _Tp>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>&& __os, const _Tp& __x)
    {
      __os << __x;
      return __os;
    }



}

#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/ostream.tcc" 1 3
#37 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/ostream.tcc" 3

#38 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/ostream.tcc" 3



namespace std
{


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {

      if (__os.tie() && __os.good())
 __os.tie()->flush();

      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_ostream<_CharT, _Traits>&
      basic_ostream<_CharT, _Traits>::
      _M_insert(_ValueT __v)
      {
 sentry __cerb(*this);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_put_type& __np = __check_facet(this->_M_num_put);
  if (__np.put(*this, *this, this->fill(), __v).failed())
    __err |= ios_base::badbit;
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(short __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(int __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   try
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {






      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {







      sentry __cerb(*this);
      if (__cerb)
 {
   try
     { _M_write(__s, __n); }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {



      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 {


   const size_t __clen = char_traits<char>::length(__s);
   try
     {
       struct __ptr_guard
       {
  _CharT *__p;
  __ptr_guard (_CharT *__ip): __p(__ip) { }
  ~__ptr_guard() { delete[] __p; }
  _CharT* __get() { return __p; }
       } __pg (new _CharT[__clen]);

       _CharT *__ws = __pg.__get();
       for (size_t __i = 0; __i < __clen; ++__i)
  __ws[__i] = __out.widen(__s[__i]);
       __ostream_insert(__out, __ws, __clen);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
    }




  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);

  extern template ostream& ostream::_M_insert(long);
  extern template ostream& ostream::_M_insert(unsigned long);
  extern template ostream& ostream::_M_insert(bool);

  extern template ostream& ostream::_M_insert(long long);
  extern template ostream& ostream::_M_insert(unsigned long long);

  extern template ostream& ostream::_M_insert(double);
  extern template ostream& ostream::_M_insert(long double);
  extern template ostream& ostream::_M_insert(const void*);


  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);

  extern template wostream& wostream::_M_insert(long);
  extern template wostream& wostream::_M_insert(unsigned long);
  extern template wostream& wostream::_M_insert(bool);

  extern template wostream& wostream::_M_insert(long long);
  extern template wostream& wostream::_M_insert(unsigned long long);

  extern template wostream& wostream::_M_insert(double);
  extern template wostream& wostream::_M_insert(long double);
  extern template wostream& wostream::_M_insert(const void*);




}
#639 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ostream" 2 3
#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/iostream" 2 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/istream" 1 3
#36 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/istream" 3

#37 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/istream" 3




namespace std
{

#57 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;

    protected:





      streamsize _M_gcount;

    public:







      explicit
      basic_istream(__streambuf_type* __sb)
      : _M_gcount(streamsize(0))
      { this->init(__sb); }






      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }


      class sentry;
      friend class sentry;
#119 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&))
      { return __pf(*this); }

      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&))
      {
 __pf(*this);
 return *this;
      }

      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&))
      {
 __pf(*this);
 return *this;
      }
#167 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      operator>>(bool& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(long long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long long& __n)
      { return _M_extract(__n); }
#213 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      operator>>(float& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(long double& __f)
      { return _M_extract(__f); }
#234 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      operator>>(void*& __p)
      { return _M_extract(__p); }
#258 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      operator>>(__streambuf_type* __sb);
#268 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/istream" 3
      streamsize
      gcount() const
      { return _M_gcount; }
#301 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/istream" 3
      int_type
      get();
#315 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      get(char_type& __c);
#342 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
#353 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
#376 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
#386 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
#415 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
#426 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
#450 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      ignore(streamsize __n, int_type __delim);

      __istream_type&
      ignore(streamsize __n);

      __istream_type&
      ignore();
#467 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/istream" 3
      int_type
      peek();
#485 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      read(char_type* __s, streamsize __n);
#504 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/istream" 3
      streamsize
      readsome(char_type* __s, streamsize __n);
#521 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      putback(char_type __c);
#537 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      unget();
#555 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/istream" 3
      int
      sync();
#570 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/istream" 3
      pos_type
      tellg();
#585 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      seekg(pos_type);
#601 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      seekg(off_type, ios_base::seekdir);


    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }


      basic_istream(const basic_istream&) = delete;

      basic_istream(basic_istream&& __rhs)
      : __ios_type(), _M_gcount(__rhs._M_gcount)
      {
 __ios_type::move(__rhs);
 __rhs._M_gcount = 0;
      }



      basic_istream& operator=(const basic_istream&) = delete;

      basic_istream&
      operator=(basic_istream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_istream& __rhs)
      {
 __ios_type::swap(__rhs);
 std::swap(_M_gcount, __rhs._M_gcount);
      }


      template<typename _ValueT>
 __istream_type&
 _M_extract(_ValueT& __v);
    };


  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);


  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n, int_type __delim);
#685 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {

      bool _M_ok;

    public:

      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
#721 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/istream" 3
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
#732 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/istream" 3
      explicit

      operator bool() const
      { return _M_ok; }
    };
#750 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
#792 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);


  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __in, char* __s);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
#823 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:



      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;







      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(__sb), __ostream_type(__sb) { }




      virtual
      ~basic_iostream() { }

    protected:
      basic_iostream()
      : __istream_type(), __ostream_type() { }


      basic_iostream(const basic_iostream&) = delete;

      basic_iostream(basic_iostream&& __rhs)
      : __istream_type(std::move(__rhs)), __ostream_type(*this)
      { }



      basic_iostream& operator=(const basic_iostream&) = delete;

      basic_iostream&
      operator=(basic_iostream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_iostream& __rhs)
      { __istream_type::swap(__rhs); }

    };
#906 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);
#922 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/istream" 3
  template<typename _CharT, typename _Traits, typename _Tp>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>&& __is, _Tp& __x)
    {
      __is >> __x;
      return __is;
    }



}

#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/istream.tcc" 1 3
#37 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/istream.tcc" 3

#38 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/istream.tcc" 3



namespace std
{


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::goodbit;
      if (__in.good())
 {
   if (__in.tie())
     __in.tie()->flush();
   if (!__noskip && bool(__in.flags() & ios_base::skipws))
     {
       const __int_type __eof = traits_type::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();

       const __ctype_type& __ct = __check_facet(__in._M_ctype);
       while (!traits_type::eq_int_type(__c, __eof)
       && __ct.is(ctype_base::space,
    traits_type::to_char_type(__c)))
  __c = __sb->snextc();




       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
 }

      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_istream<_CharT, _Traits>&
      basic_istream<_CharT, _Traits>::
      _M_extract(_ValueT& __v)
      {
 sentry __cerb(*this, false);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_get_type& __ng = __check_facet(this->_M_num_get);
  __ng.get(*this, 0, *this, __err, __v);
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<short>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<short>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__max;
  }
       else
  __n = short(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<int>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<int>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__max;
  }
       else
  __n = int(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   try
     {
       bool __ineof;
       if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
  __err |= ios_base::failbit;
       if (__ineof)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::failbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       __c = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __cb = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();

       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);

       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++_M_gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
        }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }




  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();

       if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
  __err |= ios_base::eofbit;
       else
  _M_gcount = 1;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
#513 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/istream.tcc" 3
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

       if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();


       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof)
    && !traits_type::eq_int_type(__c, __delim))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof)
        && !traits_type::eq_int_type(__c, __delim))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
       else if (traits_type::eq_int_type(__c, __delim))
  {
    if (_M_gcount
        < __gnu_cxx::__numeric_traits<streamsize>::__max)
      ++_M_gcount;
    __sb->sbumpc();
  }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {

       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {


      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {


      pos_type __ret = pos_type(-1);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       if (!this->fail())
  __ret = this->rdbuf()->pubseekoff(0, ios_base::cur,
        ios_base::in);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekpos(__pos,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;

      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       streamsize __num = __in.width();
       if (__num <= 0)
  __num = __gnu_cxx::__numeric_traits<streamsize>::__max;

       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());

       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();

       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;



       *__s = char_type();
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename __istream_type::int_type __int_type;
      typedef ctype<_CharT> __ctype_type;

      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }




  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);

  extern template istream& istream::_M_extract(unsigned short&);
  extern template istream& istream::_M_extract(unsigned int&);
  extern template istream& istream::_M_extract(long&);
  extern template istream& istream::_M_extract(unsigned long&);
  extern template istream& istream::_M_extract(bool&);

  extern template istream& istream::_M_extract(long long&);
  extern template istream& istream::_M_extract(unsigned long long&);

  extern template istream& istream::_M_extract(float&);
  extern template istream& istream::_M_extract(double&);
  extern template istream& istream::_M_extract(long double&);
  extern template istream& istream::_M_extract(void*&);

  extern template class basic_iostream<char>;


  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);

  extern template wistream& wistream::_M_extract(unsigned short&);
  extern template wistream& wistream::_M_extract(unsigned int&);
  extern template wistream& wistream::_M_extract(long&);
  extern template wistream& wistream::_M_extract(unsigned long&);
  extern template wistream& wistream::_M_extract(bool&);

  extern template wistream& wistream::_M_extract(long long&);
  extern template wistream& wistream::_M_extract(unsigned long long&);

  extern template wistream& wistream::_M_extract(float&);
  extern template wistream& wistream::_M_extract(double&);
  extern template wistream& wistream::_M_extract(long double&);
  extern template wistream& wistream::_M_extract(void*&);

  extern template class basic_iostream<wchar_t>;




}
#935 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/istream" 2 3
#41 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/iostream" 2 3

namespace std
{

#60 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/iostream" 3
  extern istream cin;
  extern ostream cout;
  extern ostream cerr;
  extern ostream clog;


  extern wistream wcin;
  extern wostream wcout;
  extern wostream wcerr;
  extern wostream wclog;




  static ios_base::Init __ioinit;


}
#212 "C:/Xilinx/Vivado/2018.3/include/hls_half.h" 2

#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/climits" 1 3
#39 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/climits" 3

#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/climits" 3


#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include-fixed/limits.h" 1 3 4
#43 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/climits" 2 3
#214 "C:/Xilinx/Vivado/2018.3/include/hls_half.h" 2

#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstring" 1 3
#39 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstring" 3

#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstring" 3


#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/string.h" 1 3
#21 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/string.h" 3
extern "C" {
#45 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/string.h" 3
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _memccpy(void *_Dst,const void *_Src,int _Val,size_t _MaxCount);
  void *__attribute__((__cdecl__)) memchr(const void *_Buf ,int _Val,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _memicmp(const void *_Buf1,const void *_Buf2,size_t _Size);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _memicmp_l(const void *_Buf1,const void *_Buf2,size_t _Size,_locale_t _Locale);
  int __attribute__((__cdecl__)) memcmp(const void *_Buf1,const void *_Buf2,size_t _Size);
  void * __attribute__((__cdecl__)) memcpy(void * __restrict__ _Dst,const void * __restrict__ _Src,size_t _Size) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) memcpy_s (void *_dest,size_t _numberOfElements,const void *_src,size_t _count);
  void * __attribute__((__cdecl__)) mempcpy (void *_Dst, const void *_Src, size_t _Size);
  void * __attribute__((__cdecl__)) memset(void *_Dst,int _Val,size_t _Size);

  void * __attribute__((__cdecl__)) memccpy(void *_Dst,const void *_Src,int _Val,size_t _Size) ;
  int __attribute__((__cdecl__)) memicmp(const void *_Buf1,const void *_Buf2,size_t _Size) ;


  char * __attribute__((__cdecl__)) _strset(char *_Str,int _Val) ;
  char * __attribute__((__cdecl__)) _strset_l(char *_Str,int _Val,_locale_t _Locale) ;
  char * __attribute__((__cdecl__)) strcpy(char * __restrict__ _Dest,const char * __restrict__ _Source);
  char * __attribute__((__cdecl__)) strcat(char * __restrict__ _Dest,const char * __restrict__ _Source);
  int __attribute__((__cdecl__)) strcmp(const char *_Str1,const char *_Str2);
  size_t __attribute__((__cdecl__)) strlen(const char *_Str);
  size_t __attribute__((__cdecl__)) strnlen(const char *_Str,size_t _MaxCount);
  void *__attribute__((__cdecl__)) memmove(void *_Dst,const void *_Src,size_t _Size) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strdup(const char *_Src);
  char *__attribute__((__cdecl__)) strchr(const char *_Str,int _Val);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _stricmp(const char *_Str1,const char *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strcmpi(const char *_Str1,const char *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _stricmp_l(const char *_Str1,const char *_Str2,_locale_t _Locale);
  int __attribute__((__cdecl__)) strcoll(const char *_Str1,const char *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strcoll_l(const char *_Str1,const char *_Str2,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _stricoll(const char *_Str1,const char *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _stricoll_l(const char *_Str1,const char *_Str2,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strncoll (const char *_Str1,const char *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strncoll_l(const char *_Str1,const char *_Str2,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strnicoll (const char *_Str1,const char *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strnicoll_l(const char *_Str1,const char *_Str2,size_t _MaxCount,_locale_t _Locale);
  size_t __attribute__((__cdecl__)) strcspn(const char *_Str,const char *_Control);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strerror(const char *_ErrMsg) ;
  char *__attribute__((__cdecl__)) strerror(int) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strlwr(char *_String) ;
  char *strlwr_l(char *_String,_locale_t _Locale) ;
  char *__attribute__((__cdecl__)) strncat(char * __restrict__ _Dest,const char * __restrict__ _Source,size_t _Count) ;
  int __attribute__((__cdecl__)) strncmp(const char *_Str1,const char *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strnicmp(const char *_Str1,const char *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strnicmp_l(const char *_Str1,const char *_Str2,size_t _MaxCount,_locale_t _Locale);
  char *strncpy(char * __restrict__ _Dest,const char * __restrict__ _Source,size_t _Count) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strnset(char *_Str,int _Val,size_t _MaxCount) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strnset_l(char *str,int c,size_t count,_locale_t _Locale) ;
  char *__attribute__((__cdecl__)) strpbrk(const char *_Str,const char *_Control);
  char *__attribute__((__cdecl__)) strrchr(const char *_Str,int _Ch);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strrev(char *_Str);
  size_t __attribute__((__cdecl__)) strspn(const char *_Str,const char *_Control);
  char *__attribute__((__cdecl__)) strstr(const char *_Str,const char *_SubStr);
  char *__attribute__((__cdecl__)) strtok(char * __restrict__ _Str,const char * __restrict__ _Delim) ;


  char *strtok_r(char * __restrict__ _Str, const char * __restrict__ _Delim, char ** __restrict__ __last);

  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strupr(char *_String) ;
  __attribute__ ((__dllimport__)) char *_strupr_l(char *_String,_locale_t _Locale) ;
  size_t __attribute__((__cdecl__)) strxfrm(char * __restrict__ _Dst,const char * __restrict__ _Src,size_t _MaxCount);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _strxfrm_l(char * __restrict__ _Dst,const char * __restrict__ _Src,size_t _MaxCount,_locale_t _Locale);


  char *__attribute__((__cdecl__)) strdup(const char *_Src) ;
  int __attribute__((__cdecl__)) strcmpi(const char *_Str1,const char *_Str2) ;
  int __attribute__((__cdecl__)) stricmp(const char *_Str1,const char *_Str2) ;
  char *__attribute__((__cdecl__)) strlwr(char *_Str) ;
  int __attribute__((__cdecl__)) strnicmp(const char *_Str1,const char *_Str,size_t _MaxCount) ;
  int __attribute__((__cdecl__)) strncasecmp (const char *, const char *, size_t);
  int __attribute__((__cdecl__)) strcasecmp (const char *, const char *);







  char *__attribute__((__cdecl__)) strnset(char *_Str,int _Val,size_t _MaxCount) ;
  char *__attribute__((__cdecl__)) strrev(char *_Str) ;
  char *__attribute__((__cdecl__)) strset(char *_Str,int _Val) ;
  char *__attribute__((__cdecl__)) strupr(char *_Str) ;
#187 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/string.h" 3
}


#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/string_s.h" 1 3
#9 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/string_s.h" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/string.h" 1 3
#10 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/string_s.h" 2 3
#23 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/string_s.h" 3
extern "C" {


  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strset_s(char *_Dst,size_t _DstSize,int _Value);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strerror_s(char *_Buf,size_t _SizeInBytes,const char *_ErrMsg);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) strerror_s(char *_Buf,size_t _SizeInBytes,int _ErrNum);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strlwr_s(char *_Str,size_t _Size);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strlwr_s_l(char *_Str,size_t _Size,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strnset_s(char *_Str,size_t _Size,int _Val,size_t _MaxCount);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strupr_s(char *_Str,size_t _Size);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strupr_s_l(char *_Str,size_t _Size,_locale_t _Locale);

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) strncat_s(char *_Dst,size_t _DstSizeInChars,const char *_Src,size_t _MaxCount);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strncat_s_l(char *_Dst,size_t _DstSizeInChars,const char *_Src,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) strcpy_s(char *_Dst, rsize_t _SizeInBytes, const char *_Src);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) strcpy_s(char (&_Dest)[__size], const char * _Source) { return strcpy_s(_Dest,__size,_Source); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) strncpy_s(char *_Dst, size_t _DstSizeInChars, const char *_Src, size_t _MaxCount);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) strncpy_s(char (&_Dest)[__size], const char * _Source, size_t _MaxCount) { return strncpy_s(_Dest,__size,_Source,_MaxCount); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strncpy_s_l(char *_Dst, size_t _DstSizeInChars, const char *_Src, size_t _MaxCount, _locale_t _Locale);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _strncpy_s_l(char (&_Dest)[__size], const char * _Source, size_t _MaxCount, _locale_t _Locale) { return _strncpy_s_l(_Dest,__size,_Source,_MaxCount,_Locale); } };
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) strtok_s(char *_Str,const char *_Delim,char **_Context);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strtok_s_l(char *_Str,const char *_Delim,char **_Context,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) strcat_s(char *_Dst, rsize_t _SizeInBytes, const char * _Src);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) strcat_s(char (&_Dest)[__size], const char * _Source) { return strcat_s(_Dest,__size,_Source); } }

  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) memmove_s(void *_dest,size_t _numberOfElements,const void *_src,size_t _count);
#82 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/string_s.h" 3
}
#191 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/string.h" 2 3
#43 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstring" 2 3
#71 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstring" 3
namespace std
{


  using ::memchr;
  using ::memcmp;
  using ::memcpy;
  using ::memmove;
  using ::memset;
  using ::strcat;
  using ::strcmp;
  using ::strcoll;
  using ::strcpy;
  using ::strcspn;
  using ::strerror;
  using ::strlen;
  using ::strncat;
  using ::strncmp;
  using ::strncpy;
  using ::strspn;
  using ::strtok;
  using ::strxfrm;
  using ::strchr;
  using ::strpbrk;
  using ::strrchr;
  using ::strstr;


  inline void*
  memchr(void* __s, int __c, size_t __n)
  { return __builtin_memchr(__s, __c, __n); }

  inline char*
  strchr(char* __s, int __n)
  { return __builtin_strchr(__s, __n); }

  inline char*
  strpbrk(char* __s1, const char* __s2)
  { return __builtin_strpbrk(__s1, __s2); }

  inline char*
  strrchr(char* __s, int __n)
  { return __builtin_strrchr(__s, __n); }

  inline char*
  strstr(char* __s1, const char* __s2)
  { return __builtin_strstr(__s1, __s2); }



}
#216 "C:/Xilinx/Vivado/2018.3/include/hls_half.h" 2







#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/functional" 1 3
#46 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/functional" 3

#47 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/functional" 3






#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/typeinfo" 1 3
#32 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/typeinfo" 3

#33 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/typeinfo" 3






#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
#80 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();



    const char* name() const noexcept
    { return __name[0] == '*' ? __name + 1 : __name; }





    bool before(const type_info& __arg) const noexcept;
    bool operator==(const type_info& __arg) const noexcept;
#136 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/typeinfo" 3
    bool operator!=(const type_info& __arg) const noexcept
    { return !operator==(__arg); }


    size_t hash_code() const noexcept
    {

      return _Hash_bytes(name(), __builtin_strlen(name()),
    static_cast<size_t>(0xc70f6907UL));



    }



    virtual bool __is_pointer_p() const;


    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;

  protected:
    const char *__name;

    explicit type_info(const char *__n): __name(__n) { }

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);
  };







  class bad_cast : public exception
  {
  public:
    bad_cast() noexcept { }



    virtual ~bad_cast() noexcept;


    virtual const char* what() const noexcept;
  };





  class bad_typeid : public exception
  {
  public:
    bad_typeid () noexcept { }



    virtual ~bad_typeid() noexcept;


    virtual const char* what() const noexcept;
  };
}

}

#pragma GCC visibility pop
#54 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/functional" 2 3

#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/tuple" 1 3
#32 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/tuple" 3

#33 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/tuple" 3






#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/array" 1 3
#32 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/array" 3

#33 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/array" 3
#43 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/array" 3
namespace std
{


  template<typename _Tp, std::size_t _Nm>
    struct __array_traits
    {
      typedef _Tp _Type[_Nm];

      static constexpr _Tp&
      _S_ref(const _Type& __t, std::size_t __n) noexcept
      { return const_cast<_Tp&>(__t[__n]); }

      static constexpr _Tp*
      _S_ptr(const _Type& __t) noexcept
      { return const_cast<_Tp*>(__t); }
    };

 template<typename _Tp>
   struct __array_traits<_Tp, 0>
   {
     struct _Type { };

     static constexpr _Tp&
     _S_ref(const _Type&, std::size_t) noexcept
     { return *static_cast<_Tp*>(nullptr); }

     static constexpr _Tp*
     _S_ptr(const _Type&) noexcept
     { return nullptr; }
   };
#89 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/array" 3
  template<typename _Tp, std::size_t _Nm>
    struct array
    {
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef value_type* iterator;
      typedef const value_type* const_iterator;
      typedef std::size_t size_type;
      typedef std::ptrdiff_t difference_type;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;


      typedef std::__array_traits<_Tp, _Nm> _AT_Type;
      typename _AT_Type::_Type _M_elems;




      void
      fill(const value_type& __u)
      { std::fill_n(begin(), size(), __u); }

      void
      swap(array& __other)
      noexcept(__is_nothrow_swappable<_Tp>::value)
      { std::swap_ranges(begin(), end(), __other.begin()); }


      iterator
      begin() noexcept
      { return iterator(data()); }

      const_iterator
      begin() const noexcept
      { return const_iterator(data()); }

      iterator
      end() noexcept
      { return iterator(data() + _Nm); }

      const_iterator
      end() const noexcept
      { return const_iterator(data() + _Nm); }

      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }

      const_iterator
      cbegin() const noexcept
      { return const_iterator(data()); }

      const_iterator
      cend() const noexcept
      { return const_iterator(data() + _Nm); }

      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }

      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }


      constexpr size_type
      size() const noexcept { return _Nm; }

      constexpr size_type
      max_size() const noexcept { return _Nm; }

      constexpr bool
      empty() const noexcept { return size() == 0; }


      reference
      operator[](size_type __n) noexcept
      { return _AT_Type::_S_ref(_M_elems, __n); }

      constexpr const_reference
      operator[](size_type __n) const noexcept
      { return _AT_Type::_S_ref(_M_elems, __n); }

      reference
      at(size_type __n)
      {
 if (__n >= _Nm)
   std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) " ">= _Nm (which is %zu)")
                                 ,
     __n, _Nm);
 return _AT_Type::_S_ref(_M_elems, __n);
      }

      constexpr const_reference
      at(size_type __n) const
      {


 return __n < _Nm ? _AT_Type::_S_ref(_M_elems, __n)
   : (std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) " ">= _Nm (which is %zu)")
                                    ,
        __n, _Nm),
      _AT_Type::_S_ref(_M_elems, 0));
      }

      reference
      front() noexcept
      { return *begin(); }

      constexpr const_reference
      front() const noexcept
      { return _AT_Type::_S_ref(_M_elems, 0); }

      reference
      back() noexcept
      { return _Nm ? *(end() - 1) : *end(); }

      constexpr const_reference
      back() const noexcept
      {
 return _Nm ? _AT_Type::_S_ref(_M_elems, _Nm - 1)
             : _AT_Type::_S_ref(_M_elems, 0);
      }

      pointer
      data() noexcept
      { return _AT_Type::_S_ptr(_M_elems); }

      const_pointer
      data() const noexcept
      { return _AT_Type::_S_ptr(_M_elems); }
    };


  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator==(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return std::equal(__one.begin(), __one.end(), __two.begin()); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one == __two); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator<(const array<_Tp, _Nm>& __a, const array<_Tp, _Nm>& __b)
    {
      return std::lexicographical_compare(__a.begin(), __a.end(),
       __b.begin(), __b.end());
    }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator>(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return __two < __one; }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator<=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one > __two); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator>=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one < __two); }


  template<typename _Tp, std::size_t _Nm>
    inline void
    swap(array<_Tp, _Nm>& __one, array<_Tp, _Nm>& __two)
    noexcept(noexcept(__one.swap(__two)))
    { __one.swap(__two); }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr _Tp&
    get(array<_Tp, _Nm>& __arr) noexcept
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      return std::__array_traits<_Tp, _Nm>::
 _S_ref(__arr._M_elems, _Int);
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr _Tp&&
    get(array<_Tp, _Nm>&& __arr) noexcept
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      return std::move(std::get<_Int>(__arr));
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr const _Tp&
    get(const array<_Tp, _Nm>& __arr) noexcept
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      return std::__array_traits<_Tp, _Nm>::
 _S_ref(__arr._M_elems, _Int);
    }


}

namespace std
{





  template<typename _Tp>
    class tuple_size;


  template<typename _Tp, std::size_t _Nm>
    struct tuple_size<std::array<_Tp, _Nm>>
    : public integral_constant<std::size_t, _Nm> { };


  template<std::size_t _Int, typename _Tp>
    class tuple_element;


  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    struct tuple_element<_Int, std::array<_Tp, _Nm>>
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      typedef _Tp type;
    };

  template<typename _Tp, std::size_t _Nm>
    struct __is_tuple_like_impl<std::array<_Tp, _Nm>> : true_type
    { };


}
#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/tuple" 2 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/uses_allocator.h" 1 3
#35 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/uses_allocator.h" 3
namespace std
{


  struct __erased_type { };

  template<typename _Alloc, typename _Tp>
    using __is_erased_or_convertible
      = __or_<is_same<_Tp, __erased_type>, is_convertible<_Alloc, _Tp>>;


  struct allocator_arg_t { explicit allocator_arg_t() = default; };

  constexpr allocator_arg_t allocator_arg = allocator_arg_t();

  template<typename _Tp, typename _Alloc, typename = __void_t<>>
    struct __uses_allocator_helper
    : false_type { };

  template<typename _Tp, typename _Alloc>
    struct __uses_allocator_helper<_Tp, _Alloc,
       __void_t<typename _Tp::allocator_type>>
    : __is_erased_or_convertible<_Alloc, typename _Tp::allocator_type>::type
    { };


  template<typename _Tp, typename _Alloc>
    struct uses_allocator
    : __uses_allocator_helper<_Tp, _Alloc>::type
    { };

  struct __uses_alloc_base { };

  struct __uses_alloc0 : __uses_alloc_base
  {
    struct _Sink { void operator=(const void*) { } } _M_a;
  };

  template<typename _Alloc>
    struct __uses_alloc1 : __uses_alloc_base { const _Alloc* _M_a; };

  template<typename _Alloc>
    struct __uses_alloc2 : __uses_alloc_base { const _Alloc* _M_a; };

  template<bool, typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc;

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<true, _Tp, _Alloc, _Args...>
    : conditional<
        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value,
        __uses_alloc1<_Alloc>,
        __uses_alloc2<_Alloc>>::type
    {
      static_assert(__or_<
   is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>,
   is_constructible<_Tp, _Args..., _Alloc>>::value, "construction with"
   " an allocator must be possible if uses_allocator is true");
    };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<false, _Tp, _Alloc, _Args...>
    : __uses_alloc0 { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    using __uses_alloc_t =
      __uses_alloc<uses_allocator<_Tp, _Alloc>::value, _Tp, _Alloc, _Args...>;

  template<typename _Tp, typename _Alloc, typename... _Args>
    inline __uses_alloc_t<_Tp, _Alloc, _Args...>
    __use_alloc(const _Alloc& __a)
    {
      __uses_alloc_t<_Tp, _Alloc, _Args...> __ret;
      __ret._M_a = std::__addressof(__a);
      return __ret;
    }


}
#41 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/tuple" 2 3

namespace std
{







  template<std::size_t _Idx, typename _Head, bool _IsEmptyNotFinal>
    struct _Head_base;

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, true>
    : public _Head
    {
      constexpr _Head_base()
      : _Head() { }

      constexpr _Head_base(const _Head& __h)
      : _Head(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
 : _Head(std::forward<_UHead>(__h)) { }

      _Head_base(allocator_arg_t, __uses_alloc0)
      : _Head() { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _Head(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _Head(*__a._M_a) { }

      template<typename _UHead>
 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _Head(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _Head(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _Head(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b; }
    };

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, false>
    {
      constexpr _Head_base()
      : _M_head_impl() { }

      constexpr _Head_base(const _Head& __h)
      : _M_head_impl(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
 : _M_head_impl(std::forward<_UHead>(__h)) { }

      _Head_base(allocator_arg_t, __uses_alloc0)
      : _M_head_impl() { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _M_head_impl(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _M_head_impl(*__a._M_a) { }

      template<typename _UHead>
 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead))
 { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b._M_head_impl; }

      _Head _M_head_impl;
    };
#158 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/tuple" 3
  template<std::size_t _Idx, typename... _Elements>
    struct _Tuple_impl;

  template<typename _Tp>
    struct __is_empty_non_tuple : is_empty<_Tp> { };


  template<typename _El0, typename... _El>
    struct __is_empty_non_tuple<tuple<_El0, _El...>> : false_type { };


  template<typename _Tp>
    using __empty_not_final
    = typename conditional<__is_final(_Tp), false_type,
      __is_empty_non_tuple<_Tp>>::type;






  template<std::size_t _Idx, typename _Head, typename... _Tail>
    struct _Tuple_impl<_Idx, _Head, _Tail...>
    : public _Tuple_impl<_Idx + 1, _Tail...>,
      private _Head_base<_Idx, _Head, __empty_not_final<_Head>::value>
    {
      template<std::size_t, typename...> friend class _Tuple_impl;

      typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;
      typedef _Head_base<_Idx, _Head, __empty_not_final<_Head>::value> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr _Inherited&
      _M_tail(_Tuple_impl& __t) noexcept { return __t; }

      static constexpr const _Inherited&
      _M_tail(const _Tuple_impl& __t) noexcept { return __t; }

      constexpr _Tuple_impl()
      : _Inherited(), _Base() { }

      explicit
      constexpr _Tuple_impl(const _Head& __head, const _Tail&... __tail)
      : _Inherited(__tail...), _Base(__head) { }

      template<typename _UHead, typename... _UTail, typename = typename
               enable_if<sizeof...(_Tail) == sizeof...(_UTail)>::type>
        explicit
        constexpr _Tuple_impl(_UHead&& __head, _UTail&&... __tail)
 : _Inherited(std::forward<_UTail>(__tail)...),
   _Base(std::forward<_UHead>(__head)) { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;

      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(__and_<is_nothrow_move_constructible<_Head>,
               is_nothrow_move_constructible<_Inherited>>::value)
      : _Inherited(std::move(_M_tail(__in))),
 _Base(std::forward<_Head>(_M_head(__in))) { }

      template<typename... _UElements>
        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }

      template<typename _UHead, typename... _UTails>
        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a),
          _Base(__tag, __use_alloc<_Head>(__a)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Head& __head, const _Tail&... __tail)
 : _Inherited(__tag, __a, __tail...),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }

      template<typename _Alloc, typename _UHead, typename... _UTail,
               typename = typename enable_if<sizeof...(_Tail)
          == sizeof...(_UTail)>::type>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _UHead&& __head, _UTail&&... __tail)
 : _Inherited(__tag, __a, std::forward<_UTail>(__tail)...),
          _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
         std::forward<_UHead>(__head)) { }

      template<typename _Alloc>
        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl& __in)
 : _Inherited(__tag, __a, _M_tail(__in)),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl&& __in)
 : _Inherited(__tag, __a, std::move(_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
         std::forward<_Head>(_M_head(__in))) { }

      template<typename _Alloc, typename... _UElements>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(__tag, __a,
       _Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  _Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }

      template<typename _Alloc, typename _UHead, typename... _UTails>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(__tag, __a, std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }

      _Tuple_impl&
      operator=(const _Tuple_impl& __in)
      {
 _M_head(*this) = _M_head(__in);
 _M_tail(*this) = _M_tail(__in);
 return *this;
      }

      _Tuple_impl&
      operator=(_Tuple_impl&& __in)
      noexcept(__and_<is_nothrow_move_assignable<_Head>,
               is_nothrow_move_assignable<_Inherited>>::value)
      {
 _M_head(*this) = std::forward<_Head>(_M_head(__in));
 _M_tail(*this) = std::move(_M_tail(__in));
 return *this;
      }

      template<typename... _UElements>
        _Tuple_impl&
        operator=(const _Tuple_impl<_Idx, _UElements...>& __in)
        {
   _M_head(*this) = _Tuple_impl<_Idx, _UElements...>::_M_head(__in);
   _M_tail(*this) = _Tuple_impl<_Idx, _UElements...>::_M_tail(__in);
   return *this;
 }

      template<typename _UHead, typename... _UTails>
        _Tuple_impl&
        operator=(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
        {
   _M_head(*this) = std::forward<_UHead>
     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in));
   _M_tail(*this) = std::move
     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in));
   return *this;
 }

    protected:
      void
      _M_swap(_Tuple_impl& __in)
      noexcept(__is_nothrow_swappable<_Head>::value
               && noexcept(_M_tail(__in)._M_swap(_M_tail(__in))))
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
 _Inherited::_M_swap(_M_tail(__in));
      }
    };


  template<std::size_t _Idx, typename _Head>
    struct _Tuple_impl<_Idx, _Head>
    : private _Head_base<_Idx, _Head, __empty_not_final<_Head>::value>
    {
      template<std::size_t, typename...> friend class _Tuple_impl;

      typedef _Head_base<_Idx, _Head, __empty_not_final<_Head>::value> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      constexpr _Tuple_impl()
      : _Base() { }

      explicit
      constexpr _Tuple_impl(const _Head& __head)
      : _Base(__head) { }

      template<typename _UHead>
        explicit
        constexpr _Tuple_impl(_UHead&& __head)
 : _Base(std::forward<_UHead>(__head)) { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;

      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(is_nothrow_move_constructible<_Head>::value)
      : _Base(std::forward<_Head>(_M_head(__in))) { }

      template<typename _UHead>
        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(_Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }

      template<typename _UHead>
        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Base(__tag, __use_alloc<_Head>(__a)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Head& __head)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }

      template<typename _Alloc, typename _UHead>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _UHead&& __head)
 : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
         std::forward<_UHead>(__head)) { }

      template<typename _Alloc>
        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl&& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
         std::forward<_Head>(_M_head(__in))) { }

      template<typename _Alloc, typename _UHead>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  _Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }

      template<typename _Alloc, typename _UHead>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }

      _Tuple_impl&
      operator=(const _Tuple_impl& __in)
      {
 _M_head(*this) = _M_head(__in);
 return *this;
      }

      _Tuple_impl&
      operator=(_Tuple_impl&& __in)
      noexcept(is_nothrow_move_assignable<_Head>::value)
      {
 _M_head(*this) = std::forward<_Head>(_M_head(__in));
 return *this;
      }

      template<typename _UHead>
        _Tuple_impl&
        operator=(const _Tuple_impl<_Idx, _UHead>& __in)
        {
   _M_head(*this) = _Tuple_impl<_Idx, _UHead>::_M_head(__in);
   return *this;
 }

      template<typename _UHead>
        _Tuple_impl&
        operator=(_Tuple_impl<_Idx, _UHead>&& __in)
        {
   _M_head(*this)
     = std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in));
   return *this;
 }

    protected:
      void
      _M_swap(_Tuple_impl& __in)
      noexcept(__is_nothrow_swappable<_Head>::value)
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
      }
    };

  template<typename... _Elements>
    class tuple;



  template<bool, typename... _Elements>
  struct _TC
  {
    template<typename... _UElements>
    static constexpr bool _ConstructibleTuple()
    {
      return __and_<is_constructible<_Elements, const _UElements&>...>::value;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyConvertibleTuple()
    {
      return __and_<is_convertible<const _UElements&, _Elements>...>::value;
    }

    template<typename... _UElements>
    static constexpr bool _MoveConstructibleTuple()
    {
      return __and_<is_constructible<_Elements, _UElements&&>...>::value;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyMoveConvertibleTuple()
    {
      return __and_<is_convertible<_UElements&&, _Elements>...>::value;
    }

    template<typename _SrcTuple>
    static constexpr bool _NonNestedTuple()
    {
      return __and_<__not_<is_same<tuple<_Elements...>,
                                   typename remove_cv<
                                     typename remove_reference<_SrcTuple>::type
                                   >::type>>,
                     __not_<is_convertible<_SrcTuple, _Elements...>>,
                     __not_<is_constructible<_Elements..., _SrcTuple>>
              >::value;
    }
    template<typename... _UElements>
    static constexpr bool _NotSameTuple()
    {
      return __not_<is_same<tuple<_Elements...>,
        typename remove_const<
          typename remove_reference<_UElements...>::type
          >::type>>::value;
    }
  };

  template<typename... _Elements>
  struct _TC<false, _Elements...>
  {
    template<typename... _UElements>
    static constexpr bool _ConstructibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyConvertibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _MoveConstructibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyMoveConvertibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _NonNestedTuple()
    {
      return true;
    }
    template<typename... _UElements>
    static constexpr bool _NotSameTuple()
    {
      return true;
    }
  };


  template<typename... _Elements>
    class tuple : public _Tuple_impl<0, _Elements...>
    {
      typedef _Tuple_impl<0, _Elements...> _Inherited;



      template<typename _Dummy>
      struct _TC2
      {
        static constexpr bool _DefaultConstructibleTuple()
        {
          return __and_<is_default_constructible<_Elements>...>::value;
        }
        static constexpr bool _ImplicitlyDefaultConstructibleTuple()
        {
          return __and_<__is_implicitly_default_constructible<_Elements>...>
            ::value;
        }
      };

    public:
      template<typename _Dummy = void,
               typename enable_if<_TC2<_Dummy>::
                                    _ImplicitlyDefaultConstructibleTuple(),
                                  bool>::type = true>
      constexpr tuple()
      : _Inherited() { }

      template<typename _Dummy = void,
               typename enable_if<_TC2<_Dummy>::
                                    _DefaultConstructibleTuple()
                                  &&
                                  !_TC2<_Dummy>::
                                    _ImplicitlyDefaultConstructibleTuple(),
                                  bool>::type = false>
      explicit constexpr tuple()
      : _Inherited() { }



      template<typename _Dummy> using _TCC =
        _TC<is_same<_Dummy, void>::value,
            _Elements...>;

      template<typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && _TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>()
                 && (sizeof...(_Elements) >= 1),
               bool>::type=true>
        constexpr tuple(const _Elements&... __elements)
      : _Inherited(__elements...) { }

      template<typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && !_TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>()
                 && (sizeof...(_Elements) >= 1),
               bool>::type=false>
      explicit constexpr tuple(const _Elements&... __elements)
      : _Inherited(__elements...) { }



      template<typename... _UElements> using _TMC =
                  _TC<(sizeof...(_Elements) == sizeof...(_UElements)),
                      _Elements...>;

      template<typename... _UElements, typename
        enable_if<
    _TC<sizeof...(_UElements) == 1, _Elements...>::template
      _NotSameTuple<_UElements...>()
    && _TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && (sizeof...(_Elements) >= 1),
        bool>::type=true>
        constexpr tuple(_UElements&&... __elements)
        : _Inherited(std::forward<_UElements>(__elements)...) { }

      template<typename... _UElements, typename
        enable_if<
    _TC<sizeof...(_UElements) == 1, _Elements...>::template
      _NotSameTuple<_UElements...>()
    && _TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && (sizeof...(_Elements) >= 1),
        bool>::type=false>
        explicit constexpr tuple(_UElements&&... __elements)
 : _Inherited(std::forward<_UElements>(__elements)...) { }

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;



      template<typename _Dummy> using _TNTC =
        _TC<is_same<_Dummy, void>::value && sizeof...(_Elements) == 1,
            _Elements...>;

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMC<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && _TMC<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<const tuple<_UElements...>&>(),
        bool>::type=true>
        constexpr tuple(const tuple<_UElements...>& __in)
        : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
        { }

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMC<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && !_TMC<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<const tuple<_UElements...>&>(),
        bool>::type=false>
        explicit constexpr tuple(const tuple<_UElements...>& __in)
        : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
        { }

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=true>
        constexpr tuple(tuple<_UElements...>&& __in)
        : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=false>
        explicit constexpr tuple(tuple<_UElements...>&& __in)
        : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }



      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && _TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>(),
               bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _Elements&... __elements)
 : _Inherited(__tag, __a, __elements...) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && !_TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>(),
               bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       const _Elements&... __elements)
 : _Inherited(__tag, __a, __elements...) { }

      template<typename _Alloc, typename... _UElements, typename
        enable_if<_TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),
        bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       _UElements&&... __elements)
 : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)
        { }

      template<typename _Alloc, typename... _UElements, typename
        enable_if<_TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),
        bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       _UElements&&... __elements)
 : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)
        { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }

      template<typename _Alloc, typename... _UElements, typename
        enable_if<_TMC<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && _TMC<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>(),
        bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_UElements...>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename _Alloc, typename... _UElements, typename
        enable_if<_TMC<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && !_TMC<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>(),
        bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_UElements...>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename _Alloc, typename... _UElements, typename
        enable_if<_TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),
        bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       tuple<_UElements...>&& __in)
 : _Inherited(__tag, __a,
              static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
 { }

      template<typename _Alloc, typename... _UElements, typename
        enable_if<_TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),
        bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       tuple<_UElements...>&& __in)
 : _Inherited(__tag, __a,
              static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
 { }

      tuple&
      operator=(const tuple& __in)
      {
 static_cast<_Inherited&>(*this) = __in;
 return *this;
      }

      tuple&
      operator=(tuple&& __in)
      noexcept(is_nothrow_move_assignable<_Inherited>::value)
      {
 static_cast<_Inherited&>(*this) = std::move(__in);
 return *this;
      }

      template<typename... _UElements, typename = typename
        enable_if<sizeof...(_UElements)
    == sizeof...(_Elements)>::type>
        tuple&
        operator=(const tuple<_UElements...>& __in)
        {
   static_cast<_Inherited&>(*this) = __in;
   return *this;
 }

      template<typename... _UElements, typename = typename
        enable_if<sizeof...(_UElements)
    == sizeof...(_Elements)>::type>
        tuple&
        operator=(tuple<_UElements...>&& __in)
        {
   static_cast<_Inherited&>(*this) = std::move(__in);
   return *this;
 }

      void
      swap(tuple& __in)
      noexcept(noexcept(__in._M_swap(__in)))
      { _Inherited::_M_swap(__in); }
    };


  template<>
    class tuple<>
    {
    public:
      void swap(tuple&) noexcept { }
    };



  template<typename _T1, typename _T2>
    class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2>
    {
      typedef _Tuple_impl<0, _T1, _T2> _Inherited;

    public:
      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                                     __is_implicitly_default_constructible<_U1>,
                                     __is_implicitly_default_constructible<_U2>>
                                   ::value, bool>::type = true>

      constexpr tuple()
      : _Inherited() { }

      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<
                  __and_<
                    is_default_constructible<_U1>,
                    is_default_constructible<_U2>,
                    __not_<
                      __and_<__is_implicitly_default_constructible<_U1>,
                             __is_implicitly_default_constructible<_U2>>>>
                  ::value, bool>::type = false>

      explicit constexpr tuple()
      : _Inherited() { }



      template<typename _Dummy> using _TCC =
        _TC<is_same<_Dummy, void>::value, _T1, _T2>;

      template<typename _Dummy = void, typename
               enable_if<_TCC<_Dummy>::template
                           _ConstructibleTuple<_T1, _T2>()
                         && _TCC<_Dummy>::template
                           _ImplicitlyConvertibleTuple<_T1, _T2>(),
 bool>::type = true>
        constexpr tuple(const _T1& __a1, const _T2& __a2)
        : _Inherited(__a1, __a2) { }

      template<typename _Dummy = void, typename
               enable_if<_TCC<_Dummy>::template
                           _ConstructibleTuple<_T1, _T2>()
                         && !_TCC<_Dummy>::template
                           _ImplicitlyConvertibleTuple<_T1, _T2>(),
 bool>::type = false>
        explicit constexpr tuple(const _T1& __a1, const _T2& __a2)
        : _Inherited(__a1, __a2) { }



      using _TMC = _TC<true, _T1, _T2>;

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(_U1&& __a1, _U2&& __a2)
 : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(_U1&& __a1, _U2&& __a2)
 : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(const tuple<_U1, _U2>& __in)
 : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(const tuple<_U1, _U2>& __in)
 : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(tuple<_U1, _U2>&& __in)
 : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(tuple<_U1, _U2>&& __in)
 : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(const pair<_U1, _U2>& __in)
 : _Inherited(__in.first, __in.second) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(const pair<_U1, _U2>& __in)
 : _Inherited(__in.first, __in.second) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(pair<_U1, _U2>&& __in)
 : _Inherited(std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(pair<_U1, _U2>&& __in)
 : _Inherited(std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }



      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_T1, _T2>()
                 && _TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_T1, _T2>(),
               bool>::type=true>

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _T1& __a1, const _T2& __a2)
 : _Inherited(__tag, __a, __a1, __a2) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_T1, _T2>()
                 && !_TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_T1, _T2>(),
               bool>::type=false>

 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _T1& __a1, const _T2& __a2)
 : _Inherited(__tag, __a, __a1, __a2) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
 tuple(allocator_arg_t __tag, const _Alloc& __a, _U1&& __a1, _U2&& __a2)
 : _Inherited(__tag, __a, std::forward<_U1>(__a1),
              std::forward<_U2>(__a2)) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       _U1&& __a1, _U2&& __a2)
 : _Inherited(__tag, __a, std::forward<_U1>(__a1),
              std::forward<_U2>(__a2)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_U1, _U2>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_U1, _U2>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       tuple<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        tuple(allocator_arg_t __tag, const _Alloc& __a,
       const pair<_U1, _U2>& __in)
 : _Inherited(__tag, __a, __in.first, __in.second) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const pair<_U1, _U2>& __in)
 : _Inherited(__tag, __a, __in.first, __in.second) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       pair<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      tuple&
      operator=(const tuple& __in)
      {
 static_cast<_Inherited&>(*this) = __in;
 return *this;
      }

      tuple&
      operator=(tuple&& __in)
      noexcept(is_nothrow_move_assignable<_Inherited>::value)
      {
 static_cast<_Inherited&>(*this) = std::move(__in);
 return *this;
      }

      template<typename _U1, typename _U2>
        tuple&
        operator=(const tuple<_U1, _U2>& __in)
        {
   static_cast<_Inherited&>(*this) = __in;
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(tuple<_U1, _U2>&& __in)
        {
   static_cast<_Inherited&>(*this) = std::move(__in);
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(const pair<_U1, _U2>& __in)
        {
   this->_M_head(*this) = __in.first;
   this->_M_tail(*this)._M_head(*this) = __in.second;
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(pair<_U1, _U2>&& __in)
        {
   this->_M_head(*this) = std::forward<_U1>(__in.first);
   this->_M_tail(*this)._M_head(*this) = std::forward<_U2>(__in.second);
   return *this;
 }

      void
      swap(tuple& __in)
      noexcept(noexcept(__in._M_swap(__in)))
      { _Inherited::_M_swap(__in); }
    };






  template<std::size_t __i, typename _Head, typename... _Tail>
    struct tuple_element<__i, tuple<_Head, _Tail...> >
    : tuple_element<__i - 1, tuple<_Tail...> > { };




  template<typename _Head, typename... _Tail>
    struct tuple_element<0, tuple<_Head, _Tail...> >
    {
      typedef _Head type;
    };


  template<typename... _Elements>
    struct tuple_size<tuple<_Elements...>>
    : public integral_constant<std::size_t, sizeof...(_Elements)> { };

  template<std::size_t __i, typename _Head, typename... _Tail>
    constexpr _Head&
    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }

  template<std::size_t __i, typename _Head, typename... _Tail>
    constexpr const _Head&
    __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&
    get(tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&
    get(const tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&&
    get(tuple<_Elements...>&& __t) noexcept
    {
      typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
      return std::forward<__element_type&&>(std::get<__i>(__t));
    }





  template<typename _Head, size_t __i, typename... _Tail>
    constexpr _Head&
    __get_helper2(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }

  template<typename _Head, size_t __i, typename... _Tail>
    constexpr const _Head&
    __get_helper2(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }


  template <typename _Tp, typename... _Types>
    constexpr _Tp&
    get(tuple<_Types...>& __t) noexcept
    { return std::__get_helper2<_Tp>(__t); }


  template <typename _Tp, typename... _Types>
    constexpr _Tp&&
    get(tuple<_Types...>&& __t) noexcept
    { return std::forward<_Tp&&>(std::__get_helper2<_Tp>(__t)); }


  template <typename _Tp, typename... _Types>
    constexpr const _Tp&
    get(const tuple<_Types...>& __t) noexcept
    { return std::__get_helper2<_Tp>(__t); }



  template<typename _Tp, typename _Up, size_t __i, size_t __size>
    struct __tuple_compare
    {
      static constexpr bool
      __eq(const _Tp& __t, const _Up& __u)
      {
 return bool(std::get<__i>(__t) == std::get<__i>(__u))
   && __tuple_compare<_Tp, _Up, __i + 1, __size>::__eq(__t, __u);
      }

      static constexpr bool
      __less(const _Tp& __t, const _Up& __u)
      {
 return bool(std::get<__i>(__t) < std::get<__i>(__u))
   || (!bool(std::get<__i>(__u) < std::get<__i>(__t))
       && __tuple_compare<_Tp, _Up, __i + 1, __size>::__less(__t, __u));
      }
    };

  template<typename _Tp, typename _Up, size_t __size>
    struct __tuple_compare<_Tp, _Up, __size, __size>
    {
      static constexpr bool
      __eq(const _Tp&, const _Up&) { return true; }

      static constexpr bool
      __less(const _Tp&, const _Up&) { return false; }
    };

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator==(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    {
      static_assert(sizeof...(_TElements) == sizeof...(_UElements),
   "tuple objects can only be compared if they have equal sizes.");
      using __compare = __tuple_compare<tuple<_TElements...>,
     tuple<_UElements...>,
     0, sizeof...(_TElements)>;
      return __compare::__eq(__t, __u);
    }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator<(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    {
      static_assert(sizeof...(_TElements) == sizeof...(_UElements),
   "tuple objects can only be compared if they have equal sizes.");
      using __compare = __tuple_compare<tuple<_TElements...>,
     tuple<_UElements...>,
     0, sizeof...(_TElements)>;
      return __compare::__less(__t, __u);
    }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator!=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t == __u); }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator>(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    { return __u < __t; }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator<=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__u < __t); }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator>=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t < __u); }


  template<typename... _Elements>
    constexpr tuple<typename __decay_and_strip<_Elements>::__type...>
    make_tuple(_Elements&&... __args)
    {
      typedef tuple<typename __decay_and_strip<_Elements>::__type...>
 __result_type;
      return __result_type(std::forward<_Elements>(__args)...);
    }



  template<typename... _Elements>
    constexpr tuple<_Elements&&...>
    forward_as_tuple(_Elements&&... __args) noexcept
    { return tuple<_Elements&&...>(std::forward<_Elements>(__args)...); }

  template<typename... _Tps>
    struct __is_tuple_like_impl<tuple<_Tps...>> : true_type
    { };


  template<typename _Tp>
    struct __is_tuple_like
    : public __is_tuple_like_impl<typename std::remove_cv
            <typename std::remove_reference<_Tp>::type>::type>::type
    { };

  template<size_t, typename, typename, size_t>
    struct __make_tuple_impl;

  template<size_t _Idx, typename _Tuple, typename... _Tp, size_t _Nm>
    struct __make_tuple_impl<_Idx, tuple<_Tp...>, _Tuple, _Nm>
    : __make_tuple_impl<_Idx + 1,
   tuple<_Tp..., __tuple_element_t<_Idx, _Tuple>>,
   _Tuple, _Nm>
    { };

  template<std::size_t _Nm, typename _Tuple, typename... _Tp>
    struct __make_tuple_impl<_Nm, tuple<_Tp...>, _Tuple, _Nm>
    {
      typedef tuple<_Tp...> __type;
    };

  template<typename _Tuple>
    struct __do_make_tuple
    : __make_tuple_impl<0, tuple<>, _Tuple, std::tuple_size<_Tuple>::value>
    { };


  template<typename _Tuple>
    struct __make_tuple
    : public __do_make_tuple<typename std::remove_cv
            <typename std::remove_reference<_Tuple>::type>::type>
    { };


  template<typename...>
    struct __combine_tuples;

  template<>
    struct __combine_tuples<>
    {
      typedef tuple<> __type;
    };

  template<typename... _Ts>
    struct __combine_tuples<tuple<_Ts...>>
    {
      typedef tuple<_Ts...> __type;
    };

  template<typename... _T1s, typename... _T2s, typename... _Rem>
    struct __combine_tuples<tuple<_T1s...>, tuple<_T2s...>, _Rem...>
    {
      typedef typename __combine_tuples<tuple<_T1s..., _T2s...>,
     _Rem...>::__type __type;
    };


  template<typename... _Tpls>
    struct __tuple_cat_result
    {
      typedef typename __combine_tuples
        <typename __make_tuple<_Tpls>::__type...>::__type __type;
    };



  template<typename...>
    struct __make_1st_indices;

  template<>
    struct __make_1st_indices<>
    {
      typedef std::_Index_tuple<> __type;
    };

  template<typename _Tp, typename... _Tpls>
    struct __make_1st_indices<_Tp, _Tpls...>
    {
      typedef typename std::_Build_index_tuple<std::tuple_size<
 typename std::remove_reference<_Tp>::type>::value>::__type __type;
    };




  template<typename _Ret, typename _Indices, typename... _Tpls>
    struct __tuple_concater;

  template<typename _Ret, std::size_t... _Is, typename _Tp, typename... _Tpls>
    struct __tuple_concater<_Ret, std::_Index_tuple<_Is...>, _Tp, _Tpls...>
    {
      template<typename... _Us>
        static constexpr _Ret
        _S_do(_Tp&& __tp, _Tpls&&... __tps, _Us&&... __us)
        {
   typedef typename __make_1st_indices<_Tpls...>::__type __idx;
   typedef __tuple_concater<_Ret, __idx, _Tpls...> __next;
   return __next::_S_do(std::forward<_Tpls>(__tps)...,
          std::forward<_Us>(__us)...,
          std::get<_Is>(std::forward<_Tp>(__tp))...);
 }
    };

  template<typename _Ret>
    struct __tuple_concater<_Ret, std::_Index_tuple<>>
    {
      template<typename... _Us>
 static constexpr _Ret
 _S_do(_Us&&... __us)
        {
   return _Ret(std::forward<_Us>(__us)...);
 }
    };


  template<typename... _Tpls, typename = typename
           enable_if<__and_<__is_tuple_like<_Tpls>...>::value>::type>
    constexpr auto
    tuple_cat(_Tpls&&... __tpls)
    -> typename __tuple_cat_result<_Tpls...>::__type
    {
      typedef typename __tuple_cat_result<_Tpls...>::__type __ret;
      typedef typename __make_1st_indices<_Tpls...>::__type __idx;
      typedef __tuple_concater<__ret, __idx, _Tpls...> __concater;
      return __concater::_S_do(std::forward<_Tpls>(__tpls)...);
    }




  template<typename... _Elements>
    constexpr tuple<_Elements&...>
    tie(_Elements&... __args) noexcept
    { return tuple<_Elements&...>(__args...); }


  template<typename... _Elements>
    inline void
    swap(tuple<_Elements...>& __x, tuple<_Elements...>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }



  struct _Swallow_assign
  {
    template<class _Tp>
      const _Swallow_assign&
      operator=(const _Tp&) const
      { return *this; }
  };

  const _Swallow_assign ignore{};


  template<typename... _Types, typename _Alloc>
    struct uses_allocator<tuple<_Types...>, _Alloc> : true_type { };


  template<class _T1, class _T2>
    template<typename... _Args1, typename... _Args2>
      inline
      pair<_T1, _T2>::
      pair(piecewise_construct_t,
    tuple<_Args1...> __first, tuple<_Args2...> __second)
      : pair(__first, __second,
      typename _Build_index_tuple<sizeof...(_Args1)>::__type(),
      typename _Build_index_tuple<sizeof...(_Args2)>::__type())
      { }

  template<class _T1, class _T2>
    template<typename... _Args1, std::size_t... _Indexes1,
             typename... _Args2, std::size_t... _Indexes2>
      inline
      pair<_T1, _T2>::
      pair(tuple<_Args1...>& __tuple1, tuple<_Args2...>& __tuple2,
    _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>)
      : first(std::forward<_Args1>(std::get<_Indexes1>(__tuple1))...),
        second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...)
      { }




}
#56 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/functional" 2 3




namespace std
{


  template<typename _MemberPointer>
    class _Mem_fn;
  template<typename _Tp, typename _Class>
    _Mem_fn<_Tp _Class::*>
    mem_fn(_Tp _Class::*) noexcept;


  template<typename _Functor, typename = __void_t<>>
    struct _Maybe_get_result_type
    { };

  template<typename _Functor>
    struct _Maybe_get_result_type<_Functor,
      __void_t<typename _Functor::result_type>>
    { typedef typename _Functor::result_type result_type; };





  template<typename _Functor>
    struct _Weak_result_type_impl
    : _Maybe_get_result_type<_Functor>
    { };


  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes...)>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes......)>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes...) const>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes......) const>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes...) volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes......) volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes...) const volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes......) const volatile>
    { typedef _Res result_type; };


  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(&)(_ArgTypes...)>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(&)(_ArgTypes......)>
    { typedef _Res result_type; };


  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(*)(_ArgTypes...)>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(*)(_ArgTypes......)>
    { typedef _Res result_type; };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)>
    { typedef _Res result_type; };

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......)>
    { typedef _Res result_type; };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) const>
    { typedef _Res result_type; };

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......) const>
    { typedef _Res result_type; };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......) volatile>
    { typedef _Res result_type; };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)
      const volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......)
      const volatile>
    { typedef _Res result_type; };





  template<typename _Functor>
    struct _Weak_result_type
    : _Weak_result_type_impl<typename remove_cv<_Functor>::type>
    { };

  template<typename _Tp, typename _Up = typename decay<_Tp>::type>
    struct _Unwrap
    {
      using type = _Tp&&;


      static constexpr _Tp&&
      _S_fwd(_Tp& __t) noexcept { return static_cast<_Tp&&>(__t); }
    };

  template<typename _Tp, typename _Up>
    struct _Unwrap<_Tp, reference_wrapper<_Up>>
    {
      using type = _Up&;


      static _Up&
      _S_fwd(const _Tp& __t) noexcept { __t.get(); }
    };



  template<typename _Tp>
    inline typename _Unwrap<_Tp>::type
    __invfwd(typename remove_reference<_Tp>::type& __t) noexcept
    { return _Unwrap<_Tp>::_S_fwd(__t); }

  template<typename _Res, typename _Fn, typename... _Args>
    inline _Res
    __invoke_impl(__invoke_other, _Fn&& __f, _Args&&... __args)
    noexcept(noexcept(std::forward<_Fn>(__f)(std::forward<_Args>(__args)...)))
    { return std::forward<_Fn>(__f)(std::forward<_Args>(__args)...); }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    inline _Res
    __invoke_impl(__invoke_memfun_ref, _MemFun&& __f, _Tp&& __t,
    _Args&&... __args)
    noexcept(noexcept(
   (__invfwd<_Tp>(__t).*__f)(std::forward<_Args>(__args)...)))
    { return (__invfwd<_Tp>(__t).*__f)(std::forward<_Args>(__args)...); }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    inline _Res
    __invoke_impl(__invoke_memfun_deref, _MemFun&& __f, _Tp&& __t,
    _Args&&... __args)
    noexcept(noexcept(
   ((*std::forward<_Tp>(__t)).*__f)(std::forward<_Args>(__args)...)))
    {
      return ((*std::forward<_Tp>(__t)).*__f)(std::forward<_Args>(__args)...);
    }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    inline _Res
    __invoke_impl(__invoke_memobj_ref, _MemFun&& __f, _Tp&& __t)
    noexcept(noexcept(__invfwd<_Tp>(__t).*__f))
    { return __invfwd<_Tp>(__t).*__f; }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    inline _Res
    __invoke_impl(__invoke_memobj_deref, _MemFun&& __f, _Tp&& __t,
    _Args&&... __args)
    noexcept(noexcept((*std::forward<_Tp>(__t)).*__f))
    { return (*std::forward<_Tp>(__t)).*__f; }


  template<typename _Callable, typename... _Args>
    inline typename result_of<_Callable&&(_Args&&...)>::type
    __invoke(_Callable&& __fn, _Args&&... __args)
    {
      using __result_of = result_of<_Callable&&(_Args&&...)>;
      using __type = typename __result_of::type;
      using __tag = typename __result_of::__invoke_type;
      return std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),
     std::forward<_Args>(__args)...);
    }
#281 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/functional" 3
  template<bool _Unary, bool _Binary, typename _Tp>
    struct _Reference_wrapper_base_impl;


  template<typename _Tp>
    struct _Reference_wrapper_base_impl<false, false, _Tp>
    : _Weak_result_type<_Tp>
    { };


  template<typename _Tp>
    struct _Reference_wrapper_base_impl<true, false, _Tp>
    : _Weak_result_type<_Tp>
    {
      typedef typename _Tp::argument_type argument_type;
    };


  template<typename _Tp>
    struct _Reference_wrapper_base_impl<false, true, _Tp>
    : _Weak_result_type<_Tp>
    {
      typedef typename _Tp::first_argument_type first_argument_type;
      typedef typename _Tp::second_argument_type second_argument_type;
    };


   template<typename _Tp>
    struct _Reference_wrapper_base_impl<true, true, _Tp>
    : _Weak_result_type<_Tp>
    {
      typedef typename _Tp::argument_type argument_type;
      typedef typename _Tp::first_argument_type first_argument_type;
      typedef typename _Tp::second_argument_type second_argument_type;
    };

  template<typename _Tp, typename = __void_t<>> struct __has_argument_type : false_type { }; template<typename _Tp> struct __has_argument_type<_Tp, __void_t<typename _Tp::argument_type>> : true_type { };
  template<typename _Tp, typename = __void_t<>> struct __has_first_argument_type : false_type { }; template<typename _Tp> struct __has_first_argument_type<_Tp, __void_t<typename _Tp::first_argument_type>> : true_type { };
  template<typename _Tp, typename = __void_t<>> struct __has_second_argument_type : false_type { }; template<typename _Tp> struct __has_second_argument_type<_Tp, __void_t<typename _Tp::second_argument_type>> : true_type { };







  template<typename _Tp>
    struct _Reference_wrapper_base
    : _Reference_wrapper_base_impl<
      __has_argument_type<_Tp>::value,
      __has_first_argument_type<_Tp>::value
      && __has_second_argument_type<_Tp>::value,
      _Tp>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1)>
    : unary_function<_T1, _Res>
    { };

  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1) const>
    : unary_function<_T1, _Res>
    { };

  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1) volatile>
    : unary_function<_T1, _Res>
    { };

  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1) const volatile>
    : unary_function<_T1, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2)>
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2) const>
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2) volatile>
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2) const volatile>
    : binary_function<_T1, _T2, _Res>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(*)(_T1)>
    : unary_function<_T1, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(*)(_T1, _T2)>
    : binary_function<_T1, _T2, _Res>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res (_T1::*)()>
    : unary_function<_T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2)>
    : binary_function<_T1*, _T2, _Res>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res (_T1::*)() const>
    : unary_function<const _T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const>
    : binary_function<const _T1*, _T2, _Res>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res (_T1::*)() volatile>
    : unary_function<volatile _T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) volatile>
    : binary_function<volatile _T1*, _T2, _Res>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res (_T1::*)() const volatile>
    : unary_function<const volatile _T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const volatile>
    : binary_function<const volatile _T1*, _T2, _Res>
    { };






  template<typename _Tp>
    class reference_wrapper
    : public _Reference_wrapper_base<typename remove_cv<_Tp>::type>
    {
      _Tp* _M_data;

    public:
      typedef _Tp type;

      reference_wrapper(_Tp& __indata) noexcept
      : _M_data(std::__addressof(__indata))
      { }

      reference_wrapper(_Tp&&) = delete;

      reference_wrapper(const reference_wrapper&) = default;

      reference_wrapper&
      operator=(const reference_wrapper&) = default;

      operator _Tp&() const noexcept
      { return this->get(); }

      _Tp&
      get() const noexcept
      { return *_M_data; }

      template<typename... _Args>
 typename result_of<_Tp&(_Args&&...)>::type
 operator()(_Args&&... __args) const
 {
   return std::__invoke(get(), std::forward<_Args>(__args)...);
 }
    };



  template<typename _Tp>
    inline reference_wrapper<_Tp>
    ref(_Tp& __t) noexcept
    { return reference_wrapper<_Tp>(__t); }


  template<typename _Tp>
    inline reference_wrapper<const _Tp>
    cref(const _Tp& __t) noexcept
    { return reference_wrapper<const _Tp>(__t); }

  template<typename _Tp>
    void ref(const _Tp&&) = delete;

  template<typename _Tp>
    void cref(const _Tp&&) = delete;


  template<typename _Tp>
    inline reference_wrapper<_Tp>
    ref(reference_wrapper<_Tp> __t) noexcept
    { return ref(__t.get()); }


  template<typename _Tp>
    inline reference_wrapper<const _Tp>
    cref(reference_wrapper<_Tp> __t) noexcept
    { return cref(__t.get()); }



  template<typename... _Types>
    struct _Pack : integral_constant<size_t, sizeof...(_Types)>
    { };

  template<typename _From, typename _To, bool = _From::value == _To::value>
    struct _AllConvertible : false_type
    { };

  template<typename... _From, typename... _To>
    struct _AllConvertible<_Pack<_From...>, _Pack<_To...>, true>
    : __and_<is_convertible<_From, _To>...>
    { };

  template<typename _Tp1, typename _Tp2>
    using _NotSame = __not_<is_same<typename std::decay<_Tp1>::type,
        typename std::decay<_Tp2>::type>>;






  template<typename _Res, typename... _ArgTypes>
    struct _Maybe_unary_or_binary_function { };


  template<typename _Res, typename _T1>
    struct _Maybe_unary_or_binary_function<_Res, _T1>
    : std::unary_function<_T1, _Res> { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Maybe_unary_or_binary_function<_Res, _T1, _T2>
    : std::binary_function<_T1, _T2, _Res> { };

  template<typename _Signature>
    struct _Mem_fn_traits;

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Mem_fn_traits_base
    {
      using __result_type = _Res;
      using __maybe_type
 = _Maybe_unary_or_binary_function<_Res, _Class*, _ArgTypes...>;
      using __arity = integral_constant<size_t, sizeof...(_ArgTypes)>;
    };
#578 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/functional" 3
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) > : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) > : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const > : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const > : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile > : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile > : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile > : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile > : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) &> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const &> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile &> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile &> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &&> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) &&> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &&> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const &&> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &&> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile &&> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &&> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile &&> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };




  template<typename _MemFunPtr,
    bool __is_mem_fn = is_member_function_pointer<_MemFunPtr>::value>
    class _Mem_fn_base
    : public _Mem_fn_traits<_MemFunPtr>::__maybe_type
    {
      using _Traits = _Mem_fn_traits<_MemFunPtr>;

      using _Arity = typename _Traits::__arity;
      using _Varargs = typename _Traits::__vararg;

      template<typename _Func, typename... _BoundArgs>
 friend struct _Bind_check_arity;

      _MemFunPtr _M_pmf;

    public:

      using result_type = typename _Traits::__result_type;

      explicit constexpr
      _Mem_fn_base(_MemFunPtr __pmf) noexcept : _M_pmf(__pmf) { }

      template<typename... _Args>
 auto
 operator()(_Args&&... __args) const
 noexcept(noexcept(
       std::__invoke(_M_pmf, std::forward<_Args>(__args)...)))
 -> decltype(std::__invoke(_M_pmf, std::forward<_Args>(__args)...))
 { return std::__invoke(_M_pmf, std::forward<_Args>(__args)...); }
    };


  template<typename _MemObjPtr>
    class _Mem_fn_base<_MemObjPtr, false>
    {
      using _Arity = integral_constant<size_t, 0>;
      using _Varargs = false_type;

      template<typename _Func, typename... _BoundArgs>
 friend struct _Bind_check_arity;

      _MemObjPtr _M_pm;

    public:
      explicit constexpr
      _Mem_fn_base(_MemObjPtr __pm) noexcept : _M_pm(__pm) { }

      template<typename _Tp>
 auto
 operator()(_Tp&& __obj) const
 noexcept(noexcept(std::__invoke(_M_pm, std::forward<_Tp>(__obj))))
 -> decltype(std::__invoke(_M_pm, std::forward<_Tp>(__obj)))
 { return std::__invoke(_M_pm, std::forward<_Tp>(__obj)); }
    };

  template<typename _Res, typename _Class>
    struct _Mem_fn<_Res _Class::*>
    : _Mem_fn_base<_Res _Class::*>
    {
      using _Mem_fn_base<_Res _Class::*>::_Mem_fn_base;
    };
#654 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/functional" 3
  template<typename _Tp, typename _Class>
    inline _Mem_fn<_Tp _Class::*>
    mem_fn(_Tp _Class::* __pm) noexcept
    {
      return _Mem_fn<_Tp _Class::*>(__pm);
    }
#669 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/functional" 3
  template<typename _Tp>
    struct is_bind_expression
    : public false_type { };
#680 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/functional" 3
  template<typename _Tp>
    struct is_placeholder
    : public integral_constant<int, 0>
    { };




  template<int _Num> struct _Placeholder { };







  namespace placeholders
  {





    extern const _Placeholder<1> _1;
    extern const _Placeholder<2> _2;
    extern const _Placeholder<3> _3;
    extern const _Placeholder<4> _4;
    extern const _Placeholder<5> _5;
    extern const _Placeholder<6> _6;
    extern const _Placeholder<7> _7;
    extern const _Placeholder<8> _8;
    extern const _Placeholder<9> _9;
    extern const _Placeholder<10> _10;
    extern const _Placeholder<11> _11;
    extern const _Placeholder<12> _12;
    extern const _Placeholder<13> _13;
    extern const _Placeholder<14> _14;
    extern const _Placeholder<15> _15;
    extern const _Placeholder<16> _16;
    extern const _Placeholder<17> _17;
    extern const _Placeholder<18> _18;
    extern const _Placeholder<19> _19;
    extern const _Placeholder<20> _20;
    extern const _Placeholder<21> _21;
    extern const _Placeholder<22> _22;
    extern const _Placeholder<23> _23;
    extern const _Placeholder<24> _24;
    extern const _Placeholder<25> _25;
    extern const _Placeholder<26> _26;
    extern const _Placeholder<27> _27;
    extern const _Placeholder<28> _28;
    extern const _Placeholder<29> _29;

  }








  template<int _Num>
    struct is_placeholder<_Placeholder<_Num> >
    : public integral_constant<int, _Num>
    { };

  template<int _Num>
    struct is_placeholder<const _Placeholder<_Num> >
    : public integral_constant<int, _Num>
    { };



 template<std::size_t __i, typename _Tuple>
   using _Safe_tuple_element_t
     = typename enable_if<(__i < tuple_size<_Tuple>::value),
     tuple_element<__i, _Tuple>>::type::type;
#770 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/functional" 3
  template<typename _Arg,
    bool _IsBindExp = is_bind_expression<_Arg>::value,
    bool _IsPlaceholder = (is_placeholder<_Arg>::value > 0)>
    class _Mu;






  template<typename _Tp>
    class _Mu<reference_wrapper<_Tp>, false, false>
    {
    public:




      template<typename _CVRef, typename _Tuple>
 _Tp&
 operator()(_CVRef& __arg, _Tuple&) const volatile
 { return __arg.get(); }
    };







  template<typename _Arg>
    class _Mu<_Arg, true, false>
    {
    public:
      template<typename _CVArg, typename... _Args>
 auto
 operator()(_CVArg& __arg,
     tuple<_Args...>& __tuple) const volatile
 -> decltype(__arg(declval<_Args>()...))
 {

   typedef typename _Build_index_tuple<sizeof...(_Args)>::__type
     _Indexes;
   return this->__call(__arg, __tuple, _Indexes());
 }

    private:


      template<typename _CVArg, typename... _Args, std::size_t... _Indexes>
 auto
 __call(_CVArg& __arg, tuple<_Args...>& __tuple,
        const _Index_tuple<_Indexes...>&) const volatile
 -> decltype(__arg(declval<_Args>()...))
 {
   return __arg(std::forward<_Args>(std::get<_Indexes>(__tuple))...);
 }
    };






  template<typename _Arg>
    class _Mu<_Arg, false, true>
    {
    public:
      template<typename _Tuple>
 _Safe_tuple_element_t<(is_placeholder<_Arg>::value - 1), _Tuple>&&
 operator()(const volatile _Arg&, _Tuple& __tuple) const volatile
 {
   using __type
     = __tuple_element_t<(is_placeholder<_Arg>::value - 1), _Tuple>;
   return std::forward<__type>(
       ::std::get<(is_placeholder<_Arg>::value - 1)>(__tuple));
 }
    };






  template<typename _Arg>
    class _Mu<_Arg, false, false>
    {
    public:
      template<typename _CVArg, typename _Tuple>
 _CVArg&&
 operator()(_CVArg&& __arg, _Tuple&) const volatile
 { return std::forward<_CVArg>(__arg); }
    };






  template<typename _Tp>
    struct _Maybe_wrap_member_pointer
    {
      typedef _Tp type;

      static constexpr const _Tp&
      __do_wrap(const _Tp& __x)
      { return __x; }

      static constexpr _Tp&&
      __do_wrap(_Tp&& __x)
      { return static_cast<_Tp&&>(__x); }
    };






  template<typename _Tp, typename _Class>
    struct _Maybe_wrap_member_pointer<_Tp _Class::*>
    {
      typedef _Mem_fn<_Tp _Class::*> type;

      static constexpr type
      __do_wrap(_Tp _Class::* __pm)
      { return type(__pm); }
    };





  template<>
    struct _Maybe_wrap_member_pointer<void>
    {
      typedef void type;
    };


  template<std::size_t _Ind, typename... _Tp>
    inline auto
    __volget(volatile tuple<_Tp...>& __tuple)
    -> __tuple_element_t<_Ind, tuple<_Tp...>> volatile&
    { return std::get<_Ind>(const_cast<tuple<_Tp...>&>(__tuple)); }


  template<std::size_t _Ind, typename... _Tp>
    inline auto
    __volget(const volatile tuple<_Tp...>& __tuple)
    -> __tuple_element_t<_Ind, tuple<_Tp...>> const volatile&
    { return std::get<_Ind>(const_cast<const tuple<_Tp...>&>(__tuple)); }


  template<typename _Signature>
    struct _Bind;

   template<typename _Functor, typename... _Bound_args>
    class _Bind<_Functor(_Bound_args...)>
    : public _Weak_result_type<_Functor>
    {
      typedef _Bind __self_type;
      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type
 _Bound_indexes;

      _Functor _M_f;
      tuple<_Bound_args...> _M_bound_args;


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)
 {
   return _M_f(_Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call_c(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) const
 {
   return _M_f(_Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call_v(tuple<_Args...>&& __args,
   _Index_tuple<_Indexes...>) volatile
 {
   return _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call_c_v(tuple<_Args...>&& __args,
     _Index_tuple<_Indexes...>) const volatile
 {
   return _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }

     public:
      template<typename... _Args>
 explicit _Bind(const _Functor& __f, _Args&&... __args)
 : _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      template<typename... _Args>
 explicit _Bind(_Functor&& __f, _Args&&... __args)
 : _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      _Bind(const _Bind&) = default;

      _Bind(_Bind&& __b)
      : _M_f(std::move(__b._M_f)), _M_bound_args(std::move(__b._M_bound_args))
      { }


      template<typename... _Args, typename _Result
 = decltype( std::declval<_Functor&>()(
       _Mu<_Bound_args>()( std::declval<_Bound_args&>(),
      std::declval<tuple<_Args...>&>() )... ) )>
 _Result
 operator()(_Args&&... __args)
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args, typename _Result
 = decltype( std::declval<typename enable_if<(sizeof...(_Args) >= 0),
         typename add_const<_Functor>::type&>::type>()(
       _Mu<_Bound_args>()( std::declval<const _Bound_args&>(),
      std::declval<tuple<_Args...>&>() )... ) )>
 _Result
 operator()(_Args&&... __args) const
 {
   return this->__call_c<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args, typename _Result
 = decltype( std::declval<typename enable_if<(sizeof...(_Args) >= 0),
                       typename add_volatile<_Functor>::type&>::type>()(
       _Mu<_Bound_args>()( std::declval<volatile _Bound_args&>(),
      std::declval<tuple<_Args...>&>() )... ) )>
 _Result
 operator()(_Args&&... __args) volatile
 {
   return this->__call_v<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args, typename _Result
 = decltype( std::declval<typename enable_if<(sizeof...(_Args) >= 0),
                       typename add_cv<_Functor>::type&>::type>()(
       _Mu<_Bound_args>()( std::declval<const volatile _Bound_args&>(),
      std::declval<tuple<_Args...>&>() )... ) )>
 _Result
 operator()(_Args&&... __args) const volatile
 {
   return this->__call_c_v<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }
    };


  template<typename _Result, typename _Signature>
    struct _Bind_result;

  template<typename _Result, typename _Functor, typename... _Bound_args>
    class _Bind_result<_Result, _Functor(_Bound_args...)>
    {
      typedef _Bind_result __self_type;
      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type
 _Bound_indexes;

      _Functor _M_f;
      tuple<_Bound_args...> _M_bound_args;


      template<typename _Res>
 struct __enable_if_void : enable_if<is_void<_Res>::value, int> { };
      template<typename _Res>
 struct __disable_if_void : enable_if<!is_void<_Res>::value, int> { };


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __disable_if_void<_Res>::type = 0)
 {
   return _M_f(_Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 void
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __enable_if_void<_Res>::type = 0)
 {
   _M_f(_Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __disable_if_void<_Res>::type = 0) const
 {
   return _M_f(_Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 void
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __enable_if_void<_Res>::type = 0) const
 {
   _M_f(_Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __disable_if_void<_Res>::type = 0) volatile
 {
   return _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 void
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __enable_if_void<_Res>::type = 0) volatile
 {
   _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __disable_if_void<_Res>::type = 0) const volatile
 {
   return _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 void
 __call(tuple<_Args...>&& __args,
        _Index_tuple<_Indexes...>,
     typename __enable_if_void<_Res>::type = 0) const volatile
 {
   _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }

    public:
      typedef _Result result_type;

      template<typename... _Args>
 explicit _Bind_result(const _Functor& __f, _Args&&... __args)
 : _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      template<typename... _Args>
 explicit _Bind_result(_Functor&& __f, _Args&&... __args)
 : _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      _Bind_result(const _Bind_result&) = default;

      _Bind_result(_Bind_result&& __b)
      : _M_f(std::move(__b._M_f)), _M_bound_args(std::move(__b._M_bound_args))
      { }


      template<typename... _Args>
 result_type
 operator()(_Args&&... __args)
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args>
 result_type
 operator()(_Args&&... __args) const
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args>
 result_type
 operator()(_Args&&... __args) volatile
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args>
 result_type
 operator()(_Args&&... __args) const volatile
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }
    };





  template<typename _Signature>
    struct is_bind_expression<_Bind<_Signature> >
    : public true_type { };





  template<typename _Signature>
    struct is_bind_expression<const _Bind<_Signature> >
    : public true_type { };





  template<typename _Signature>
    struct is_bind_expression<volatile _Bind<_Signature> >
    : public true_type { };





  template<typename _Signature>
    struct is_bind_expression<const volatile _Bind<_Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<_Bind_result<_Result, _Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<const _Bind_result<_Result, _Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<volatile _Bind_result<_Result, _Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<const volatile _Bind_result<_Result, _Signature>>
    : public true_type { };

  template<typename _Func, typename... _BoundArgs>
    struct _Bind_check_arity { };

  template<typename _Ret, typename... _Args, typename... _BoundArgs>
    struct _Bind_check_arity<_Ret (*)(_Args...), _BoundArgs...>
    {
      static_assert(sizeof...(_BoundArgs) == sizeof...(_Args),
                   "Wrong number of arguments for function");
    };

  template<typename _Ret, typename... _Args, typename... _BoundArgs>
    struct _Bind_check_arity<_Ret (*)(_Args......), _BoundArgs...>
    {
      static_assert(sizeof...(_BoundArgs) >= sizeof...(_Args),
                   "Wrong number of arguments for function");
    };

  template<typename _Tp, typename _Class, typename... _BoundArgs>
    struct _Bind_check_arity<_Tp _Class::*, _BoundArgs...>
    {
      using _Arity = typename _Mem_fn<_Tp _Class::*>::_Arity;
      using _Varargs = typename _Mem_fn<_Tp _Class::*>::_Varargs;
      static_assert(_Varargs::value
      ? sizeof...(_BoundArgs) >= _Arity::value + 1
      : sizeof...(_BoundArgs) == _Arity::value + 1,
      "Wrong number of arguments for pointer-to-member");
    };




  template<typename _Tp, typename _Tp2 = typename decay<_Tp>::type>
    using __is_socketlike = __or_<is_integral<_Tp2>, is_enum<_Tp2>>;

  template<bool _SocketLike, typename _Func, typename... _BoundArgs>
    struct _Bind_helper
    : _Bind_check_arity<typename decay<_Func>::type, _BoundArgs...>
    {
      typedef _Maybe_wrap_member_pointer<typename decay<_Func>::type>
 __maybe_type;
      typedef typename __maybe_type::type __func_type;
      typedef _Bind<__func_type(typename decay<_BoundArgs>::type...)> type;
    };




  template<typename _Func, typename... _BoundArgs>
    struct _Bind_helper<true, _Func, _BoundArgs...>
    { };





  template<typename _Func, typename... _BoundArgs>
    inline typename
    _Bind_helper<__is_socketlike<_Func>::value, _Func, _BoundArgs...>::type
    bind(_Func&& __f, _BoundArgs&&... __args)
    {
      typedef _Bind_helper<false, _Func, _BoundArgs...> __helper_type;
      typedef typename __helper_type::__maybe_type __maybe_type;
      typedef typename __helper_type::type __result_type;
      return __result_type(__maybe_type::__do_wrap(std::forward<_Func>(__f)),
      std::forward<_BoundArgs>(__args)...);
    }

  template<typename _Result, typename _Func, typename... _BoundArgs>
    struct _Bindres_helper
    : _Bind_check_arity<typename decay<_Func>::type, _BoundArgs...>
    {
      typedef _Maybe_wrap_member_pointer<typename decay<_Func>::type>
 __maybe_type;
      typedef typename __maybe_type::type __functor_type;
      typedef _Bind_result<_Result,
      __functor_type(typename decay<_BoundArgs>::type...)>
 type;
    };





  template<typename _Result, typename _Func, typename... _BoundArgs>
    inline
    typename _Bindres_helper<_Result, _Func, _BoundArgs...>::type
    bind(_Func&& __f, _BoundArgs&&... __args)
    {
      typedef _Bindres_helper<_Result, _Func, _BoundArgs...> __helper_type;
      typedef typename __helper_type::__maybe_type __maybe_type;
      typedef typename __helper_type::type __result_type;
      return __result_type(__maybe_type::__do_wrap(std::forward<_Func>(__f)),
      std::forward<_BoundArgs>(__args)...);
    }

  template<typename _Signature>
    struct _Bind_simple;

  template<typename _Callable, typename... _Args>
    struct _Bind_simple<_Callable(_Args...)>
    {
      typedef typename result_of<_Callable(_Args...)>::type result_type;

      template<typename _Tp, typename... _Up>
        explicit
        _Bind_simple(_Tp&& __f, _Up&&... __args)
        : _M_bound(std::forward<_Tp>(__f), std::forward<_Up>(__args)...)
        { }

      _Bind_simple(const _Bind_simple&) = default;
      _Bind_simple(_Bind_simple&&) = default;

      result_type
      operator()()
      {
        typedef typename _Build_index_tuple<sizeof...(_Args)>::__type _Indices;
        return _M_invoke(_Indices());
      }

    private:
      template<std::size_t... _Indices>
        typename result_of<_Callable(_Args...)>::type
        _M_invoke(_Index_tuple<_Indices...>)
        {


          return std::forward<_Callable>(std::get<0>(_M_bound))(
              std::forward<_Args>(std::get<_Indices+1>(_M_bound))...);
        }

      std::tuple<_Callable, _Args...> _M_bound;
    };

  template<typename _Func, typename... _BoundArgs>
    struct _Bind_simple_helper
    : _Bind_check_arity<typename decay<_Func>::type, _BoundArgs...>
    {
      typedef _Maybe_wrap_member_pointer<typename decay<_Func>::type>
        __maybe_type;
      typedef typename __maybe_type::type __func_type;
      typedef _Bind_simple<__func_type(typename decay<_BoundArgs>::type...)>
        __type;
    };



  template<typename _Callable, typename... _Args>
    typename _Bind_simple_helper<_Callable, _Args...>::__type
    __bind_simple(_Callable&& __callable, _Args&&... __args)
    {
      typedef _Bind_simple_helper<_Callable, _Args...> __helper_type;
      typedef typename __helper_type::__maybe_type __maybe_type;
      typedef typename __helper_type::__type __result_type;
      return __result_type(
          __maybe_type::__do_wrap( std::forward<_Callable>(__callable)),
          std::forward<_Args>(__args)...);
    }






  class bad_function_call : public std::exception
  {
  public:
    virtual ~bad_function_call() noexcept;

    const char* what() const noexcept;
  };







  template<typename _Tp>
    struct __is_location_invariant
    : is_trivially_copyable<_Tp>::type
    { };

  class _Undefined_class;

  union _Nocopy_types
  {
    void* _M_object;
    const void* _M_const_object;
    void (*_M_function_pointer)();
    void (_Undefined_class::*_M_member_pointer)();
  };

  union _Any_data
  {
    void* _M_access() { return &_M_pod_data[0]; }
    const void* _M_access() const { return &_M_pod_data[0]; }

    template<typename _Tp>
      _Tp&
      _M_access()
      { return *static_cast<_Tp*>(_M_access()); }

    template<typename _Tp>
      const _Tp&
      _M_access() const
      { return *static_cast<const _Tp*>(_M_access()); }

    _Nocopy_types _M_unused;
    char _M_pod_data[sizeof(_Nocopy_types)];
  };

  enum _Manager_operation
  {
    __get_type_info,
    __get_functor_ptr,
    __clone_functor,
    __destroy_functor
  };



  template<typename _Tp>
    struct _Simple_type_wrapper
    {
      _Simple_type_wrapper(_Tp __value) : __value(__value) { }

      _Tp __value;
    };

  template<typename _Tp>
    struct __is_location_invariant<_Simple_type_wrapper<_Tp> >
    : __is_location_invariant<_Tp>
    { };



  template<typename _Functor>
    inline _Functor&
    __callable_functor(_Functor& __f)
    { return __f; }

  template<typename _Member, typename _Class>
    inline _Mem_fn<_Member _Class::*>
    __callable_functor(_Member _Class::* &__p)
    { return std::mem_fn(__p); }

  template<typename _Member, typename _Class>
    inline _Mem_fn<_Member _Class::*>
    __callable_functor(_Member _Class::* const &__p)
    { return std::mem_fn(__p); }

  template<typename _Member, typename _Class>
    inline _Mem_fn<_Member _Class::*>
    __callable_functor(_Member _Class::* volatile &__p)
    { return std::mem_fn(__p); }

  template<typename _Member, typename _Class>
    inline _Mem_fn<_Member _Class::*>
    __callable_functor(_Member _Class::* const volatile &__p)
    { return std::mem_fn(__p); }

  template<typename _Signature>
    class function;


  class _Function_base
  {
  public:
    static const std::size_t _M_max_size = sizeof(_Nocopy_types);
    static const std::size_t _M_max_align = __alignof__(_Nocopy_types);

    template<typename _Functor>
      class _Base_manager
      {
      protected:
 static const bool __stored_locally =
 (__is_location_invariant<_Functor>::value
  && sizeof(_Functor) <= _M_max_size
  && __alignof__(_Functor) <= _M_max_align
  && (_M_max_align % __alignof__(_Functor) == 0));

 typedef integral_constant<bool, __stored_locally> _Local_storage;


 static _Functor*
 _M_get_pointer(const _Any_data& __source)
 {
   const _Functor* __ptr =
     __stored_locally? std::__addressof(__source._M_access<_Functor>())
                                 : __source._M_access<_Functor*>();
   return const_cast<_Functor*>(__ptr);
 }



 static void
 _M_clone(_Any_data& __dest, const _Any_data& __source, true_type)
 {
   new (__dest._M_access()) _Functor(__source._M_access<_Functor>());
 }



 static void
 _M_clone(_Any_data& __dest, const _Any_data& __source, false_type)
 {
   __dest._M_access<_Functor*>() =
     new _Functor(*__source._M_access<_Functor*>());
 }



 static void
 _M_destroy(_Any_data& __victim, true_type)
 {
   __victim._M_access<_Functor>().~_Functor();
 }


 static void
 _M_destroy(_Any_data& __victim, false_type)
 {
   delete __victim._M_access<_Functor*>();
 }

      public:
 static bool
 _M_manager(_Any_data& __dest, const _Any_data& __source,
     _Manager_operation __op)
 {
   switch (__op)
     {

     case __get_type_info:
       __dest._M_access<const type_info*>() = &typeid(_Functor);
       break;

     case __get_functor_ptr:
       __dest._M_access<_Functor*>() = _M_get_pointer(__source);
       break;

     case __clone_functor:
       _M_clone(__dest, __source, _Local_storage());
       break;

     case __destroy_functor:
       _M_destroy(__dest, _Local_storage());
       break;
     }
   return false;
 }

 static void
 _M_init_functor(_Any_data& __functor, _Functor&& __f)
 { _M_init_functor(__functor, std::move(__f), _Local_storage()); }

 template<typename _Signature>
   static bool
   _M_not_empty_function(const function<_Signature>& __f)
   { return static_cast<bool>(__f); }

 template<typename _Tp>
   static bool
   _M_not_empty_function(_Tp* __fp)
   { return __fp != nullptr; }

 template<typename _Class, typename _Tp>
   static bool
   _M_not_empty_function(_Tp _Class::* __mp)
   { return __mp != nullptr; }

 template<typename _Tp>
   static bool
   _M_not_empty_function(const _Tp&)
   { return true; }

      private:
 static void
 _M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
 { new (__functor._M_access()) _Functor(std::move(__f)); }

 static void
 _M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
 { __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
      };

    template<typename _Functor>
      class _Ref_manager : public _Base_manager<_Functor*>
      {
 typedef _Function_base::_Base_manager<_Functor*> _Base;

      public:
 static bool
 _M_manager(_Any_data& __dest, const _Any_data& __source,
     _Manager_operation __op)
 {
   switch (__op)
     {

     case __get_type_info:
       __dest._M_access<const type_info*>() = &typeid(_Functor);
       break;

     case __get_functor_ptr:
       __dest._M_access<_Functor*>() = *_Base::_M_get_pointer(__source);
       return is_const<_Functor>::value;
       break;

     default:
       _Base::_M_manager(__dest, __source, __op);
     }
   return false;
 }

 static void
 _M_init_functor(_Any_data& __functor, reference_wrapper<_Functor> __f)
 {
   _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
 }
      };

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
    {
      if (_M_manager)
 _M_manager(_M_functor, _M_functor, __destroy_functor);
    }


    bool _M_empty() const { return !_M_manager; }

    typedef bool (*_Manager_type)(_Any_data&, const _Any_data&,
      _Manager_operation);

    _Any_data _M_functor;
    _Manager_type _M_manager;
  };

  template<typename _Signature, typename _Functor>
    class _Function_handler;

  template<typename _Res, typename _Functor, typename... _ArgTypes>
    class _Function_handler<_Res(_ArgTypes...), _Functor>
    : public _Function_base::_Base_manager<_Functor>
    {
      typedef _Function_base::_Base_manager<_Functor> _Base;

    public:
      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 return (*_Base::_M_get_pointer(__functor))(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Functor, typename... _ArgTypes>
    class _Function_handler<void(_ArgTypes...), _Functor>
    : public _Function_base::_Base_manager<_Functor>
    {
      typedef _Function_base::_Base_manager<_Functor> _Base;

     public:
      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 (*_Base::_M_get_pointer(__functor))(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Res, typename _Functor, typename... _ArgTypes>
    class _Function_handler<_Res(_ArgTypes...), reference_wrapper<_Functor> >
    : public _Function_base::_Ref_manager<_Functor>
    {
      typedef _Function_base::_Ref_manager<_Functor> _Base;

     public:
      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 return std::__callable_functor(**_Base::_M_get_pointer(__functor))(
       std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Functor, typename... _ArgTypes>
    class _Function_handler<void(_ArgTypes...), reference_wrapper<_Functor> >
    : public _Function_base::_Ref_manager<_Functor>
    {
      typedef _Function_base::_Ref_manager<_Functor> _Base;

     public:
      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 std::__callable_functor(**_Base::_M_get_pointer(__functor))(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Class, typename _Member, typename _Res,
    typename... _ArgTypes>
    class _Function_handler<_Res(_ArgTypes...), _Member _Class::*>
    : public _Function_handler<void(_ArgTypes...), _Member _Class::*>
    {
      typedef _Function_handler<void(_ArgTypes...), _Member _Class::*>
 _Base;

     public:
      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 return std::mem_fn(_Base::_M_get_pointer(__functor)->__value)(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Class, typename _Member, typename... _ArgTypes>
    class _Function_handler<void(_ArgTypes...), _Member _Class::*>
    : public _Function_base::_Base_manager<
   _Simple_type_wrapper< _Member _Class::* > >
    {
      typedef _Member _Class::* _Functor;
      typedef _Simple_type_wrapper<_Functor> _Wrapper;
      typedef _Function_base::_Base_manager<_Wrapper> _Base;

    public:
      static bool
      _M_manager(_Any_data& __dest, const _Any_data& __source,
   _Manager_operation __op)
      {
 switch (__op)
   {

   case __get_type_info:
     __dest._M_access<const type_info*>() = &typeid(_Functor);
     break;

   case __get_functor_ptr:
     __dest._M_access<_Functor*>() =
       &_Base::_M_get_pointer(__source)->__value;
     break;

   default:
     _Base::_M_manager(__dest, __source, __op);
   }
 return false;
      }

      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 std::mem_fn(_Base::_M_get_pointer(__functor)->__value)(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _From, typename _To>
    using __check_func_return_type
      = __or_<is_void<_To>, is_same<_From, _To>, is_convertible<_From, _To>>;







  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
    : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,
      private _Function_base
    {
      typedef _Res _Signature_type(_ArgTypes...);

      template<typename _Func,
        typename _Res2 = typename result_of<_Func&(_ArgTypes...)>::type>
 struct _Callable : __check_func_return_type<_Res2, _Res> { };



      template<typename _Tp>
 struct _Callable<function, _Tp> : false_type { };

      template<typename _Cond, typename _Tp>
 using _Requires = typename enable_if<_Cond::value, _Tp>::type;

    public:
      typedef _Res result_type;







      function() noexcept
      : _Function_base() { }





      function(nullptr_t) noexcept
      : _Function_base() { }
#1888 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/functional" 3
      function(const function& __x);
#1897 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/functional" 3
      function(function&& __x) : _Function_base()
      {
 __x.swap(*this);
      }
#1920 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/functional" 3
      template<typename _Functor,
        typename = _Requires<__not_<is_same<_Functor, function>>, void>,
        typename = _Requires<_Callable<_Functor>, void>>
 function(_Functor);
#1937 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/functional" 3
      function&
      operator=(const function& __x)
      {
 function(__x).swap(*this);
 return *this;
      }
#1955 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/functional" 3
      function&
      operator=(function&& __x)
      {
 function(std::move(__x)).swap(*this);
 return *this;
      }
#1969 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/functional" 3
      function&
      operator=(nullptr_t) noexcept
      {
 if (_M_manager)
   {
     _M_manager(_M_functor, _M_functor, __destroy_functor);
     _M_manager = nullptr;
     _M_invoker = nullptr;
   }
 return *this;
      }
#1997 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/functional" 3
      template<typename _Functor>
 _Requires<_Callable<typename decay<_Functor>::type>, function&>
 operator=(_Functor&& __f)
 {
   function(std::forward<_Functor>(__f)).swap(*this);
   return *this;
 }


      template<typename _Functor>
 function&
 operator=(reference_wrapper<_Functor> __f) noexcept
 {
   function(__f).swap(*this);
   return *this;
 }
#2023 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/functional" 3
      void swap(function& __x)
      {
 std::swap(_M_functor, __x._M_functor);
 std::swap(_M_manager, __x._M_manager);
 std::swap(_M_invoker, __x._M_invoker);
      }
#2051 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/functional" 3
      explicit operator bool() const noexcept
      { return !_M_empty(); }
#2064 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/functional" 3
      _Res operator()(_ArgTypes... __args) const;
#2077 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/functional" 3
      const type_info& target_type() const noexcept;
#2088 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/functional" 3
      template<typename _Functor> _Functor* target() noexcept;


      template<typename _Functor> const _Functor* target() const noexcept;


    private:
      using _Invoker_type = _Res (*)(const _Any_data&, _ArgTypes&&...);
      _Invoker_type _M_invoker;
  };


  template<typename _Res, typename... _ArgTypes>
    function<_Res(_ArgTypes...)>::
    function(const function& __x)
    : _Function_base()
    {
      if (static_cast<bool>(__x))
 {
   __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
   _M_invoker = __x._M_invoker;
   _M_manager = __x._M_manager;
 }
    }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor, typename, typename>
      function<_Res(_ArgTypes...)>::
      function(_Functor __f)
      : _Function_base()
      {
 typedef _Function_handler<_Signature_type, _Functor> _My_handler;

 if (_My_handler::_M_not_empty_function(__f))
   {
     _My_handler::_M_init_functor(_M_functor, std::move(__f));
     _M_invoker = &_My_handler::_M_invoke;
     _M_manager = &_My_handler::_M_manager;
   }
      }

  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
 __throw_bad_function_call();
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
    }


  template<typename _Res, typename... _ArgTypes>
    const type_info&
    function<_Res(_ArgTypes...)>::
    target_type() const noexcept
    {
      if (_M_manager)
 {
   _Any_data __typeinfo_result;
   _M_manager(__typeinfo_result, _M_functor, __get_type_info);
   return *__typeinfo_result._M_access<const type_info*>();
 }
      else
 return typeid(void);
    }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor>
      _Functor*
      function<_Res(_ArgTypes...)>::
      target() noexcept
      {
 if (typeid(_Functor) == target_type() && _M_manager)
   {
     _Any_data __ptr;
     if (_M_manager(__ptr, _M_functor, __get_functor_ptr)
  && !is_const<_Functor>::value)
       return 0;
     else
       return __ptr._M_access<_Functor*>();
   }
 else
   return 0;
      }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor>
      const _Functor*
      function<_Res(_ArgTypes...)>::
      target() const noexcept
      {
 if (typeid(_Functor) == target_type() && _M_manager)
   {
     _Any_data __ptr;
     _M_manager(__ptr, _M_functor, __get_functor_ptr);
     return __ptr._M_access<const _Functor*>();
   }
 else
   return 0;
      }
#2200 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/functional" 3
  template<typename _Res, typename... _Args>
    inline bool
    operator==(const function<_Res(_Args...)>& __f, nullptr_t) noexcept
    { return !static_cast<bool>(__f); }


  template<typename _Res, typename... _Args>
    inline bool
    operator==(nullptr_t, const function<_Res(_Args...)>& __f) noexcept
    { return !static_cast<bool>(__f); }
#2218 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/functional" 3
  template<typename _Res, typename... _Args>
    inline bool
    operator!=(const function<_Res(_Args...)>& __f, nullptr_t) noexcept
    { return static_cast<bool>(__f); }


  template<typename _Res, typename... _Args>
    inline bool
    operator!=(nullptr_t, const function<_Res(_Args...)>& __f) noexcept
    { return static_cast<bool>(__f); }
#2236 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/functional" 3
  template<typename _Res, typename... _Args>
    inline void
    swap(function<_Res(_Args...)>& __x, function<_Res(_Args...)>& __y)
    { __x.swap(__y); }


}
#224 "C:/Xilinx/Vivado/2018.3/include/hls_half.h" 2
#292 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"

#292 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
class half;



 namespace detail
 {
#311 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
  template<bool,typename T,typename> struct conditional { typedef T type; };
  template<typename T,typename F> struct conditional<false,T,F> { typedef F type; };


  template<bool> struct bool_type {};
  typedef bool_type<true> true_type;
  typedef bool_type<false> false_type;


  template<typename> struct is_float : false_type {};
  template<typename T> struct is_float<const T> : is_float<T> {};
  template<typename T> struct is_float<volatile T> : is_float<T> {};
  template<typename T> struct is_float<const volatile T> : is_float<T> {};
  template<> struct is_float<float> : true_type {};
  template<> struct is_float<double> : true_type {};
  template<> struct is_float<long double> : true_type {};




  typedef std::uint_least16_t uint16;


  typedef std::uint_least32_t uint32;


  typedef std::int_fast32_t int17;
#350 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
  struct binary_t {};


  constexpr binary_t binary = binary_t();



  struct expr
  {


   explicit constexpr expr(float f) : value_(f) {}



   constexpr operator float() const { return value_; }

  private:

   float value_;
  };





  template<typename T,typename,typename=void,typename=void> struct enable {};
  template<typename T> struct enable<T,half,void,void> { typedef T type; };
  template<typename T> struct enable<T,float,void,void> { typedef T type; };
  template<typename T> struct enable<T,double,void,void> { typedef T type; };
  template<typename T> struct enable<T,long long,void,void> { typedef T type; };
  template<typename T> struct enable<T,unsigned long long,void,void> { typedef T type; };
  template<typename T> struct enable<T,long,void,void> { typedef T type; };
  template<typename T> struct enable<T,unsigned long,void,void> { typedef T type; };
  template<typename T> struct enable<T,int,void,void> { typedef T type; };
  template<typename T> struct enable<T,unsigned int,void,void> { typedef T type; };
  template<typename T> struct enable<T,short,void,void> { typedef T type; };
  template<typename T> struct enable<T,unsigned short,void,void> { typedef T type; };
  template<typename T> struct enable<T,char,void,void> { typedef T type; };
  template<typename T> struct enable<T,unsigned char,void,void> { typedef T type; };
  template<typename T> struct enable<T,expr,void,void> { typedef T type; };
  template<typename T> struct enable<T,half,half,void> { typedef T type; };
  template<typename T> struct enable<T,half,long long,void> { typedef T type; };
  template<typename T> struct enable<T,half,unsigned long long,void> { typedef T type; };
  template<typename T> struct enable<T,half,long,void> { typedef T type; };
  template<typename T> struct enable<T,half,unsigned long,void> { typedef T type; };
  template<typename T> struct enable<T,half,int,void> { typedef T type; };
  template<typename T> struct enable<T,half,unsigned int,void> { typedef T type; };
  template<typename T> struct enable<T,half,short,void> { typedef T type; };
  template<typename T> struct enable<T,half,unsigned short,void> { typedef T type; };
  template<typename T> struct enable<T,half,char,void> { typedef T type; };
  template<typename T> struct enable<T,half,unsigned char,void> { typedef T type; };
  template<typename T> struct enable<T,float,half,void> { typedef float type; };
  template<typename T> struct enable<T,half,float,void> { typedef float type; };
  template<typename T> struct enable<T,double,half,void> { typedef double type; };
  template<typename T> struct enable<T,half,double,void> { typedef double type; };
  template<typename T> struct enable<T,half,expr,void> { typedef T type; };
  template<typename T> struct enable<T,expr,half,void> { typedef T type; };
  template<typename T> struct enable<T,expr,expr,void> { typedef T type; };
  template<typename T> struct enable<T,half,half,half> { typedef T type; };
  template<typename T> struct enable<T,half,half,expr> { typedef T type; };
  template<typename T> struct enable<T,half,expr,half> { typedef T type; };
  template<typename T> struct enable<T,half,expr,expr> { typedef T type; };
  template<typename T> struct enable<T,expr,half,half> { typedef T type; };
  template<typename T> struct enable<T,expr,half,expr> { typedef T type; };
  template<typename T> struct enable<T,expr,expr,half> { typedef T type; };
  template<typename T> struct enable<T,expr,expr,expr> { typedef T type; };






  template<typename T,typename U> struct result : enable<expr,T,U> {};
  template<> struct result<half,half> { typedef half type; };
#434 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
  template<typename T> bool builtin_isinf(T arg)
  {

   return std::isinf(arg);





  }






  template<typename T> bool builtin_isnan(T arg)
  {

   return std::isnan(arg);





  }






  template<typename T> bool builtin_signbit(T arg)
  {

   return std::signbit(arg);



  }
#484 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
  template<std::float_round_style R> uint16 float2half_impl(float value, true_type)
  {

   static_assert(std::numeric_limits<float>::is_iec559, "float to half conversion needs IEEE 754 conformant 'float' type");
   static_assert(sizeof(uint32)==sizeof(float), "float to half conversion needs unsigned integer type of exactly the size of a 'float'");

   static const uint16 base_table[512] = {
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080, 0x0100,
    0x0200, 0x0400, 0x0800, 0x0C00, 0x1000, 0x1400, 0x1800, 0x1C00, 0x2000, 0x2400, 0x2800, 0x2C00, 0x3000, 0x3400, 0x3800, 0x3C00,
    0x4000, 0x4400, 0x4800, 0x4C00, 0x5000, 0x5400, 0x5800, 0x5C00, 0x6000, 0x6400, 0x6800, 0x6C00, 0x7000, 0x7400, 0x7800, 0x7C00,
    0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
    0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
    0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
    0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
    0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
    0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
    0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
    0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
    0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
    0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
    0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
    0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
    0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
    0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8001, 0x8002, 0x8004, 0x8008, 0x8010, 0x8020, 0x8040, 0x8080, 0x8100,
    0x8200, 0x8400, 0x8800, 0x8C00, 0x9000, 0x9400, 0x9800, 0x9C00, 0xA000, 0xA400, 0xA800, 0xAC00, 0xB000, 0xB400, 0xB800, 0xBC00,
    0xC000, 0xC400, 0xC800, 0xCC00, 0xD000, 0xD400, 0xD800, 0xDC00, 0xE000, 0xE400, 0xE800, 0xEC00, 0xF000, 0xF400, 0xF800, 0xFC00,
    0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
    0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
    0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
    0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
    0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
    0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
    0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00 };
   static const unsigned char shift_table[512] = {
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 13,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 13 };
   uint32 bits;
   std::memcpy(&bits, &value, sizeof(float));
   uint16 hbits = base_table[bits>>23] + static_cast<uint16>((bits&0x7FFFFF)>>shift_table[bits>>23]);
   if(R == std::round_to_nearest)
    hbits += (((bits&0x7FFFFF)>>(shift_table[bits>>23]-1))|(((bits>>23)&0xFF)==102)) & ((hbits&0x7C00)!=0x7C00)

     & (((((static_cast<uint32>(1)<<(shift_table[bits>>23]-1))-1)&bits)!=0)|hbits)

    ;
   else if(R == std::round_toward_zero)
    hbits -= ((hbits&0x7FFF)==0x7C00) & ~shift_table[bits>>23];
   else if(R == std::round_toward_infinity)
    hbits += ((((bits&0x7FFFFF&((static_cast<uint32>(1)<<(shift_table[bits>>23]))-1))!=0)|(((bits>>23)<=102)&
     ((bits>>23)!=0)))&(hbits<0x7C00)) - ((hbits==0xFC00)&((bits>>23)!=511));
   else if(R == std::round_toward_neg_infinity)
    hbits += ((((bits&0x7FFFFF&((static_cast<uint32>(1)<<(shift_table[bits>>23]))-1))!=0)|(((bits>>23)<=358)&
     ((bits>>23)!=256)))&(hbits<0xFC00)&(hbits>>15)) - ((hbits==0x7C00)&((bits>>23)!=255));
   return hbits;
  }




  template<std::float_round_style R> uint16 float2half_impl(float value, false_type)
  {
   uint16 hbits = builtin_signbit(value) << 15;
   if(value == 0.0f)
    return hbits;
   if(builtin_isnan(value))
    return hbits | 0x7FFF;
   if(builtin_isinf(value))
    return hbits | 0x7C00;
   int exp;
   std::frexp(value, &exp);
   if(exp > 16)
   {
    if(R == std::round_toward_zero)
     return hbits | 0x7BFF;
    else if(R == std::round_toward_infinity)
     return hbits | 0x7C00 - (hbits>>15);
    else if(R == std::round_toward_neg_infinity)
     return hbits | 0x7BFF + (hbits>>15);
    return hbits | 0x7C00;
   }
   if(exp < -13)
    value = std::ldexp(value, 24);
   else
   {
    value = std::ldexp(value, 11-exp);
    hbits |= ((exp+14)<<10);
   }
   int ival = static_cast<int>(value);
   hbits |= static_cast<uint16>(std::abs(ival)&0x3FF);
   if(R == std::round_to_nearest)
   {
    float diff = std::abs(value-static_cast<float>(ival));

     hbits += (diff>0.5f) | ((diff==0.5f)&hbits);



   }
   else if(R == std::round_toward_infinity)
    hbits += value > static_cast<float>(ival);
   else if(R == std::round_toward_neg_infinity)
    hbits += value < static_cast<float>(ival);
   return hbits;
  }




  template<std::float_round_style R> uint16 float2half(float value)
  {
   return float2half_impl<R>(value, bool_type<std::numeric_limits<float>::is_iec559&&sizeof(uint32)==sizeof(float)>());
  }







  template<std::float_round_style R,bool S,typename T> uint16 int2half_impl(T value)
  {
   if(S)
    value = -value;
   uint16 bits = S << 15;
   if(value > 65504)
   {
    if(R == std::round_toward_infinity)
     bits |= 0x7C00 - S;
    else if(R == std::round_toward_neg_infinity)
     bits |= 0x7BFF + S;
    else
     bits |= 0x7BFF + (R!=std::round_toward_zero);
   }
   else if(value)
   {
    unsigned int m = value, exp = 25;
    for(; m<0x400; m<<=1,--exp) ;
    for(; m>0x7FF; m>>=1,++exp) ;
    bits |= (exp<<10) | (m&0x3FF);
    if(exp > 25)
    {
     if(R == std::round_to_nearest)
      bits += (value>>(exp-26)) & 1

       & (((((1<<(exp-26))-1)&value)!=0)|bits)

      ;
     else if(R == std::round_toward_infinity)
      bits += ((value&((1<<(exp-25))-1))!=0) & !S;
     else if(R == std::round_toward_neg_infinity)
      bits += ((value&((1<<(exp-25))-1))!=0) & S;
    }
   }
   return bits;
  }






  template<std::float_round_style R,typename T> uint16 int2half(T value)
  {
   return (value<0) ? int2half_impl<R,true>(value) : int2half_impl<R,false>(value);
  }





  inline float half2float_impl(uint16 value, true_type)
  {

   static_assert(std::numeric_limits<float>::is_iec559, "half to float conversion needs IEEE 754 conformant 'float' type");
   static_assert(sizeof(uint32)==sizeof(float), "half to float conversion needs unsigned integer type of exactly the size of a 'float'");

   static const uint32 mantissa_table[2048] = {
    0x00000000, 0x33800000, 0x34000000, 0x34400000, 0x34800000, 0x34A00000, 0x34C00000, 0x34E00000, 0x35000000, 0x35100000, 0x35200000, 0x35300000, 0x35400000, 0x35500000, 0x35600000, 0x35700000,
    0x35800000, 0x35880000, 0x35900000, 0x35980000, 0x35A00000, 0x35A80000, 0x35B00000, 0x35B80000, 0x35C00000, 0x35C80000, 0x35D00000, 0x35D80000, 0x35E00000, 0x35E80000, 0x35F00000, 0x35F80000,
    0x36000000, 0x36040000, 0x36080000, 0x360C0000, 0x36100000, 0x36140000, 0x36180000, 0x361C0000, 0x36200000, 0x36240000, 0x36280000, 0x362C0000, 0x36300000, 0x36340000, 0x36380000, 0x363C0000,
    0x36400000, 0x36440000, 0x36480000, 0x364C0000, 0x36500000, 0x36540000, 0x36580000, 0x365C0000, 0x36600000, 0x36640000, 0x36680000, 0x366C0000, 0x36700000, 0x36740000, 0x36780000, 0x367C0000,
    0x36800000, 0x36820000, 0x36840000, 0x36860000, 0x36880000, 0x368A0000, 0x368C0000, 0x368E0000, 0x36900000, 0x36920000, 0x36940000, 0x36960000, 0x36980000, 0x369A0000, 0x369C0000, 0x369E0000,
    0x36A00000, 0x36A20000, 0x36A40000, 0x36A60000, 0x36A80000, 0x36AA0000, 0x36AC0000, 0x36AE0000, 0x36B00000, 0x36B20000, 0x36B40000, 0x36B60000, 0x36B80000, 0x36BA0000, 0x36BC0000, 0x36BE0000,
    0x36C00000, 0x36C20000, 0x36C40000, 0x36C60000, 0x36C80000, 0x36CA0000, 0x36CC0000, 0x36CE0000, 0x36D00000, 0x36D20000, 0x36D40000, 0x36D60000, 0x36D80000, 0x36DA0000, 0x36DC0000, 0x36DE0000,
    0x36E00000, 0x36E20000, 0x36E40000, 0x36E60000, 0x36E80000, 0x36EA0000, 0x36EC0000, 0x36EE0000, 0x36F00000, 0x36F20000, 0x36F40000, 0x36F60000, 0x36F80000, 0x36FA0000, 0x36FC0000, 0x36FE0000,
    0x37000000, 0x37010000, 0x37020000, 0x37030000, 0x37040000, 0x37050000, 0x37060000, 0x37070000, 0x37080000, 0x37090000, 0x370A0000, 0x370B0000, 0x370C0000, 0x370D0000, 0x370E0000, 0x370F0000,
    0x37100000, 0x37110000, 0x37120000, 0x37130000, 0x37140000, 0x37150000, 0x37160000, 0x37170000, 0x37180000, 0x37190000, 0x371A0000, 0x371B0000, 0x371C0000, 0x371D0000, 0x371E0000, 0x371F0000,
    0x37200000, 0x37210000, 0x37220000, 0x37230000, 0x37240000, 0x37250000, 0x37260000, 0x37270000, 0x37280000, 0x37290000, 0x372A0000, 0x372B0000, 0x372C0000, 0x372D0000, 0x372E0000, 0x372F0000,
    0x37300000, 0x37310000, 0x37320000, 0x37330000, 0x37340000, 0x37350000, 0x37360000, 0x37370000, 0x37380000, 0x37390000, 0x373A0000, 0x373B0000, 0x373C0000, 0x373D0000, 0x373E0000, 0x373F0000,
    0x37400000, 0x37410000, 0x37420000, 0x37430000, 0x37440000, 0x37450000, 0x37460000, 0x37470000, 0x37480000, 0x37490000, 0x374A0000, 0x374B0000, 0x374C0000, 0x374D0000, 0x374E0000, 0x374F0000,
    0x37500000, 0x37510000, 0x37520000, 0x37530000, 0x37540000, 0x37550000, 0x37560000, 0x37570000, 0x37580000, 0x37590000, 0x375A0000, 0x375B0000, 0x375C0000, 0x375D0000, 0x375E0000, 0x375F0000,
    0x37600000, 0x37610000, 0x37620000, 0x37630000, 0x37640000, 0x37650000, 0x37660000, 0x37670000, 0x37680000, 0x37690000, 0x376A0000, 0x376B0000, 0x376C0000, 0x376D0000, 0x376E0000, 0x376F0000,
    0x37700000, 0x37710000, 0x37720000, 0x37730000, 0x37740000, 0x37750000, 0x37760000, 0x37770000, 0x37780000, 0x37790000, 0x377A0000, 0x377B0000, 0x377C0000, 0x377D0000, 0x377E0000, 0x377F0000,
    0x37800000, 0x37808000, 0x37810000, 0x37818000, 0x37820000, 0x37828000, 0x37830000, 0x37838000, 0x37840000, 0x37848000, 0x37850000, 0x37858000, 0x37860000, 0x37868000, 0x37870000, 0x37878000,
    0x37880000, 0x37888000, 0x37890000, 0x37898000, 0x378A0000, 0x378A8000, 0x378B0000, 0x378B8000, 0x378C0000, 0x378C8000, 0x378D0000, 0x378D8000, 0x378E0000, 0x378E8000, 0x378F0000, 0x378F8000,
    0x37900000, 0x37908000, 0x37910000, 0x37918000, 0x37920000, 0x37928000, 0x37930000, 0x37938000, 0x37940000, 0x37948000, 0x37950000, 0x37958000, 0x37960000, 0x37968000, 0x37970000, 0x37978000,
    0x37980000, 0x37988000, 0x37990000, 0x37998000, 0x379A0000, 0x379A8000, 0x379B0000, 0x379B8000, 0x379C0000, 0x379C8000, 0x379D0000, 0x379D8000, 0x379E0000, 0x379E8000, 0x379F0000, 0x379F8000,
    0x37A00000, 0x37A08000, 0x37A10000, 0x37A18000, 0x37A20000, 0x37A28000, 0x37A30000, 0x37A38000, 0x37A40000, 0x37A48000, 0x37A50000, 0x37A58000, 0x37A60000, 0x37A68000, 0x37A70000, 0x37A78000,
    0x37A80000, 0x37A88000, 0x37A90000, 0x37A98000, 0x37AA0000, 0x37AA8000, 0x37AB0000, 0x37AB8000, 0x37AC0000, 0x37AC8000, 0x37AD0000, 0x37AD8000, 0x37AE0000, 0x37AE8000, 0x37AF0000, 0x37AF8000,
    0x37B00000, 0x37B08000, 0x37B10000, 0x37B18000, 0x37B20000, 0x37B28000, 0x37B30000, 0x37B38000, 0x37B40000, 0x37B48000, 0x37B50000, 0x37B58000, 0x37B60000, 0x37B68000, 0x37B70000, 0x37B78000,
    0x37B80000, 0x37B88000, 0x37B90000, 0x37B98000, 0x37BA0000, 0x37BA8000, 0x37BB0000, 0x37BB8000, 0x37BC0000, 0x37BC8000, 0x37BD0000, 0x37BD8000, 0x37BE0000, 0x37BE8000, 0x37BF0000, 0x37BF8000,
    0x37C00000, 0x37C08000, 0x37C10000, 0x37C18000, 0x37C20000, 0x37C28000, 0x37C30000, 0x37C38000, 0x37C40000, 0x37C48000, 0x37C50000, 0x37C58000, 0x37C60000, 0x37C68000, 0x37C70000, 0x37C78000,
    0x37C80000, 0x37C88000, 0x37C90000, 0x37C98000, 0x37CA0000, 0x37CA8000, 0x37CB0000, 0x37CB8000, 0x37CC0000, 0x37CC8000, 0x37CD0000, 0x37CD8000, 0x37CE0000, 0x37CE8000, 0x37CF0000, 0x37CF8000,
    0x37D00000, 0x37D08000, 0x37D10000, 0x37D18000, 0x37D20000, 0x37D28000, 0x37D30000, 0x37D38000, 0x37D40000, 0x37D48000, 0x37D50000, 0x37D58000, 0x37D60000, 0x37D68000, 0x37D70000, 0x37D78000,
    0x37D80000, 0x37D88000, 0x37D90000, 0x37D98000, 0x37DA0000, 0x37DA8000, 0x37DB0000, 0x37DB8000, 0x37DC0000, 0x37DC8000, 0x37DD0000, 0x37DD8000, 0x37DE0000, 0x37DE8000, 0x37DF0000, 0x37DF8000,
    0x37E00000, 0x37E08000, 0x37E10000, 0x37E18000, 0x37E20000, 0x37E28000, 0x37E30000, 0x37E38000, 0x37E40000, 0x37E48000, 0x37E50000, 0x37E58000, 0x37E60000, 0x37E68000, 0x37E70000, 0x37E78000,
    0x37E80000, 0x37E88000, 0x37E90000, 0x37E98000, 0x37EA0000, 0x37EA8000, 0x37EB0000, 0x37EB8000, 0x37EC0000, 0x37EC8000, 0x37ED0000, 0x37ED8000, 0x37EE0000, 0x37EE8000, 0x37EF0000, 0x37EF8000,
    0x37F00000, 0x37F08000, 0x37F10000, 0x37F18000, 0x37F20000, 0x37F28000, 0x37F30000, 0x37F38000, 0x37F40000, 0x37F48000, 0x37F50000, 0x37F58000, 0x37F60000, 0x37F68000, 0x37F70000, 0x37F78000,
    0x37F80000, 0x37F88000, 0x37F90000, 0x37F98000, 0x37FA0000, 0x37FA8000, 0x37FB0000, 0x37FB8000, 0x37FC0000, 0x37FC8000, 0x37FD0000, 0x37FD8000, 0x37FE0000, 0x37FE8000, 0x37FF0000, 0x37FF8000,
    0x38000000, 0x38004000, 0x38008000, 0x3800C000, 0x38010000, 0x38014000, 0x38018000, 0x3801C000, 0x38020000, 0x38024000, 0x38028000, 0x3802C000, 0x38030000, 0x38034000, 0x38038000, 0x3803C000,
    0x38040000, 0x38044000, 0x38048000, 0x3804C000, 0x38050000, 0x38054000, 0x38058000, 0x3805C000, 0x38060000, 0x38064000, 0x38068000, 0x3806C000, 0x38070000, 0x38074000, 0x38078000, 0x3807C000,
    0x38080000, 0x38084000, 0x38088000, 0x3808C000, 0x38090000, 0x38094000, 0x38098000, 0x3809C000, 0x380A0000, 0x380A4000, 0x380A8000, 0x380AC000, 0x380B0000, 0x380B4000, 0x380B8000, 0x380BC000,
    0x380C0000, 0x380C4000, 0x380C8000, 0x380CC000, 0x380D0000, 0x380D4000, 0x380D8000, 0x380DC000, 0x380E0000, 0x380E4000, 0x380E8000, 0x380EC000, 0x380F0000, 0x380F4000, 0x380F8000, 0x380FC000,
    0x38100000, 0x38104000, 0x38108000, 0x3810C000, 0x38110000, 0x38114000, 0x38118000, 0x3811C000, 0x38120000, 0x38124000, 0x38128000, 0x3812C000, 0x38130000, 0x38134000, 0x38138000, 0x3813C000,
    0x38140000, 0x38144000, 0x38148000, 0x3814C000, 0x38150000, 0x38154000, 0x38158000, 0x3815C000, 0x38160000, 0x38164000, 0x38168000, 0x3816C000, 0x38170000, 0x38174000, 0x38178000, 0x3817C000,
    0x38180000, 0x38184000, 0x38188000, 0x3818C000, 0x38190000, 0x38194000, 0x38198000, 0x3819C000, 0x381A0000, 0x381A4000, 0x381A8000, 0x381AC000, 0x381B0000, 0x381B4000, 0x381B8000, 0x381BC000,
    0x381C0000, 0x381C4000, 0x381C8000, 0x381CC000, 0x381D0000, 0x381D4000, 0x381D8000, 0x381DC000, 0x381E0000, 0x381E4000, 0x381E8000, 0x381EC000, 0x381F0000, 0x381F4000, 0x381F8000, 0x381FC000,
    0x38200000, 0x38204000, 0x38208000, 0x3820C000, 0x38210000, 0x38214000, 0x38218000, 0x3821C000, 0x38220000, 0x38224000, 0x38228000, 0x3822C000, 0x38230000, 0x38234000, 0x38238000, 0x3823C000,
    0x38240000, 0x38244000, 0x38248000, 0x3824C000, 0x38250000, 0x38254000, 0x38258000, 0x3825C000, 0x38260000, 0x38264000, 0x38268000, 0x3826C000, 0x38270000, 0x38274000, 0x38278000, 0x3827C000,
    0x38280000, 0x38284000, 0x38288000, 0x3828C000, 0x38290000, 0x38294000, 0x38298000, 0x3829C000, 0x382A0000, 0x382A4000, 0x382A8000, 0x382AC000, 0x382B0000, 0x382B4000, 0x382B8000, 0x382BC000,
    0x382C0000, 0x382C4000, 0x382C8000, 0x382CC000, 0x382D0000, 0x382D4000, 0x382D8000, 0x382DC000, 0x382E0000, 0x382E4000, 0x382E8000, 0x382EC000, 0x382F0000, 0x382F4000, 0x382F8000, 0x382FC000,
    0x38300000, 0x38304000, 0x38308000, 0x3830C000, 0x38310000, 0x38314000, 0x38318000, 0x3831C000, 0x38320000, 0x38324000, 0x38328000, 0x3832C000, 0x38330000, 0x38334000, 0x38338000, 0x3833C000,
    0x38340000, 0x38344000, 0x38348000, 0x3834C000, 0x38350000, 0x38354000, 0x38358000, 0x3835C000, 0x38360000, 0x38364000, 0x38368000, 0x3836C000, 0x38370000, 0x38374000, 0x38378000, 0x3837C000,
    0x38380000, 0x38384000, 0x38388000, 0x3838C000, 0x38390000, 0x38394000, 0x38398000, 0x3839C000, 0x383A0000, 0x383A4000, 0x383A8000, 0x383AC000, 0x383B0000, 0x383B4000, 0x383B8000, 0x383BC000,
    0x383C0000, 0x383C4000, 0x383C8000, 0x383CC000, 0x383D0000, 0x383D4000, 0x383D8000, 0x383DC000, 0x383E0000, 0x383E4000, 0x383E8000, 0x383EC000, 0x383F0000, 0x383F4000, 0x383F8000, 0x383FC000,
    0x38400000, 0x38404000, 0x38408000, 0x3840C000, 0x38410000, 0x38414000, 0x38418000, 0x3841C000, 0x38420000, 0x38424000, 0x38428000, 0x3842C000, 0x38430000, 0x38434000, 0x38438000, 0x3843C000,
    0x38440000, 0x38444000, 0x38448000, 0x3844C000, 0x38450000, 0x38454000, 0x38458000, 0x3845C000, 0x38460000, 0x38464000, 0x38468000, 0x3846C000, 0x38470000, 0x38474000, 0x38478000, 0x3847C000,
    0x38480000, 0x38484000, 0x38488000, 0x3848C000, 0x38490000, 0x38494000, 0x38498000, 0x3849C000, 0x384A0000, 0x384A4000, 0x384A8000, 0x384AC000, 0x384B0000, 0x384B4000, 0x384B8000, 0x384BC000,
    0x384C0000, 0x384C4000, 0x384C8000, 0x384CC000, 0x384D0000, 0x384D4000, 0x384D8000, 0x384DC000, 0x384E0000, 0x384E4000, 0x384E8000, 0x384EC000, 0x384F0000, 0x384F4000, 0x384F8000, 0x384FC000,
    0x38500000, 0x38504000, 0x38508000, 0x3850C000, 0x38510000, 0x38514000, 0x38518000, 0x3851C000, 0x38520000, 0x38524000, 0x38528000, 0x3852C000, 0x38530000, 0x38534000, 0x38538000, 0x3853C000,
    0x38540000, 0x38544000, 0x38548000, 0x3854C000, 0x38550000, 0x38554000, 0x38558000, 0x3855C000, 0x38560000, 0x38564000, 0x38568000, 0x3856C000, 0x38570000, 0x38574000, 0x38578000, 0x3857C000,
    0x38580000, 0x38584000, 0x38588000, 0x3858C000, 0x38590000, 0x38594000, 0x38598000, 0x3859C000, 0x385A0000, 0x385A4000, 0x385A8000, 0x385AC000, 0x385B0000, 0x385B4000, 0x385B8000, 0x385BC000,
    0x385C0000, 0x385C4000, 0x385C8000, 0x385CC000, 0x385D0000, 0x385D4000, 0x385D8000, 0x385DC000, 0x385E0000, 0x385E4000, 0x385E8000, 0x385EC000, 0x385F0000, 0x385F4000, 0x385F8000, 0x385FC000,
    0x38600000, 0x38604000, 0x38608000, 0x3860C000, 0x38610000, 0x38614000, 0x38618000, 0x3861C000, 0x38620000, 0x38624000, 0x38628000, 0x3862C000, 0x38630000, 0x38634000, 0x38638000, 0x3863C000,
    0x38640000, 0x38644000, 0x38648000, 0x3864C000, 0x38650000, 0x38654000, 0x38658000, 0x3865C000, 0x38660000, 0x38664000, 0x38668000, 0x3866C000, 0x38670000, 0x38674000, 0x38678000, 0x3867C000,
    0x38680000, 0x38684000, 0x38688000, 0x3868C000, 0x38690000, 0x38694000, 0x38698000, 0x3869C000, 0x386A0000, 0x386A4000, 0x386A8000, 0x386AC000, 0x386B0000, 0x386B4000, 0x386B8000, 0x386BC000,
    0x386C0000, 0x386C4000, 0x386C8000, 0x386CC000, 0x386D0000, 0x386D4000, 0x386D8000, 0x386DC000, 0x386E0000, 0x386E4000, 0x386E8000, 0x386EC000, 0x386F0000, 0x386F4000, 0x386F8000, 0x386FC000,
    0x38700000, 0x38704000, 0x38708000, 0x3870C000, 0x38710000, 0x38714000, 0x38718000, 0x3871C000, 0x38720000, 0x38724000, 0x38728000, 0x3872C000, 0x38730000, 0x38734000, 0x38738000, 0x3873C000,
    0x38740000, 0x38744000, 0x38748000, 0x3874C000, 0x38750000, 0x38754000, 0x38758000, 0x3875C000, 0x38760000, 0x38764000, 0x38768000, 0x3876C000, 0x38770000, 0x38774000, 0x38778000, 0x3877C000,
    0x38780000, 0x38784000, 0x38788000, 0x3878C000, 0x38790000, 0x38794000, 0x38798000, 0x3879C000, 0x387A0000, 0x387A4000, 0x387A8000, 0x387AC000, 0x387B0000, 0x387B4000, 0x387B8000, 0x387BC000,
    0x387C0000, 0x387C4000, 0x387C8000, 0x387CC000, 0x387D0000, 0x387D4000, 0x387D8000, 0x387DC000, 0x387E0000, 0x387E4000, 0x387E8000, 0x387EC000, 0x387F0000, 0x387F4000, 0x387F8000, 0x387FC000,
    0x38000000, 0x38002000, 0x38004000, 0x38006000, 0x38008000, 0x3800A000, 0x3800C000, 0x3800E000, 0x38010000, 0x38012000, 0x38014000, 0x38016000, 0x38018000, 0x3801A000, 0x3801C000, 0x3801E000,
    0x38020000, 0x38022000, 0x38024000, 0x38026000, 0x38028000, 0x3802A000, 0x3802C000, 0x3802E000, 0x38030000, 0x38032000, 0x38034000, 0x38036000, 0x38038000, 0x3803A000, 0x3803C000, 0x3803E000,
    0x38040000, 0x38042000, 0x38044000, 0x38046000, 0x38048000, 0x3804A000, 0x3804C000, 0x3804E000, 0x38050000, 0x38052000, 0x38054000, 0x38056000, 0x38058000, 0x3805A000, 0x3805C000, 0x3805E000,
    0x38060000, 0x38062000, 0x38064000, 0x38066000, 0x38068000, 0x3806A000, 0x3806C000, 0x3806E000, 0x38070000, 0x38072000, 0x38074000, 0x38076000, 0x38078000, 0x3807A000, 0x3807C000, 0x3807E000,
    0x38080000, 0x38082000, 0x38084000, 0x38086000, 0x38088000, 0x3808A000, 0x3808C000, 0x3808E000, 0x38090000, 0x38092000, 0x38094000, 0x38096000, 0x38098000, 0x3809A000, 0x3809C000, 0x3809E000,
    0x380A0000, 0x380A2000, 0x380A4000, 0x380A6000, 0x380A8000, 0x380AA000, 0x380AC000, 0x380AE000, 0x380B0000, 0x380B2000, 0x380B4000, 0x380B6000, 0x380B8000, 0x380BA000, 0x380BC000, 0x380BE000,
    0x380C0000, 0x380C2000, 0x380C4000, 0x380C6000, 0x380C8000, 0x380CA000, 0x380CC000, 0x380CE000, 0x380D0000, 0x380D2000, 0x380D4000, 0x380D6000, 0x380D8000, 0x380DA000, 0x380DC000, 0x380DE000,
    0x380E0000, 0x380E2000, 0x380E4000, 0x380E6000, 0x380E8000, 0x380EA000, 0x380EC000, 0x380EE000, 0x380F0000, 0x380F2000, 0x380F4000, 0x380F6000, 0x380F8000, 0x380FA000, 0x380FC000, 0x380FE000,
    0x38100000, 0x38102000, 0x38104000, 0x38106000, 0x38108000, 0x3810A000, 0x3810C000, 0x3810E000, 0x38110000, 0x38112000, 0x38114000, 0x38116000, 0x38118000, 0x3811A000, 0x3811C000, 0x3811E000,
    0x38120000, 0x38122000, 0x38124000, 0x38126000, 0x38128000, 0x3812A000, 0x3812C000, 0x3812E000, 0x38130000, 0x38132000, 0x38134000, 0x38136000, 0x38138000, 0x3813A000, 0x3813C000, 0x3813E000,
    0x38140000, 0x38142000, 0x38144000, 0x38146000, 0x38148000, 0x3814A000, 0x3814C000, 0x3814E000, 0x38150000, 0x38152000, 0x38154000, 0x38156000, 0x38158000, 0x3815A000, 0x3815C000, 0x3815E000,
    0x38160000, 0x38162000, 0x38164000, 0x38166000, 0x38168000, 0x3816A000, 0x3816C000, 0x3816E000, 0x38170000, 0x38172000, 0x38174000, 0x38176000, 0x38178000, 0x3817A000, 0x3817C000, 0x3817E000,
    0x38180000, 0x38182000, 0x38184000, 0x38186000, 0x38188000, 0x3818A000, 0x3818C000, 0x3818E000, 0x38190000, 0x38192000, 0x38194000, 0x38196000, 0x38198000, 0x3819A000, 0x3819C000, 0x3819E000,
    0x381A0000, 0x381A2000, 0x381A4000, 0x381A6000, 0x381A8000, 0x381AA000, 0x381AC000, 0x381AE000, 0x381B0000, 0x381B2000, 0x381B4000, 0x381B6000, 0x381B8000, 0x381BA000, 0x381BC000, 0x381BE000,
    0x381C0000, 0x381C2000, 0x381C4000, 0x381C6000, 0x381C8000, 0x381CA000, 0x381CC000, 0x381CE000, 0x381D0000, 0x381D2000, 0x381D4000, 0x381D6000, 0x381D8000, 0x381DA000, 0x381DC000, 0x381DE000,
    0x381E0000, 0x381E2000, 0x381E4000, 0x381E6000, 0x381E8000, 0x381EA000, 0x381EC000, 0x381EE000, 0x381F0000, 0x381F2000, 0x381F4000, 0x381F6000, 0x381F8000, 0x381FA000, 0x381FC000, 0x381FE000,
    0x38200000, 0x38202000, 0x38204000, 0x38206000, 0x38208000, 0x3820A000, 0x3820C000, 0x3820E000, 0x38210000, 0x38212000, 0x38214000, 0x38216000, 0x38218000, 0x3821A000, 0x3821C000, 0x3821E000,
    0x38220000, 0x38222000, 0x38224000, 0x38226000, 0x38228000, 0x3822A000, 0x3822C000, 0x3822E000, 0x38230000, 0x38232000, 0x38234000, 0x38236000, 0x38238000, 0x3823A000, 0x3823C000, 0x3823E000,
    0x38240000, 0x38242000, 0x38244000, 0x38246000, 0x38248000, 0x3824A000, 0x3824C000, 0x3824E000, 0x38250000, 0x38252000, 0x38254000, 0x38256000, 0x38258000, 0x3825A000, 0x3825C000, 0x3825E000,
    0x38260000, 0x38262000, 0x38264000, 0x38266000, 0x38268000, 0x3826A000, 0x3826C000, 0x3826E000, 0x38270000, 0x38272000, 0x38274000, 0x38276000, 0x38278000, 0x3827A000, 0x3827C000, 0x3827E000,
    0x38280000, 0x38282000, 0x38284000, 0x38286000, 0x38288000, 0x3828A000, 0x3828C000, 0x3828E000, 0x38290000, 0x38292000, 0x38294000, 0x38296000, 0x38298000, 0x3829A000, 0x3829C000, 0x3829E000,
    0x382A0000, 0x382A2000, 0x382A4000, 0x382A6000, 0x382A8000, 0x382AA000, 0x382AC000, 0x382AE000, 0x382B0000, 0x382B2000, 0x382B4000, 0x382B6000, 0x382B8000, 0x382BA000, 0x382BC000, 0x382BE000,
    0x382C0000, 0x382C2000, 0x382C4000, 0x382C6000, 0x382C8000, 0x382CA000, 0x382CC000, 0x382CE000, 0x382D0000, 0x382D2000, 0x382D4000, 0x382D6000, 0x382D8000, 0x382DA000, 0x382DC000, 0x382DE000,
    0x382E0000, 0x382E2000, 0x382E4000, 0x382E6000, 0x382E8000, 0x382EA000, 0x382EC000, 0x382EE000, 0x382F0000, 0x382F2000, 0x382F4000, 0x382F6000, 0x382F8000, 0x382FA000, 0x382FC000, 0x382FE000,
    0x38300000, 0x38302000, 0x38304000, 0x38306000, 0x38308000, 0x3830A000, 0x3830C000, 0x3830E000, 0x38310000, 0x38312000, 0x38314000, 0x38316000, 0x38318000, 0x3831A000, 0x3831C000, 0x3831E000,
    0x38320000, 0x38322000, 0x38324000, 0x38326000, 0x38328000, 0x3832A000, 0x3832C000, 0x3832E000, 0x38330000, 0x38332000, 0x38334000, 0x38336000, 0x38338000, 0x3833A000, 0x3833C000, 0x3833E000,
    0x38340000, 0x38342000, 0x38344000, 0x38346000, 0x38348000, 0x3834A000, 0x3834C000, 0x3834E000, 0x38350000, 0x38352000, 0x38354000, 0x38356000, 0x38358000, 0x3835A000, 0x3835C000, 0x3835E000,
    0x38360000, 0x38362000, 0x38364000, 0x38366000, 0x38368000, 0x3836A000, 0x3836C000, 0x3836E000, 0x38370000, 0x38372000, 0x38374000, 0x38376000, 0x38378000, 0x3837A000, 0x3837C000, 0x3837E000,
    0x38380000, 0x38382000, 0x38384000, 0x38386000, 0x38388000, 0x3838A000, 0x3838C000, 0x3838E000, 0x38390000, 0x38392000, 0x38394000, 0x38396000, 0x38398000, 0x3839A000, 0x3839C000, 0x3839E000,
    0x383A0000, 0x383A2000, 0x383A4000, 0x383A6000, 0x383A8000, 0x383AA000, 0x383AC000, 0x383AE000, 0x383B0000, 0x383B2000, 0x383B4000, 0x383B6000, 0x383B8000, 0x383BA000, 0x383BC000, 0x383BE000,
    0x383C0000, 0x383C2000, 0x383C4000, 0x383C6000, 0x383C8000, 0x383CA000, 0x383CC000, 0x383CE000, 0x383D0000, 0x383D2000, 0x383D4000, 0x383D6000, 0x383D8000, 0x383DA000, 0x383DC000, 0x383DE000,
    0x383E0000, 0x383E2000, 0x383E4000, 0x383E6000, 0x383E8000, 0x383EA000, 0x383EC000, 0x383EE000, 0x383F0000, 0x383F2000, 0x383F4000, 0x383F6000, 0x383F8000, 0x383FA000, 0x383FC000, 0x383FE000,
    0x38400000, 0x38402000, 0x38404000, 0x38406000, 0x38408000, 0x3840A000, 0x3840C000, 0x3840E000, 0x38410000, 0x38412000, 0x38414000, 0x38416000, 0x38418000, 0x3841A000, 0x3841C000, 0x3841E000,
    0x38420000, 0x38422000, 0x38424000, 0x38426000, 0x38428000, 0x3842A000, 0x3842C000, 0x3842E000, 0x38430000, 0x38432000, 0x38434000, 0x38436000, 0x38438000, 0x3843A000, 0x3843C000, 0x3843E000,
    0x38440000, 0x38442000, 0x38444000, 0x38446000, 0x38448000, 0x3844A000, 0x3844C000, 0x3844E000, 0x38450000, 0x38452000, 0x38454000, 0x38456000, 0x38458000, 0x3845A000, 0x3845C000, 0x3845E000,
    0x38460000, 0x38462000, 0x38464000, 0x38466000, 0x38468000, 0x3846A000, 0x3846C000, 0x3846E000, 0x38470000, 0x38472000, 0x38474000, 0x38476000, 0x38478000, 0x3847A000, 0x3847C000, 0x3847E000,
    0x38480000, 0x38482000, 0x38484000, 0x38486000, 0x38488000, 0x3848A000, 0x3848C000, 0x3848E000, 0x38490000, 0x38492000, 0x38494000, 0x38496000, 0x38498000, 0x3849A000, 0x3849C000, 0x3849E000,
    0x384A0000, 0x384A2000, 0x384A4000, 0x384A6000, 0x384A8000, 0x384AA000, 0x384AC000, 0x384AE000, 0x384B0000, 0x384B2000, 0x384B4000, 0x384B6000, 0x384B8000, 0x384BA000, 0x384BC000, 0x384BE000,
    0x384C0000, 0x384C2000, 0x384C4000, 0x384C6000, 0x384C8000, 0x384CA000, 0x384CC000, 0x384CE000, 0x384D0000, 0x384D2000, 0x384D4000, 0x384D6000, 0x384D8000, 0x384DA000, 0x384DC000, 0x384DE000,
    0x384E0000, 0x384E2000, 0x384E4000, 0x384E6000, 0x384E8000, 0x384EA000, 0x384EC000, 0x384EE000, 0x384F0000, 0x384F2000, 0x384F4000, 0x384F6000, 0x384F8000, 0x384FA000, 0x384FC000, 0x384FE000,
    0x38500000, 0x38502000, 0x38504000, 0x38506000, 0x38508000, 0x3850A000, 0x3850C000, 0x3850E000, 0x38510000, 0x38512000, 0x38514000, 0x38516000, 0x38518000, 0x3851A000, 0x3851C000, 0x3851E000,
    0x38520000, 0x38522000, 0x38524000, 0x38526000, 0x38528000, 0x3852A000, 0x3852C000, 0x3852E000, 0x38530000, 0x38532000, 0x38534000, 0x38536000, 0x38538000, 0x3853A000, 0x3853C000, 0x3853E000,
    0x38540000, 0x38542000, 0x38544000, 0x38546000, 0x38548000, 0x3854A000, 0x3854C000, 0x3854E000, 0x38550000, 0x38552000, 0x38554000, 0x38556000, 0x38558000, 0x3855A000, 0x3855C000, 0x3855E000,
    0x38560000, 0x38562000, 0x38564000, 0x38566000, 0x38568000, 0x3856A000, 0x3856C000, 0x3856E000, 0x38570000, 0x38572000, 0x38574000, 0x38576000, 0x38578000, 0x3857A000, 0x3857C000, 0x3857E000,
    0x38580000, 0x38582000, 0x38584000, 0x38586000, 0x38588000, 0x3858A000, 0x3858C000, 0x3858E000, 0x38590000, 0x38592000, 0x38594000, 0x38596000, 0x38598000, 0x3859A000, 0x3859C000, 0x3859E000,
    0x385A0000, 0x385A2000, 0x385A4000, 0x385A6000, 0x385A8000, 0x385AA000, 0x385AC000, 0x385AE000, 0x385B0000, 0x385B2000, 0x385B4000, 0x385B6000, 0x385B8000, 0x385BA000, 0x385BC000, 0x385BE000,
    0x385C0000, 0x385C2000, 0x385C4000, 0x385C6000, 0x385C8000, 0x385CA000, 0x385CC000, 0x385CE000, 0x385D0000, 0x385D2000, 0x385D4000, 0x385D6000, 0x385D8000, 0x385DA000, 0x385DC000, 0x385DE000,
    0x385E0000, 0x385E2000, 0x385E4000, 0x385E6000, 0x385E8000, 0x385EA000, 0x385EC000, 0x385EE000, 0x385F0000, 0x385F2000, 0x385F4000, 0x385F6000, 0x385F8000, 0x385FA000, 0x385FC000, 0x385FE000,
    0x38600000, 0x38602000, 0x38604000, 0x38606000, 0x38608000, 0x3860A000, 0x3860C000, 0x3860E000, 0x38610000, 0x38612000, 0x38614000, 0x38616000, 0x38618000, 0x3861A000, 0x3861C000, 0x3861E000,
    0x38620000, 0x38622000, 0x38624000, 0x38626000, 0x38628000, 0x3862A000, 0x3862C000, 0x3862E000, 0x38630000, 0x38632000, 0x38634000, 0x38636000, 0x38638000, 0x3863A000, 0x3863C000, 0x3863E000,
    0x38640000, 0x38642000, 0x38644000, 0x38646000, 0x38648000, 0x3864A000, 0x3864C000, 0x3864E000, 0x38650000, 0x38652000, 0x38654000, 0x38656000, 0x38658000, 0x3865A000, 0x3865C000, 0x3865E000,
    0x38660000, 0x38662000, 0x38664000, 0x38666000, 0x38668000, 0x3866A000, 0x3866C000, 0x3866E000, 0x38670000, 0x38672000, 0x38674000, 0x38676000, 0x38678000, 0x3867A000, 0x3867C000, 0x3867E000,
    0x38680000, 0x38682000, 0x38684000, 0x38686000, 0x38688000, 0x3868A000, 0x3868C000, 0x3868E000, 0x38690000, 0x38692000, 0x38694000, 0x38696000, 0x38698000, 0x3869A000, 0x3869C000, 0x3869E000,
    0x386A0000, 0x386A2000, 0x386A4000, 0x386A6000, 0x386A8000, 0x386AA000, 0x386AC000, 0x386AE000, 0x386B0000, 0x386B2000, 0x386B4000, 0x386B6000, 0x386B8000, 0x386BA000, 0x386BC000, 0x386BE000,
    0x386C0000, 0x386C2000, 0x386C4000, 0x386C6000, 0x386C8000, 0x386CA000, 0x386CC000, 0x386CE000, 0x386D0000, 0x386D2000, 0x386D4000, 0x386D6000, 0x386D8000, 0x386DA000, 0x386DC000, 0x386DE000,
    0x386E0000, 0x386E2000, 0x386E4000, 0x386E6000, 0x386E8000, 0x386EA000, 0x386EC000, 0x386EE000, 0x386F0000, 0x386F2000, 0x386F4000, 0x386F6000, 0x386F8000, 0x386FA000, 0x386FC000, 0x386FE000,
    0x38700000, 0x38702000, 0x38704000, 0x38706000, 0x38708000, 0x3870A000, 0x3870C000, 0x3870E000, 0x38710000, 0x38712000, 0x38714000, 0x38716000, 0x38718000, 0x3871A000, 0x3871C000, 0x3871E000,
    0x38720000, 0x38722000, 0x38724000, 0x38726000, 0x38728000, 0x3872A000, 0x3872C000, 0x3872E000, 0x38730000, 0x38732000, 0x38734000, 0x38736000, 0x38738000, 0x3873A000, 0x3873C000, 0x3873E000,
    0x38740000, 0x38742000, 0x38744000, 0x38746000, 0x38748000, 0x3874A000, 0x3874C000, 0x3874E000, 0x38750000, 0x38752000, 0x38754000, 0x38756000, 0x38758000, 0x3875A000, 0x3875C000, 0x3875E000,
    0x38760000, 0x38762000, 0x38764000, 0x38766000, 0x38768000, 0x3876A000, 0x3876C000, 0x3876E000, 0x38770000, 0x38772000, 0x38774000, 0x38776000, 0x38778000, 0x3877A000, 0x3877C000, 0x3877E000,
    0x38780000, 0x38782000, 0x38784000, 0x38786000, 0x38788000, 0x3878A000, 0x3878C000, 0x3878E000, 0x38790000, 0x38792000, 0x38794000, 0x38796000, 0x38798000, 0x3879A000, 0x3879C000, 0x3879E000,
    0x387A0000, 0x387A2000, 0x387A4000, 0x387A6000, 0x387A8000, 0x387AA000, 0x387AC000, 0x387AE000, 0x387B0000, 0x387B2000, 0x387B4000, 0x387B6000, 0x387B8000, 0x387BA000, 0x387BC000, 0x387BE000,
    0x387C0000, 0x387C2000, 0x387C4000, 0x387C6000, 0x387C8000, 0x387CA000, 0x387CC000, 0x387CE000, 0x387D0000, 0x387D2000, 0x387D4000, 0x387D6000, 0x387D8000, 0x387DA000, 0x387DC000, 0x387DE000,
    0x387E0000, 0x387E2000, 0x387E4000, 0x387E6000, 0x387E8000, 0x387EA000, 0x387EC000, 0x387EE000, 0x387F0000, 0x387F2000, 0x387F4000, 0x387F6000, 0x387F8000, 0x387FA000, 0x387FC000, 0x387FE000 };
   static const uint32 exponent_table[64] = {
    0x00000000, 0x00800000, 0x01000000, 0x01800000, 0x02000000, 0x02800000, 0x03000000, 0x03800000, 0x04000000, 0x04800000, 0x05000000, 0x05800000, 0x06000000, 0x06800000, 0x07000000, 0x07800000,
    0x08000000, 0x08800000, 0x09000000, 0x09800000, 0x0A000000, 0x0A800000, 0x0B000000, 0x0B800000, 0x0C000000, 0x0C800000, 0x0D000000, 0x0D800000, 0x0E000000, 0x0E800000, 0x0F000000, 0x47800000,
    0x80000000, 0x80800000, 0x81000000, 0x81800000, 0x82000000, 0x82800000, 0x83000000, 0x83800000, 0x84000000, 0x84800000, 0x85000000, 0x85800000, 0x86000000, 0x86800000, 0x87000000, 0x87800000,
    0x88000000, 0x88800000, 0x89000000, 0x89800000, 0x8A000000, 0x8A800000, 0x8B000000, 0x8B800000, 0x8C000000, 0x8C800000, 0x8D000000, 0x8D800000, 0x8E000000, 0x8E800000, 0x8F000000, 0xC7800000 };
   static const unsigned short offset_table[64] = {
       0, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024,
       0, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024 };
   uint32 bits = mantissa_table[offset_table[value>>10]+(value&0x3FF)] + exponent_table[value>>10];


   float out;
   std::memcpy(&out, &bits, sizeof(float));
   return out;
  }




  inline float half2float_impl(uint16 value, false_type)
  {
   float out;
   int abs = value & 0x7FFF;
   if(abs > 0x7C00)
    out = std::numeric_limits<float>::has_quiet_NaN ? std::numeric_limits<float>::quiet_NaN() : 0.0f;
   else if(abs == 0x7C00)
    out = std::numeric_limits<float>::has_infinity ? std::numeric_limits<float>::infinity() : std::numeric_limits<float>::max();
   else if(abs > 0x3FF)
    out = std::ldexp(static_cast<float>((value&0x3FF)|0x400), (abs>>10)-25);
   else
    out = std::ldexp(static_cast<float>(abs), -24);
   return (value&0x8000) ? -out : out;
  }




  inline float half2float(uint16 value)
  {
   return half2float_impl(value, bool_type<std::numeric_limits<float>::is_iec559&&sizeof(uint32)==sizeof(float)>());
  }







  template<std::float_round_style R,bool E,typename T> T half2int_impl(uint16 value)
  {
   unsigned int e = value & 0x7FFF;
   if(e >= 0x7C00)
    return (value&0x8000) ? std::numeric_limits<T>::min() : std::numeric_limits<T>::max();
   if(e < 0x3800)
   {
    if(R == std::round_toward_infinity)
     return T(~(value>>15)&(e!=0));
    else if(R == std::round_toward_neg_infinity)
     return -T(value>0x8000);
    return T();
   }
   int17 m = (value&0x3FF) | 0x400;
   e >>= 10;
   if(e < 25)
   {
    if(R == std::round_indeterminate || R == std::round_toward_zero)
     m >>= 25 - e;
    else
    {
     if(R == std::round_to_nearest)
      m += (1<<(24-e)) - (~(m>>(25-e))&E);
     else if(R == std::round_toward_infinity)
      m += ((value>>15)-1) & ((1<<(25-e))-1U);
     else if(R == std::round_toward_neg_infinity)
      m += -(value>>15) & ((1<<(25-e))-1U);
     m >>= 25 - e;
    }
   }
   else
    m <<= e - 25;


   return static_cast<T>((value&0x8000) ? -m : m);
  }






  template<std::float_round_style R,typename T> T half2int(uint16 value) { return half2int_impl<R,1,T>(value); }





  template<typename T> T half2int_up(uint16 value) { return half2int_impl<std::round_to_nearest,0,T>(value); }






  template<std::float_round_style R,bool E> uint16 round_half_impl(uint16 value)
  {
   unsigned int e = value & 0x7FFF;
   uint16 result = value;
   if(e < 0x3C00)
   {
    result &= 0x8000;
    if(R == std::round_to_nearest)
     result |= 0x3C00U & -(e>=(0x3800+E));
    else if(R == std::round_toward_infinity)
     result |= 0x3C00U & -(~(value>>15)&(e!=0));
    else if(R == std::round_toward_neg_infinity)
     result |= 0x3C00U & -(value>0x8000);
   }
   else if(e < 0x6400)
   {
    e = 25 - (e>>10);
    unsigned int mask = (1<<e) - 1;
    if(R == std::round_to_nearest)
     result += (1<<(e-1)) - (~(result>>e)&E);
    else if(R == std::round_toward_infinity)
     result += mask & ((value>>15)-1);
    else if(R == std::round_toward_neg_infinity)
     result += mask & -(value>>15);
    result &= ~mask;
   }
   return result;
  }





  template<std::float_round_style R> uint16 round_half(uint16 value) { return round_half_impl<R,1>(value); }




  inline uint16 round_half_up(uint16 value) { return round_half_impl<std::round_to_nearest,0>(value); }


  struct functions;
  template<typename> struct unary_specialized;
  template<typename,typename> struct binary_specialized;
  template<typename,typename,std::float_round_style> struct half_caster;
 }
#979 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
 class half
 {
  friend struct detail::functions;
  friend struct detail::unary_specialized<half>;
  friend struct detail::binary_specialized<half,half>;
  template<typename,typename,std::float_round_style> friend struct detail::half_caster;
  friend struct std::numeric_limits<half>;

  friend struct std::hash<half>;


 public:



  constexpr half() : data_() {}




  half(detail::expr rhs) : data_(detail::float2half<round_style>(rhs)) {

            xip_fpo_half_set_flt(rhs);

        }



  half(float rhs) : data_(detail::float2half<round_style>(rhs)) {

            xip_fpo_half_set_flt(rhs);

        }


  template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
  half(const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& rhs) {
   std::cout << "WARNING: explicit method ap_fixed::to_half() should be used to convert ap_fixed to half." << std::endl;
   *this = rhs.to_half();
  }



  operator float() const {



            return xip_fpo_half_get_flt();

        }





  half& operator=(detail::expr rhs) { return *this = static_cast<float>(rhs); }





  template<typename T> typename detail::enable<half&,T>::type operator+=(T rhs) { return *this = *this + rhs; }





  template<typename T> typename detail::enable<half&,T>::type operator-=(T rhs) { return *this = *this - rhs; }





  template<typename T> typename detail::enable<half&,T>::type operator*=(T rhs) { return *this = *this * rhs; }





  template<typename T> typename detail::enable<half&,T>::type operator/=(T rhs) { return *this = *this / rhs; }
#1097 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
  half& operator++() { return *this += 1.0f; }



  half& operator--() { return *this -= 1.0f; }



  half operator++(int) { half out(*this); ++*this; return out; }



  half operator--(int) { half out(*this); --*this; return out; }



        detail::uint16 get_bits() { return data_; }



        void set_bits(detail::uint16 bits) { data_ = bits; }





        xip_fpo_exc_t xip_fpo_get_data(xip_fpo_ptr op) const {
            int exc = 0;
            op->_xip_fpo_sign = ((data_ & 0x8000) ? -1 : 1);
            op->_xip_fpo_exp = ((data_ & 0x7C00) >> 10) - 14;
            *(op->_xip_fpo_d) = ((mp_limb_t)(data_ & 0x3FF) + (mp_limb_t)(0x400)) << (8*sizeof(*(op->_xip_fpo_d)) - 11);
            if ((data_ & 0x7C00) == 0) {
                exc |= 0x1;
                xip_fpo_set_zero(op, op->_xip_fpo_sign);
            } else if ((data_ & 0x7FFF) == 0x7C00) {
                exc |= 0x2;
                xip_fpo_set_inf(op, op->_xip_fpo_sign);
            } else if ((data_ & 0x7FFF) > 0x7C00) {
                exc |= 0x4;
                xip_fpo_set_nan(op);
            }
            return exc;
        }


        float xip_fpo_half_get_flt() const {
            xip_fpo_t op;
            xip_fpo_init2(op, 5, 11);
            xip_fpo_exc_t exc = xip_fpo_get_data(op);
            float res;
            if (exc & 0x1) {
                res = (op->_xip_fpo_sign > 0 ? 0.0f : -0.0f);
            } else if (exc & 0x2) {
                res = (op->_xip_fpo_sign > 0 ? std::numeric_limits<float>::infinity() : -std::numeric_limits<float>::infinity());
            } else if (exc & 0x4) {
                res = std::numeric_limits<float>::quiet_NaN();
            } else {
                res = xip_fpo_get_flt(op);
            }
            xip_fpo_clear(op);
            return res;
        }



        void xip_fpo_set_data(xip_fpo_ptr op) {
            mpfr_t fr;
            (fr)->_mpfr_prec = (op)->_xip_fpo_mant_prec; (fr)->_mpfr_sign = (op)->_xip_fpo_sign; (fr)->_mpfr_exp = (op)->_xip_fpo_exp; (fr)->_mpfr_d = (op)->_xip_fpo_d;;
            data_ = 0;
            data_ |= (op->_xip_fpo_sign == 1 ? 0 : 1) << 15;
            if (((fr)->_mpfr_exp == ((mpfr_exp_t)((~((~(mpfr_ulong)0)>>1))+1)))) {
                data_ &= 0x8000;
            } else if (((fr)->_mpfr_exp == ((mpfr_exp_t)((~((~(mpfr_ulong)0)>>1))+3)))) {
                data_ |= 0x7C00;
            } else if (((fr)->_mpfr_exp == ((mpfr_exp_t)((~((~(mpfr_ulong)0)>>1))+2)))) {
                data_ |= 0x7E00;
            } else {
                data_ |= (op->_xip_fpo_exp + 14) << 10;
                data_ |= (*(op->_xip_fpo_d) << 1) >> (8*sizeof(*(op->_xip_fpo_d)) - 10);
            }
        }


        void xip_fpo_half_set_flt(float rhs) {
            xip_fpo_t op;
            xip_fpo_init2(op, 5, 11);
            xip_fpo_set_flt(op, rhs);
            xip_fpo_set_data(op);
            xip_fpo_clear(op);
        }


        private:

  static const std::float_round_style round_style = (std::float_round_style)(1);



  constexpr half(detail::binary_t, detail::uint16 bits) : data_(bits) {}


  detail::uint16 data_;
 };



    template<typename F>
    half math_function_1arg(F f, half x) {
        half res;
        xip_fpo_t rop, xop;
        xip_fpo_inits2(5, 11, rop, xop, (xip_fpo_ptr)0);
        x.xip_fpo_get_data(xop);
        f(rop, xop);
        res.xip_fpo_set_data(rop);
        xip_fpo_clears(rop, xop, (xip_fpo_ptr)0);
        return res;
    }

    template<typename F>
    half binary_operator(F f, half x, half y) {
        half res;
        xip_fpo_t op, xop, yop;
        xip_fpo_inits2(5, 11, op, xop, yop, (xip_fpo_ptr)0);
        x.xip_fpo_get_data(xop);
        y.xip_fpo_get_data(yop);
        f(op, xop, yop);
        res.xip_fpo_set_data(op);
        xip_fpo_clears(op, xop, yop, (xip_fpo_ptr)0);
        return res;
    }

    template<typename F>
    bool binary_operator_compare(F f, half x, half y) {
        int res;
        xip_fpo_t xop, yop;
        xip_fpo_inits2(5, 11, xop, yop, (xip_fpo_ptr)0);
        x.xip_fpo_get_data(xop);
        y.xip_fpo_get_data(yop);
        f(&res, xop, yop);
        xip_fpo_clears(xop, yop, (xip_fpo_ptr)0);
        return res;
    }
#1248 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
 namespace literal
 {





  inline half operator "" _h(long double value) { return half(static_cast<float>(value)); }
 }



 namespace detail
 {

  struct functions
  {
#1273 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
            template<typename T1, typename T2>
   static half plus(T1 x, T2 y) { return binary_operator(xip_fpo_add, x, y); }
   static float plus(float x, half y) { return xil_fpo_add_flt(x,y); }
   static float plus(half x, float y) { return xil_fpo_add_flt(x,y); }
   static double plus(double x, half y) { return xil_fpo_add_d(x,y); }
   static double plus(half x, double y) { return xil_fpo_add_d(x,y); }
#1289 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
            template<typename T1, typename T2>
   static half minus(T1 x, T2 y) { return binary_operator(xip_fpo_sub, x, y); }
   static float minus(float x, half y) { return xil_fpo_sub_flt(x,y); }
   static float minus(half x, float y) { return xil_fpo_sub_flt(x,y); }
   static double minus(double x, half y) { return xil_fpo_sub_d(x,y); }
   static double minus(half x, double y) { return xil_fpo_sub_d(x,y); }
#1305 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
            template<typename T1, typename T2>
   static half multiplies(T1 x, T2 y) { return binary_operator(xip_fpo_mul, x, y); }
   static float multiplies(float x, half y) { return xil_fpo_mul_flt(x,y); }
   static float multiplies(half x, float y) { return xil_fpo_mul_flt(x,y); }
   static double multiplies(double x, half y) { return xil_fpo_mul_d(x,y); }
   static double multiplies(half x, double y) { return xil_fpo_mul_d(x,y); }
#1321 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
            template<typename T1, typename T2>
   static half divides(T1 x, T2 y) { return binary_operator(xip_fpo_div, x, y); }
   static float divides(float x, half y) { return xil_fpo_div_flt(x,y); }
   static float divides(half x, float y) { return xil_fpo_div_flt(x,y); }
   static double divides(double x, half y) { return xil_fpo_div_d(x,y); }
   static double divides(half x, double y) { return xil_fpo_div_d(x,y); }






   template<typename charT,typename traits> static std::basic_ostream<charT,traits>& write(std::basic_ostream<charT,traits> &out, float arg) { return out << arg; }





   template<typename charT,typename traits> static std::basic_istream<charT,traits>& read(std::basic_istream<charT,traits> &in, half &arg)
   {
    float f;
    if(in >> f)
     arg = f;
    return in;
   }





   static expr fmod(float x, float y) { return expr(std::fmod(x, y)); }





   static expr remainder(float x, float y)
   {

    return expr(std::remainder(x, y));
#1381 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
   }






   static expr remquo(float x, float y, int *quo)
   {

    return expr(std::remquo(x, y, quo));
#1428 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
   }





   static expr fdim(float x, float y)
   {

    return expr(std::fdim(x, y));



   }

                        static expr maxmag(float x, float y)
                        {
    if (fabs(y)>fabs(x)) return expr(y);
    else return expr(x);
                        }

                        static expr minmag(float x, float y)
                        {
    if (fabs(y)<fabs(x)) return expr(y);
    else return expr(x);
                        }






   static expr fma(float x, float y, float z)
   {



    return expr(x*y+z);

   }



   static half nanh(const char*) { return half(binary, 0x7FFF); }




   static expr exp(float arg) { return expr(std::exp(arg)); }




   static expr expm1(float arg)
   {

    return expr(std::expm1(arg));



   }




   static expr exp2(float arg)
   {

    return expr(std::exp2(arg));



   }




   static expr log(float arg) { return expr(std::log(arg)); }




   static expr log10(float arg) { return expr(std::log10(arg)); }




   static expr log1p(float arg)
   {

    return expr(std::log1p(arg));



   }




   static expr log2(float arg)
   {

    return expr(std::log2(arg));



   }

                        static expr logb(float arg)
                        {

                                return expr(std::logb(arg));



                        }




   static expr sqrt(float arg) { return expr(std::sqrt(arg)); }




   static expr cbrt(float arg)
   {

    return expr(std::cbrt(arg));






   }





   static expr hypot(float x, float y)
   {

    return expr(std::hypot(x, y));




   }





   static expr pow(float base, float exp) { return expr(std::pow(base, exp)); }
                        static expr powr(float base, float exp) { return expr(std::pow(base, exp)); }
                        static expr pown(float base, int exp) { return expr(std::pow(base, exp)); }
   static expr rootn(float base, int exp) { return expr(std::pow(base, float(float(1)/float(exp)))); }




   static expr sin(float arg) { return expr(std::sin(arg)); }




   static expr cos(float arg) { return expr(std::cos(arg)); }




   static expr tan(float arg) { return expr(std::tan(arg)); }




   static expr asin(float arg) { return expr(std::asin(arg)); }




   static expr acos(float arg) { return expr(std::acos(arg)); }




   static expr atan(float arg) { return expr(std::atan(arg)); }





   static expr atan2(float x, float y) { return expr(std::atan2(x, y)); }




   static expr sinh(float arg) { return expr(std::sinh(arg)); }




   static expr cosh(float arg) { return expr(std::cosh(arg)); }




   static expr tanh(float arg) { return expr(std::tanh(arg)); }




   static expr asinh(float arg)
   {

    return expr(std::asinh(arg));



   }




   static expr acosh(float arg)
   {

    return expr(std::acosh(arg));



   }




   static expr atanh(float arg)
   {

    return expr(std::atanh(arg));



   }




   static expr erf(float arg)
   {

    return expr(std::erf(arg));



   }




   static expr erfc(float arg)
   {

    return expr(std::erfc(arg));



   }




   static expr lgamma(float arg)
   {

    return expr(std::lgamma(arg));
#1721 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
   }




   static expr tgamma(float arg)
   {

    return expr(std::tgamma(arg));
#1748 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
   }




   static half floor(half arg) { return half(binary, round_half<std::round_toward_neg_infinity>(arg.data_)); }




   static half ceil(half arg) { return half(binary, round_half<std::round_toward_infinity>(arg.data_)); }




   static half trunc(half arg) { return half(binary, round_half<std::round_toward_zero>(arg.data_)); }




   static half round(half arg) { return half(binary, round_half_up(arg.data_)); }




   static long lround(half arg) { return detail::half2int_up<long>(arg.data_); }




   static half rint(half arg) { return half(binary, round_half<half::round_style>(arg.data_)); }




   static long lrint(half arg) { return detail::half2int<half::round_style,long>(arg.data_); }





   static long long llround(half arg) { return detail::half2int_up<long long>(arg.data_); }




   static long long llrint(half arg) { return detail::half2int<half::round_style,long long>(arg.data_); }






   static half frexp(half arg, int *exp)
   {
    unsigned int m = arg.data_ & 0x7FFF;
    if(m >= 0x7C00 || !m)
     return *exp = 0, arg;
    int e = m >> 10;
    if(!e)
     for(m<<=1; m<0x400; m<<=1,--e) ;
    return *exp = e-14, half(binary, static_cast<uint16>((arg.data_&0x8000)|0x3800|(m&0x3FF)));
   }





   static half modf(half arg, half *iptr)
   {
    unsigned int e = arg.data_ & 0x7C00;
    if(e > 0x6000)
     return *iptr = arg, (e==0x7C00&&(arg.data_&0x3FF)) ? arg : half(binary, arg.data_&0x8000);
    if(e < 0x3C00)
     return iptr->data_ = arg.data_ & 0x8000, arg;
    e >>= 10;
    unsigned int mask = (1<<(25-e)) - 1, m = arg.data_ & mask;
    iptr->data_ = arg.data_ & ~mask;
    if(!m)
     return half(binary, arg.data_&0x8000);
    for(; m<0x400; m<<=1,--e) ;
    return half(binary, static_cast<uint16>((arg.data_&0x8000)|(e<<10)|(m&0x3FF)));
   }





   static half scalbln(half arg, long exp)
   {
    long e = arg.data_ & 0x7C00;
    if(e == 0x7C00)
     return arg;
    unsigned int m = arg.data_ & 0x3FF;
    if(e >>= 10)
     m |= 0x400;
    else
    {
     if(!m)
      return arg;
     for(m<<=1; m<0x400; m<<=1,--e) ;
    }
    e += exp;
    uint16 value = arg.data_ & 0x8000;
    if(e > 30)
    {
     if(half::round_style == std::round_toward_zero)
      value |= 0x7BFF;
     else if(half::round_style == std::round_toward_infinity)
      value |= 0x7C00 - (value>>15);
     else if(half::round_style == std::round_toward_neg_infinity)
      value |= 0x7BFF + (value>>15);
     else
      value |= 0x7C00;
    }
    else if(e > 0)
     value |= (e<<10) | (m&0x3FF);
    else if(e > -11)
    {
     if(half::round_style == std::round_to_nearest)
     {
      m += 1 << -e;

      m -= (m>>(1-e)) & 1;

     }
     else if(half::round_style == std::round_toward_infinity)
      m += ((value>>15)-1) & ((1<<(1-e))-1U);
     else if(half::round_style == std::round_toward_neg_infinity)
      m += -(value>>15) & ((1<<(1-e))-1U);
     value |= m >> (1-e);
    }
    else if(half::round_style == std::round_toward_infinity)
     value |= ((value>>15)-1) & 1;
    else if(half::round_style == std::round_toward_neg_infinity)
     value |= value >> 15;
    return half(binary, value);
   }




   static int ilogb(half arg)
   {
    int exp = arg.data_ & 0x7FFF;
    if(!exp)
     return 
#1894 "C:/Xilinx/Vivado/2018.3/include/hls_half.h" 3
           ((int)0x80000000)
#1894 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
                    ;
    if(exp < 0x7C00)
    {
     if(!(exp>>=10))
      for(unsigned int m=(arg.data_&0x3FF); m<0x200; m<<=1,--exp) ;
     return exp - 15;
    }
    if(exp > 0x7C00)
     return 
#1902 "C:/Xilinx/Vivado/2018.3/include/hls_half.h" 3
           ((int)0x80000000)
#1902 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
                      ;
    return 0x7fffffff;
   }




   static half nextafter(half from, half to)
   {
    uint16 fabs = from.data_ & 0x7FFF, tabs = to.data_ & 0x7FFF;
    if(fabs > 0x7C00)
     return from;
    if(tabs > 0x7C00 || from.data_ == to.data_ || !(fabs|tabs))
     return to;
    if(!fabs)
     return half(binary, (to.data_&0x8000)+1);
    bool lt = (signbit(from) ? (static_cast<int17>(0x8000)-from.data_) : static_cast<int17>(from.data_)) <
     (signbit(to) ? (static_cast<int17>(0x8000)-to.data_) : static_cast<int17>(to.data_));
    return half(binary, from.data_+(((from.data_>>15)^static_cast<uint16>(lt))<<1)-1);
   }





   static half nexttoward(half from, long double to)
   {
    if(isnan(from))
     return from;
    long double lfrom = static_cast<long double>(from);
    if(builtin_isnan(to) || lfrom == to)
     return half(static_cast<float>(to));
    if(!(from.data_&0x7FFF))
     return half(binary, (static_cast<detail::uint16>(builtin_signbit(to))<<15)+1);
    return half(binary, from.data_+(((from.data_>>15)^static_cast<uint16>(lfrom<to))<<1)-1);
   }





   static half copysign(half x, half y) { return half(binary, x.data_^((x.data_^y.data_)&0x8000)); }





   static int fpclassify(half arg)
   {
    unsigned int abs = arg.data_ & 0x7FFF;
    if(abs > 0x7C00)
     return 
#1953 "C:/Xilinx/Vivado/2018.3/include/hls_half.h" 3
           0x0100
#1953 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
                 ;
    if(abs == 0x7C00)
     return 
#1955 "C:/Xilinx/Vivado/2018.3/include/hls_half.h" 3
           (0x0100 | 0x0400)
#1955 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
                      ;
    if(abs > 0x3FF)
     return 
#1957 "C:/Xilinx/Vivado/2018.3/include/hls_half.h" 3
           0x0400
#1957 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
                    ;
    return abs ? 
#1958 "C:/Xilinx/Vivado/2018.3/include/hls_half.h" 3
                (0x0400 | 0x4000) 
#1958 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
                             : 
#1958 "C:/Xilinx/Vivado/2018.3/include/hls_half.h" 3
                               0x4000
#1958 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
                                      ;
   }





   static bool isfinite(half arg) { return (arg.data_&0x7C00) != 0x7C00; }





   static bool isinf(half arg) { return (arg.data_&0x7FFF) == 0x7C00; }





   static bool isnan(half arg) { return (arg.data_&0x7FFF) > 0x7C00; }





   static bool isnormal(half arg) { return ((arg.data_&0x7C00)!=0) & ((arg.data_&0x7C00)!=0x7C00); }





   static bool signbit(half arg) { return (arg.data_&0x8000) != 0; }
#1999 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
            template<typename T1, typename T2>
   static bool isequal(T1 x, T2 y) { return binary_operator_compare(xip_fpo_equal, x, y); }
   static bool isequal(float x, half y) { return xil_fpo_equal_flt(x,y); }
   static bool isequal(half x, float y) { return xil_fpo_equal_flt(x,y); }
   static bool isequal(double x, half y) { return xil_fpo_equal_d(x,y); }
   static bool isequal(half x, double y) { return xil_fpo_equal_d(x,y); }
#2015 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
            template<typename T1, typename T2>
   static bool isnotequal(T1 x, T2 y) { return binary_operator_compare(xip_fpo_notequal, x, y); }
   static bool isnotequal(float x, half y) { return xil_fpo_notequal_flt(x,y); }
   static bool isnotequal(half x, float y) { return xil_fpo_notequal_flt(x,y); }
   static bool isnotequal(double x, half y) { return xil_fpo_notequal_d(x,y); }
   static bool isnotequal(half x, double y) { return xil_fpo_notequal_d(x,y); }
#2032 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
            template<typename T1, typename T2>
   static bool isgreater(T1 x, T2 y) { return binary_operator_compare(xip_fpo_greater, x, y); }
   static bool isgreater(float x, half y) { return xil_fpo_greater_flt(x,y); }
   static bool isgreater(half x, float y) { return xil_fpo_greater_flt(x,y); }
   static bool isgreater(double x, half y) { return xil_fpo_greater_d(x,y); }
   static bool isgreater(half x, double y) { return xil_fpo_greater_d(x,y); }
#2049 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
            template<typename T1, typename T2>
   static bool isgreaterequal(T1 x, T2 y) { return binary_operator_compare(xip_fpo_greaterequal, x, y); }
   static bool isgreaterequal(float x, half y) { return xil_fpo_greaterequal_flt(x,y); }
   static bool isgreaterequal(half x, float y) { return xil_fpo_greaterequal_flt(x,y); }
   static bool isgreaterequal(double x, half y) { return xil_fpo_greaterequal_d(x,y); }
   static bool isgreaterequal(half x, double y) { return xil_fpo_greaterequal_d(x,y); }
#2066 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
            template<typename T1, typename T2>
   static bool isless(T1 x, T2 y) { return binary_operator_compare(xip_fpo_less, x, y); }
   static bool isless(float x, half y) { return xil_fpo_less_flt(x,y); }
   static bool isless(half x, float y) { return xil_fpo_less_flt(x,y); }
   static bool isless(double x, half y) { return xil_fpo_less_d(x,y); }
   static bool isless(half x, double y) { return xil_fpo_less_d(x,y); }
#2083 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
            template<typename T1, typename T2>
   static bool islessequal(T1 x, T2 y) { return binary_operator_compare(xip_fpo_lessequal, x, y); }
   static bool islessequal(float x, half y) { return xil_fpo_lessequal_flt(x,y); }
   static bool islessequal(half x, float y) { return xil_fpo_lessequal_flt(x,y); }
   static bool islessequal(double x, half y) { return xil_fpo_lessequal_d(x,y); }
   static bool islessequal(half x, double y) { return xil_fpo_lessequal_d(x,y); }







   static bool islessgreater(half x, half y)
   {
    if(isnan(x) || isnan(y))
     return false;



                return isless(x, y) || isgreater(x, y);
   }






   static bool isunordered(half x, half y) { return isnan(x) || isnan(y); }

  private:
   static double erf(double arg)
   {
    if(builtin_isinf(arg))
     return (arg<0.0) ? -1.0 : 1.0;
    double x2 = static_cast<double>(arg) * static_cast<double>(arg), ax2 = 0.147 * x2;
    double value = std::sqrt(1.0-std::exp(-x2*(1.2732395447351626861510701069801+ax2)/(1.0+ax2)));
    return builtin_signbit(arg) ? -value : value;
   }

   static double lgamma(double arg)
   {
    double v = 1.0;
    for(; arg<8.0; ++arg) v *= arg;
    double w = 1.0 / (arg * arg);
    return (((((((-0.02955065359477124183006535947712*w+0.00641025641025641025641025641026)*w+
     -0.00191752691752691752691752691753)*w+8.4175084175084175084175084175084e-4)*w+
     -5.952380952380952380952380952381e-4)*w+7.9365079365079365079365079365079e-4)*w+
     -0.00277777777777777777777777777778)*w+0.08333333333333333333333333333333)/arg +
     0.91893853320467274178032973640562 - std::log(v) - arg + (arg-0.5) * std::log(arg);
   }
  };



  template<typename T> struct unary_specialized
  {



   static constexpr half negate(half arg) { return half(binary, arg.data_^0x8000); }




   static half fabs(half arg) { return half(binary, arg.data_&0x7FFF); }
  };
  template<> struct unary_specialized<expr>
  {
   static constexpr expr negate(float arg) { return expr(-arg); }
   static expr fabs(float arg) { return expr(std::fabs(arg)); }
  };




  template<typename T,typename U> struct binary_specialized
  {




   static expr fmin(float x, float y)
   {

    return expr(std::fmin(x, y));







   }





   static expr fmax(float x, float y)
   {

    return expr(std::fmax(x, y));







   }
  };
  template<> struct binary_specialized<half,half>
  {
   static half fmin(half x, half y)
   {
    if(functions::isnan(x))
     return y;
    if(functions::isnan(y))
     return x;
    return ((functions::signbit(x) ? (static_cast<int17>(0x8000)-x.data_) : static_cast<int17>(x.data_)) >
      (functions::signbit(y) ? (static_cast<int17>(0x8000)-y.data_) : static_cast<int17>(y.data_))) ? y : x;
   }
   static half fmax(half x, half y)
   {
    if(functions::isnan(x))
     return y;
    if(functions::isnan(y))
     return x;
    return ((functions::signbit(x) ? (static_cast<int17>(0x8000)-x.data_) : static_cast<int17>(x.data_)) <
      (functions::signbit(y) ? (static_cast<int17>(0x8000)-y.data_) : static_cast<int17>(y.data_))) ? y : x;
   }
  };







  template<typename T,typename U,std::float_round_style R=(std::float_round_style)(1)> struct half_caster {};
  template<typename U,std::float_round_style R> struct half_caster<half,U,R>
  {




   typedef half type;
   static half cast(U arg) { return cast_impl(arg, is_float<U>()); };

  private:
   static half cast_impl(U arg, true_type) { return half(binary, float2half<R>(static_cast<float>(arg))); }
   static half cast_impl(U arg, false_type) { return half(binary, int2half<R>(arg)); }
  };
  template<typename T,std::float_round_style R> struct half_caster<T,half,R>
  {




   typedef T type;
   template<typename U> static T cast(U arg) { return cast_impl(arg, is_float<T>()); }

  private:
   static T cast_impl(float arg, true_type) { return static_cast<T>(arg); }
   static T cast_impl(half arg, false_type) { return half2int<R,T>(arg.data_); }
  };
  template<typename T,std::float_round_style R> struct half_caster<T,expr,R> : public half_caster<T,half,R> {};
  template<std::float_round_style R> struct half_caster<half,half,R>
  {
   typedef half type;
   static half cast(half arg) { return arg; }
  };
  template<std::float_round_style R> struct half_caster<half,expr,R> : public half_caster<half,half,R> {};
#2269 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
  template<typename T,typename U> typename enable<bool,T,U>::type operator==(T x, U y) { return functions::isequal(x, y); }






  template<typename T,typename U> typename enable<bool,T,U>::type operator!=(T x, U y) { return functions::isnotequal(x, y); }






  template<typename T,typename U> typename enable<bool,T,U>::type operator<(T x, U y) { return functions::isless(x, y); }






  template<typename T,typename U> typename enable<bool,T,U>::type operator>(T x, U y) { return functions::isgreater(x, y); }






  template<typename T,typename U> typename enable<bool,T,U>::type operator<=(T x, U y) { return functions::islessequal(x, y); }






  template<typename T,typename U> typename enable<bool,T,U>::type operator>=(T x, U y) { return functions::isgreaterequal(x, y); }
#2317 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
  template<typename T,typename U> typename enable<half,T,U>::type operator+(T x, U y) { return functions::plus(x, y); }
#2327 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
  template<typename T,typename U> typename enable<half,T,U>::type operator-(T x, U y) { return functions::minus(x, y); }
#2337 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
  template<typename T,typename U> typename enable<half,T,U>::type operator*(T x, U y) { return functions::multiplies(x, y); }
#2347 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
  template<typename T,typename U> typename enable<half,T,U>::type operator/(T x, U y) { return functions::divides(x, y); }





  template<typename T> constexpr typename enable<T,T>::type operator+(T arg) { return arg; }




  template<typename T> constexpr typename enable<T,T>::type operator-(T arg) { return unary_specialized<T>::negate(arg); }
#2368 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
  template<typename T,typename charT,typename traits> typename enable<std::basic_ostream<charT,traits>&,T>::type
   operator<<(std::basic_ostream<charT,traits> &out, T arg) { return functions::write(out, arg); }





  template<typename charT,typename traits> std::basic_istream<charT,traits>&
   operator>>(std::basic_istream<charT,traits> &in, half &arg) { return functions::read(in, arg); }
#2386 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
  inline half abs(half arg) { return unary_specialized<half>::fabs(arg); }
  inline expr abs(expr arg) { return unary_specialized<expr>::fabs(arg); }





  inline half fabs(half arg) { return unary_specialized<half>::fabs(arg); }
  inline expr fabs(expr arg) { return unary_specialized<expr>::fabs(arg); }






  inline expr fmod(half x, half y) { return functions::fmod(x, y); }
  inline expr fmod(half x, expr y) { return functions::fmod(x, y); }
  inline expr fmod(expr x, half y) { return functions::fmod(x, y); }
  inline expr fmod(expr x, expr y) { return functions::fmod(x, y); }






  inline expr remainder(half x, half y) { return functions::remainder(x, y); }
  inline expr remainder(half x, expr y) { return functions::remainder(x, y); }
  inline expr remainder(expr x, half y) { return functions::remainder(x, y); }
  inline expr remainder(expr x, expr y) { return functions::remainder(x, y); }







  inline expr remquo(half x, half y, int *quo) { return functions::remquo(x, y, quo); }
  inline expr remquo(half x, expr y, int *quo) { return functions::remquo(x, y, quo); }
  inline expr remquo(expr x, half y, int *quo) { return functions::remquo(x, y, quo); }
  inline expr remquo(expr x, expr y, int *quo) { return functions::remquo(x, y, quo); }







  inline expr fma(half x, half y, half z) { return functions::fma(x, y, z); }
  inline expr fma(half x, half y, expr z) { return functions::fma(x, y, z); }
  inline expr fma(half x, expr y, half z) { return functions::fma(x, y, z); }
  inline expr fma(half x, expr y, expr z) { return functions::fma(x, y, z); }
  inline expr fma(expr x, half y, half z) { return functions::fma(x, y, z); }
  inline expr fma(expr x, half y, expr z) { return functions::fma(x, y, z); }
  inline expr fma(expr x, expr y, half z) { return functions::fma(x, y, z); }
  inline expr fma(expr x, expr y, expr z) { return functions::fma(x, y, z); }

                inline expr mad(half x, half y, half z) { return functions::fma(x, y, z); }
                inline expr mad(half x, half y, expr z) { return functions::fma(x, y, z); }
                inline expr mad(half x, expr y, half z) { return functions::fma(x, y, z); }
                inline expr mad(half x, expr y, expr z) { return functions::fma(x, y, z); }
                inline expr mad(expr x, half y, half z) { return functions::fma(x, y, z); }
                inline expr mad(expr x, half y, expr z) { return functions::fma(x, y, z); }
                inline expr mad(expr x, expr y, half z) { return functions::fma(x, y, z); }
                inline expr mad(expr x, expr y, expr z) { return functions::fma(x, y, z); }






  inline half fmax(half x, half y) { return binary_specialized<half,half>::fmax(x, y); }
  inline expr fmax(half x, expr y) { return binary_specialized<half,expr>::fmax(x, y); }
  inline expr fmax(expr x, half y) { return binary_specialized<expr,half>::fmax(x, y); }
  inline expr fmax(expr x, expr y) { return binary_specialized<expr,expr>::fmax(x, y); }






  inline half fmin(half x, half y) { return binary_specialized<half,half>::fmin(x, y); }
  inline expr fmin(half x, expr y) { return binary_specialized<half,expr>::fmin(x, y); }
  inline expr fmin(expr x, half y) { return binary_specialized<expr,half>::fmin(x, y); }
  inline expr fmin(expr x, expr y) { return binary_specialized<expr,expr>::fmin(x, y); }






  inline expr fdim(half x, half y) { return functions::fdim(x, y); }
  inline expr fdim(half x, expr y) { return functions::fdim(x, y); }
  inline expr fdim(expr x, half y) { return functions::fdim(x, y); }
  inline expr fdim(expr x, expr y) { return functions::fdim(x, y); }

                inline expr maxmag(half x, half y) { return functions::maxmag(x, y); }
                inline expr maxmag(half x, expr y) { return functions::maxmag(x, y); }
                inline expr maxmag(expr x, half y) { return functions::maxmag(x, y); }
                inline expr maxmag(expr x, expr y) { return functions::maxmag(x, y); }

                inline expr minmag(half x, half y) { return functions::minmag(x, y); }
                inline expr minmag(half x, expr y) { return functions::minmag(x, y); }
                inline expr minmag(expr x, half y) { return functions::minmag(x, y); }
                inline expr minmag(expr x, expr y) { return functions::minmag(x, y); }




  inline half nanh(const char *arg) { return functions::nanh(arg); }
#2504 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
  inline expr exp(half arg) { return functions::exp(arg); }
  inline expr exp(expr arg) { return functions::exp(arg); }





  inline expr expm1(half arg) { return functions::expm1(arg); }
  inline expr expm1(expr arg) { return functions::expm1(arg); }





  inline expr exp2(half arg) { return functions::exp2(arg); }
  inline expr exp2(expr arg) { return functions::exp2(arg); }





  inline expr log(half arg) { return functions::log(arg); }
  inline expr log(expr arg) { return functions::log(arg); }





  inline expr log10(half arg) { return functions::log10(arg); }
  inline expr log10(expr arg) { return functions::log10(arg); }





  inline expr log1p(half arg) { return functions::log1p(arg); }
  inline expr log1p(expr arg) { return functions::log1p(arg); }





  inline expr log2(half arg) { return functions::log2(arg); }
  inline expr log2(expr arg) { return functions::log2(arg); }
#2560 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
  inline half sqrt(half arg) { return math_function_1arg(xip_fpo_sqrt, arg); }

  inline expr sqrt(expr arg) { return functions::sqrt(arg); }





  inline expr cbrt(half arg) { return functions::cbrt(arg); }
  inline expr cbrt(expr arg) { return functions::cbrt(arg); }






  inline expr hypot(half x, half y) { return functions::hypot(x, y); }
  inline expr hypot(half x, expr y) { return functions::hypot(x, y); }
  inline expr hypot(expr x, half y) { return functions::hypot(x, y); }
  inline expr hypot(expr x, expr y) { return functions::hypot(x, y); }






  inline expr pow(half base, half exp) { return functions::pow(base, exp); }
  inline expr pow(half base, expr exp) { return functions::pow(base, exp); }
  inline expr pow(expr base, half exp) { return functions::pow(base, exp); }
  inline expr pow(expr base, expr exp) { return functions::pow(base, exp); }
                inline expr powr(half base, half exp) { return functions::powr(base, exp); }
                inline expr powr(half base, expr exp) { return functions::powr(base, exp); }
                inline expr powr(expr base, half exp) { return functions::powr(base, exp); }
                inline expr powr(expr base, expr exp) { return functions::powr(base, exp); }
                inline expr pown(half base, int exp) { return functions::pown(base, exp); }
                inline expr pown(expr base, int exp) { return functions::pown(base, exp); }
#2605 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
  inline expr sin(half arg) { return functions::sin(arg); }
  inline expr sin(expr arg) { return functions::sin(arg); }





  inline expr cos(half arg) { return functions::cos(arg); }
  inline expr cos(expr arg) { return functions::cos(arg); }





  inline expr tan(half arg) { return functions::tan(arg); }
  inline expr tan(expr arg) { return functions::tan(arg); }





  inline expr asin(half arg) { return functions::asin(arg); }
  inline expr asin(expr arg) { return functions::asin(arg); }





  inline expr acos(half arg) { return functions::acos(arg); }
  inline expr acos(expr arg) { return functions::acos(arg); }





  inline expr atan(half arg) { return functions::atan(arg); }
  inline expr atan(expr arg) { return functions::atan(arg); }






  inline expr atan2(half x, half y) { return functions::atan2(x, y); }
  inline expr atan2(half x, expr y) { return functions::atan2(x, y); }
  inline expr atan2(expr x, half y) { return functions::atan2(x, y); }
  inline expr atan2(expr x, expr y) { return functions::atan2(x, y); }
#2661 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
  inline expr sinh(half arg) { return functions::sinh(arg); }
  inline expr sinh(expr arg) { return functions::sinh(arg); }





  inline expr cosh(half arg) { return functions::cosh(arg); }
  inline expr cosh(expr arg) { return functions::cosh(arg); }





  inline expr tanh(half arg) { return functions::tanh(arg); }
  inline expr tanh(expr arg) { return functions::tanh(arg); }





  inline expr asinh(half arg) { return functions::asinh(arg); }
  inline expr asinh(expr arg) { return functions::asinh(arg); }





  inline expr acosh(half arg) { return functions::acosh(arg); }
  inline expr acosh(expr arg) { return functions::acosh(arg); }





  inline expr atanh(half arg) { return functions::atanh(arg); }
  inline expr atanh(expr arg) { return functions::atanh(arg); }
#2707 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
  inline expr erf(half arg) { return functions::erf(arg); }
  inline expr erf(expr arg) { return functions::erf(arg); }





  inline expr erfc(half arg) { return functions::erfc(arg); }
  inline expr erfc(expr arg) { return functions::erfc(arg); }





                inline expr lgamma_r(half arg, int *signgamp) { return functions::lgamma(arg); }
                inline expr lgamma_r(expr arg, int *signgamp) { return functions::lgamma(arg); }
  inline expr lgamma(half arg) { return functions::lgamma(arg); }
  inline expr lgamma(expr arg) { return functions::lgamma(arg); }





  inline expr tgamma(half arg) { return functions::tgamma(arg); }
  inline expr tgamma(expr arg) { return functions::tgamma(arg); }
#2741 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
  inline half ceil(half arg) { return functions::ceil(arg); }
  inline half ceil(expr arg) { return functions::ceil(arg); }





  inline half floor(half arg) { return functions::floor(arg); }
  inline half floor(expr arg) { return functions::floor(arg); }





  inline half trunc(half arg) { return functions::trunc(arg); }
  inline half trunc(expr arg) { return functions::trunc(arg); }





  inline half round(half arg) { return functions::round(arg); }
  inline half round(expr arg) { return functions::round(arg); }





  inline long lround(half arg) { return functions::lround(arg); }
  inline long lround(expr arg) { return functions::lround(arg); }





  inline half nearbyint(half arg) { return functions::rint(arg); }
  inline half nearbyint(expr arg) { return functions::rint(arg); }





  inline half rint(half arg) { return functions::rint(arg); }
  inline half rint(expr arg) { return functions::rint(arg); }





  inline long lrint(half arg) { return functions::lrint(arg); }
  inline long lrint(expr arg) { return functions::lrint(arg); }





  inline long long llround(half arg) { return functions::llround(arg); }
  inline long long llround(expr arg) { return functions::llround(arg); }





  inline long long llrint(half arg) { return functions::llrint(arg); }
  inline long long llrint(expr arg) { return functions::llrint(arg); }
#2817 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
  inline half frexp(half arg, int *exp) { return functions::frexp(arg, exp); }
  inline half frexp(expr arg, int *exp) { return functions::frexp(arg, exp); }






  inline half ldexp(half arg, int exp) { return functions::scalbln(arg, exp); }
  inline half ldexp(expr arg, int exp) { return functions::scalbln(arg, exp); }






  inline half modf(half arg, half *iptr) { return functions::modf(arg, iptr); }
  inline half modf(expr arg, half *iptr) { return functions::modf(arg, iptr); }






  inline half scalbn(half arg, int exp) { return functions::scalbln(arg, exp); }
  inline half scalbn(expr arg, int exp) { return functions::scalbln(arg, exp); }






  inline half scalbln(half arg, long exp) { return functions::scalbln(arg, exp); }
  inline half scalbln(expr arg, long exp) { return functions::scalbln(arg, exp); }
#2859 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
  inline int ilogb(half arg) { return functions::ilogb(arg); }
  inline int ilogb(expr arg) { return functions::ilogb(arg); }





  inline half logb(half arg) { return functions::logb(arg); }
  inline half logb(expr arg) { return functions::logb(arg); }






  inline half nextafter(half from, half to) { return functions::nextafter(from, to); }
  inline half nextafter(half from, expr to) { return functions::nextafter(from, to); }
  inline half nextafter(expr from, half to) { return functions::nextafter(from, to); }
  inline half nextafter(expr from, expr to) { return functions::nextafter(from, to); }






  inline half nexttoward(half from, long double to) { return functions::nexttoward(from, to); }
  inline half nexttoward(expr from, long double to) { return functions::nexttoward(from, to); }






  inline half copysign(half x, half y) { return functions::copysign(x, y); }
  inline half copysign(half x, expr y) { return functions::copysign(x, y); }
  inline half copysign(expr x, half y) { return functions::copysign(x, y); }
  inline half copysign(expr x, expr y) { return functions::copysign(x, y); }
#2910 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
  inline int fpclassify(half arg) { return functions::fpclassify(arg); }
  inline int fpclassify(expr arg) { return functions::fpclassify(arg); }






  inline bool isfinite(half arg) { return functions::isfinite(arg); }
  inline bool isfinite(expr arg) { return functions::isfinite(arg); }






  inline bool isinf(half arg) { return functions::isinf(arg); }
  inline bool isinf(expr arg) { return functions::isinf(arg); }






  inline bool isnan(half arg) { return functions::isnan(arg); }
  inline bool isnan(expr arg) { return functions::isnan(arg); }






  inline bool isnormal(half arg) { return functions::isnormal(arg); }
  inline bool isnormal(expr arg) { return functions::isnormal(arg); }






  inline bool signbit(half arg) { return functions::signbit(arg); }
  inline bool signbit(expr arg) { return functions::signbit(arg); }
#2963 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
  inline bool isgreater(half x, half y) { return functions::isgreater(x, y); }
  inline bool isgreater(half x, expr y) { return functions::isgreater(x, y); }
  inline bool isgreater(expr x, half y) { return functions::isgreater(x, y); }
  inline bool isgreater(expr x, expr y) { return functions::isgreater(x, y); }







  inline bool isgreaterequal(half x, half y) { return functions::isgreaterequal(x, y); }
  inline bool isgreaterequal(half x, expr y) { return functions::isgreaterequal(x, y); }
  inline bool isgreaterequal(expr x, half y) { return functions::isgreaterequal(x, y); }
  inline bool isgreaterequal(expr x, expr y) { return functions::isgreaterequal(x, y); }







  inline bool isless(half x, half y) { return functions::isless(x, y); }
  inline bool isless(half x, expr y) { return functions::isless(x, y); }
  inline bool isless(expr x, half y) { return functions::isless(x, y); }
  inline bool isless(expr x, expr y) { return functions::isless(x, y); }







  inline bool islessequal(half x, half y) { return functions::islessequal(x, y); }
  inline bool islessequal(half x, expr y) { return functions::islessequal(x, y); }
  inline bool islessequal(expr x, half y) { return functions::islessequal(x, y); }
  inline bool islessequal(expr x, expr y) { return functions::islessequal(x, y); }







  inline bool islessgreater(half x, half y) { return functions::islessgreater(x, y); }
  inline bool islessgreater(half x, expr y) { return functions::islessgreater(x, y); }
  inline bool islessgreater(expr x, half y) { return functions::islessgreater(x, y); }
  inline bool islessgreater(expr x, expr y) { return functions::islessgreater(x, y); }







  inline bool isunordered(half x, half y) { return functions::isunordered(x, y); }
  inline bool isunordered(half x, expr y) { return functions::isunordered(x, y); }
  inline bool isunordered(expr x, half y) { return functions::isunordered(x, y); }
  inline bool isunordered(expr x, expr y) { return functions::isunordered(x, y); }
#3040 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
  template<typename T,typename U> typename half_caster<T,U>::type half_cast(U arg) { return half_caster<T,U>::cast(arg); }
#3057 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
  template<typename T,std::float_round_style R,typename U> typename half_caster<T,U,R>::type half_cast(U arg)
   { return half_caster<T,U,R>::cast(arg); }

 }

 using detail::operator==;
 using detail::operator!=;
 using detail::operator<;
 using detail::operator>;
 using detail::operator<=;
 using detail::operator>=;
 using detail::operator+;
 using detail::operator-;
 using detail::operator*;
 using detail::operator/;
 using detail::operator<<;
 using detail::operator>>;
#3135 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
  using detail::fpclassify;
  using detail::isfinite;
  using detail::isinf;
  using detail::isnan;
  using detail::isnormal;
  using detail::signbit;
  using detail::isgreater;
  using detail::isgreaterequal;
  using detail::isless;
  using detail::islessequal;
  using detail::islessgreater;
  using detail::isunordered;

 using detail::half_cast;


namespace std
{



 template<> struct numeric_limits<half> : public numeric_limits<float>
 {
 public:

  static constexpr bool is_signed = true;


  static constexpr bool is_exact = false;


  static constexpr bool is_modulo = false;


  static constexpr bool is_iec559 = true;


  static constexpr bool has_infinity = true;


  static constexpr bool has_quiet_NaN = true;


  static constexpr float_denorm_style has_denorm = denorm_present;





  static constexpr float_round_style round_style = (std::numeric_limits<float>::round_style==
   half::round_style) ? half::round_style : round_indeterminate;


  static constexpr int digits = 11;


  static constexpr int digits10 = 3;


  static constexpr int max_digits10 = 5;


  static constexpr int radix = 2;


  static constexpr int min_exponent = -13;


  static constexpr int min_exponent10 = -4;


  static constexpr int max_exponent = 16;


  static constexpr int max_exponent10 = 4;


  static constexpr half min() noexcept { return half(detail::binary, 0x0400); }


  static constexpr half lowest() noexcept { return half(detail::binary, 0xFBFF); }


  static constexpr half max() noexcept { return half(detail::binary, 0x7BFF); }


  static constexpr half epsilon() noexcept { return half(detail::binary, 0x1400); }


  static constexpr half round_error() noexcept
   { return half(detail::binary, (round_style==std::round_to_nearest) ? 0x3800 : 0x3C00); }


  static constexpr half infinity() noexcept { return half(detail::binary, 0x7C00); }


  static constexpr half quiet_NaN() noexcept { return half(detail::binary, 0x7FFF); }


  static constexpr half signaling_NaN() noexcept { return half(detail::binary, 0x7DFF); }


  static constexpr half denorm_min() noexcept { return half(detail::binary, 0x0001); }
 };




 template<> struct hash<half>
 {

  typedef half argument_type;


  typedef size_t result_type;




  result_type operator()(argument_type arg) const
   { return hash<detail::uint16>()(static_cast<unsigned int>(arg.data_)&-(arg.data_!=0x8000)); }
 };

}
#3274 "C:/Xilinx/Vivado/2018.3/include/hls_half.h"
extern half half_nan(const char *tagp);





extern half half_atan(half t);
extern half half_atan2(half y, half x);
extern half half_copysign(half x, half y);

extern half half_fabs(half x);

extern half half_abs(half x);
extern half half_fma(half x, half y, half z);
extern half half_mad(half x, half y, half z);
extern half half_frexp (half x, int* exp);
extern half half_ldexp (half x, int exp);
extern half half_fmax(half x, half y);

extern half half_fmin(half x, half y);

extern half half_asin(half t_in);
extern half half_acos(half t_in);
extern half half_sin(half t_in);
extern half half_cos(half t_in);
extern void half_sincos(half x, half *sin, half *cos);
extern half half_sinh(half t_in);
extern half half_cosh(half t_in);
extern half half_sinpi(half t_in);
extern half half_cospi(half t_in);
extern half half_recip(half x);
extern half half_sqrt(half x);
extern half half_rsqrt(half x);
extern half half_cbrt(half x);
extern half half_hypot(half x, half y);
extern half half_log(half x);
extern half half_log10(half x);
extern half half_log2(half x);
extern half half_logb(half x);
extern half half_log1p(half x);
extern int half_ilogb(half x);
extern half half_exp(half x);
extern half half_exp10(half x);
extern half half_exp2(half x);
extern half half_expm1(half x);
extern half half_pow(half x, half y);
extern half half_powr(half x, half y);
extern half half_pown(half x, int y);
extern half half_rootn(half x, int y);
extern half half_floor(half x);

extern half half_ceil(half x);

extern half half_trunc(half x);

extern half half_round(half x);

extern half half_nearbyint(half x);
extern half half_rint(half x);
extern long int half_lrint(half x);
extern long long int half_llrint(half x);
extern long int half_lround(half x);
extern long long int half_llround(half x);
extern half half_modf(half x, half *intpart);

extern half half_fract(half x, half *intpart);
extern half half_nextafter(half x, half y);
extern half half_fmod(half x, half y);
extern half half_remainder(half x, half y);
extern half half_remquo(half x, half y, int* quo);
extern half half_divide(half x, half y);
#37 "C:/Xilinx/Vivado/2018.3/include/hls_math.h" 2



namespace hls {


  int signbit(double);
  int signbit(float);
  int signbit(half);
  int signbitf(float);
  int half_signbit(half);


  double nan(const char*);
  float nanf(const char*);
  half half_nan(const char *);


  int isfinite(double);
  int isfinite(float);
  int isfinite(half);
  int isfinitef(float);
  int half_isfinite(half);


  int __isfinite(double);
  int __isfinite(float);
  int __isfinite(half);
  int __isfinitef(float);


  int isinf(double);
  int isinf(float);
  int isinf(half);
  int isinff(float);
  int half_isinf(half);


  int __isinf(double);
  int __isinf(float);
  int __isinf(half);
  int __isinff(float);


  int isnan(double);
  int isnan(float);
  int isnan(half);
  int 
#84 "C:/Xilinx/Vivado/2018.3/include/hls_math.h" 3
     _isnanf
#84 "C:/Xilinx/Vivado/2018.3/include/hls_math.h"
           (float);
  int half_isnan(half);


  int __isnan(double);
  int __isnan(float);
  int __isnan(half);
  int __isnanf(float);


  int isnormal(double);
  int isnormal(float);
  int isnormal(half);
  int isnormalf(float);
  int half_isnormal(half);


  int __isnormal(double);
  int __isnormal(float);
  int __isnormal(half);
  int __isnormalf(float);


  int fpclassify(double);
  int fpclassify(float);
  int fpclassify(half);
  int fpclassifyf(float);
  int half_fpclassify(half);


  int __fpclassify(double);
  int __fpclassify(float);
  int __fpclassify(half);
  int __fpclassifyf(float);


  double copysign(double, double);
  float copysign(float, float);
  half copysign(half, half);
  float copysignf(float, float);
  half half_copysign(half, half);
  int8_t copysign(int8_t, int8_t);
  uint8_t copysign(uint8_t, uint8_t);
  int16_t copysign(int16_t, int16_t);
  uint16_t copysign(uint16_t, uint16_t);
  int32_t copysign(int32_t, int32_t);
  uint32_t copysign(uint32_t, uint32_t);


  double fabs(double);
  float fabs(float);
  half fabs(half);
  float fabsf(float);
  half half_fabs(half);
  int8_t fabs(int8_t);
  uint8_t fabs(uint8_t);
  int16_t fabs(int16_t);
  uint16_t fabs(uint16_t);
  int32_t fabs(int32_t);
  uint32_t fabs(uint32_t);


  double abs(double);
  float abs(float);
  half abs(half);
  float absf(float);
  half half_abs(half);
  int8_t abs(int8_t);
  uint8_t abs(uint8_t);
  int16_t abs(int16_t);
  uint16_t abs(uint16_t);
  int32_t abs(int32_t);
  uint32_t abs(uint32_t);


  double fma(double, double, double);
  float fma(float, float, float);
  half fma(half, half, half);
  float fmaf(float, float, float);
  half half_fma(half, half, half);


  double mad(double, double, double);
  float mad(float, float, float);
  half mad(half, half, half);
  float madf(float, float, float);
  half half_mad(half, half, half);


  int isequal(double, double);
  int isequal(float, float);
  int isequal(half, half);
  int isequalf(float, float);
  int half_isequal(half, half);


  int isgreater(double, double);
  int isgreater(float, float);
  int isgreater(half, half);
  int isgreaterf(float, float);
  int half_isgreater(half, half);


  int isgreaterequal(double, double);
  int isgreaterequal(float, float);
  int isgreaterequal(half, half);
  int isgreaterequalf(float, float);
  int half_isgreaterequal(half, half);


  int isless(double, double);
  int isless(float, float);
  int isless(half, half);
  int islessf(float, float);
  int half_isless(half, half);


  int islessequal(double, double);
  int islessequal(float, float);
  int islessequal(half, half);
  int islessequalf(float, float);
  int half_islessequal(half, half);


  int islessgreater(double, double);
  int islessgreater(float, float);
  int islessgreater(half, half);
  int islessgreaterf(float, float);
  int half_islessgreater(half, half);


  int isnotequal(double, double);
  int isnotequal(float, float);
  int isnotequal(half, half);
  int isnotequalf(float, float);
  int half_isnotequal(half, half);


  double fmax(double, double);
  float fmax(float, float);
  half fmax(half, half);
  float fmaxf(float, float);
  half half_fmax(half, half);
  int8_t fmax(int8_t,int8_t);
  uint8_t fmax(uint8_t, uint8_t);
  int16_t fmax(int16_t, int16_t);
  uint16_t fmax(uint16_t, uint16_t);
  int32_t fmax(int32_t, int32_t);
  uint32_t fmax(uint32_t, uint32_t);


  double fmin(double, double);
  float fmin(float, float);
  half fmin(half, half);
  float fminf(float, float);
  half half_fmin(half, half);
  int8_t fmin(int8_t,int8_t);
  uint8_t fmin(uint8_t, uint8_t);
  int16_t fmin(int16_t, int16_t);
  uint16_t fmin(uint16_t, uint16_t);
  int32_t fmin(int32_t, int32_t);
  uint32_t fmin(uint32_t, uint32_t);


  template <class T>
  T max(T x, T y){
 return (x > y) ? x : y;
  }


  template <class T>
  T min(T x, T y){
 return (x < y) ? x : y;
  }


  double fdim(double, double);
  float fdim(float, float);
  half fdim(half, half);
  float fdimf(float, float);
  half half_fdim(half, half);
  int8_t fdim(int8_t,int8_t);
  uint8_t fdim(uint8_t, uint8_t);
  int16_t fdim(int16_t, int16_t);
  uint16_t fdim(uint16_t, uint16_t);
  int32_t fdim(int32_t, int32_t);
  uint32_t fdim(uint32_t, uint32_t);


  double maxmag(double, double);
  float maxmag(float, float);
  half maxmag(half, half);
  float maxmagf(float, float);
  half half_maxmag(half, half);
  int8_t maxmag(int8_t,int8_t);
  uint8_t maxmag(uint8_t, uint8_t);
  int16_t maxmag(int16_t, int16_t);
  uint16_t maxmag(uint16_t, uint16_t);
  int32_t maxmag(int32_t, int32_t);
  uint32_t maxmag(uint32_t, uint32_t);


  double minmag(double, double);
  float minmag(float, float);
  half minmag(half, half);
  float minmagf(float, float);
  half half_minmag(half, half);
  int8_t minmag(int8_t,int8_t);
  uint8_t minmag(uint8_t, uint8_t);
  int16_t minmag(int16_t, int16_t);
  uint16_t minmag(uint16_t, uint16_t);
  int32_t minmag(int32_t, int32_t);
  uint32_t minmag(uint32_t, uint32_t);



  double frexp(double, int*);
  float frexp(float, int*);
  half frexp(half, int*);
  float frexpf(float, int*);
  half half_frexp(half, int*);


  double ldexp(double, int);
  float ldexp(float, int);
  half ldexp(half, int);
  float ldexpf(float, int);
  half half_ldexp(half, int);


  int ilogb(double);
  int ilogb(float);
  int ilogb(half);
  int ilogbf(float);
  int half_ilogb(half);


  double scalbn(double, int);
  float scalbn(float, int);
  half scalbn(half, int);
  float scalbnf(float, int);
  half half_scalbn(half, int);


  double scalbln(double, long int);
  float scalbln(float, long int);
  half scalbln(half, long int);
  float scalblnf(float, long int);
  half half_scalbln(half, long int);


  double ceil(double);
  float ceil(float);
  half ceil(half);
  float ceilf(float);
  half half_ceil(half);


  double floor(double);
  float floor(float);
  half floor(half);
  float floorf(float);
  half half_floor(half);


  double trunc(double);
  float trunc(float);
  half trunc(half);
  float truncf(float);
  half half_trunc(half);


  double round(double);
  float round(float);
  half round(half);
  float roundf(float);
  half half_round(half);


  double rint(double);
  float rint(float);
  half rint(half);
  float rintf(float);
  half half_rint(half);


  long int lround(double);
  long int lround(float);
  long int lround(half);
  long int lroundf(float);
  long int half_lround(half);


  long long int llround(double);
  long long int llround(float);
  long long int llround(half);
  long long int llroundf(float);
  long long int half_llround(half);


  long int lrint(double);
  long int lrint(float);
  long int lrint(half);
  long int lrintf(float);
  long int half_lrint(half);


  long long int llrint(double);
  long long int llrint(float);
  long long int llrint(half);
  long long int llrintf(float);
  long long int half_llrint(half);


  template<class T>
  T cast_IEEE754(double, bool);
  template<class T>
  T cast_IEEE754(float, bool);
  template<class T>
  T cast_IEEE754(half, bool);

  template<class T>
  T cast_IEEE754(double);
  template<class T>
  T cast_IEEE754(float);
  template<class T>
  T cast_IEEE754(half);



  template<>
  char cast_IEEE754<char>(double, bool);
  template<>
  char cast_IEEE754<char>(float, bool);
  template<>
  char cast_IEEE754<char>(half, bool);
  template<>
  char cast_IEEE754<char>(double);
  template<>
  char cast_IEEE754<char>(float);
  template<>
  char cast_IEEE754<char>(half);


  template<>
  int8_t cast_IEEE754<int8_t>(double, bool);
  template<>
  int8_t cast_IEEE754<int8_t>(float, bool);
  template<>
  int8_t cast_IEEE754<int8_t>(half, bool);
  template<>
  int8_t cast_IEEE754<int8_t>(double);
  template<>
  int8_t cast_IEEE754<int8_t>(float);
  template<>
  int8_t cast_IEEE754<int8_t>(half);


  template<>
  uint8_t cast_IEEE754<uint8_t>(double, bool);
  template<>
  uint8_t cast_IEEE754<uint8_t>(float, bool);
  template<>
  uint8_t cast_IEEE754<uint8_t>(half, bool);
  template<>
  uint8_t cast_IEEE754<uint8_t>(double);
  template<>
  uint8_t cast_IEEE754<uint8_t>(float);
  template<>
  uint8_t cast_IEEE754<uint8_t>(half);


  template<>
  int16_t cast_IEEE754<int16_t>(double, bool);
  template<>
  int16_t cast_IEEE754<int16_t>(float, bool);
  template<>
  int16_t cast_IEEE754<int16_t>(half, bool);
  template<>
  int16_t cast_IEEE754<int16_t>(double);
  template<>
  int16_t cast_IEEE754<int16_t>(float);
  template<>
  int16_t cast_IEEE754<int16_t>(half);


  template<>
  uint16_t cast_IEEE754<uint16_t>(double, bool);
  template<>
  uint16_t cast_IEEE754<uint16_t>(float, bool);
  template<>
  uint16_t cast_IEEE754<uint16_t>(half, bool);
  template<>
  uint16_t cast_IEEE754<uint16_t>(double);
  template<>
  uint16_t cast_IEEE754<uint16_t>(float);
  template<>
  uint16_t cast_IEEE754<uint16_t>(half);


  template<>
  int32_t cast_IEEE754<int32_t>(double, bool);
  template<>
  int32_t cast_IEEE754<int32_t>(float, bool);
  template<>
  int32_t cast_IEEE754<int32_t>(half, bool);
  template<>
  int32_t cast_IEEE754<int32_t>(double);
  template<>
  int32_t cast_IEEE754<int32_t>(float);
  template<>
  int32_t cast_IEEE754<int32_t>(half);


  template<>
  uint32_t cast_IEEE754<uint32_t>(double, bool);
  template<>
  uint32_t cast_IEEE754<uint32_t>(float, bool);
  template<>
  uint32_t cast_IEEE754<uint32_t>(half, bool);
  template<>
  uint32_t cast_IEEE754<uint32_t>(double);
  template<>
  uint32_t cast_IEEE754<uint32_t>(float);
  template<>
  uint32_t cast_IEEE754<uint32_t>(half);


  template<>
  int64_t cast_IEEE754<int64_t>(double, bool);
  template<>
  int64_t cast_IEEE754<int64_t>(float, bool);
  template<>
  int64_t cast_IEEE754<int64_t>(half, bool);
  template<>
  int64_t cast_IEEE754<int64_t>(double);
  template<>
  int64_t cast_IEEE754<int64_t>(float);
  template<>
  int64_t cast_IEEE754<int64_t>(half);


  template<>
  uint64_t cast_IEEE754<uint64_t>(double, bool);
  template<>
  uint64_t cast_IEEE754<uint64_t>(float, bool);
  template<>
  uint64_t cast_IEEE754<uint64_t>(half, bool);
  template<>
  uint64_t cast_IEEE754<uint64_t>(double);
  template<>
  uint64_t cast_IEEE754<uint64_t>(float);
  template<>
  uint64_t cast_IEEE754<uint64_t>(half);



  double nearbyint(double);
  float nearbyint(float);
  half nearbyint(half);
  float nearbyintf(float);
  half half_nearbyint(half);


  double modf(double, double*);
  float modf(float, float*);
  half modf(half, half*);
  float modff(float, float*);
  half half_modf(half, half*);


  double fract(double, double*);
  float fract(float, float*);
  half fract(half, half*);
  float fractf(float, float*);
  half half_fract(half, half*);


  int isordered(double, double);
  int isordered(float, float);
  int isordered(half, half);
  int isorderedf(float, float);
  int half_isordered(half, half);


  int isunordered(double, double);
  int isunordered(float, float);
  int isunordered(half, half);
  int isunorderedf(float, float);
  int half_isunordered(half, half);


  double bitselect(double, double, double);
  float bitselect(float, float, float);
  int bitselect(int, int, int);
  uint32_t bitselect(uint32_t, uint32_t, uint32_t);
  half bitselect(half, half, half);
  float bitselectf(float, float, float);
  half half_bitselect(half, half, half);


  namespace hotbm {
 double sin(double);
 float sin(float);
 half sin(half);
 float sinf(float);
 half half_sin(half);

 double cos(double);
 float cos(float);
 half cos(half);
 float cosf(float);
 half half_cos(half);

 void sincos(double, double*, double*);
 void sincos(float, float*, float*);
 void sincos(half, half*, half*);
 void sincosf(float, float*, float*);
 void half_sincos(half, half*, half*);
  }


  namespace cordic {
 double sin(double);
 float sin(float);
 half sin(half);
 float sinf(float);
 half half_sin(half);

 double cos(double);
 float cos(float);
 half cos(half);
 float cosf(float);
 half half_cos(half);

 void sincos(double, double*, double*);
 void sincos(float, float*, float*);
 void sincos(half, half*, half*);
 void sincosf(float, float*, float*);
 void half_sincos(half, half*, half*);
  }


  double sin(double);
  float sin(float);
  half sin(half);
  float sinf(float);
  half half_sin(half);

  double cos(double);
  float cos(float);
  half cos(half);
  float cosf(float);
  half half_cos(half);


  void sincos(double, double*, double*);
  void sincos(float, float*, float*);
  void sincos(half, half*, half*);
  void sincosf(float, float*, float*);
  void half_sincos(half, half*, half*);


  double sinpi(double);
  float sinpi(float);
  half sinpi(half);
  float sinpif(float);
  half half_sinpi(half);


  double cospi(double);
  float cospi(float);
  half cospi(half);
  float cospif(float);
  half half_cospi(half);


  double atan(double);
  float atan(float);
  half atan(half);
  float atanf(float);
  half half_atan(half);


  double atan2(double, double);
  float atan2(float, float);
  half atan2(half, half);
  float atan2f(float, float);
  half half_atan2(half, half);


  double tan(double);
  float tan(float);
  half tan(half);
  float tanf(float);
  half half_tan(half);


  double sinh(double);
  float sinh(float);
  half sinh(half);
  float sinhf(float);
  half half_sinh(half);


  double cosh(double);
  float cosh(float);
  half cosh(half);
  float coshf(float);
  half half_cosh(half);


  double exp(double);
  float exp(float);
  half exp(half);
  float expf(float);
  half half_exp(half);
  int8_t exp(int8_t);
  uint8_t exp(uint8_t);
  int16_t exp(int16_t);
  uint16_t exp(uint16_t);
  int32_t exp(int32_t);
  uint32_t exp(uint32_t);


  double exp2(double);
  float exp2(float);
  half exp2(half);
  float exp2f(float);
  half half_exp2(half);


  double exp10(double);
  float exp10(float);
  half exp10(half);
  float exp10f(float);
  half half_exp10(half);


  double expm1(double);
  float expm1(float);
  half expm1(half);
  float expm1f(float);
  half half_expm1(half);


  double log(double);
  float log(float);
  half log(half);
  float logf(float);
  half half_log(half);
  int8_t log(int8_t);
  uint8_t log(uint8_t);
  int16_t log(int16_t);
  uint16_t log(uint16_t);
  int32_t log(int32_t);
  uint32_t log(uint32_t);


  double log2(double);
  float log2(float);
  half log2(half);
  float log2f(float);
  half half_log2(half);


  double log10(double);
  float log10(float);
  half log10(half);
  float log10f(float);
  half half_log10(half);
  int8_t log10(int8_t);
  uint8_t log10(uint8_t);
  int16_t log10(int16_t);
  uint16_t log10(uint16_t);
  int32_t log10(int32_t);
  uint32_t log10(uint32_t);


  double logb(double);
  float logb(float);
  half logb(half);
  float logbf(float);
  half half_logb(half);


  double log1p(double);
  float log1p(float);
  half log1p(half);
  float log1pf(float);
  half half_log1p(half);


  half pow(half, half);
  float pow(float, float);
  double pow(double, double);
  float powf(float, float);
  half half_pow(half, half);
  int8_t pow(int8_t, int8_t);
  uint8_t pow(uint8_t, uint8_t);
  int16_t pow(int16_t, int16_t);
  uint16_t pow(uint16_t, uint16_t);
  int32_t pow(int32_t, int32_t);
  uint32_t pow(uint32_t, uint32_t);


  half powr(half, half);
  float powr(float, float);
  double powr(double, double);
  float powrf(float, float);
  half half_powr(half, half);


  half pown(half, int);
  float pown(float, int);
  double pown(double, int);
  float pownf(float, int);
  half half_pown(half, int);


  half rootn(half, int);
  float rootn(float, int);
  double rootn(double, int);
  float rootnf(float, int);
  half half_rootn(half, int);


  double sqrt(double);
  float sqrt(float);
  half sqrt(half);
  float sqrtf(float);
  half half_sqrt(half);
  int8_t sqrt(int8_t);
  uint8_t sqrt(uint8_t);
  int16_t sqrt(int16_t);
  uint16_t sqrt(uint16_t);
  int32_t sqrt(int32_t);
  uint32_t sqrt(uint32_t);
#841 "C:/Xilinx/Vivado/2018.3/include/hls_math.h"
  double recip(double);
  float recip(float);
  half recip(half);
  float recipf(float);
  half half_recip(half);
  int8_t recip(int8_t);
  uint8_t recip(uint8_t);
  int16_t recip(int16_t);
  uint16_t recip(uint16_t);
  int32_t recip(int32_t);
  uint32_t recip(uint32_t);


  double rsqrt(double);
  float rsqrt(float);
  half rsqrt(half);
  float rsqrtf(float);
  half half_rsqrt(half);
  int8_t rsqrt(int8_t);
  uint8_t rsqrt(uint8_t);
  int16_t rsqrt(int16_t);
  uint16_t rsqrt(uint16_t);
  int32_t rsqrt(int32_t);
  uint32_t rsqrt(uint32_t);


  double cbrt(double);
  float cbrt(float);
  half cbrt(half);
  float cbrtf(float);
  half half_cbrt(half);


  double hypot(double, double);
  float hypot(float, float);
  half hypot(half, half);
  float hypotf(float, float);
  half half_hypot(half, half);


  double erf(double);
  float erf(float);
  half erf(half);
  float erff(float);
  half half_erf(half);
  int8_t erf(int8_t);
  uint8_t erf(uint8_t);
  int16_t erf(int16_t);
  uint16_t erf(uint16_t);
  int32_t erf(int32_t);
  uint32_t erf(uint32_t);


  double erfc(double);
  float erfc(float);
  half erfc(half);
  float erfcf(float);
  half half_erfc(half);
  int8_t erfc(int8_t);
  uint8_t erfc(uint8_t);
  int16_t erfc(int16_t);
  uint16_t erfc(uint16_t);
  int32_t erfc(int32_t);
  uint32_t erfc(uint32_t);


  double lgamma(double);
  float lgamma(float);
  half lgamma(half);
  float lgammaf(float);
  half half_lgamma(half);
  int8_t lgamma(int8_t);
  uint8_t lgamma(uint8_t);
  int16_t lgamma(int16_t);
  uint16_t lgamma(uint16_t);
  int32_t lgamma(int32_t);
  uint32_t lgamma(uint32_t);


  double lgamma_r(double, int*);
  float lgamma_r(float, int*);
  half lgamma_r(half, int*);
  float lgamma_rf(float, int*);
  half half_lgamma_r(half, int*);
  int8_t lgamma_r(int8_t);
  uint8_t lgamma_r(uint8_t);
  int16_t lgamma_r(int16_t);
  uint16_t lgamma_r(uint16_t);
  int32_t lgamma_r(int32_t);
  uint32_t lgamma_r(uint32_t);


  double tgamma(double);
  float tgamma(float);
  half tgamma(half);
  float tgammaf(float);
  half half_tgamma(half);
  int8_t tgamma(int8_t);
  uint8_t tgamma(uint8_t);
  int16_t tgamma(int16_t);
  uint16_t tgamma(uint16_t);
  int32_t tgamma(int32_t);
  uint32_t tgamma(uint32_t);


  double fmod(double, double);
  float fmod(float, float);
  half fmod(half, half);
  float fmodf(float, float);
  half half_fmod(half, half);


  double remainder(double, double);
  float remainder(float, float);
  half remainder(half, half);
  float remainderf(float, float);
  half half_remainder(half, half);


  double remquo(double, double, int*);
  float remquo(float, float, int*);
  half remquo(half, half, int*);
  float remquof(float, float, int*);
  half half_remquo(half, half, int*);


  double divide(double, double);
  float divide(float, float);
  half divide(half, half);
  float dividef(float, float);
  half half_divide(half, half);


  double nextafter(double, double);
  float nextafter(float, float);
  half nextafter(half, half);
  float nextafterf(float, float);
  half half_nextafter(half, half);


  double tanh(double);
  float tanh(float);
  half tanh(half);
  float tanhf(float);
  half half_tanh(half);


  double atanh(double);
  float atanh(float);
  half atanh(half);
  float atanhf(float);
  half half_atanh(half);


  double asinh(double);
  float asinh(float);
  half asinh(half);
  float asinhf(float);
  half half_asinh(half);


  double acosh(double);
  float acosh(float);
  half acosh(half);
  float acoshf(float);
  half half_acosh(half);


  double asin(double);
  float asin(float);
  half asin(half);
  float asinf(float);
  half half_asin(half);


  double acos(double);
  float acos(float);
  half acos(half);
  float acosf(float);
  half half_acos(half);
}

#1 "C:/Xilinx/Vivado/2018.3/include/hls_hotbm_apfixed.h" 1
#41 "C:/Xilinx/Vivado/2018.3/include/hls_hotbm_apfixed.h"
#1 "C:/Xilinx/Vivado/2018.3/include/ap_fixed.h" 1
#54 "C:/Xilinx/Vivado/2018.3/include/ap_fixed.h"
#1 "C:/Xilinx/Vivado/2018.3/include/ap_common.h" 1
#56 "C:/Xilinx/Vivado/2018.3/include/ap_common.h"
#1 "C:/Xilinx/Vivado/2018.3/include/ap_decl.h" 1
#57 "C:/Xilinx/Vivado/2018.3/include/ap_common.h" 2
#65 "C:/Xilinx/Vivado/2018.3/include/ap_common.h"
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/assert.h" 1 3
#66 "C:/Xilinx/Vivado/2018.3/include/ap_common.h" 2
#76 "C:/Xilinx/Vivado/2018.3/include/ap_common.h"
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/stdlib.h" 1 3
#77 "C:/Xilinx/Vivado/2018.3/include/ap_common.h" 2
#150 "C:/Xilinx/Vivado/2018.3/include/ap_common.h"
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/sstream" 1 3
#36 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/sstream" 3

#37 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/sstream" 3





#41 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/sstream" 3
namespace std
{

namespace __cxx11 {
#64 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
    {
      struct __xfer_bufptrs;
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;

      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_string<char_type, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;

    protected:

      ios_base::openmode _M_mode;


      __string_type _M_string;

    public:
#99 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/sstream" 3
      explicit
      basic_stringbuf(ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(__mode), _M_string()
      { }
#112 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/sstream" 3
      explicit
      basic_stringbuf(const __string_type& __str,
        ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(), _M_string(__str.data(), __str.size())
      { _M_stringbuf_init(__mode); }


      basic_stringbuf(const basic_stringbuf&) = delete;

      basic_stringbuf(basic_stringbuf&& __rhs)
      : basic_stringbuf(std::move(__rhs), __xfer_bufptrs(__rhs, this))
      { __rhs._M_sync(const_cast<char_type*>(__rhs._M_string.data()), 0, 0); }



      basic_stringbuf&
      operator=(const basic_stringbuf&) = delete;

      basic_stringbuf&
      operator=(basic_stringbuf&& __rhs)
      {
 __xfer_bufptrs __st{__rhs, this};
 const __streambuf_type& __base = __rhs;
 __streambuf_type::operator=(__base);
 this->pubimbue(__rhs.getloc());
 _M_mode = __rhs._M_mode;
 _M_string = std::move(__rhs._M_string);
 __rhs._M_sync(const_cast<char_type*>(__rhs._M_string.data()), 0, 0);
 return *this;
      }

      void
      swap(basic_stringbuf& __rhs)
      {
 __xfer_bufptrs __l_st{*this, std::__addressof(__rhs)};
 __xfer_bufptrs __r_st{__rhs, this};
 __streambuf_type& __base = __rhs;
 __streambuf_type::swap(__base);
 __rhs.pubimbue(this->pubimbue(__rhs.getloc()));
 std::swap(_M_mode, __rhs._M_mode);
 std::swap(_M_string, __rhs._M_string);
      }
#165 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/sstream" 3
      __string_type
      str() const
      {
 __string_type __ret;
 if (this->pptr())
   {

     if (this->pptr() > this->egptr())
       __ret = __string_type(this->pbase(), this->pptr());
     else
        __ret = __string_type(this->pbase(), this->egptr());
   }
 else
   __ret = _M_string;
 return __ret;
      }
#189 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/sstream" 3
      void
      str(const __string_type& __s)
      {


 _M_string.assign(__s.data(), __s.size());
 _M_stringbuf_init(_M_mode);
      }

    protected:

      void
      _M_stringbuf_init(ios_base::openmode __mode)
      {
 _M_mode = __mode;
 __size_type __len = 0;
 if (_M_mode & (ios_base::ate | ios_base::app))
   __len = _M_string.size();
 _M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
      }

      virtual streamsize
      showmanyc()
      {
 streamsize __ret = -1;
 if (_M_mode & ios_base::in)
   {
     _M_update_egptr();
     __ret = this->egptr() - this->gptr();
   }
 return __ret;
      }

      virtual int_type
      underflow();

      virtual int_type
      pbackfail(int_type __c = traits_type::eof());

      virtual int_type
      overflow(int_type __c = traits_type::eof());
#242 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/sstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n)
      {
 if (__s && __n >= 0)
   {






     _M_string.clear();


     _M_sync(__s, __n, 0);
   }
 return this;
      }

      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);

      virtual pos_type
      seekpos(pos_type __sp,
       ios_base::openmode __mode = ios_base::in | ios_base::out);




      void
      _M_sync(char_type* __base, __size_type __i, __size_type __o);



      void
      _M_update_egptr()
      {
 const bool __testin = _M_mode & ios_base::in;
 if (this->pptr() && this->pptr() > this->egptr())
   {
     if (__testin)
       this->setg(this->eback(), this->gptr(), this->pptr());
     else
       this->setg(this->pptr(), this->pptr(), this->pptr());
   }
      }



      void
      _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off);

    private:




      struct __xfer_bufptrs
      {
 __xfer_bufptrs(const basic_stringbuf& __from, basic_stringbuf* __to)
 : _M_to{__to}, _M_goff{-1, -1, -1}, _M_poff{-1, -1, -1}
 {
   const _CharT* __str = __from._M_string.data();
   if (__from.eback())
     {
     _M_goff[0] = __from.eback() - __str;
     _M_goff[1] = __from.gptr() - __str;
     _M_goff[2] = __from.egptr() - __str;
     }
   if (__from.pbase())
     {
       _M_poff[0] = __from.pbase() - __str;
       _M_poff[1] = __from.pptr() - __from.pbase();
       _M_poff[2] = __from.epptr() - __str;
     }
 }

 ~__xfer_bufptrs()
 {
   char_type* __str = const_cast<char_type*>(_M_to->_M_string.data());
   if (_M_goff[0] != -1)
     _M_to->setg(__str+_M_goff[0], __str+_M_goff[1], __str+_M_goff[2]);
   if (_M_poff[0] != -1)
     _M_to->_M_pbump(__str+_M_poff[0], __str+_M_poff[2], _M_poff[1]);
 }

 basic_stringbuf* _M_to;
 off_type _M_goff[3];
 off_type _M_poff[3];
      };
#343 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/sstream" 3
      basic_stringbuf(basic_stringbuf&& __rhs, __xfer_bufptrs&&)
      : __streambuf_type(static_cast<const __streambuf_type&>(__rhs)),
      _M_mode(__rhs._M_mode), _M_string(std::move(__rhs._M_string))
      { }

    };
#366 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_istringstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
#402 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/sstream" 3
      explicit
      basic_istringstream(ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__mode | ios_base::in)
      { this->init(&_M_stringbuf); }
#420 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/sstream" 3
      explicit
      basic_istringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
      { this->init(&_M_stringbuf); }







      ~basic_istringstream()
      { }


      basic_istringstream(const basic_istringstream&) = delete;

      basic_istringstream(basic_istringstream&& __rhs)
      : __istream_type(std::move(__rhs)),
      _M_stringbuf(std::move(__rhs._M_stringbuf))
      { __istream_type::set_rdbuf(&_M_stringbuf); }



      basic_istringstream&
      operator=(const basic_istringstream&) = delete;

      basic_istringstream&
      operator=(basic_istringstream&& __rhs)
      {
 __istream_type::operator=(std::move(__rhs));
 _M_stringbuf = std::move(__rhs._M_stringbuf);
 return *this;
      }

      void
      swap(basic_istringstream& __rhs)
      {
 __istream_type::swap(__rhs);
 _M_stringbuf.swap(__rhs._M_stringbuf);
      }
#471 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
#510 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_ostringstream : public basic_ostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
#546 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/sstream" 3
      explicit
      basic_ostringstream(ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__mode | ios_base::out)
      { this->init(&_M_stringbuf); }
#564 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/sstream" 3
      explicit
      basic_ostringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__str, __mode | ios_base::out)
      { this->init(&_M_stringbuf); }







      ~basic_ostringstream()
      { }


      basic_ostringstream(const basic_ostringstream&) = delete;

      basic_ostringstream(basic_ostringstream&& __rhs)
      : __ostream_type(std::move(__rhs)),
      _M_stringbuf(std::move(__rhs._M_stringbuf))
      { __ostream_type::set_rdbuf(&_M_stringbuf); }



      basic_ostringstream&
      operator=(const basic_ostringstream&) = delete;

      basic_ostringstream&
      operator=(basic_ostringstream&& __rhs)
      {
 __ostream_type::operator=(std::move(__rhs));
 _M_stringbuf = std::move(__rhs._M_stringbuf);
 return *this;
      }

      void
      swap(basic_ostringstream& __rhs)
      {
 __ostream_type::swap(__rhs);
 _M_stringbuf.swap(__rhs._M_stringbuf);
      }
#615 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
#654 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
#689 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/sstream" 3
      explicit
      basic_stringstream(ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__m)
      { this->init(&_M_stringbuf); }
#705 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/sstream" 3
      explicit
      basic_stringstream(const __string_type& __str,
    ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__str, __m)
      { this->init(&_M_stringbuf); }







      ~basic_stringstream()
      { }


      basic_stringstream(const basic_stringstream&) = delete;

      basic_stringstream(basic_stringstream&& __rhs)
      : __iostream_type(std::move(__rhs)),
      _M_stringbuf(std::move(__rhs._M_stringbuf))
      { __iostream_type::set_rdbuf(&_M_stringbuf); }



      basic_stringstream&
      operator=(const basic_stringstream&) = delete;

      basic_stringstream&
      operator=(basic_stringstream&& __rhs)
      {
 __iostream_type::operator=(std::move(__rhs));
 _M_stringbuf = std::move(__rhs._M_stringbuf);
 return *this;
      }

      void
      swap(basic_stringstream& __rhs)
      {
 __iostream_type::swap(__rhs);
 _M_stringbuf.swap(__rhs._M_stringbuf);
      }
#756 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };



  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_stringbuf<_CharT, _Traits, _Allocator>& __x,
  basic_stringbuf<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_istringstream<_CharT, _Traits, _Allocator>& __x,
  basic_istringstream<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_ostringstream<_CharT, _Traits, _Allocator>& __x,
  basic_ostringstream<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_stringstream<_CharT, _Traits, _Allocator>& __x,
  basic_stringstream<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


}

}

#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/sstream.tcc" 1 3
#37 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/sstream.tcc" 3

#38 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/sstream.tcc" 3

namespace std
{


  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    pbackfail(int_type __c)
    {
      int_type __ret = traits_type::eof();
      if (this->eback() < this->gptr())
 {


   const bool __testeof = traits_type::eq_int_type(__c, __ret);
   if (!__testeof)
     {
       const bool __testeq = traits_type::eq(traits_type::
          to_char_type(__c),
          this->gptr()[-1]);
       const bool __testout = this->_M_mode & ios_base::out;
       if (__testeq || __testout)
  {
    this->gbump(-1);
    if (!__testeq)
      *this->gptr() = traits_type::to_char_type(__c);
    __ret = __c;
  }
     }
   else
     {
       this->gbump(-1);
       __ret = traits_type::not_eof(__c);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    overflow(int_type __c)
    {
      const bool __testout = this->_M_mode & ios_base::out;
      if (__builtin_expect(!__testout, false))
 return traits_type::eof();

      const bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());
      if (__builtin_expect(__testeof, false))
 return traits_type::not_eof(__c);

      const __size_type __capacity = _M_string.capacity();
      const __size_type __max_size = _M_string.max_size();
      const bool __testput = this->pptr() < this->epptr();
      if (__builtin_expect(!__testput && __capacity == __max_size, false))
 return traits_type::eof();



      const char_type __conv = traits_type::to_char_type(__c);
      if (!__testput)
 {
#110 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/sstream.tcc" 3
   const __size_type __opt_len = std::max(__size_type(2 * __capacity),
       __size_type(512));
   const __size_type __len = std::min(__opt_len, __max_size);
   __string_type __tmp;
   __tmp.reserve(__len);
   if (this->pbase())
     __tmp.assign(this->pbase(), this->epptr() - this->pbase());
   __tmp.push_back(__conv);
   _M_string.swap(__tmp);
   _M_sync(const_cast<char_type*>(_M_string.data()),
    this->gptr() - this->eback(), this->pptr() - this->pbase());
 }
      else
 *this->pptr() = __conv;
      this->pbump(1);
      return __c;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = this->_M_mode & ios_base::in;
      if (__testin)
 {

   _M_update_egptr();

   if (this->gptr() < this->egptr())
     __ret = traits_type::to_int_type(*this->gptr());
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;
      const bool __testboth = __testin && __testout && __way != ios_base::cur;
      __testin &= !(__mode & ios_base::out);
      __testout &= !(__mode & ios_base::in);



      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !__off) && (__testin || __testout || __testboth))
 {
   _M_update_egptr();

   off_type __newoffi = __off;
   off_type __newoffo = __newoffi;
   if (__way == ios_base::cur)
     {
       __newoffi += this->gptr() - __beg;
       __newoffo += this->pptr() - __beg;
     }
   else if (__way == ios_base::end)
     __newoffo = __newoffi += this->egptr() - __beg;

   if ((__testin || __testboth)
       && __newoffi >= 0
       && this->egptr() - __beg >= __newoffi)
     {
       this->setg(this->eback(), this->eback() + __newoffi,
    this->egptr());
       __ret = pos_type(__newoffi);
     }
   if ((__testout || __testboth)
       && __newoffo >= 0
       && this->egptr() - __beg >= __newoffo)
     {
       _M_pbump(this->pbase(), this->epptr(), __newoffo);
       __ret = pos_type(__newoffo);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekpos(pos_type __sp, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      const bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      const bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;

      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !off_type(__sp)) && (__testin || __testout))
 {
   _M_update_egptr();

   const off_type __pos(__sp);
   const bool __testpos = (0 <= __pos
      && __pos <= this->egptr() - __beg);
   if (__testpos)
     {
       if (__testin)
  this->setg(this->eback(), this->eback() + __pos,
      this->egptr());
       if (__testout)
  _M_pbump(this->pbase(), this->epptr(), __pos);
       __ret = __sp;
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_sync(char_type* __base, __size_type __i, __size_type __o)
    {
      const bool __testin = _M_mode & ios_base::in;
      const bool __testout = _M_mode & ios_base::out;
      char_type* __endg = __base + _M_string.size();
      char_type* __endp = __base + _M_string.capacity();

      if (__base != _M_string.data())
 {

   __endg += __i;
   __i = 0;
   __endp = __endg;
 }

      if (__testin)
 this->setg(__base, __base + __i, __endg);
      if (__testout)
 {
   _M_pbump(__base, __endp, __o);



   if (!__testin)
     this->setg(__endg, __endg, __endg);
 }
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off)
    {
      this->setp(__pbeg, __pend);
      while (__off > __gnu_cxx::__numeric_traits<int>::__max)
 {
   this->pbump(__gnu_cxx::__numeric_traits<int>::__max);
   __off -= __gnu_cxx::__numeric_traits<int>::__max;
 }
      this->pbump(__off);
    }




  extern template class basic_stringbuf<char>;
  extern template class basic_istringstream<char>;
  extern template class basic_ostringstream<char>;
  extern template class basic_stringstream<char>;


  extern template class basic_stringbuf<wchar_t>;
  extern template class basic_istringstream<wchar_t>;
  extern template class basic_ostringstream<wchar_t>;
  extern template class basic_stringstream<wchar_t>;




}
#814 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/sstream" 2 3
#151 "C:/Xilinx/Vivado/2018.3/include/ap_common.h" 2





#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/climits" 1 3
#39 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/climits" 3

#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/climits" 3


#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include-fixed/limits.h" 1 3 4
#43 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/climits" 2 3
#157 "C:/Xilinx/Vivado/2018.3/include/ap_common.h" 2

#157 "C:/Xilinx/Vivado/2018.3/include/ap_common.h"
enum { CHAR_IS_SIGNED = 
#157 "C:/Xilinx/Vivado/2018.3/include/ap_common.h" 3 4
                       (-0x7f - 1) 
#157 "C:/Xilinx/Vivado/2018.3/include/ap_common.h"
                                < 0 };


namespace _ap_type {
template <typename _Tp>
struct is_signed {
  static const bool value = _Tp(-1) < _Tp(1);
};

template <typename _Tp>
struct is_integral {
  static const bool value = false;
};





template <> struct is_integral<bool> { static const bool value = true; };
template <> struct is_integral<char> { static const bool value = true; };
template <> struct is_integral<signed char> { static const bool value = true; };
template <> struct is_integral<unsigned char> { static const bool value = true; };
template <> struct is_integral<short> { static const bool value = true; };
template <> struct is_integral<unsigned short> { static const bool value = true; };
template <> struct is_integral<int> { static const bool value = true; };
template <> struct is_integral<unsigned int> { static const bool value = true; };
template <> struct is_integral<long> { static const bool value = true; };
template <> struct is_integral<unsigned long> { static const bool value = true; };
template <> struct is_integral<ap_slong> { static const bool value = true; };
template <> struct is_integral<ap_ulong> { static const bool value = true; };


template <bool, typename _Tp = void>
struct enable_if {};

template <typename _Tp>
struct enable_if<true, _Tp> {
  typedef _Tp type;
};

template <typename _Tp>
struct remove_const {
  typedef _Tp type;
};

template <typename _Tp>
struct remove_const<_Tp const> {
  typedef _Tp type;
};
}
#574 "C:/Xilinx/Vivado/2018.3/include/ap_common.h"
static inline unsigned char guess_radix(const char* s) {
  unsigned char rd = 10;
  const char* p = s;

  if (p[0] == '-' || p[0] == '+') ++p;

  if (p[0] == '0') {
    if (p[1] == 'b' || p[1] == 'B') {
      rd = 2;
    } else if (p[1] == 'o' || p[1] == 'O') {
      rd = 8;
    } else if (p[1] == 'x' || p[1] == 'X') {
      rd = 16;
    } else if (p[1] == 'd' || p[1] == 'D') {
      rd = 10;
    }
  }
  return rd;
}
#602 "C:/Xilinx/Vivado/2018.3/include/ap_common.h"
class half;






#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cmath" 1 3
#39 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cmath" 3

#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cmath" 3
#610 "C:/Xilinx/Vivado/2018.3/include/ap_common.h" 2
#630 "C:/Xilinx/Vivado/2018.3/include/ap_common.h"
template <int _AP_W, bool _AP_S, bool _AP_C = _AP_W <= 64>
class ap_private;

template <int _AP_W, bool _AP_S>
struct ssdm_int_sim {

  ap_private<_AP_W, _AP_S> V;
  ssdm_int_sim() {}
};


#1 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 1
#63 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
template <int _AP_W, bool _AP_S>
struct _private_range_ref;
template <int _AP_W, bool _AP_S>
struct _private_bit_ref;
#90 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
#1 "C:/Xilinx/Vivado/2018.3/include/hls_half.h" 1
#91 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 2
#101 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
namespace AESL_std {
template <class DataType>
DataType inline min(DataType a, DataType b) {
  return (a >= b) ? b : a;
}

template <class DataType>
DataType inline max(DataType a, DataType b) {
  return (a >= b) ? a : b;
}
}


#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/math.h" 1 3
#115 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 2

#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cassert" 1 3
#41 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cassert" 3

#42 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cassert" 3


#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/assert.h" 1 3
#44 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cassert" 2 3
#117 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 2
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdlib" 1 3
#39 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdlib" 3

#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
#118 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 2
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstring" 1 3
#39 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstring" 3

#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstring" 3
#119 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 2
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/iomanip" 1 3
#36 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/iomanip" 3

#37 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/iomanip" 3






#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/locale" 1 3
#36 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/locale" 3

#37 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/locale" 3




#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 1 3
#37 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3

#38 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3

#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ctime" 1 3
#39 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ctime" 3

#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ctime" 3


#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/time.h" 1 3
#24 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/time.h" 3
#pragma pack(push,_CRT_PACKING)



#27 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/time.h" 3
extern "C" {
#60 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/time.h" 3
  typedef long clock_t;
#112 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/time.h" 3
  extern __attribute__ ((__dllimport__)) int _daylight;
  extern __attribute__ ((__dllimport__)) long _dstbias;
  extern __attribute__ ((__dllimport__)) long _timezone;
  extern __attribute__ ((__dllimport__)) char * _tzname[2];

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _get_daylight(int *_Daylight);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _get_dstbias(long *_Daylight_savings_bias);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _get_timezone(long *_Timezone);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _get_tzname(size_t *_ReturnValue,char *_Buffer,size_t _SizeInBytes,int _Index);
  char *__attribute__((__cdecl__)) asctime(const struct tm *_Tm) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) asctime_s (char *_Buf,size_t _SizeInWords,const struct tm *_Tm);
  char *__attribute__((__cdecl__)) _ctime32(const __time32_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _ctime32_s (char *_Buf,size_t _SizeInBytes,const __time32_t *_Time);
  clock_t __attribute__((__cdecl__)) clock(void);
  double __attribute__((__cdecl__)) _difftime32(__time32_t _Time1,__time32_t _Time2);
  struct tm *__attribute__((__cdecl__)) _gmtime32(const __time32_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _gmtime32_s (struct tm *_Tm,const __time32_t *_Time);
  struct tm *__attribute__((__cdecl__)) _localtime32(const __time32_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _localtime32_s (struct tm *_Tm,const __time32_t *_Time);
  size_t __attribute__((__cdecl__)) strftime(char * __restrict__ _Buf,size_t _SizeInBytes,const char * __restrict__ _Format,const struct tm * __restrict__ _Tm);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _strftime_l(char * __restrict__ _Buf,size_t _Max_size,const char * __restrict__ _Format,const struct tm * __restrict__ _Tm,_locale_t _Locale);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strdate(char *_Buffer) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _strdate_s (char *_Buf,size_t _SizeInBytes);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strtime(char *_Buffer) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _strtime_s (char *_Buf ,size_t _SizeInBytes);
  __time32_t __attribute__((__cdecl__)) _time32(__time32_t *_Time);
  __time32_t __attribute__((__cdecl__)) _mktime32(struct tm *_Tm);
  __time32_t __attribute__((__cdecl__)) _mkgmtime32(struct tm *_Tm);


  void __attribute__((__cdecl__)) tzset(void) ;


  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _tzset(void);


  double __attribute__((__cdecl__)) _difftime64(__time64_t _Time1,__time64_t _Time2);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ctime64(const __time64_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _ctime64_s (char *_Buf,size_t _SizeInBytes,const __time64_t *_Time);
  __attribute__ ((__dllimport__)) struct tm *__attribute__((__cdecl__)) _gmtime64(const __time64_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _gmtime64_s (struct tm *_Tm,const __time64_t *_Time);
  __attribute__ ((__dllimport__)) struct tm *__attribute__((__cdecl__)) _localtime64(const __time64_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _localtime64_s (struct tm *_Tm,const __time64_t *_Time);
  __attribute__ ((__dllimport__)) __time64_t __attribute__((__cdecl__)) _mktime64(struct tm *_Tm);
  __attribute__ ((__dllimport__)) __time64_t __attribute__((__cdecl__)) _mkgmtime64(struct tm *_Tm);
  __attribute__ ((__dllimport__)) __time64_t __attribute__((__cdecl__)) _time64(__time64_t *_Time);
  unsigned __attribute__((__cdecl__)) _getsystime(struct tm *_Tm);
  unsigned __attribute__((__cdecl__)) _setsystime(struct tm *_Tm,unsigned _MilliSec);
#203 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/time.h" 3
double __attribute__((__cdecl__)) difftime(time_t _Time1,time_t _Time2);
char *__attribute__((__cdecl__)) ctime(const time_t *_Time) ;
struct tm *__attribute__((__cdecl__)) gmtime(const time_t *_Time) ;
struct tm *__attribute__((__cdecl__)) localtime(const time_t *_Time) ;

time_t __attribute__((__cdecl__)) mktime(struct tm *_Tm);
time_t __attribute__((__cdecl__)) _mkgmtime(struct tm *_Tm);
time_t __attribute__((__cdecl__)) time(time_t *_Time);
#240 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/time.h" 3
inline __attribute__((__always_inline__)) errno_t __attribute__((__cdecl__)) localtime_s(struct tm *_Tm,const time_t *_Time) { return _localtime64_s(_Tm,_Time); }
inline __attribute__((__always_inline__)) errno_t __attribute__((__cdecl__)) gmtime_s(struct tm *_Tm, const time_t *_Time) { return _gmtime64_s(_Tm, _Time); }
inline __attribute__((__always_inline__)) errno_t __attribute__((__cdecl__)) ctime_s(char *_Buf,size_t _SizeInBytes,const time_t *_Time) { return _ctime64_s(_Buf,_SizeInBytes,_Time); }






  __attribute__ ((__dllimport__)) extern int daylight;
  __attribute__ ((__dllimport__)) extern long timezone;
  __attribute__ ((__dllimport__)) extern char *tzname[2];
  void __attribute__((__cdecl__)) tzset(void) ;


#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/_timeval.h" 1 3
#10 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/_timeval.h" 3
struct timeval
{
 long tv_sec;
 long tv_usec;
};
#256 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/time.h" 2 3



struct timezone {
  int tz_minuteswest;
  int tz_dsttime;
};

  extern int __attribute__((__cdecl__)) mingw_gettimeofday (struct timeval *p, struct timezone *z);



}


#pragma pack(pop)






inline __attribute__((__always_inline__)) struct tm *__attribute__((__cdecl__)) localtime_r(const time_t *_Time, struct tm *_Tm) {
  return localtime_s(_Tm, _Time) ? __null : _Tm;
}
inline __attribute__((__always_inline__)) struct tm *__attribute__((__cdecl__)) gmtime_r(const time_t *_Time, struct tm *_Tm) {
  return gmtime_s(_Tm, _Time) ? __null : _Tm;
}
inline __attribute__((__always_inline__)) char *__attribute__((__cdecl__)) ctime_r(const time_t *_Time, char *_Str) {
  return ctime_s(_Str, 0x7fffffff, _Time) ? __null : _Str;
}
inline __attribute__((__always_inline__)) char *__attribute__((__cdecl__)) asctime_r(const struct tm *_Tm, char * _Str) {
  return asctime_s(_Str, 0x7fffffff, _Tm) ? __null : _Str;
}
#301 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/time.h" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/pthread_time.h" 1 3
#74 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/pthread_time.h" 3
extern "C" {









int __attribute__((__cdecl__)) nanosleep(const struct timespec *request, struct timespec *remain);

int __attribute__((__cdecl__)) clock_nanosleep(clockid_t clock_id, int flags, const struct timespec *request, struct timespec *remain);
int __attribute__((__cdecl__)) clock_getres(clockid_t clock_id, struct timespec *res);
int __attribute__((__cdecl__)) clock_gettime(clockid_t clock_id, struct timespec *tp);
int __attribute__((__cdecl__)) clock_settime(clockid_t clock_id, const struct timespec *tp);




}
#302 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/time.h" 2 3
#43 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ctime" 2 3
#58 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/ctime" 3
namespace std
{
  using ::clock_t;
  using ::time_t;
  using ::tm;

  using ::clock;
  using ::difftime;
  using ::mktime;
  using ::time;
  using ::asctime;
  using ::ctime;
  using ::gmtime;
  using ::localtime;
  using ::strftime;
}
#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 2 3

namespace std
{

#52 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
  class time_base
  {
  public:
    enum dateorder { no_order, dmy, mdy, ymd, ydm };
  };

  template<typename _CharT>
    struct __timepunct_cache : public locale::facet
    {

      static const _CharT* _S_timezones[14];

      const _CharT* _M_date_format;
      const _CharT* _M_date_era_format;
      const _CharT* _M_time_format;
      const _CharT* _M_time_era_format;
      const _CharT* _M_date_time_format;
      const _CharT* _M_date_time_era_format;
      const _CharT* _M_am;
      const _CharT* _M_pm;
      const _CharT* _M_am_pm_format;


      const _CharT* _M_day1;
      const _CharT* _M_day2;
      const _CharT* _M_day3;
      const _CharT* _M_day4;
      const _CharT* _M_day5;
      const _CharT* _M_day6;
      const _CharT* _M_day7;


      const _CharT* _M_aday1;
      const _CharT* _M_aday2;
      const _CharT* _M_aday3;
      const _CharT* _M_aday4;
      const _CharT* _M_aday5;
      const _CharT* _M_aday6;
      const _CharT* _M_aday7;


      const _CharT* _M_month01;
      const _CharT* _M_month02;
      const _CharT* _M_month03;
      const _CharT* _M_month04;
      const _CharT* _M_month05;
      const _CharT* _M_month06;
      const _CharT* _M_month07;
      const _CharT* _M_month08;
      const _CharT* _M_month09;
      const _CharT* _M_month10;
      const _CharT* _M_month11;
      const _CharT* _M_month12;


      const _CharT* _M_amonth01;
      const _CharT* _M_amonth02;
      const _CharT* _M_amonth03;
      const _CharT* _M_amonth04;
      const _CharT* _M_amonth05;
      const _CharT* _M_amonth06;
      const _CharT* _M_amonth07;
      const _CharT* _M_amonth08;
      const _CharT* _M_amonth09;
      const _CharT* _M_amonth10;
      const _CharT* _M_amonth11;
      const _CharT* _M_amonth12;

      bool _M_allocated;

      __timepunct_cache(size_t __refs = 0) : facet(__refs),
      _M_date_format(0), _M_date_era_format(0), _M_time_format(0),
      _M_time_era_format(0), _M_date_time_format(0),
      _M_date_time_era_format(0), _M_am(0), _M_pm(0),
      _M_am_pm_format(0), _M_day1(0), _M_day2(0), _M_day3(0),
      _M_day4(0), _M_day5(0), _M_day6(0), _M_day7(0),
      _M_aday1(0), _M_aday2(0), _M_aday3(0), _M_aday4(0),
      _M_aday5(0), _M_aday6(0), _M_aday7(0), _M_month01(0),
      _M_month02(0), _M_month03(0), _M_month04(0), _M_month05(0),
      _M_month06(0), _M_month07(0), _M_month08(0), _M_month09(0),
      _M_month10(0), _M_month11(0), _M_month12(0), _M_amonth01(0),
      _M_amonth02(0), _M_amonth03(0), _M_amonth04(0),
      _M_amonth05(0), _M_amonth06(0), _M_amonth07(0),
      _M_amonth08(0), _M_amonth09(0), _M_amonth10(0),
      _M_amonth11(0), _M_amonth12(0), _M_allocated(false)
      { }

      ~__timepunct_cache();

    private:
      __timepunct_cache&
      operator=(const __timepunct_cache&);

      explicit
      __timepunct_cache(const __timepunct_cache&);
    };

  template<typename _CharT>
    __timepunct_cache<_CharT>::~__timepunct_cache()
    {
      if (_M_allocated)
 {

 }
    }


  template<>
    const char*
    __timepunct_cache<char>::_S_timezones[14];


  template<>
    const wchar_t*
    __timepunct_cache<wchar_t>::_S_timezones[14];



  template<typename _CharT>
    const _CharT* __timepunct_cache<_CharT>::_S_timezones[14];

  template<typename _CharT>
    class __timepunct : public locale::facet
    {
    public:

      typedef _CharT __char_type;
      typedef __timepunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;
      __c_locale _M_c_locale_timepunct;
      const char* _M_name_timepunct;

    public:

      static locale::id id;

      explicit
      __timepunct(size_t __refs = 0);

      explicit
      __timepunct(__cache_type* __cache, size_t __refs = 0);
#206 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      explicit
      __timepunct(__c_locale __cloc, const char* __s, size_t __refs = 0);



      void
      _M_put(_CharT* __s, size_t __maxlen, const _CharT* __format,
      const tm* __tm) const throw ();

      void
      _M_date_formats(const _CharT** __date) const
      {

 __date[0] = _M_data->_M_date_format;
 __date[1] = _M_data->_M_date_era_format;
      }

      void
      _M_time_formats(const _CharT** __time) const
      {

 __time[0] = _M_data->_M_time_format;
 __time[1] = _M_data->_M_time_era_format;
      }

      void
      _M_date_time_formats(const _CharT** __dt) const
      {

 __dt[0] = _M_data->_M_date_time_format;
 __dt[1] = _M_data->_M_date_time_era_format;
      }

      void
      _M_am_pm_format(const _CharT* __ampm) const
      { __ampm = _M_data->_M_am_pm_format; }

      void
      _M_am_pm(const _CharT** __ampm) const
      {
 __ampm[0] = _M_data->_M_am;
 __ampm[1] = _M_data->_M_pm;
      }

      void
      _M_days(const _CharT** __days) const
      {
 __days[0] = _M_data->_M_day1;
 __days[1] = _M_data->_M_day2;
 __days[2] = _M_data->_M_day3;
 __days[3] = _M_data->_M_day4;
 __days[4] = _M_data->_M_day5;
 __days[5] = _M_data->_M_day6;
 __days[6] = _M_data->_M_day7;
      }

      void
      _M_days_abbreviated(const _CharT** __days) const
      {
 __days[0] = _M_data->_M_aday1;
 __days[1] = _M_data->_M_aday2;
 __days[2] = _M_data->_M_aday3;
 __days[3] = _M_data->_M_aday4;
 __days[4] = _M_data->_M_aday5;
 __days[5] = _M_data->_M_aday6;
 __days[6] = _M_data->_M_aday7;
      }

      void
      _M_months(const _CharT** __months) const
      {
 __months[0] = _M_data->_M_month01;
 __months[1] = _M_data->_M_month02;
 __months[2] = _M_data->_M_month03;
 __months[3] = _M_data->_M_month04;
 __months[4] = _M_data->_M_month05;
 __months[5] = _M_data->_M_month06;
 __months[6] = _M_data->_M_month07;
 __months[7] = _M_data->_M_month08;
 __months[8] = _M_data->_M_month09;
 __months[9] = _M_data->_M_month10;
 __months[10] = _M_data->_M_month11;
 __months[11] = _M_data->_M_month12;
      }

      void
      _M_months_abbreviated(const _CharT** __months) const
      {
 __months[0] = _M_data->_M_amonth01;
 __months[1] = _M_data->_M_amonth02;
 __months[2] = _M_data->_M_amonth03;
 __months[3] = _M_data->_M_amonth04;
 __months[4] = _M_data->_M_amonth05;
 __months[5] = _M_data->_M_amonth06;
 __months[6] = _M_data->_M_amonth07;
 __months[7] = _M_data->_M_amonth08;
 __months[8] = _M_data->_M_amonth09;
 __months[9] = _M_data->_M_amonth10;
 __months[10] = _M_data->_M_amonth11;
 __months[11] = _M_data->_M_amonth12;
      }

    protected:
      virtual
      ~__timepunct();


      void
      _M_initialize_timepunct(__c_locale __cloc = 0);
    };

  template<typename _CharT>
    locale::id __timepunct<_CharT>::id;


  template<>
    void
    __timepunct<char>::_M_initialize_timepunct(__c_locale __cloc);

  template<>
    void
    __timepunct<char>::_M_put(char*, size_t, const char*, const tm*) const throw ();


  template<>
    void
    __timepunct<wchar_t>::_M_initialize_timepunct(__c_locale __cloc);

  template<>
    void
    __timepunct<wchar_t>::_M_put(wchar_t*, size_t, const wchar_t*,
     const tm*) const throw ();



}


#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/time_members.h" 1 3
#37 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/time_members.h" 3
namespace std
{


  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(size_t __refs)
    : facet(__refs), _M_data(0)
    {
      _M_name_timepunct = _S_get_c_name();
      _M_initialize_timepunct();
    }

  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(__cache_type* __cache, size_t __refs)
    : facet(__refs), _M_data(__cache)
    {
      _M_name_timepunct = _S_get_c_name();
      _M_initialize_timepunct();
    }

  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(__c_locale __cloc, const char* __s,
         size_t __refs)
    : facet(__refs), _M_data(0)
    {
      if (__builtin_strcmp(__s, _S_get_c_name()) != 0)
 {
   const size_t __len = __builtin_strlen(__s) + 1;
   char* __tmp = new char[__len];
   __builtin_memcpy(__tmp, __s, __len);
   _M_name_timepunct = __tmp;
 }
      else
 _M_name_timepunct = _S_get_c_name();

      try
 { _M_initialize_timepunct(__cloc); }
      catch(...)
 {
   if (_M_name_timepunct != _S_get_c_name())
     delete [] _M_name_timepunct;
   throw;
 }
    }

  template<typename _CharT>
    __timepunct<_CharT>::~__timepunct()
    {
      if (_M_name_timepunct != _S_get_c_name())
 delete [] _M_name_timepunct;
      delete _M_data;
      _S_destroy_c_locale(_M_c_locale_timepunct);
    }


}
#345 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 2 3

namespace std
{


namespace __cxx11 {
#365 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _InIter>
    class time_get : public locale::facet, public time_base
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
#386 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      explicit
      time_get(size_t __refs = 0)
      : facet (__refs) { }
#403 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      dateorder
      date_order() const
      { return this->do_date_order(); }
#427 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      get_time(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_time(__beg, __end, __io, __err, __tm); }
#452 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      get_date(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_date(__beg, __end, __io, __err, __tm); }
#480 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_weekday(__beg, __end, __io, __err, __tm); }
#509 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      get_monthname(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_monthname(__beg, __end, __io, __err, __tm); }
#535 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      get_year(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_year(__beg, __end, __io, __err, __tm); }
#556 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      inline
      iter_type get(iter_type __s, iter_type __end, ios_base& __io,
                    ios_base::iostate& __err, tm* __tm, char __format,
                    char __modifier = 0) const
      {
        return this->do_get(__s, __end, __io, __err, __tm, __format,
                            __modifier);
      }
#583 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      iter_type get(iter_type __s, iter_type __end, ios_base& __io,
                    ios_base::iostate& __err, tm* __tm, const char_type* __fmt,
                    const char_type* __fmtend) const;


    protected:

      virtual
      ~time_get() { }
#603 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual dateorder
      do_date_order() const;
#621 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
#640 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
#659 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_weekday(iter_type __beg, iter_type __end, ios_base&,
       ios_base::iostate& __err, tm* __tm) const;
#678 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_monthname(iter_type __beg, iter_type __end, ios_base&,
         ios_base::iostate& __err, tm* __tm) const;
#697 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
#720 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual

      iter_type
      do_get(iter_type __s, iter_type __end, ios_base& __f,
             ios_base::iostate& __err, tm* __tm,
             char __format, char __modifier) const;



      iter_type
      _M_extract_num(iter_type __beg, iter_type __end, int& __member,
       int __min, int __max, size_t __len,
       ios_base& __io, ios_base::iostate& __err) const;


      iter_type
      _M_extract_name(iter_type __beg, iter_type __end, int& __member,
        const _CharT** __names, size_t __indexlen,
        ios_base& __io, ios_base::iostate& __err) const;


      iter_type
      _M_extract_wday_or_month(iter_type __beg, iter_type __end, int& __member,
          const _CharT** __names, size_t __indexlen,
          ios_base& __io, ios_base::iostate& __err) const;


      iter_type
      _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,
       ios_base::iostate& __err, tm* __tm,
       const _CharT* __format) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id time_get<_CharT, _InIter>::id;


  template<typename _CharT, typename _InIter>
    class time_get_byname : public time_get<_CharT, _InIter>
    {
    public:

      typedef _CharT char_type;
      typedef _InIter iter_type;

      explicit
      time_get_byname(const char*, size_t __refs = 0)
      : time_get<_CharT, _InIter>(__refs) { }


      explicit
      time_get_byname(const string& __s, size_t __refs = 0)
      : time_get_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~time_get_byname() { }
    };

}
#794 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _OutIter>
    class time_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
#815 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      explicit
      time_put(size_t __refs = 0)
      : facet(__refs) { }
#834 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
   const _CharT* __beg, const _CharT* __end) const;
#854 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   const tm* __tm, char __format, char __mod = 0) const
      { return this->do_put(__s, __io, __fill, __tm, __format, __mod); }

    protected:

      virtual
      ~time_put()
      { }
#881 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
      char __format, char __mod) const;
    };

  template<typename _CharT, typename _OutIter>
    locale::id time_put<_CharT, _OutIter>::id;


  template<typename _CharT, typename _OutIter>
    class time_put_byname : public time_put<_CharT, _OutIter>
    {
    public:

      typedef _CharT char_type;
      typedef _OutIter iter_type;

      explicit
      time_put_byname(const char*, size_t __refs = 0)
      : time_put<_CharT, _OutIter>(__refs)
      { };


      explicit
      time_put_byname(const string& __s, size_t __refs = 0)
      : time_put_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~time_put_byname() { }
    };
#926 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
  class money_base
  {
  public:
    enum part { none, space, symbol, sign, value };
    struct pattern { char field[4]; };

    static const pattern _S_default_pattern;

    enum
    {
      _S_minus,
      _S_zero,
      _S_end = 11
    };



    static const char* _S_atoms;



    __attribute__ ((__const__)) static pattern
    _S_construct_pattern(char __precedes, char __space, char __posn) throw ();
  };

  template<typename _CharT, bool _Intl>
    struct __moneypunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;
      const _CharT* _M_curr_symbol;
      size_t _M_curr_symbol_size;
      const _CharT* _M_positive_sign;
      size_t _M_positive_sign_size;
      const _CharT* _M_negative_sign;
      size_t _M_negative_sign_size;
      int _M_frac_digits;
      money_base::pattern _M_pos_format;
      money_base::pattern _M_neg_format;




      _CharT _M_atoms[money_base::_S_end];

      bool _M_allocated;

      __moneypunct_cache(size_t __refs = 0) : facet(__refs),
      _M_grouping(0), _M_grouping_size(0), _M_use_grouping(false),
      _M_decimal_point(_CharT()), _M_thousands_sep(_CharT()),
      _M_curr_symbol(0), _M_curr_symbol_size(0),
      _M_positive_sign(0), _M_positive_sign_size(0),
      _M_negative_sign(0), _M_negative_sign_size(0),
      _M_frac_digits(0),
      _M_pos_format(money_base::pattern()),
      _M_neg_format(money_base::pattern()), _M_allocated(false)
      { }

      ~__moneypunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __moneypunct_cache&
      operator=(const __moneypunct_cache&);

      explicit
      __moneypunct_cache(const __moneypunct_cache&);
    };

  template<typename _CharT, bool _Intl>
    __moneypunct_cache<_CharT, _Intl>::~__moneypunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_curr_symbol;
   delete [] _M_positive_sign;
   delete [] _M_negative_sign;
 }
    }

namespace __cxx11 {
#1021 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
  template<typename _CharT, bool _Intl>
    class moneypunct : public locale::facet, public money_base
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

    private:
      __cache_type* _M_data;

    public:


      static const bool intl = _Intl;

      static locale::id id;
#1050 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      explicit
      moneypunct(size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_moneypunct(); }
#1063 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      explicit
      moneypunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_moneypunct(); }
#1078 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      explicit
      moneypunct(__c_locale __cloc, const char* __s, size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_moneypunct(__cloc, __s); }
#1092 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
#1105 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
#1135 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
#1148 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      string_type
      curr_symbol() const
      { return this->do_curr_symbol(); }
#1165 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      string_type
      positive_sign() const
      { return this->do_positive_sign(); }
#1182 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      string_type
      negative_sign() const
      { return this->do_negative_sign(); }
#1198 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      int
      frac_digits() const
      { return this->do_frac_digits(); }
#1234 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      pattern
      pos_format() const
      { return this->do_pos_format(); }

      pattern
      neg_format() const
      { return this->do_neg_format(); }


    protected:

      virtual
      ~moneypunct();
#1256 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
#1268 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
#1281 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
#1294 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_curr_symbol() const
      { return _M_data->_M_curr_symbol; }
#1307 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_positive_sign() const
      { return _M_data->_M_positive_sign; }
#1320 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_negative_sign() const
      { return _M_data->_M_negative_sign; }
#1334 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual int
      do_frac_digits() const
      { return _M_data->_M_frac_digits; }
#1348 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual pattern
      do_pos_format() const
      { return _M_data->_M_pos_format; }
#1362 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual pattern
      do_neg_format() const
      { return _M_data->_M_neg_format; }


       void
       _M_initialize_moneypunct(__c_locale __cloc = 0,
    const char* __name = 0);
    };

  template<typename _CharT, bool _Intl>
    locale::id moneypunct<_CharT, _Intl>::id;

  template<typename _CharT, bool _Intl>
    const bool moneypunct<_CharT, _Intl>::intl;

  template<>
    moneypunct<char, true>::~moneypunct();

  template<>
    moneypunct<char, false>::~moneypunct();

  template<>
    void
    moneypunct<char, true>::_M_initialize_moneypunct(__c_locale, const char*);

  template<>
    void
    moneypunct<char, false>::_M_initialize_moneypunct(__c_locale, const char*);


  template<>
    moneypunct<wchar_t, true>::~moneypunct();

  template<>
    moneypunct<wchar_t, false>::~moneypunct();

  template<>
    void
    moneypunct<wchar_t, true>::_M_initialize_moneypunct(__c_locale,
       const char*);

  template<>
    void
    moneypunct<wchar_t, false>::_M_initialize_moneypunct(__c_locale,
        const char*);



  template<typename _CharT, bool _Intl>
    class moneypunct_byname : public moneypunct<_CharT, _Intl>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      static const bool intl = _Intl;

      explicit
      moneypunct_byname(const char* __s, size_t __refs = 0)
      : moneypunct<_CharT, _Intl>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_moneypunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }


      explicit
      moneypunct_byname(const string& __s, size_t __refs = 0)
      : moneypunct_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~moneypunct_byname() { }
    };

  template<typename _CharT, bool _Intl>
    const bool moneypunct_byname<_CharT, _Intl>::intl;

}

namespace __cxx11 {
#1465 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _InIter>
    class money_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;
      typedef basic_string<_CharT> string_type;



      static locale::id id;
#1487 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      explicit
      money_get(size_t __refs = 0) : facet(__refs) { }
#1517 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
   ios_base::iostate& __err, long double& __units) const
      { return this->do_get(__s, __end, __intl, __io, __err, __units); }
#1548 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
   ios_base::iostate& __err, string_type& __digits) const
      { return this->do_get(__s, __end, __intl, __io, __err, __digits); }

    protected:

      virtual
      ~money_get() { }
#1572 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
      ios_base::iostate& __err, long double& __units) const;
#1584 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
      ios_base::iostate& __err, string_type& __digits) const;
#1596 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      template<bool _Intl>
        iter_type
        _M_extract(iter_type __s, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, string& __digits) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id money_get<_CharT, _InIter>::id;
#1618 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _OutIter>
    class money_put : public locale::facet
    {
    public:


      typedef _CharT char_type;
      typedef _OutIter iter_type;
      typedef basic_string<_CharT> string_type;



      static locale::id id;
#1639 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      explicit
      money_put(size_t __refs = 0) : facet(__refs) { }
#1659 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
   char_type __fill, long double __units) const
      { return this->do_put(__s, __intl, __io, __fill, __units); }
#1682 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
   char_type __fill, const string_type& __digits) const
      { return this->do_put(__s, __intl, __io, __fill, __digits); }

    protected:

      virtual
      ~money_put() { }
#1717 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
      long double __units) const;
#1741 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
      const string_type& __digits) const;
#1753 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      template<bool _Intl>
        iter_type
        _M_insert(iter_type __s, ios_base& __io, char_type __fill,
    const string_type& __digits) const;
    };

  template<typename _CharT, typename _OutIter>
    locale::id money_put<_CharT, _OutIter>::id;

}





  struct messages_base
  {
    typedef int catalog;
  };

namespace __cxx11 {
#1796 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
  template<typename _CharT>
    class messages : public locale::facet, public messages_base
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_messages;
      const char* _M_name_messages;

    public:

      static locale::id id;
#1824 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      explicit
      messages(size_t __refs = 0);
#1838 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      explicit
      messages(__c_locale __cloc, const char* __s, size_t __refs = 0);
#1851 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      catalog
      open(const basic_string<char>& __s, const locale& __loc) const
      { return this->do_open(__s, __loc); }
#1869 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      catalog
      open(const basic_string<char>&, const locale&, const char*) const;
#1887 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      string_type
      get(catalog __c, int __set, int __msgid, const string_type& __s) const
      { return this->do_get(__c, __set, __msgid, __s); }
#1898 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      void
      close(catalog __c) const
      { return this->do_close(__c); }

    protected:

      virtual
      ~messages();
#1918 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual catalog
      do_open(const basic_string<char>&, const locale&) const;
#1937 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_get(catalog, int, int, const string_type& __dfault) const;






      virtual void
      do_close(catalog) const;


      char*
      _M_convert_to_char(const string_type& __msg) const
      {

 return reinterpret_cast<char*>(const_cast<_CharT*>(__msg.c_str()));
      }


      string_type
      _M_convert_from_char(char*) const
      {

 return string_type();
      }
     };

  template<typename _CharT>
    locale::id messages<_CharT>::id;


  template<>
    string
    messages<char>::do_get(catalog, int, int, const string&) const;


  template<>
    wstring
    messages<wchar_t>::do_get(catalog, int, int, const wstring&) const;



   template<typename _CharT>
    class messages_byname : public messages<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      messages_byname(const char* __s, size_t __refs = 0);


      explicit
      messages_byname(const string& __s, size_t __refs = 0)
      : messages_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~messages_byname()
      { }
    };

}


}


#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/messages_members.h" 1 3
#36 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/messages_members.h" 3
namespace std
{



  template<typename _CharT>
     messages<_CharT>::messages(size_t __refs)
     : facet(__refs)
     { _M_c_locale_messages = _S_get_c_locale(); }

  template<typename _CharT>
     messages<_CharT>::messages(__c_locale, const char*, size_t __refs)
     : facet(__refs)
     { _M_c_locale_messages = _S_get_c_locale(); }

  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::open(const basic_string<char>& __s, const locale& __loc,
      const char*) const
    { return this->do_open(__s, __loc); }


  template<typename _CharT>
    messages<_CharT>::~messages()
    { _S_destroy_c_locale(_M_c_locale_messages); }

  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::do_open(const basic_string<char>&, const locale&) const
    { return 0; }

  template<typename _CharT>
    typename messages<_CharT>::string_type
    messages<_CharT>::do_get(catalog, int, int,
        const string_type& __dfault) const
    { return __dfault; }

  template<typename _CharT>
    void
    messages<_CharT>::do_close(catalog) const
    { }


   template<typename _CharT>
     messages_byname<_CharT>::messages_byname(const char* __s, size_t __refs)
     : messages<_CharT>(__refs)
     {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_messages);
     this->_S_create_c_locale(this->_M_c_locale_messages, __s);
   }
     }


}
#2009 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 2 3


#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/codecvt.h" 1 3
#39 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/codecvt.h" 3

#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/codecvt.h" 3

namespace std
{



  class codecvt_base
  {
  public:
    enum result
    {
      ok,
      partial,
      error,
      noconv
    };
  };
#67 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/codecvt.h" 3
  template<typename _InternT, typename _ExternT, typename _StateT>
    class __codecvt_abstract_base
    : public locale::facet, public codecvt_base
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;
#115 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/codecvt.h" 3
      result
      out(state_type& __state, const intern_type* __from,
   const intern_type* __from_end, const intern_type*& __from_next,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const
      {
 return this->do_out(__state, __from, __from_end, __from_next,
       __to, __to_end, __to_next);
      }
#154 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/codecvt.h" 3
      result
      unshift(state_type& __state, extern_type* __to, extern_type* __to_end,
       extern_type*& __to_next) const
      { return this->do_unshift(__state, __to,__to_end,__to_next); }
#195 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/codecvt.h" 3
      result
      in(state_type& __state, const extern_type* __from,
  const extern_type* __from_end, const extern_type*& __from_next,
  intern_type* __to, intern_type* __to_end,
  intern_type*& __to_next) const
      {
 return this->do_in(__state, __from, __from_end, __from_next,
      __to, __to_end, __to_next);
      }

      int
      encoding() const throw()
      { return this->do_encoding(); }

      bool
      always_noconv() const throw()
      { return this->do_always_noconv(); }

      int
      length(state_type& __state, const extern_type* __from,
      const extern_type* __end, size_t __max) const
      { return this->do_length(__state, __from, __end, __max); }

      int
      max_length() const throw()
      { return this->do_max_length(); }

    protected:
      explicit
      __codecvt_abstract_base(size_t __refs = 0) : locale::facet(__refs) { }

      virtual
      ~__codecvt_abstract_base() { }
#236 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/codecvt.h" 3
      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const = 0;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const = 0;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const = 0;

      virtual int
      do_encoding() const throw() = 0;

      virtual bool
      do_always_noconv() const throw() = 0;

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const = 0;

      virtual int
      do_max_length() const throw() = 0;
    };
#273 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/codecvt.h" 3
   template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt
    : public __codecvt_abstract_base<_InternT, _ExternT, _StateT>
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<_InternT, _ExternT, _StateT> (__refs),
 _M_c_locale_codecvt(0)
      { }

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt() { }

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };

  template<typename _InternT, typename _ExternT, typename _StateT>
    locale::id codecvt<_InternT, _ExternT, _StateT>::id;


  template<>
    class codecvt<char, char, mbstate_t>
    : public __codecvt_abstract_base<char, char, mbstate_t>
    {
      friend class messages<char>;

    public:

      typedef char intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
  };






  template<>
    class codecvt<wchar_t, char, mbstate_t>
    : public __codecvt_abstract_base<wchar_t, char, mbstate_t>
    {
      friend class messages<wchar_t>;

    public:

      typedef wchar_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };
#467 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/codecvt.h" 3
  template<>
    class codecvt<char16_t, char, mbstate_t>
    : public __codecvt_abstract_base<char16_t, char, mbstate_t>
    {
    public:

      typedef char16_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<char16_t, char, mbstate_t>(__refs) { }

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };





  template<>
    class codecvt<char32_t, char, mbstate_t>
    : public __codecvt_abstract_base<char32_t, char, mbstate_t>
    {
    public:

      typedef char32_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<char32_t, char, mbstate_t>(__refs) { }

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };





  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname : public codecvt<_InternT, _ExternT, _StateT>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<_InternT, _ExternT, _StateT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_codecvt);
     this->_S_create_c_locale(this->_M_c_locale_codecvt, __s);
   }
      }


      explicit
      codecvt_byname(const string& __s, size_t __refs = 0)
      : codecvt_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~codecvt_byname() { }
    };


  template<>
    class codecvt_byname<char16_t, char, mbstate_t>
    : public codecvt<char16_t, char, mbstate_t>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<char16_t, char, mbstate_t>(__refs) { }

      explicit
      codecvt_byname(const string& __s, size_t __refs = 0)
      : codecvt_byname(__s.c_str(), __refs) { }

    protected:
      virtual
      ~codecvt_byname() { }
    };

  template<>
    class codecvt_byname<char32_t, char, mbstate_t>
    : public codecvt<char32_t, char, mbstate_t>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<char32_t, char, mbstate_t>(__refs) { }

      explicit
      codecvt_byname(const string& __s, size_t __refs = 0)
      : codecvt_byname(__s.c_str(), __refs) { }

    protected:
      virtual
      ~codecvt_byname() { }
    };





  extern template class codecvt_byname<char, char, mbstate_t>;

  extern template
    const codecvt<char, char, mbstate_t>&
    use_facet<codecvt<char, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<char, char, mbstate_t> >(const locale&);


  extern template class codecvt_byname<wchar_t, char, mbstate_t>;

  extern template
    const codecvt<wchar_t, char, mbstate_t>&
    use_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);



  extern template class codecvt_byname<char16_t, char, mbstate_t>;
  extern template class codecvt_byname<char32_t, char, mbstate_t>;





}
#2012 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 2 3

#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.tcc" 1 3
#33 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.tcc" 3

#34 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.tcc" 3

namespace std
{


  template<typename _CharT, bool _Intl>
    struct __use_cache<__moneypunct_cache<_CharT, _Intl> >
    {
      const __moneypunct_cache<_CharT, _Intl>*
      operator() (const locale& __loc) const
      {
 const size_t __i = moneypunct<_CharT, _Intl>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __moneypunct_cache<_CharT, _Intl>* __tmp = 0;
     try
       {
  __tmp = new __moneypunct_cache<_CharT, _Intl>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<
   const __moneypunct_cache<_CharT, _Intl>*>(__caches[__i]);
      }
    };

  template<typename _CharT, bool _Intl>
    void
    __moneypunct_cache<_CharT, _Intl>::_M_cache(const locale& __loc)
    {
      const moneypunct<_CharT, _Intl>& __mp =
 use_facet<moneypunct<_CharT, _Intl> >(__loc);

      _M_decimal_point = __mp.decimal_point();
      _M_thousands_sep = __mp.thousands_sep();
      _M_frac_digits = __mp.frac_digits();

      char* __grouping = 0;
      _CharT* __curr_symbol = 0;
      _CharT* __positive_sign = 0;
      _CharT* __negative_sign = 0;
      try
 {
   const string& __g = __mp.grouping();
   _M_grouping_size = __g.size();
   __grouping = new char[_M_grouping_size];
   __g.copy(__grouping, _M_grouping_size);
   _M_use_grouping = (_M_grouping_size
        && static_cast<signed char>(__grouping[0]) > 0
        && (__grouping[0]
     != __gnu_cxx::__numeric_traits<char>::__max));

   const basic_string<_CharT>& __cs = __mp.curr_symbol();
   _M_curr_symbol_size = __cs.size();
   __curr_symbol = new _CharT[_M_curr_symbol_size];
   __cs.copy(__curr_symbol, _M_curr_symbol_size);

   const basic_string<_CharT>& __ps = __mp.positive_sign();
   _M_positive_sign_size = __ps.size();
   __positive_sign = new _CharT[_M_positive_sign_size];
   __ps.copy(__positive_sign, _M_positive_sign_size);

   const basic_string<_CharT>& __ns = __mp.negative_sign();
   _M_negative_sign_size = __ns.size();
   __negative_sign = new _CharT[_M_negative_sign_size];
   __ns.copy(__negative_sign, _M_negative_sign_size);

   _M_pos_format = __mp.pos_format();
   _M_neg_format = __mp.neg_format();

   const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
   __ct.widen(money_base::_S_atoms,
       money_base::_S_atoms + money_base::_S_end, _M_atoms);

   _M_grouping = __grouping;
   _M_curr_symbol = __curr_symbol;
   _M_positive_sign = __positive_sign;
   _M_negative_sign = __negative_sign;
   _M_allocated = true;
 }
      catch(...)
 {
   delete [] __grouping;
   delete [] __curr_symbol;
   delete [] __positive_sign;
   delete [] __negative_sign;
   throw;
 }
    }

namespace __cxx11 {

  template<typename _CharT, typename _InIter>
    template<bool _Intl>
      _InIter
      money_get<_CharT, _InIter>::
      _M_extract(iter_type __beg, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, string& __units) const
      {
 typedef char_traits<_CharT> __traits_type;
 typedef typename string_type::size_type size_type;
 typedef money_base::part part;
 typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

 const locale& __loc = __io._M_getloc();
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 __use_cache<__cache_type> __uc;
 const __cache_type* __lc = __uc(__loc);
 const char_type* __lit = __lc->_M_atoms;


 bool __negative = false;

 size_type __sign_size = 0;

 const bool __mandatory_sign = (__lc->_M_positive_sign_size
           && __lc->_M_negative_sign_size);

 string __grouping_tmp;
 if (__lc->_M_use_grouping)
   __grouping_tmp.reserve(32);

 int __last_pos = 0;

 int __n = 0;

 bool __testvalid = true;

 bool __testdecfound = false;


 string __res;
 __res.reserve(32);

 const char_type* __lit_zero = __lit + money_base::_S_zero;
 const money_base::pattern __p = __lc->_M_neg_format;
 for (int __i = 0; __i < 4 && __testvalid; ++__i)
   {
     const part __which = static_cast<part>(__p.field[__i]);
     switch (__which)
       {
       case money_base::symbol:




  if (__io.flags() & ios_base::showbase || __sign_size > 1
      || __i == 0
      || (__i == 1 && (__mandatory_sign
         || (static_cast<part>(__p.field[0])
      == money_base::sign)
         || (static_cast<part>(__p.field[2])
      == money_base::space)))
      || (__i == 2 && ((static_cast<part>(__p.field[3])
          == money_base::value)
         || (__mandatory_sign
      && (static_cast<part>(__p.field[3])
          == money_base::sign)))))
    {
      const size_type __len = __lc->_M_curr_symbol_size;
      size_type __j = 0;
      for (; __beg != __end && __j < __len
      && *__beg == __lc->_M_curr_symbol[__j];
    ++__beg, (void)++__j);
      if (__j != __len
   && (__j || __io.flags() & ios_base::showbase))
        __testvalid = false;
    }
  break;
       case money_base::sign:

  if (__lc->_M_positive_sign_size && __beg != __end
      && *__beg == __lc->_M_positive_sign[0])
    {
      __sign_size = __lc->_M_positive_sign_size;
      ++__beg;
    }
  else if (__lc->_M_negative_sign_size && __beg != __end
    && *__beg == __lc->_M_negative_sign[0])
    {
      __negative = true;
      __sign_size = __lc->_M_negative_sign_size;
      ++__beg;
    }
  else if (__lc->_M_positive_sign_size
    && !__lc->_M_negative_sign_size)


    __negative = true;
  else if (__mandatory_sign)
    __testvalid = false;
  break;
       case money_base::value:


  for (; __beg != __end; ++__beg)
    {
      const char_type __c = *__beg;
      const char_type* __q = __traits_type::find(__lit_zero,
              10, __c);
      if (__q != 0)
        {
   __res += money_base::_S_atoms[__q - __lit];
   ++__n;
        }
      else if (__c == __lc->_M_decimal_point
        && !__testdecfound)
        {
   if (__lc->_M_frac_digits <= 0)
     break;

   __last_pos = __n;
   __n = 0;
   __testdecfound = true;
        }
      else if (__lc->_M_use_grouping
        && __c == __lc->_M_thousands_sep
        && !__testdecfound)
        {
   if (__n)
     {

       __grouping_tmp += static_cast<char>(__n);
       __n = 0;
     }
   else
     {
       __testvalid = false;
       break;
     }
        }
      else
        break;
    }
  if (__res.empty())
    __testvalid = false;
  break;
       case money_base::space:

  if (__beg != __end && __ctype.is(ctype_base::space, *__beg))
    ++__beg;
  else
    __testvalid = false;
       case money_base::none:

  if (__i != 3)
    for (; __beg != __end
    && __ctype.is(ctype_base::space, *__beg); ++__beg);
  break;
       }
   }


 if (__sign_size > 1 && __testvalid)
   {
     const char_type* __sign = __negative ? __lc->_M_negative_sign
                                          : __lc->_M_positive_sign;
     size_type __i = 1;
     for (; __beg != __end && __i < __sign_size
     && *__beg == __sign[__i]; ++__beg, (void)++__i);

     if (__i != __sign_size)
       __testvalid = false;
   }

 if (__testvalid)
   {

     if (__res.size() > 1)
       {
  const size_type __first = __res.find_first_not_of('0');
  const bool __only_zeros = __first == string::npos;
  if (__first)
    __res.erase(0, __only_zeros ? __res.size() - 1 : __first);
       }


     if (__negative && __res[0] != '0')
       __res.insert(__res.begin(), '-');


     if (__grouping_tmp.size())
       {

  __grouping_tmp += static_cast<char>(__testdecfound ? __last_pos
                         : __n);
  if (!std::__verify_grouping(__lc->_M_grouping,
         __lc->_M_grouping_size,
         __grouping_tmp))
    __err |= ios_base::failbit;
       }


     if (__testdecfound && __n != __lc->_M_frac_digits)
       __testvalid = false;
   }


 if (!__testvalid)
   __err |= ios_base::failbit;
 else
   __units.swap(__res);


 if (__beg == __end)
   __err |= ios_base::eofbit;
 return __beg;
      }
#367 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
    ios_base::iostate& __err, long double& __units) const
    {
      string __str;
      __beg = __intl ? _M_extract<true>(__beg, __end, __io, __err, __str)
              : _M_extract<false>(__beg, __end, __io, __err, __str);
      std::__convert_to_v(__str.c_str(), __units, __err, _S_get_c_locale());
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
    ios_base::iostate& __err, string_type& __digits) const
    {
      typedef typename string::size_type size_type;

      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      string __str;
      __beg = __intl ? _M_extract<true>(__beg, __end, __io, __err, __str)
              : _M_extract<false>(__beg, __end, __io, __err, __str);
      const size_type __len = __str.size();
      if (__len)
 {
   __digits.resize(__len);
   __ctype.widen(__str.data(), __str.data() + __len, &__digits[0]);
 }
      return __beg;
    }

  template<typename _CharT, typename _OutIter>
    template<bool _Intl>
      _OutIter
      money_put<_CharT, _OutIter>::
      _M_insert(iter_type __s, ios_base& __io, char_type __fill,
  const string_type& __digits) const
      {
 typedef typename string_type::size_type size_type;
 typedef money_base::part part;
 typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

 const locale& __loc = __io._M_getloc();
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 __use_cache<__cache_type> __uc;
 const __cache_type* __lc = __uc(__loc);
 const char_type* __lit = __lc->_M_atoms;



 const char_type* __beg = __digits.data();

 money_base::pattern __p;
 const char_type* __sign;
 size_type __sign_size;
 if (!(*__beg == __lit[money_base::_S_minus]))
   {
     __p = __lc->_M_pos_format;
     __sign = __lc->_M_positive_sign;
     __sign_size = __lc->_M_positive_sign_size;
   }
 else
   {
     __p = __lc->_M_neg_format;
     __sign = __lc->_M_negative_sign;
     __sign_size = __lc->_M_negative_sign_size;
     if (__digits.size())
       ++__beg;
   }


 size_type __len = __ctype.scan_not(ctype_base::digit, __beg,
        __beg + __digits.size()) - __beg;
 if (__len)
   {



     string_type __value;
     __value.reserve(2 * __len);



     long __paddec = __len - __lc->_M_frac_digits;
     if (__paddec > 0)
         {
  if (__lc->_M_frac_digits < 0)
    __paddec = __len;
    if (__lc->_M_grouping_size)
      {
      __value.assign(2 * __paddec, char_type());
       _CharT* __vend =
        std::__add_grouping(&__value[0], __lc->_M_thousands_sep,
       __lc->_M_grouping,
       __lc->_M_grouping_size,
       __beg, __beg + __paddec);
      __value.erase(__vend - &__value[0]);
      }
    else
    __value.assign(__beg, __paddec);
       }


     if (__lc->_M_frac_digits > 0)
       {
  __value += __lc->_M_decimal_point;
  if (__paddec >= 0)
    __value.append(__beg + __paddec, __lc->_M_frac_digits);
  else
    {

      __value.append(-__paddec, __lit[money_base::_S_zero]);
      __value.append(__beg, __len);
    }
         }


     const ios_base::fmtflags __f = __io.flags()
                                    & ios_base::adjustfield;
     __len = __value.size() + __sign_size;
     __len += ((__io.flags() & ios_base::showbase)
        ? __lc->_M_curr_symbol_size : 0);

     string_type __res;
     __res.reserve(2 * __len);

     const size_type __width = static_cast<size_type>(__io.width());
     const bool __testipad = (__f == ios_base::internal
         && __len < __width);

     for (int __i = 0; __i < 4; ++__i)
       {
  const part __which = static_cast<part>(__p.field[__i]);
  switch (__which)
    {
    case money_base::symbol:
      if (__io.flags() & ios_base::showbase)
        __res.append(__lc->_M_curr_symbol,
       __lc->_M_curr_symbol_size);
      break;
    case money_base::sign:



      if (__sign_size)
        __res += __sign[0];
      break;
    case money_base::value:
      __res += __value;
      break;
    case money_base::space:



      if (__testipad)
        __res.append(__width - __len, __fill);
      else
        __res += __fill;
      break;
    case money_base::none:
      if (__testipad)
        __res.append(__width - __len, __fill);
      break;
    }
       }


     if (__sign_size > 1)
       __res.append(__sign + 1, __sign_size - 1);


     __len = __res.size();
     if (__width > __len)
       {
  if (__f == ios_base::left)

    __res.append(__width - __len, __fill);
  else

    __res.insert(0, __width - __len, __fill);
  __len = __width;
       }


     __s = std::__write(__s, __res.data(), __len);
   }
 __io.width(0);
 return __s;
      }
#573 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
    long double __units) const
    {
      const locale __loc = __io.getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);


      int __cs_size = 64;
      char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));


      int __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     "%.*Lf", 0, __units);

      if (__len >= __cs_size)
 {
   __cs_size = __len + 1;
   __cs = static_cast<char*>(__builtin_alloca(__cs_size));
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     "%.*Lf", 0, __units);
 }
#605 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.tcc" 3
      string_type __digits(__len, char_type());
      __ctype.widen(__cs, __cs + __len, &__digits[0]);
      return __intl ? _M_insert<true>(__s, __io, __fill, __digits)
             : _M_insert<false>(__s, __io, __fill, __digits);
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
    const string_type& __digits) const
    { return __intl ? _M_insert<true>(__s, __io, __fill, __digits)
             : _M_insert<false>(__s, __io, __fill, __digits); }

}




  template<typename _CharT, typename _InIter>
    time_base::dateorder
    time_get<_CharT, _InIter>::do_date_order() const
    { return time_base::no_order; }



  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, tm* __tm,
     const _CharT* __format) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const size_t __len = char_traits<_CharT>::length(__format);

      ios_base::iostate __tmperr = ios_base::goodbit;
      size_t __i = 0;
      for (; __beg != __end && __i < __len && !__tmperr; ++__i)
 {
   if (__ctype.narrow(__format[__i], 0) == '%')
     {

       char __c = __ctype.narrow(__format[++__i], 0);
       int __mem = 0;
       if (__c == 'E' || __c == 'O')
  __c = __ctype.narrow(__format[++__i], 0);
       switch (__c)
  {
    const char* __cs;
    _CharT __wcs[10];
  case 'a':

    const char_type* __days1[7];
    __tp._M_days_abbreviated(__days1);
    __beg = _M_extract_name(__beg, __end, __tm->tm_wday, __days1,
       7, __io, __tmperr);
    break;
  case 'A':

    const char_type* __days2[7];
    __tp._M_days(__days2);
    __beg = _M_extract_name(__beg, __end, __tm->tm_wday, __days2,
       7, __io, __tmperr);
    break;
  case 'h':
  case 'b':

    const char_type* __months1[12];
    __tp._M_months_abbreviated(__months1);
    __beg = _M_extract_name(__beg, __end, __tm->tm_mon,
       __months1, 12, __io, __tmperr);
    break;
  case 'B':

    const char_type* __months2[12];
    __tp._M_months(__months2);
    __beg = _M_extract_name(__beg, __end, __tm->tm_mon,
       __months2, 12, __io, __tmperr);
    break;
  case 'c':

    const char_type* __dt[2];
    __tp._M_date_time_formats(__dt);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __dt[0]);
    break;
  case 'd':

    __beg = _M_extract_num(__beg, __end, __tm->tm_mday, 1, 31, 2,
      __io, __tmperr);
    break;
  case 'e':


    if (__ctype.is(ctype_base::space, *__beg))
      __beg = _M_extract_num(++__beg, __end, __tm->tm_mday, 1, 9,
        1, __io, __tmperr);
    else
      __beg = _M_extract_num(__beg, __end, __tm->tm_mday, 10, 31,
        2, __io, __tmperr);
    break;
  case 'D':

    __cs = "%m/%d/%y";
    __ctype.widen(__cs, __cs + 9, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'H':

    __beg = _M_extract_num(__beg, __end, __tm->tm_hour, 0, 23, 2,
      __io, __tmperr);
    break;
  case 'I':

    __beg = _M_extract_num(__beg, __end, __tm->tm_hour, 1, 12, 2,
      __io, __tmperr);
    break;
  case 'm':

    __beg = _M_extract_num(__beg, __end, __mem, 1, 12, 2,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_mon = __mem - 1;
    break;
  case 'M':

    __beg = _M_extract_num(__beg, __end, __tm->tm_min, 0, 59, 2,
      __io, __tmperr);
    break;
  case 'n':
    if (__ctype.narrow(*__beg, 0) == '\n')
      ++__beg;
    else
      __tmperr |= ios_base::failbit;
    break;
  case 'R':

    __cs = "%H:%M";
    __ctype.widen(__cs, __cs + 6, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'S':



    __beg = _M_extract_num(__beg, __end, __tm->tm_sec, 0, 60, 2,



      __io, __tmperr);
    break;
  case 't':
    if (__ctype.narrow(*__beg, 0) == '\t')
      ++__beg;
    else
      __tmperr |= ios_base::failbit;
    break;
  case 'T':

    __cs = "%H:%M:%S";
    __ctype.widen(__cs, __cs + 9, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'x':

    const char_type* __dates[2];
    __tp._M_date_formats(__dates);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __dates[0]);
    break;
  case 'X':

    const char_type* __times[2];
    __tp._M_time_formats(__times);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __times[0]);
    break;
  case 'y':
  case 'C':

  case 'Y':




    __beg = _M_extract_num(__beg, __end, __mem, 0, 9999, 4,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_year = __mem < 0 ? __mem + 100 : __mem - 1900;
    break;
  case 'Z':

    if (__ctype.is(ctype_base::upper, *__beg))
      {
        int __tmp;
        __beg = _M_extract_name(__beg, __end, __tmp,
           __timepunct_cache<_CharT>::_S_timezones,
           14, __io, __tmperr);


        if (__beg != __end && !__tmperr && __tmp == 0
     && (*__beg == __ctype.widen('-')
         || *__beg == __ctype.widen('+')))
   {
     __beg = _M_extract_num(__beg, __end, __tmp, 0, 23, 2,
       __io, __tmperr);
     __beg = _M_extract_num(__beg, __end, __tmp, 0, 59, 2,
       __io, __tmperr);
   }
      }
    else
      __tmperr |= ios_base::failbit;
    break;
  default:

    __tmperr |= ios_base::failbit;
  }
     }
   else
     {

       if (__format[__i] == *__beg)
  ++__beg;
       else
  __tmperr |= ios_base::failbit;
     }
 }

      if (__tmperr || __i != __len)
 __err |= ios_base::failbit;

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_num(iter_type __beg, iter_type __end, int& __member,
     int __min, int __max, size_t __len,
     ios_base& __io, ios_base::iostate& __err) const
    {
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);


      int __mult = __len == 2 ? 10 : (__len == 4 ? 1000 : 1);

      ++__min;
      size_t __i = 0;
      int __value = 0;
      for (; __beg != __end && __i < __len; ++__beg, (void)++__i)
 {
   const char __c = __ctype.narrow(*__beg, '*');
   if (__c >= '0' && __c <= '9')
     {
       __value = __value * 10 + (__c - '0');
       const int __valuec = __value * __mult;
       if (__valuec > __max || __valuec + __mult < __min)
  break;
       __mult /= 10;
     }
   else
     break;
 }
      if (__i == __len)
 __member = __value;

      else if (__len == 4 && __i == 2)
 __member = __value - 100;
      else
 __err |= ios_base::failbit;

      return __beg;
    }



  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_name(iter_type __beg, iter_type __end, int& __member,
      const _CharT** __names, size_t __indexlen,
      ios_base& __io, ios_base::iostate& __err) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      int* __matches = static_cast<int*>(__builtin_alloca(sizeof(int)
         * __indexlen));
      size_t __nmatches = 0;
      size_t __pos = 0;
      bool __testvalid = true;
      const char_type* __name;





      if (__beg != __end)
 {
   const char_type __c = *__beg;
   for (size_t __i1 = 0; __i1 < __indexlen; ++__i1)
     if (__c == __names[__i1][0]
  || __c == __ctype.toupper(__names[__i1][0]))
       __matches[__nmatches++] = __i1;
 }

      while (__nmatches > 1)
 {

   size_t __minlen = __traits_type::length(__names[__matches[0]]);
   for (size_t __i2 = 1; __i2 < __nmatches; ++__i2)
     __minlen = std::min(__minlen,
         __traits_type::length(__names[__matches[__i2]]));
   ++__beg;
   ++__pos;
   if (__pos < __minlen && __beg != __end)
     for (size_t __i3 = 0; __i3 < __nmatches;)
       {
  __name = __names[__matches[__i3]];
  if (!(__name[__pos] == *__beg))
    __matches[__i3] = __matches[--__nmatches];
  else
    ++__i3;
       }
   else
     break;
 }

      if (__nmatches == 1)
 {

   ++__beg;
   ++__pos;
   __name = __names[__matches[0]];
   const size_t __len = __traits_type::length(__name);
   while (__pos < __len && __beg != __end && __name[__pos] == *__beg)
     ++__beg, (void)++__pos;

   if (__len == __pos)
     __member = __matches[0];
   else
     __testvalid = false;
 }
      else
 __testvalid = false;
      if (!__testvalid)
 __err |= ios_base::failbit;

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_wday_or_month(iter_type __beg, iter_type __end, int& __member,
        const _CharT** __names, size_t __indexlen,
        ios_base& __io, ios_base::iostate& __err) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      int* __matches = static_cast<int*>(__builtin_alloca(2 * sizeof(int)
         * __indexlen));
      size_t __nmatches = 0;
      size_t* __matches_lengths = 0;
      size_t __pos = 0;

      if (__beg != __end)
 {
   const char_type __c = *__beg;
   for (size_t __i = 0; __i < 2 * __indexlen; ++__i)
     if (__c == __names[__i][0]
  || __c == __ctype.toupper(__names[__i][0]))
       __matches[__nmatches++] = __i;
 }

      if (__nmatches)
 {
   ++__beg;
   ++__pos;

   __matches_lengths
     = static_cast<size_t*>(__builtin_alloca(sizeof(size_t)
          * __nmatches));
   for (size_t __i = 0; __i < __nmatches; ++__i)
     __matches_lengths[__i]
       = __traits_type::length(__names[__matches[__i]]);
 }

      for (; __beg != __end; ++__beg, (void)++__pos)
 {
   size_t __nskipped = 0;
   const char_type __c = *__beg;
   for (size_t __i = 0; __i < __nmatches;)
     {
       const char_type* __name = __names[__matches[__i]];
       if (__pos >= __matches_lengths[__i])
  ++__nskipped, ++__i;
       else if (!(__name[__pos] == __c))
  {
    --__nmatches;
    __matches[__i] = __matches[__nmatches];
    __matches_lengths[__i] = __matches_lengths[__nmatches];
  }
       else
  ++__i;
     }
   if (__nskipped == __nmatches)
     break;
 }

      if ((__nmatches == 1 && __matches_lengths[0] == __pos)
   || (__nmatches == 2 && (__matches_lengths[0] == __pos
      || __matches_lengths[1] == __pos)))
 __member = (__matches[0] >= __indexlen
      ? __matches[0] - __indexlen : __matches[0]);
      else
 __err |= ios_base::failbit;

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __times[2];
      __tp._M_time_formats(__times);
      __beg = _M_extract_via_format(__beg, __end, __io, __err,
        __tm, __times[0]);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __dates[2];
      __tp._M_date_formats(__dates);
      __beg = _M_extract_via_format(__beg, __end, __io, __err,
        __tm, __dates[0]);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const char_type* __days[14];
      __tp._M_days_abbreviated(__days);
      __tp._M_days(__days + 7);
      int __tmpwday;
      ios_base::iostate __tmperr = ios_base::goodbit;

      __beg = _M_extract_wday_or_month(__beg, __end, __tmpwday, __days, 7,
           __io, __tmperr);
      if (!__tmperr)
 __tm->tm_wday = __tmpwday;
      else
 __err |= ios_base::failbit;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
     }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_monthname(iter_type __beg, iter_type __end,
                     ios_base& __io, ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const char_type* __months[24];
      __tp._M_months_abbreviated(__months);
      __tp._M_months(__months + 12);
      int __tmpmon;
      ios_base::iostate __tmperr = ios_base::goodbit;

      __beg = _M_extract_wday_or_month(__beg, __end, __tmpmon, __months, 12,
           __io, __tmperr);
      if (!__tmperr)
 __tm->tm_mon = __tmpmon;
      else
 __err |= ios_base::failbit;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      int __tmpyear;
      ios_base::iostate __tmperr = ios_base::goodbit;

      __beg = _M_extract_num(__beg, __end, __tmpyear, 0, 9999, 4,
        __io, __tmperr);
      if (!__tmperr)
 __tm->tm_year = __tmpyear < 0 ? __tmpyear + 100 : __tmpyear - 1900;
      else
 __err |= ios_base::failbit;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }


  template<typename _CharT, typename _InIter>
    inline
    _InIter
    time_get<_CharT, _InIter>::
    get(iter_type __s, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm, const char_type* __fmt,
        const char_type* __fmtend) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __err = ios_base::goodbit;
      while (__fmt != __fmtend &&
             __err == ios_base::goodbit)
        {
          if (__s == __end)
            {
              __err = ios_base::eofbit | ios_base::failbit;
              break;
            }
          else if (__ctype.narrow(*__fmt, 0) == '%')
            {
              char __format;
              char __mod = 0;
              if (++__fmt == __fmtend)
                {
                  __err = ios_base::failbit;
                  break;
                }
              const char __c = __ctype.narrow(*__fmt, 0);
              if (__c != 'E' && __c != 'O')
                __format = __c;
              else if (++__fmt != __fmtend)
                {
                  __mod = __c;
                  __format = __ctype.narrow(*__fmt, 0);
                }
              else
                {
                  __err = ios_base::failbit;
                  break;
                }
              __s = this->do_get(__s, __end, __io, __err, __tm, __format,
     __mod);
              ++__fmt;
            }
          else if (__ctype.is(ctype_base::space, *__fmt))
            {
              ++__fmt;
              while (__fmt != __fmtend &&
                     __ctype.is(ctype_base::space, *__fmt))
                ++__fmt;

              while (__s != __end &&
                     __ctype.is(ctype_base::space, *__s))
                ++__s;
            }

          else if (__ctype.tolower(*__s) == __ctype.tolower(*__fmt) ||
                   __ctype.toupper(*__s) == __ctype.toupper(*__fmt))
            {
              ++__s;
              ++__fmt;
            }
          else
            {
              __err = ios_base::failbit;
              break;
            }
        }
      return __s;
    }

  template<typename _CharT, typename _InIter>
    inline
    _InIter
    time_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, tm* __tm,
           char __format, char __mod) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __err = ios_base::goodbit;

      char_type __fmt[4];
      __fmt[0] = __ctype.widen('%');
      if (!__mod)
        {
          __fmt[1] = __format;
          __fmt[2] = char_type();
        }
      else
        {
          __fmt[1] = __mod;
          __fmt[2] = __format;
          __fmt[3] = char_type();
        }

      __beg = _M_extract_via_format(__beg, __end, __io, __err, __tm, __fmt);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
 const _CharT* __beg, const _CharT* __end) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      for (; __beg != __end; ++__beg)
 if (__ctype.narrow(*__beg, 0) != '%')
   {
     *__s = *__beg;
     ++__s;
   }
 else if (++__beg != __end)
   {
     char __format;
     char __mod = 0;
     const char __c = __ctype.narrow(*__beg, 0);
     if (__c != 'E' && __c != 'O')
       __format = __c;
     else if (++__beg != __end)
       {
  __mod = __c;
  __format = __ctype.narrow(*__beg, 0);
       }
     else
       break;
     __s = this->do_put(__s, __io, __fill, __tm, __format, __mod);
   }
 else
   break;
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type, const tm* __tm,
    char __format, char __mod) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __timepunct<_CharT> const& __tp = use_facet<__timepunct<_CharT> >(__loc);



      const size_t __maxlen = 128;
      char_type __res[__maxlen];






      char_type __fmt[4];
      __fmt[0] = __ctype.widen('%');
      if (!__mod)
 {
   __fmt[1] = __format;
   __fmt[2] = char_type();
 }
      else
 {
   __fmt[1] = __mod;
   __fmt[2] = __format;
   __fmt[3] = char_type();
 }

      __tp._M_put(__res, __maxlen, __fmt, __tm);


      return std::__write(__s, __res, char_traits<char_type>::length(__res));
    }





  extern template class moneypunct<char, false>;
  extern template class moneypunct<char, true>;
  extern template class moneypunct_byname<char, false>;
  extern template class moneypunct_byname<char, true>;
  extern template class __cxx11:: money_get<char>;
  extern template class __cxx11:: money_put<char>;
  extern template class __timepunct<char>;
  extern template class time_put<char>;
  extern template class time_put_byname<char>;
  extern template class time_get<char>;
  extern template class time_get_byname<char>;
  extern template class messages<char>;
  extern template class messages_byname<char>;

  extern template
    const moneypunct<char, true>&
    use_facet<moneypunct<char, true> >(const locale&);

  extern template
    const moneypunct<char, false>&
    use_facet<moneypunct<char, false> >(const locale&);

  extern template
    const money_put<char>&
    use_facet<money_put<char> >(const locale&);

  extern template
    const money_get<char>&
    use_facet<money_get<char> >(const locale&);

  extern template
    const __timepunct<char>&
    use_facet<__timepunct<char> >(const locale&);

  extern template
    const time_put<char>&
    use_facet<time_put<char> >(const locale&);

  extern template
    const time_get<char>&
    use_facet<time_get<char> >(const locale&);

  extern template
    const messages<char>&
    use_facet<messages<char> >(const locale&);

  extern template
    bool
    has_facet<moneypunct<char> >(const locale&);

  extern template
    bool
    has_facet<money_put<char> >(const locale&);

  extern template
    bool
    has_facet<money_get<char> >(const locale&);

  extern template
    bool
    has_facet<__timepunct<char> >(const locale&);

  extern template
    bool
    has_facet<time_put<char> >(const locale&);

  extern template
    bool
    has_facet<time_get<char> >(const locale&);

  extern template
    bool
    has_facet<messages<char> >(const locale&);


  extern template class moneypunct<wchar_t, false>;
  extern template class moneypunct<wchar_t, true>;
  extern template class moneypunct_byname<wchar_t, false>;
  extern template class moneypunct_byname<wchar_t, true>;
  extern template class __cxx11:: money_get<wchar_t>;
  extern template class __cxx11:: money_put<wchar_t>;
  extern template class __timepunct<wchar_t>;
  extern template class time_put<wchar_t>;
  extern template class time_put_byname<wchar_t>;
  extern template class time_get<wchar_t>;
  extern template class time_get_byname<wchar_t>;
  extern template class messages<wchar_t>;
  extern template class messages_byname<wchar_t>;

  extern template
    const moneypunct<wchar_t, true>&
    use_facet<moneypunct<wchar_t, true> >(const locale&);

  extern template
    const moneypunct<wchar_t, false>&
    use_facet<moneypunct<wchar_t, false> >(const locale&);

  extern template
    const money_put<wchar_t>&
    use_facet<money_put<wchar_t> >(const locale&);

  extern template
    const money_get<wchar_t>&
    use_facet<money_get<wchar_t> >(const locale&);

  extern template
    const __timepunct<wchar_t>&
    use_facet<__timepunct<wchar_t> >(const locale&);

  extern template
    const time_put<wchar_t>&
    use_facet<time_put<wchar_t> >(const locale&);

  extern template
    const time_get<wchar_t>&
    use_facet<time_get<wchar_t> >(const locale&);

  extern template
    const messages<wchar_t>&
    use_facet<messages<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<moneypunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<money_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<money_get<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<__timepunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<time_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<time_get<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<messages<wchar_t> >(const locale&);




}
#2014 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 2 3
#42 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/locale" 2 3

#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_conv.h" 1 3
#38 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_conv.h" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/stringfwd.h" 1 3
#39 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_conv.h" 2 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/allocator.h" 1 3
#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_conv.h" 2 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/codecvt.h" 1 3
#41 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_conv.h" 2 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/unique_ptr.h" 1 3
#39 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/unique_ptr.h" 3
namespace std
{








  template<typename> class auto_ptr;



  template<typename _Tp>
    struct default_delete
    {

      constexpr default_delete() noexcept = default;






      template<typename _Up, typename = typename
        enable_if<is_convertible<_Up*, _Tp*>::value>::type>
        default_delete(const default_delete<_Up>&) noexcept { }


      void
      operator()(_Tp* __ptr) const
      {
 static_assert(!is_void<_Tp>::value,
        "can't delete pointer to incomplete type");
 static_assert(sizeof(_Tp)>0,
        "can't delete pointer to incomplete type");
 delete __ptr;
      }
    };




  template<typename _Tp>
    struct default_delete<_Tp[]>
    {
    public:

      constexpr default_delete() noexcept = default;
#99 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/unique_ptr.h" 3
      template<typename _Up, typename = typename
        enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value>::type>
        default_delete(const default_delete<_Up[]>&) noexcept { }


      template<typename _Up>
      typename enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value>::type
 operator()(_Up* __ptr) const
      {
 static_assert(sizeof(_Tp)>0,
        "can't delete pointer to incomplete type");
 delete [] __ptr;
      }
    };


  template <typename _Tp, typename _Dp = default_delete<_Tp> >
    class unique_ptr
    {

      class _Pointer
      {
 template<typename _Up>
   static typename _Up::pointer __test(typename _Up::pointer*);

 template<typename _Up>
   static _Tp* __test(...);

 typedef typename remove_reference<_Dp>::type _Del;

      public:
 typedef decltype(__test<_Del>(0)) type;
      };

      typedef std::tuple<typename _Pointer::type, _Dp> __tuple_type;
      __tuple_type _M_t;

    public:
      typedef typename _Pointer::type pointer;
      typedef _Tp element_type;
      typedef _Dp deleter_type;




      template<typename _Up, typename _Ep>
 using __safe_conversion_up = __and_<
         is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>,
                __not_<is_array<_Up>>,
                __or_<__and_<is_reference<deleter_type>,
                             is_same<deleter_type, _Ep>>,
                      __and_<__not_<is_reference<deleter_type>>,
                             is_convertible<_Ep, deleter_type>>
                >
              >;




      constexpr unique_ptr() noexcept
      : _M_t()
      { static_assert(!is_pointer<deleter_type>::value,
       "constructed with null function pointer deleter"); }







      explicit
      unique_ptr(pointer __p) noexcept
      : _M_t(__p, deleter_type())
      { static_assert(!is_pointer<deleter_type>::value,
       "constructed with null function pointer deleter"); }
#182 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/unique_ptr.h" 3
      unique_ptr(pointer __p,
   typename conditional<is_reference<deleter_type>::value,
     deleter_type, const deleter_type&>::type __d) noexcept
      : _M_t(__p, __d) { }
#194 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/unique_ptr.h" 3
      unique_ptr(pointer __p,
   typename remove_reference<deleter_type>::type&& __d) noexcept
      : _M_t(std::move(__p), std::move(__d))
      { static_assert(!std::is_reference<deleter_type>::value,
        "rvalue deleter bound to reference"); }


      constexpr unique_ptr(nullptr_t) noexcept : unique_ptr() { }




      unique_ptr(unique_ptr&& __u) noexcept
      : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }







      template<typename _Up, typename _Ep, typename = _Require<
               __safe_conversion_up<_Up, _Ep>,
        typename conditional<is_reference<_Dp>::value,
        is_same<_Ep, _Dp>,
        is_convertible<_Ep, _Dp>>::type>>
 unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
 : _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
 { }



      template<typename _Up, typename = _Require<
        is_convertible<_Up*, _Tp*>, is_same<_Dp, default_delete<_Tp>>>>
 unique_ptr(auto_ptr<_Up>&& __u) noexcept;



      ~unique_ptr() noexcept
      {
 auto& __ptr = std::get<0>(_M_t);
 if (__ptr != nullptr)
   get_deleter()(__ptr);
 __ptr = pointer();
      }
#248 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/unique_ptr.h" 3
      unique_ptr&
      operator=(unique_ptr&& __u) noexcept
      {
 reset(__u.release());
 get_deleter() = std::forward<deleter_type>(__u.get_deleter());
 return *this;
      }
#263 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/unique_ptr.h" 3
      template<typename _Up, typename _Ep>
        typename enable_if< __and_<
          __safe_conversion_up<_Up, _Ep>,
          is_assignable<deleter_type&, _Ep&&>
          >::value,
          unique_ptr&>::type
 operator=(unique_ptr<_Up, _Ep>&& __u) noexcept
 {
   reset(__u.release());
   get_deleter() = std::forward<_Ep>(__u.get_deleter());
   return *this;
 }


      unique_ptr&
      operator=(nullptr_t) noexcept
      {
 reset();
 return *this;
      }




      typename add_lvalue_reference<element_type>::type
      operator*() const
      {
 ;
 return *get();
      }


      pointer
      operator->() const noexcept
      {
 ;
 return get();
      }


      pointer
      get() const noexcept
      { return std::get<0>(_M_t); }


      deleter_type&
      get_deleter() noexcept
      { return std::get<1>(_M_t); }


      const deleter_type&
      get_deleter() const noexcept
      { return std::get<1>(_M_t); }


      explicit operator bool() const noexcept
      { return get() == pointer() ? false : true; }




      pointer
      release() noexcept
      {
 pointer __p = get();
 std::get<0>(_M_t) = pointer();
 return __p;
      }







      void
      reset(pointer __p = pointer()) noexcept
      {
 using std::swap;
 swap(std::get<0>(_M_t), __p);
 if (__p != pointer())
   get_deleter()(__p);
      }


      void
      swap(unique_ptr& __u) noexcept
      {
 using std::swap;
 swap(_M_t, __u._M_t);
      }


      unique_ptr(const unique_ptr&) = delete;
      unique_ptr& operator=(const unique_ptr&) = delete;
  };





  template<typename _Tp, typename _Dp>
    class unique_ptr<_Tp[], _Dp>
    {

      class _Pointer
      {
 template<typename _Up>
   static typename _Up::pointer __test(typename _Up::pointer*);

 template<typename _Up>
   static _Tp* __test(...);

 typedef typename remove_reference<_Dp>::type _Del;

      public:
 typedef decltype(__test<_Del>(0)) type;
      };

      typedef std::tuple<typename _Pointer::type, _Dp> __tuple_type;
      __tuple_type _M_t;

      template<typename _Up>
 using __remove_cv = typename remove_cv<_Up>::type;


      template<typename _Up>
 using __is_derived_Tp
   = __and_< is_base_of<_Tp, _Up>,
      __not_<is_same<__remove_cv<_Tp>, __remove_cv<_Up>>> >;


    public:
      typedef typename _Pointer::type pointer;
      typedef _Tp element_type;
      typedef _Dp deleter_type;



      template<typename _Up, typename _Ep,
               typename _Up_up = unique_ptr<_Up, _Ep>,
        typename _Up_element_type = typename _Up_up::element_type>
 using __safe_conversion_up = __and_<
          is_array<_Up>,
          is_same<pointer, element_type*>,
          is_same<typename _Up_up::pointer, _Up_element_type*>,
          is_convertible<_Up_element_type(*)[], element_type(*)[]>,
          __or_<__and_<is_reference<deleter_type>, is_same<deleter_type, _Ep>>,
                __and_<__not_<is_reference<deleter_type>>,
                       is_convertible<_Ep, deleter_type>>>
        >;


      template<typename _Up>
        using __safe_conversion_raw = __and_<
          __or_<__or_<is_same<_Up, pointer>,
                      is_same<_Up, nullptr_t>>,
                __and_<is_pointer<_Up>,
                       is_same<pointer, element_type*>,
                       is_convertible<
                         typename remove_pointer<_Up>::type(*)[],
                         element_type(*)[]>
                >
          >
        >;




      constexpr unique_ptr() noexcept
      : _M_t()
      { static_assert(!std::is_pointer<deleter_type>::value,
        "constructed with null function pointer deleter"); }
#444 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/unique_ptr.h" 3
      template<typename _Up,
               typename = typename enable_if<
                 __safe_conversion_raw<_Up>::value, bool>::type>
      explicit
      unique_ptr(_Up __p) noexcept
      : _M_t(__p, deleter_type())
      { static_assert(!is_pointer<deleter_type>::value,
        "constructed with null function pointer deleter"); }
#461 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/unique_ptr.h" 3
      template<typename _Up,
               typename = typename enable_if<
                 __safe_conversion_raw<_Up>::value, bool>::type>
      unique_ptr(_Up __p,
                 typename conditional<is_reference<deleter_type>::value,
                 deleter_type, const deleter_type&>::type __d) noexcept
      : _M_t(__p, __d) { }
#477 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/unique_ptr.h" 3
      template<typename _Up,
               typename = typename enable_if<
                 __safe_conversion_raw<_Up>::value, bool>::type>
      unique_ptr(_Up __p, typename
   remove_reference<deleter_type>::type&& __d) noexcept
      : _M_t(std::move(__p), std::move(__d))
      { static_assert(!is_reference<deleter_type>::value,
        "rvalue deleter bound to reference"); }


      unique_ptr(unique_ptr&& __u) noexcept
      : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }


      constexpr unique_ptr(nullptr_t) noexcept : unique_ptr() { }

      template<typename _Up, typename _Ep,
        typename = _Require<__safe_conversion_up<_Up, _Ep>>>
 unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
 : _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
 { }


      ~unique_ptr()
      {
 auto& __ptr = std::get<0>(_M_t);
 if (__ptr != nullptr)
   get_deleter()(__ptr);
 __ptr = pointer();
      }
#516 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/unique_ptr.h" 3
      unique_ptr&
      operator=(unique_ptr&& __u) noexcept
      {
 reset(__u.release());
 get_deleter() = std::forward<deleter_type>(__u.get_deleter());
 return *this;
      }
#531 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/unique_ptr.h" 3
      template<typename _Up, typename _Ep>
 typename
 enable_if<__and_<__safe_conversion_up<_Up, _Ep>,
                         is_assignable<deleter_type&, _Ep&&>
                  >::value,
                  unique_ptr&>::type
 operator=(unique_ptr<_Up, _Ep>&& __u) noexcept
 {
   reset(__u.release());
   get_deleter() = std::forward<_Ep>(__u.get_deleter());
   return *this;
 }


      unique_ptr&
      operator=(nullptr_t) noexcept
      {
 reset();
 return *this;
      }




      typename std::add_lvalue_reference<element_type>::type
      operator[](size_t __i) const
      {
 ;
 return get()[__i];
      }


      pointer
      get() const noexcept
      { return std::get<0>(_M_t); }


      deleter_type&
      get_deleter() noexcept
      { return std::get<1>(_M_t); }


      const deleter_type&
      get_deleter() const noexcept
      { return std::get<1>(_M_t); }


      explicit operator bool() const noexcept
      { return get() == pointer() ? false : true; }




      pointer
      release() noexcept
      {
 pointer __p = get();
 std::get<0>(_M_t) = pointer();
 return __p;
      }







      template <typename _Up,
                typename = _Require<
                  __or_<is_same<_Up, pointer>,
                        __and_<is_same<pointer, element_type*>,
                               is_pointer<_Up>,
                               is_convertible<
                                 typename remove_pointer<_Up>::type(*)[],
                                 element_type(*)[]
                               >
                        >
                  >
               >>
      void
      reset(_Up __p) noexcept
      {
 using std::swap;
 swap(std::get<0>(_M_t), __p);
 if (__p != nullptr)
   get_deleter()(__p);
      }

      void reset(nullptr_t = nullptr) noexcept
      {
        reset(pointer());
      }


      void
      swap(unique_ptr& __u) noexcept
      {
 using std::swap;
 swap(_M_t, __u._M_t);
      }


      unique_ptr(const unique_ptr&) = delete;
      unique_ptr& operator=(const unique_ptr&) = delete;
    };

  template<typename _Tp, typename _Dp>
    inline void
    swap(unique_ptr<_Tp, _Dp>& __x,
  unique_ptr<_Tp, _Dp>& __y) noexcept
    { __x.swap(__y); }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator==(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return __x.get() == __y.get(); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator==(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept
    { return !__x; }

  template<typename _Tp, typename _Dp>
    inline bool
    operator==(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept
    { return !__x; }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator!=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return __x.get() != __y.get(); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator!=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept
    { return (bool)__x; }

  template<typename _Tp, typename _Dp>
    inline bool
    operator!=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept
    { return (bool)__x; }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator<(const unique_ptr<_Tp, _Dp>& __x,
       const unique_ptr<_Up, _Ep>& __y)
    {
      typedef typename
 std::common_type<typename unique_ptr<_Tp, _Dp>::pointer,
                  typename unique_ptr<_Up, _Ep>::pointer>::type _CT;
      return std::less<_CT>()(__x.get(), __y.get());
    }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),
         nullptr); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,
         __x.get()); }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator<=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return !(__y < __x); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return !(nullptr < __x); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return !(__x < nullptr); }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator>(const unique_ptr<_Tp, _Dp>& __x,
       const unique_ptr<_Up, _Ep>& __y)
    { return (__y < __x); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,
         __x.get()); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),
         nullptr); }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator>=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return !(__x < __y); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return !(__x < nullptr); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return !(nullptr < __x); }


  template<typename _Tp, typename _Dp>
    struct hash<unique_ptr<_Tp, _Dp>>
    : public __hash_base<size_t, unique_ptr<_Tp, _Dp>>
    {
      size_t
      operator()(const unique_ptr<_Tp, _Dp>& __u) const noexcept
      {
 typedef unique_ptr<_Tp, _Dp> _UP;
 return std::hash<typename _UP::pointer>()(__u.get());
      }
    };





  template<typename _Tp>
    struct _MakeUniq
    { typedef unique_ptr<_Tp> __single_object; };

  template<typename _Tp>
    struct _MakeUniq<_Tp[]>
    { typedef unique_ptr<_Tp[]> __array; };

  template<typename _Tp, size_t _Bound>
    struct _MakeUniq<_Tp[_Bound]>
    { struct __invalid_type { }; };


  template<typename _Tp, typename... _Args>
    inline typename _MakeUniq<_Tp>::__single_object
    make_unique(_Args&&... __args)
    { return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...)); }


  template<typename _Tp>
    inline typename _MakeUniq<_Tp>::__array
    make_unique(size_t __num)
    { return unique_ptr<_Tp>(new remove_extent_t<_Tp>[__num]()); }


  template<typename _Tp, typename... _Args>
    inline typename _MakeUniq<_Tp>::__invalid_type
    make_unique(_Args&&...) = delete;





}
#42 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_conv.h" 2 3

namespace std
{







  template<typename _OutStr, typename _InChar, typename _Codecvt,
    typename _State, typename _Fn>
    bool
    __do_str_codecvt(const _InChar* __first, const _InChar* __last,
       _OutStr& __outstr, const _Codecvt& __cvt, _State& __state,
       size_t& __count, _Fn __fn)
    {
      if (__first == __last)
 {
   __outstr.clear();
   __count = 0;
   return true;
 }

      size_t __outchars = 0;
      auto __next = __first;
      const auto __maxlen = __cvt.max_length() + 1;

      codecvt_base::result __result;
      do
 {
   __outstr.resize(__outstr.size() + (__last - __next) * __maxlen);
   auto __outnext = &__outstr.front() + __outchars;
   auto const __outlast = &__outstr.back() + 1;
   __result = (__cvt.*__fn)(__state, __next, __last, __next,
     __outnext, __outlast, __outnext);
   __outchars = __outnext - &__outstr.front();
 }
      while (__result == codecvt_base::partial && __next != __last
      && (__outstr.size() - __outchars) < __maxlen);

      if (__result == codecvt_base::error)
 return false;

      if (__result == codecvt_base::noconv)
 {
   __outstr.assign(__first, __last);
   __count = __last - __first;
 }
      else
 {
   __outstr.resize(__outchars);
   __count = __next - __first;
 }

      return true;
    }


  template<typename _CharT, typename _Traits, typename _Alloc, typename _State>
    inline bool
    __str_codecvt_in(const char* __first, const char* __last,
       basic_string<_CharT, _Traits, _Alloc>& __outstr,
       const codecvt<_CharT, char, _State>& __cvt,
       _State& __state, size_t& __count)
    {
      using _Codecvt = codecvt<_CharT, char, _State>;
      using _ConvFn
 = codecvt_base::result
   (_Codecvt::*)(_State&, const char*, const char*, const char*&,
   _CharT*, _CharT*, _CharT*&) const;
      _ConvFn __fn = &codecvt<_CharT, char, _State>::in;
      return __do_str_codecvt(__first, __last, __outstr, __cvt, __state,
         __count, __fn);
    }

  template<typename _CharT, typename _Traits, typename _Alloc, typename _State>
    inline bool
    __str_codecvt_in(const char* __first, const char* __last,
       basic_string<_CharT, _Traits, _Alloc>& __outstr,
       const codecvt<_CharT, char, _State>& __cvt)
    {
      _State __state = {};
      size_t __n;
      return __str_codecvt_in(__first, __last, __outstr, __cvt, __state, __n);
    }


  template<typename _CharT, typename _Traits, typename _Alloc, typename _State>
    inline bool
    __str_codecvt_out(const _CharT* __first, const _CharT* __last,
        basic_string<char, _Traits, _Alloc>& __outstr,
        const codecvt<_CharT, char, _State>& __cvt,
        _State& __state, size_t& __count)
    {
      using _Codecvt = codecvt<_CharT, char, _State>;
      using _ConvFn
 = codecvt_base::result
   (_Codecvt::*)(_State&, const _CharT*, const _CharT*, const _CharT*&,
   char*, char*, char*&) const;
      _ConvFn __fn = &codecvt<_CharT, char, _State>::out;
      return __do_str_codecvt(__first, __last, __outstr, __cvt, __state,
         __count, __fn);
    }

  template<typename _CharT, typename _Traits, typename _Alloc, typename _State>
    inline bool
    __str_codecvt_out(const _CharT* __first, const _CharT* __last,
        basic_string<char, _Traits, _Alloc>& __outstr,
        const codecvt<_CharT, char, _State>& __cvt)
    {
      _State __state = {};
      size_t __n;
      return __str_codecvt_out(__first, __last, __outstr, __cvt, __state, __n);
    }



namespace __cxx11 {


  template<typename _Codecvt, typename _Elem = wchar_t,
    typename _Wide_alloc = allocator<_Elem>,
    typename _Byte_alloc = allocator<char>>
    class wstring_convert
    {
    public:
      typedef basic_string<char, char_traits<char>, _Byte_alloc> byte_string;
      typedef basic_string<_Elem, char_traits<_Elem>, _Wide_alloc> wide_string;
      typedef typename _Codecvt::state_type state_type;
      typedef typename wide_string::traits_type::int_type int_type;







      explicit
      wstring_convert(_Codecvt* __pcvt = new _Codecvt()) : _M_cvt(__pcvt)
      {
 if (!_M_cvt)
   __throw_logic_error("wstring_convert");
      }
#195 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_conv.h" 3
      wstring_convert(_Codecvt* __pcvt, state_type __state)
      : _M_cvt(__pcvt), _M_state(__state), _M_with_cvtstate(true)
      {
 if (!_M_cvt)
   __throw_logic_error("wstring_convert");
      }






      explicit
      wstring_convert(const byte_string& __byte_err,
        const wide_string& __wide_err = wide_string())
      : _M_cvt(new _Codecvt),
 _M_byte_err_string(__byte_err), _M_wide_err_string(__wide_err),
 _M_with_strings(true)
      {
 if (!_M_cvt)
   __throw_logic_error("wstring_convert");
      }

      ~wstring_convert() = default;



      wstring_convert(const wstring_convert&) = delete;
      wstring_convert& operator=(const wstring_convert&) = delete;


      wide_string
      from_bytes(char __byte)
      {
 char __bytes[2] = { __byte };
 return from_bytes(__bytes, __bytes+1);
      }

      wide_string
      from_bytes(const char* __ptr)
      { return from_bytes(__ptr, __ptr+char_traits<char>::length(__ptr)); }

      wide_string
      from_bytes(const byte_string& __str)
      {
 auto __ptr = __str.data();
 return from_bytes(__ptr, __ptr + __str.size());
      }

      wide_string
      from_bytes(const char* __first, const char* __last)
      {
 if (!_M_with_cvtstate)
   _M_state = state_type();
 wide_string __out{ _M_wide_err_string.get_allocator() };
 if (__str_codecvt_in(__first, __last, __out, *_M_cvt, _M_state,
        _M_count))
   return __out;
 if (_M_with_strings)
   return _M_wide_err_string;
 __throw_range_error("wstring_convert::from_bytes");
      }



      byte_string
      to_bytes(_Elem __wchar)
      {
 _Elem __wchars[2] = { __wchar };
 return to_bytes(__wchars, __wchars+1);
      }

      byte_string
      to_bytes(const _Elem* __ptr)
      {
 return to_bytes(__ptr, __ptr+wide_string::traits_type::length(__ptr));
      }

      byte_string
      to_bytes(const wide_string& __wstr)
      {
 auto __ptr = __wstr.data();
 return to_bytes(__ptr, __ptr + __wstr.size());
      }

      byte_string
      to_bytes(const _Elem* __first, const _Elem* __last)
      {
 if (!_M_with_cvtstate)
   _M_state = state_type();
 byte_string __out{ _M_byte_err_string.get_allocator() };
 if (__str_codecvt_out(__first, __last, __out, *_M_cvt, _M_state,
         _M_count))
   return __out;
 if (_M_with_strings)
   return _M_byte_err_string;
 __throw_range_error("wstring_convert::to_bytes");
      }





      size_t converted() const noexcept { return _M_count; }


      state_type state() const { return _M_state; }

    private:
      unique_ptr<_Codecvt> _M_cvt;
      byte_string _M_byte_err_string;
      wide_string _M_wide_err_string;
      state_type _M_state = state_type();
      size_t _M_count = 0;
      bool _M_with_cvtstate = false;
      bool _M_with_strings = false;
    };

}


  template<typename _Codecvt, typename _Elem = wchar_t,
    typename _Tr = char_traits<_Elem>>
    class wbuffer_convert : public basic_streambuf<_Elem, _Tr>
    {
      typedef basic_streambuf<_Elem, _Tr> _Wide_streambuf;

    public:
      typedef typename _Codecvt::state_type state_type;
#333 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/locale_conv.h" 3
      explicit
      wbuffer_convert(streambuf* __bytebuf = 0, _Codecvt* __pcvt = new _Codecvt,
        state_type __state = state_type())
      : _M_buf(__bytebuf), _M_cvt(__pcvt), _M_state(__state)
      {
 if (!_M_cvt)
   __throw_logic_error("wbuffer_convert");

 _M_always_noconv = _M_cvt->always_noconv();

 if (_M_buf)
   {
     this->setp(_M_put_area, _M_put_area + _S_buffer_length);
     this->setg(_M_get_area + _S_putback_length,
         _M_get_area + _S_putback_length,
         _M_get_area + _S_putback_length);
   }
      }

      ~wbuffer_convert() = default;



      wbuffer_convert(const wbuffer_convert&) = delete;
      wbuffer_convert& operator=(const wbuffer_convert&) = delete;

      streambuf* rdbuf() const noexcept { return _M_buf; }

      streambuf*
      rdbuf(streambuf *__bytebuf) noexcept
      {
 auto __prev = _M_buf;
 _M_buf = __bytebuf;
 return __prev;
      }


      state_type state() const noexcept { return _M_state; }

    protected:
      int
      sync()
      { return _M_buf && _M_conv_put() && _M_buf->pubsync() ? 0 : -1; }

      typename _Wide_streambuf::int_type
      overflow(typename _Wide_streambuf::int_type __out)
      {
 if (!_M_buf || !_M_conv_put())
   return _Tr::eof();
 else if (!_Tr::eq_int_type(__out, _Tr::eof()))
   return this->sputc(__out);
 return _Tr::not_eof(__out);
      }

      typename _Wide_streambuf::int_type
      underflow()
      {
 if (!_M_buf)
   return _Tr::eof();

 if (this->gptr() < this->egptr() || (_M_buf && _M_conv_get()))
   return _Tr::to_int_type(*this->gptr());
 else
   return _Tr::eof();
      }

      streamsize
      xsputn(const typename _Wide_streambuf::char_type* __s, streamsize __n)
      {
 if (!_M_buf || __n == 0)
   return 0;
 streamsize __done = 0;
 do
 {
   auto __nn = std::min<streamsize>(this->epptr() - this->pptr(),
        __n - __done);
   _Tr::copy(this->pptr(), __s + __done, __nn);
   this->pbump(__nn);
   __done += __nn;
 } while (__done < __n && _M_conv_put());
 return __done;
      }

    private:

      bool
      _M_conv_get()
      {
 const streamsize __pb1 = this->gptr() - this->eback();
 const streamsize __pb2 = _S_putback_length;
 const streamsize __npb = std::min(__pb1, __pb2);

 _Tr::move(_M_get_area + _S_putback_length - __npb,
    this->gptr() - __npb, __npb);

 streamsize __nbytes = sizeof(_M_get_buf) - _M_unconv;
 __nbytes = std::min(__nbytes, _M_buf->in_avail());
 if (__nbytes < 1)
   __nbytes == 1;
 __nbytes = _M_buf->sgetn(_M_get_buf + _M_unconv, __nbytes);
 if (__nbytes < 1)
   return false;
 __nbytes += _M_unconv;



 _Elem* __outbuf = _M_get_area + _S_putback_length;
 _Elem* __outnext = __outbuf;
 const char* __bnext = _M_get_buf;

 codecvt_base::result __result;
 if (_M_always_noconv)
   __result = codecvt_base::noconv;
 else
   {
     _Elem* __outend = _M_get_area + _S_buffer_length;

     __result = _M_cvt->in(_M_state,
      __bnext, __bnext + __nbytes, __bnext,
      __outbuf, __outend, __outnext);
   }

 if (__result == codecvt_base::noconv)
   {

     auto __get_buf = reinterpret_cast<const _Elem*>(_M_get_buf);
     _Tr::copy(__outbuf, __get_buf, __nbytes);
     _M_unconv = 0;
     return true;
   }

 if ((_M_unconv = _M_get_buf + __nbytes - __bnext))
   char_traits<char>::move(_M_get_buf, __bnext, _M_unconv);

 this->setg(__outbuf, __outbuf, __outnext);

 return __result != codecvt_base::error;
      }


      bool
      _M_put(...)
      { return false; }

      bool
      _M_put(const char* __p, streamsize __n)
      {
 if (_M_buf->sputn(__p, __n) < __n)
   return false;
      }


      bool
      _M_conv_put()
      {
 _Elem* const __first = this->pbase();
 const _Elem* const __last = this->pptr();
 const streamsize __pending = __last - __first;

 if (_M_always_noconv)
   return _M_put(__first, __pending);

 char __outbuf[2 * _S_buffer_length];

 const _Elem* __next = __first;
 const _Elem* __start;
 do
   {
     __start = __next;
     char* __outnext = __outbuf;
     char* const __outlast = __outbuf + sizeof(__outbuf);
     auto __result = _M_cvt->out(_M_state, __next, __last, __next,
     __outnext, __outlast, __outnext);
     if (__result == codecvt_base::error)
       return false;
     else if (__result == codecvt_base::noconv)
       return _M_put(__next, __pending);

     if (!_M_put(__outbuf, __outnext - __outbuf))
       return false;
   }
 while (__next != __last && __next != __start);

 if (__next != __last)
   _Tr::move(__first, __next, __last - __next);

 this->pbump(__first - __next);
 return __next != __first;
      }

      streambuf* _M_buf;
      unique_ptr<_Codecvt> _M_cvt;
      state_type _M_state;

      static const streamsize _S_buffer_length = 32;
      static const streamsize _S_putback_length = 3;
      _Elem _M_put_area[_S_buffer_length];
      _Elem _M_get_area[_S_buffer_length];
      streamsize _M_unconv = 0;
      char _M_get_buf[_S_buffer_length-_S_putback_length];
      bool _M_always_noconv;
    };






}
#44 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/locale" 2 3
#44 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/iomanip" 2 3

#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/quoted_string.h" 1 3
#33 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/quoted_string.h" 3

#34 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/bits/quoted_string.h" 3






namespace std
{
  namespace __detail {





    template<typename _String, typename _CharT>
      struct _Quoted_string
      {
 static_assert(is_reference<_String>::value
     || is_pointer<_String>::value,
        "String type must be pointer or reference");

 _Quoted_string(_String __str, _CharT __del, _CharT __esc)
 : _M_string(__str), _M_delim{__del}, _M_escape{__esc}
 { }

 _Quoted_string&
 operator=(_Quoted_string&) = delete;

 _String _M_string;
 _CharT _M_delim;
 _CharT _M_escape;
      };







    template<typename _CharT, typename _Traits>
      std::basic_ostream<_CharT, _Traits>&
      operator<<(std::basic_ostream<_CharT, _Traits>& __os,
   const _Quoted_string<const _CharT*, _CharT>& __str)
      {
 std::basic_ostringstream<_CharT, _Traits> __ostr;
 __ostr << __str._M_delim;
 for (const _CharT* __c = __str._M_string; *__c; ++__c)
   {
     if (*__c == __str._M_delim || *__c == __str._M_escape)
       __ostr << __str._M_escape;
     __ostr << *__c;
   }
 __ostr << __str._M_delim;

 return __os << __ostr.str();
      }







    template<typename _CharT, typename _Traits, typename _String>
      std::basic_ostream<_CharT, _Traits>&
      operator<<(std::basic_ostream<_CharT, _Traits>& __os,
   const _Quoted_string<_String, _CharT>& __str)
      {
 std::basic_ostringstream<_CharT, _Traits> __ostr;
 __ostr << __str._M_delim;
 for (auto& __c : __str._M_string)
   {
     if (__c == __str._M_delim || __c == __str._M_escape)
       __ostr << __str._M_escape;
     __ostr << __c;
   }
 __ostr << __str._M_delim;

 return __os << __ostr.str();
      }





    template<typename _CharT, typename _Traits, typename _Alloc>
      std::basic_istream<_CharT, _Traits>&
      operator>>(std::basic_istream<_CharT, _Traits>& __is,
   const _Quoted_string<basic_string<_CharT, _Traits, _Alloc>&,
          _CharT>& __str)
      {
 _CharT __c;
 __is >> __c;
 if (!__is.good())
   return __is;
 if (__c != __str._M_delim)
   {
     __is.unget();
     __is >> __str._M_string;
     return __is;
   }
 __str._M_string.clear();
 std::ios_base::fmtflags __flags
   = __is.flags(__is.flags() & ~std::ios_base::skipws);
 do
   {
     __is >> __c;
     if (!__is.good())
       break;
     if (__c == __str._M_escape)
       {
  __is >> __c;
  if (!__is.good())
    break;
       }
     else if (__c == __str._M_delim)
       break;
     __str._M_string += __c;
   }
 while (true);
 __is.setf(__flags);

 return __is;
      }


  }
}
#46 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/iomanip" 2 3



namespace std
{





  struct _Resetiosflags { ios_base::fmtflags _M_mask; };
#65 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/iomanip" 3
  inline _Resetiosflags
  resetiosflags(ios_base::fmtflags __mask)
  { return { __mask }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Resetiosflags __f)
    {
      __is.setf(ios_base::fmtflags(0), __f._M_mask);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Resetiosflags __f)
    {
      __os.setf(ios_base::fmtflags(0), __f._M_mask);
      return __os;
    }


  struct _Setiosflags { ios_base::fmtflags _M_mask; };
#95 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/iomanip" 3
  inline _Setiosflags
  setiosflags(ios_base::fmtflags __mask)
  { return { __mask }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setiosflags __f)
    {
      __is.setf(__f._M_mask);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setiosflags __f)
    {
      __os.setf(__f._M_mask);
      return __os;
    }


  struct _Setbase { int _M_base; };
#126 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/iomanip" 3
  inline _Setbase
  setbase(int __base)
  { return { __base }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setbase __f)
    {
      __is.setf(__f._M_base == 8 ? ios_base::oct :
  __f._M_base == 10 ? ios_base::dec :
  __f._M_base == 16 ? ios_base::hex :
  ios_base::fmtflags(0), ios_base::basefield);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setbase __f)
    {
      __os.setf(__f._M_base == 8 ? ios_base::oct :
  __f._M_base == 10 ? ios_base::dec :
  __f._M_base == 16 ? ios_base::hex :
  ios_base::fmtflags(0), ios_base::basefield);
      return __os;
    }


  template<typename _CharT>
    struct _Setfill { _CharT _M_c; };
#163 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/iomanip" 3
  template<typename _CharT>
    inline _Setfill<_CharT>
    setfill(_CharT __c)
    { return { __c }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setfill<_CharT> __f)
    {
      __is.fill(__f._M_c);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setfill<_CharT> __f)
    {
      __os.fill(__f._M_c);
      return __os;
    }


  struct _Setprecision { int _M_n; };
#194 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/iomanip" 3
  inline _Setprecision
  setprecision(int __n)
  { return { __n }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setprecision __f)
    {
      __is.precision(__f._M_n);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setprecision __f)
    {
      __os.precision(__f._M_n);
      return __os;
    }


  struct _Setw { int _M_n; };
#224 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/iomanip" 3
  inline _Setw
  setw(int __n)
  { return { __n }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setw __f)
    {
      __is.width(__f._M_n);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setw __f)
    {
      __os.width(__f._M_n);
      return __os;
    }



  template<typename _MoneyT>
    struct _Get_money { _MoneyT& _M_mon; bool _M_intl; };
#257 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/iomanip" 3
  template<typename _MoneyT>
    inline _Get_money<_MoneyT>
    get_money(_MoneyT& __mon, bool __intl = false)
    { return { __mon, __intl }; }

  template<typename _CharT, typename _Traits, typename _MoneyT>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Get_money<_MoneyT> __f)
    {
      typename basic_istream<_CharT, _Traits>::sentry __cerb(__is, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       typedef istreambuf_iterator<_CharT, _Traits> _Iter;
       typedef money_get<_CharT, _Iter> _MoneyGet;

       const _MoneyGet& __mg = use_facet<_MoneyGet>(__is.getloc());
       __mg.get(_Iter(__is.rdbuf()), _Iter(), __f._M_intl,
         __is, __err, __f._M_mon);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __is._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __is._M_setstate(ios_base::badbit); }
   if (__err)
     __is.setstate(__err);
 }
      return __is;
    }


  template<typename _MoneyT>
    struct _Put_money { const _MoneyT& _M_mon; bool _M_intl; };
#304 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/iomanip" 3
  template<typename _MoneyT>
    inline _Put_money<_MoneyT>
    put_money(const _MoneyT& __mon, bool __intl = false)
    { return { __mon, __intl }; }

  template<typename _CharT, typename _Traits, typename _MoneyT>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Put_money<_MoneyT> __f)
    {
      typename basic_ostream<_CharT, _Traits>::sentry __cerb(__os);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       typedef ostreambuf_iterator<_CharT, _Traits> _Iter;
       typedef money_put<_CharT, _Iter> _MoneyPut;

       const _MoneyPut& __mp = use_facet<_MoneyPut>(__os.getloc());
       if (__mp.put(_Iter(__os.rdbuf()), __f._M_intl, __os,
      __os.fill(), __f._M_mon).failed())
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __os._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __os._M_setstate(ios_base::badbit); }
   if (__err)
     __os.setstate(__err);
 }
      return __os;
    }

  template<typename _CharT>
    struct _Put_time
    {
      const std::tm* _M_tmb;
      const _CharT* _M_fmt;
    };
#356 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/iomanip" 3
  template<typename _CharT>
    inline _Put_time<_CharT>
    put_time(const std::tm* __tmb, const _CharT* __fmt)
    { return { __tmb, __fmt }; }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Put_time<_CharT> __f)
    {
      typename basic_ostream<_CharT, _Traits>::sentry __cerb(__os);
      if (__cerb)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              typedef ostreambuf_iterator<_CharT, _Traits> _Iter;
              typedef time_put<_CharT, _Iter> _TimePut;

              const _CharT* const __fmt_end = __f._M_fmt +
                _Traits::length(__f._M_fmt);

              const _TimePut& __mp = use_facet<_TimePut>(__os.getloc());
              if (__mp.put(_Iter(__os.rdbuf()), __os, __os.fill(),
                           __f._M_tmb, __f._M_fmt, __fmt_end).failed())
                __err |= ios_base::badbit;
            }
          catch(__cxxabiv1::__forced_unwind&)
            {
              __os._M_setstate(ios_base::badbit);
              throw;
            }
          catch(...)
            { __os._M_setstate(ios_base::badbit); }
          if (__err)
            __os.setstate(__err);
        }
      return __os;
    }

  template<typename _CharT>
    struct _Get_time
    {
      std::tm* _M_tmb;
      const _CharT* _M_fmt;
    };
#411 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/iomanip" 3
  template<typename _CharT>
    inline _Get_time<_CharT>
    get_time(std::tm* __tmb, const _CharT* __fmt)
    { return { __tmb, __fmt }; }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Get_time<_CharT> __f)
    {
      typename basic_istream<_CharT, _Traits>::sentry __cerb(__is, false);
      if (__cerb)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              typedef istreambuf_iterator<_CharT, _Traits> _Iter;
              typedef time_get<_CharT, _Iter> _TimeGet;

              const _CharT* const __fmt_end = __f._M_fmt +
                _Traits::length(__f._M_fmt);

              const _TimeGet& __mg = use_facet<_TimeGet>(__is.getloc());
              __mg.get(_Iter(__is.rdbuf()), _Iter(), __is,
                       __err, __f._M_tmb, __f._M_fmt, __fmt_end);
            }
          catch(__cxxabiv1::__forced_unwind&)
            {
              __is._M_setstate(ios_base::badbit);
              throw;
            }
          catch(...)
            { __is._M_setstate(ios_base::badbit); }
          if (__err)
            __is.setstate(__err);
        }
      return __is;
    }
#459 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/iomanip" 3
  template<typename _CharT>
    inline auto
    quoted(const _CharT* __string,
    _CharT __delim = _CharT('"'), _CharT __escape = _CharT('\\'))
    {
      return __detail::_Quoted_string<const _CharT*, _CharT>(__string, __delim,
            __escape);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline auto
    quoted(const basic_string<_CharT, _Traits, _Alloc>& __string,
    _CharT __delim = _CharT('"'), _CharT __escape = _CharT('\\'))
    {
      return __detail::_Quoted_string<
   const basic_string<_CharT, _Traits, _Alloc>&, _CharT>(
    __string, __delim, __escape);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline auto
    quoted(basic_string<_CharT, _Traits, _Alloc>& __string,
    _CharT __delim = _CharT('"'), _CharT __escape = _CharT('\\'))
    {
      return __detail::_Quoted_string<
   basic_string<_CharT, _Traits, _Alloc>&, _CharT>(
    __string, __delim, __escape);
    }
#496 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/iomanip" 3
  extern template ostream& operator<<(ostream&, _Setfill<char>);
  extern template ostream& operator<<(ostream&, _Setiosflags);
  extern template ostream& operator<<(ostream&, _Resetiosflags);
  extern template ostream& operator<<(ostream&, _Setbase);
  extern template ostream& operator<<(ostream&, _Setprecision);
  extern template ostream& operator<<(ostream&, _Setw);
  extern template istream& operator>>(istream&, _Setfill<char>);
  extern template istream& operator>>(istream&, _Setiosflags);
  extern template istream& operator>>(istream&, _Resetiosflags);
  extern template istream& operator>>(istream&, _Setbase);
  extern template istream& operator>>(istream&, _Setprecision);
  extern template istream& operator>>(istream&, _Setw);


  extern template wostream& operator<<(wostream&, _Setfill<wchar_t>);
  extern template wostream& operator<<(wostream&, _Setiosflags);
  extern template wostream& operator<<(wostream&, _Resetiosflags);
  extern template wostream& operator<<(wostream&, _Setbase);
  extern template wostream& operator<<(wostream&, _Setprecision);
  extern template wostream& operator<<(wostream&, _Setw);
  extern template wistream& operator>>(wistream&, _Setfill<wchar_t>);
  extern template wistream& operator>>(wistream&, _Setiosflags);
  extern template wistream& operator>>(wistream&, _Resetiosflags);
  extern template wistream& operator>>(wistream&, _Setbase);
  extern template wistream& operator>>(wistream&, _Setprecision);
  extern template wistream& operator>>(wistream&, _Setw);




}
#120 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 2





#124 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
namespace ap_private_ops {

static inline uint32_t Hi_32(uint64_t Value) {
  return static_cast<uint32_t>(Value >> 32);
}


static inline uint32_t Lo_32(uint64_t Value) {
  return static_cast<uint32_t>(Value);
}

template <int _AP_W>
inline bool isNegative(const ap_private<_AP_W, false>& a) {
  return false;
}

template <int _AP_W>
inline bool isNegative(const ap_private<_AP_W, true>& a) {
  enum {
    APINT_BITS_PER_WORD = 64,
    _AP_N = (_AP_W + APINT_BITS_PER_WORD - 1) / APINT_BITS_PER_WORD
  };
  static const uint64_t sign_mask = 1ULL << ((_AP_W - 1) % APINT_BITS_PER_WORD);
  return (sign_mask & a.get_pVal(_AP_N - 1)) != 0;
}





static inline unsigned CountLeadingZeros_32(uint32_t Value) {
  unsigned Count;



  if (Value == 0) return 32;

  Count = __builtin_clz(Value);
#175 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
  return Count;
}





static inline unsigned CountLeadingZeros_64(uint64_t Value) {
  unsigned Count;



  if (!Value) return 64;

  Count = __builtin_clzll(Value);
#219 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
  return Count;
}





static inline unsigned CountTrailingZeros_64(uint64_t Value) {

  return (Value != 0) ? __builtin_ctzll(Value) : 64;
#237 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
}



static inline unsigned CountPopulation_64(uint64_t Value) {

  return __builtin_popcountll(Value);






}

static inline uint32_t countLeadingOnes_64(uint64_t __V, uint32_t skip) {
  uint32_t Count = 0;
  if (skip) (__V) <<= (skip);
  while (__V && (__V & (1ULL << 63))) {
    Count++;
    (__V) <<= 1;
  }
  return Count;
}

static inline std::string oct2Bin(char oct) {
  switch (oct) {
    case '\0': {
      return "";
    }
    case '.': {
      return ".";
    }
    case '0': {
      return "000";
    }
    case '1': {
      return "001";
    }
    case '2': {
      return "010";
    }
    case '3': {
      return "011";
    }
    case '4': {
      return "100";
    }
    case '5': {
      return "101";
    }
    case '6': {
      return "110";
    }
    case '7': {
      return "111";
    }
  }

#295 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 (void) ((!!(
#295 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
 0 && "Invalid character in digit string"
#295 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 )) || (_assert(
#295 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
 "0 && \"Invalid character in digit string\""
#295 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",295),0))
#295 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                 ;
  return "";
}

static inline std::string hex2Bin(char hex) {
  switch (hex) {
    case '\0': {
      return "";
    }
    case '.': {
      return ".";
    }
    case '0': {
      return "0000";
    }
    case '1': {
      return "0001";
    }
    case '2': {
      return "0010";
    }
    case '3': {
      return "0011";
    }
    case '4': {
      return "0100";
    }
    case '5': {
      return "0101";
    }
    case '6': {
      return "0110";
    }
    case '7': {
      return "0111";
    }
    case '8': {
      return "1000";
    }
    case '9': {
      return "1001";
    }
    case 'A':
    case 'a': {
      return "1010";
    }
    case 'B':
    case 'b': {
      return "1011";
    }
    case 'C':
    case 'c': {
      return "1100";
    }
    case 'D':
    case 'd': {
      return "1101";
    }
    case 'E':
    case 'e': {
      return "1110";
    }
    case 'F':
    case 'f': {
      return "1111";
    }
  }

#362 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 (void) ((!!(
#362 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
 0 && "Invalid character in digit string"
#362 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 )) || (_assert(
#362 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
 "0 && \"Invalid character in digit string\""
#362 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",362),0))
#362 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                 ;
  return "";
}

static inline uint32_t decode_digit(char cdigit, int radix) {
  uint32_t digit = 0;
  if (radix == 16) {




    if (!(((cdigit) >= '0' && (cdigit) <= '9') || ((cdigit) >= 'a' && (cdigit) <= 'f') || ((cdigit) >= 'A' && (cdigit) <= 'F'))) 
#373 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
                          (void) ((!!(
#373 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                          0 && "Invalid hex digit in string"
#373 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
                          )) || (_assert(
#373 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                          "0 && \"Invalid hex digit in string\""
#373 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
                          ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",373),0))
#373 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                                    ;
    if (((cdigit) >= '0' && (cdigit) <= '9'))
      digit = cdigit - '0';
    else if (cdigit >= 'a')
      digit = cdigit - 'a' + 10;
    else if (cdigit >= 'A')
      digit = cdigit - 'A' + 10;
    else

#381 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     (void) ((!!(
#381 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
     0 && "huh? we shouldn't get here"
#381 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     )) || (_assert(
#381 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
     "0 && \"huh? we shouldn't get here\""
#381 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",381),0))
#381 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                              ;
  } else if (((cdigit) >= '0' && (cdigit) <= '9')) {
    digit = cdigit - '0';
  } else {

#385 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#385 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   0 && "Invalid character in digit string"
#385 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#385 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "0 && \"Invalid character in digit string\""
#385 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",385),0))
#385 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                   ;
  }


  return digit;
}


static inline std::string parseString(const std::string& input, unsigned char& radix) {
  size_t len = input.length();
  if (len == 0) {
    if (radix == 0) radix = 10;
    return input;
  }

  size_t startPos = 0;

  while (input[startPos] == ' ' && startPos < len) startPos++;
  while (input[len - 1] == ' ' && startPos < len) len--;

  std::string val = input.substr(startPos, len - startPos);

  len = val.length();
  startPos = 0;



  if (len < 2) {
    if (radix == 0) radix = 10;
    return val;
  }

  bool isNegative = false;
  std::string ans;


  if (val[0] == '-') {
    ans = "-";
    ++startPos;
    isNegative = true;
  } else if (val[0] == '+')
    ++startPos;

  if (len - startPos < 2) {
    if (radix == 0) radix = 10;
    return val;
  }

  if (val.substr(startPos, 2) == "0x" || val.substr(startPos, 2) == "0X") {

    radix = 16;
    startPos += 2;
  } else if (val.substr(startPos, 2) == "0b" ||
             val.substr(startPos, 2) == "0B") {

    radix = 2;
    startPos += 2;
  } else if (val.substr(startPos, 2) == "0o" ||
             val.substr(startPos, 2) == "0O") {

    radix = 8;
    startPos += 2;
  } else if (radix == 0) {
    radix = 10;
  }

  int exp = 0;
  if (radix == 10) {


    size_t expPos = val.find('e');
    bool has_exponent = true;
    if (expPos == std::string::npos) expPos = val.find('E');
    if (expPos == std::string::npos) {

      expPos = len;
      has_exponent = false;
    }


    ans += val.substr(startPos, expPos - startPos);
    if (has_exponent) {

      std::istringstream iss(val.substr(expPos + 1, len - expPos - 1));
      iss >> exp;
    }
  } else {

    size_t expPos = val.find('p');
    bool has_exponent = true;
    if (expPos == std::string::npos) expPos = val.find('P');
    if (expPos == std::string::npos) {

      expPos = len;
      has_exponent = false;
    }




#484 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#484 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   startPos <= expPos
#484 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#484 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "startPos <= expPos"
#484 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",484),0))
#484 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                             ;

    for (size_t i = startPos; i < expPos; ++i) {
      if (radix == 16) {
        ans += hex2Bin(val[i]);
      } else if (radix == 8) {
        ans += oct2Bin(val[i]);
      } else {
        ans += val[i];
      }
    }

    radix = 2;
    if (has_exponent) {

      std::istringstream iss(val.substr(expPos + 1, len - expPos - 1));
      iss >> exp;
    }
  }
  if (exp == 0) return ans;

  size_t decPos = ans.find('.');
  if (decPos == std::string::npos) decPos = ans.length();
  if ((int)decPos + exp >= (int)ans.length()) {
    int i = decPos;
    for (; i < (int)ans.length() - 1; ++i) ans[i] = ans[i + 1];
    for (; i < (int)ans.length(); ++i) ans[i] = '0';
    for (; i < (int)decPos + exp; ++i) ans += '0';
    return ans;
  } else if ((int)decPos + exp < (int)isNegative) {
    std::string dupAns = "0.";
    if (ans[0] == '-') dupAns = "-0.";
    for (int i = 0; i < isNegative - (int)decPos - exp; ++i) dupAns += '0';
    for (size_t i = isNegative; i < ans.length(); ++i)
      if (ans[i] != '.') dupAns += ans[i];
    return dupAns;
  }

  if (exp > 0)
    for (size_t i = decPos; i < decPos + exp; ++i) ans[i] = ans[i + 1];
  else {
    if (decPos == ans.length()) ans += ' ';
    for (int i = decPos; i > (int)decPos + exp; --i) ans[i] = ans[i - 1];
  }
  ans[decPos + exp] = '.';
  return ans;
}







static inline bool sub_1(uint64_t x[], uint32_t len, uint64_t y) {
  for (uint32_t i = 0; i < len; ++i) {
    uint64_t __X = x[i];
    x[i] -= y;
    if (y > __X)
      y = 1;
    else {
      y = 0;
      break;
    }
  }
  return (y != 0);
}





static inline bool add_1(uint64_t dest[], uint64_t x[], uint32_t len,
                         uint64_t y) {
  for (uint32_t i = 0; i < len; ++i) {
    dest[i] = y + x[i];
    if (dest[i] < y)
      y = 1;
    else {
      y = 0;
      break;
    }
  }
  return (y != 0);
}





static inline bool add(uint64_t* dest, const uint64_t* x, const uint64_t* y,
                       uint32_t destlen, uint32_t xlen, uint32_t ylen,
                       bool xsigned, bool ysigned) {
  bool carry = false;
  uint32_t len = AESL_std::min(xlen, ylen);
  uint32_t i;
  for (i = 0; i < len && i < destlen; ++i) {
    uint64_t limit =
        AESL_std::min(x[i], y[i]);
    dest[i] = x[i] + y[i] + carry;
    carry = dest[i] < limit || (carry && dest[i] == limit);
  }
  if (xlen > ylen) {
    const uint64_t yext = ysigned && int64_t(y[ylen - 1]) < 0 ? -1 : 0;
    for (i = ylen; i < xlen && i < destlen; i++) {
      uint64_t limit = AESL_std::min(x[i], yext);
      dest[i] = x[i] + yext + carry;
      carry = (dest[i] < limit) || (carry && dest[i] == limit);
    }
  } else if (ylen > xlen) {
    const uint64_t xext = xsigned && int64_t(x[xlen - 1]) < 0 ? -1 : 0;
    for (i = xlen; i < ylen && i < destlen; i++) {
      uint64_t limit = AESL_std::min(xext, y[i]);
      dest[i] = xext + y[i] + carry;
      carry = (dest[i] < limit) || (carry && dest[i] == limit);
    }
  }
  return carry;
}



static inline bool sub(uint64_t* dest, const uint64_t* x, const uint64_t* y,
                       uint32_t destlen, uint32_t xlen, uint32_t ylen,
                       bool xsigned, bool ysigned) {
  bool borrow = false;
  uint32_t i;
  uint32_t len = AESL_std::min(xlen, ylen);
  for (i = 0; i < len && i < destlen; ++i) {
    uint64_t x_tmp = borrow ? x[i] - 1 : x[i];
    borrow = y[i] > x_tmp || (borrow && x[i] == 0);
    dest[i] = x_tmp - y[i];
  }
  if (xlen > ylen) {
    const uint64_t yext = ysigned && int64_t(y[ylen - 1]) < 0 ? -1 : 0;
    for (i = ylen; i < xlen && i < destlen; i++) {
      uint64_t x_tmp = borrow ? x[i] - 1 : x[i];
      borrow = yext > x_tmp || (borrow && x[i] == 0);
      dest[i] = x_tmp - yext;
    }
  } else if (ylen > xlen) {
    const uint64_t xext = xsigned && int64_t(x[xlen - 1]) < 0 ? -1 : 0;
    for (i = xlen; i < ylen && i < destlen; i++) {
      uint64_t x_tmp = borrow ? xext - 1 : xext;
      borrow = y[i] > x_tmp || (borrow && xext == 0);
      dest[i] = x_tmp - y[i];
    }
  }
  return borrow;
}
#643 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
static inline uint64_t mul_1(uint64_t dest[], const uint64_t x[], uint32_t len,
                             uint64_t y) {

  uint64_t ly = y & 0xffffffffULL, hy = (y) >> 32;
  uint64_t carry = 0;
  static const uint64_t two_power_32 = 1ULL << 32;

  for (uint32_t i = 0; i < len; ++i) {

    uint64_t lx = x[i] & 0xffffffffULL;
    uint64_t hx = (x[i]) >> 32;




    uint8_t hasCarry = 0;
    dest[i] = carry + lx * ly;

    hasCarry = (dest[i] < carry) ? 1 : 0;
    carry = hx * ly + ((dest[i]) >> 32) + (hasCarry ? two_power_32 : 0);


    hasCarry = (!carry && hasCarry) ? 1 : (!carry ? 2 : 0);

    carry += (lx * hy) & 0xffffffffULL;
    dest[i] = ((carry) << 32) | (dest[i] & 0xffffffffULL);
    carry = (((!carry && hasCarry != 2) || hasCarry == 1) ? two_power_32 : 0) +
            ((carry) >> 32) + ((lx * hy) >> 32) + hx * hy;
  }
  return carry;
}







static inline void mul(uint64_t dest[], const uint64_t x[], uint32_t xlen,
                       const uint64_t y[], uint32_t ylen, uint32_t destlen) {

#683 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 (void) ((!!(
#683 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
 xlen > 0
#683 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 )) || (_assert(
#683 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
 "xlen > 0"
#683 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",683),0))
#683 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                 ;

#684 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 (void) ((!!(
#684 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
 ylen > 0
#684 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 )) || (_assert(
#684 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
 "ylen > 0"
#684 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",684),0))
#684 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                 ;

#685 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 (void) ((!!(
#685 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
 destlen >= xlen + ylen
#685 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 )) || (_assert(
#685 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
 "destlen >= xlen + ylen"
#685 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",685),0))
#685 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                               ;
  if (xlen < destlen) dest[xlen] = mul_1(dest, x, xlen, y[0]);
  for (uint32_t i = 1; i < ylen; ++i) {
    uint64_t ly = y[i] & 0xffffffffULL, hy = (y[i]) >> 32;
    uint64_t carry = 0, lx = 0, hx = 0;
    for (uint32_t j = 0; j < xlen; ++j) {
      lx = x[j] & 0xffffffffULL;
      hx = (x[j]) >> 32;




      uint8_t hasCarry = 0;
      uint64_t resul = carry + lx * ly;
      hasCarry = (resul < carry) ? 1 : 0;
      carry = (hasCarry ? (1ULL << 32) : 0) + hx * ly + ((resul) >> 32);
      hasCarry = (!carry && hasCarry) ? 1 : (!carry ? 2 : 0);
      carry += (lx * hy) & 0xffffffffULL;
      resul = ((carry) << 32) | (resul & 0xffffffffULL);
      if (i + j < destlen) dest[i + j] += resul;
      carry =
          (((!carry && hasCarry != 2) || hasCarry == 1) ? (1ULL << 32) : 0) +
          ((carry) >> 32) + (dest[i + j] < resul ? 1 : 0) + ((lx * hy) >> 32) +
          hx * hy;
    }
    if (i + xlen < destlen) dest[i + xlen] = carry;
  }
}





static inline void KnuthDiv(uint32_t* u, uint32_t* v, uint32_t* q, uint32_t* r,
                            uint32_t m, uint32_t n) {

#720 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 (void) ((!!(
#720 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
 u && "Must provide dividend"
#720 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 )) || (_assert(
#720 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
 "u && \"Must provide dividend\""
#720 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",720),0))
#720 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                     ;

#721 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 (void) ((!!(
#721 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
 v && "Must provide divisor"
#721 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 )) || (_assert(
#721 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
 "v && \"Must provide divisor\""
#721 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",721),0))
#721 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                    ;

#722 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 (void) ((!!(
#722 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
 q && "Must provide quotient"
#722 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 )) || (_assert(
#722 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
 "q && \"Must provide quotient\""
#722 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",722),0))
#722 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                     ;

#723 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 (void) ((!!(
#723 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
 u != v && u != q && v != q && "Must us different memory"
#723 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 )) || (_assert(
#723 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
 "u != v && u != q && v != q && \"Must us different memory\""
#723 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",723),0))
#723 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                                 ;

#724 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 (void) ((!!(
#724 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
 n > 1 && "n must be > 1"
#724 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 )) || (_assert(
#724 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
 "n > 1 && \"n must be > 1\""
#724 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",724),0))
#724 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                 ;



  uint64_t b = uint64_t(1) << 32;
#746 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
  uint32_t shift = CountLeadingZeros_32(v[n - 1]);
  uint32_t v_carry = 0;
  uint32_t u_carry = 0;
  if (shift) {
    for (uint32_t i = 0; i < m + n; ++i) {
      uint32_t u_tmp = (u[i]) >> (32 - shift);
      u[i] = ((u[i]) << (shift)) | u_carry;
      u_carry = u_tmp;
    }
    for (uint32_t i = 0; i < n; ++i) {
      uint32_t v_tmp = (v[i]) >> (32 - shift);
      v[i] = ((v[i]) << (shift)) | v_carry;
      v_carry = v_tmp;
    }
  }
  u[m + n] = u_carry;
#771 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
  int j = m;
  do {
#782 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
    uint64_t dividend = ((uint64_t(u[j + n]) << 32) + u[j + n - 1]);

    uint64_t qp = dividend / v[n - 1];
    uint64_t rp = dividend % v[n - 1];
    if (qp == b || qp * v[n - 2] > b * rp + u[j + n - 2]) {
      qp--;
      rp += v[n - 1];
      if (rp < b && (qp == b || qp * v[n - 2] > b * rp + u[j + n - 2])) qp--;
    }






    bool isNeg = false;
    for (uint32_t i = 0; i < n; ++i) {
      uint64_t u_tmp = uint64_t(u[j + i]) | ((uint64_t(u[j + i + 1])) << 32);
      uint64_t subtrahend = uint64_t(qp) * uint64_t(v[i]);
      bool borrow = subtrahend > u_tmp;




      uint64_t result = u_tmp - subtrahend;
      uint32_t k = j + i;
      u[k++] = (uint32_t)(result & (b - 1));
      u[k++] = (uint32_t)((result) >> 32);
      while (borrow && k <= m + n) {
        borrow = u[k] == 0;
        u[k]--;
        k++;
      }
      isNeg |= borrow;


    }
#827 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
    if (isNeg) {
      bool carry = true;
      for (uint32_t i = 0; i <= m + n; ++i) {
        u[i] = ~u[i] + carry;
        carry = carry && u[i] == 0;
      }
    }






    q[j] = (uint32_t)qp;
    if (isNeg) {



      q[j]--;



      bool carry = false;
      for (uint32_t i = 0; i < n; i++) {
        uint32_t limit = AESL_std::min(u[j + i], v[i]);
        u[j + i] += v[i] + carry;
        carry = u[j + i] < limit || (carry && u[j + i] == limit);
      }
      u[j + n] += carry;
    }





  } while (--j >= 0);
#871 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
  if (r) {



    if (shift) {
      uint32_t carry = 0;

      for (int i = n - 1; i >= 0; i--) {
        r[i] = ((u[i]) >> (shift)) | carry;
        carry = (u[i]) << (32 - shift);

      }
    } else {
      for (int i = n - 1; i >= 0; i--) {
        r[i] = u[i];

      }
    }

  }

}

template <int _AP_W, bool _AP_S>
void divide(const ap_private<_AP_W, _AP_S>& LHS, uint32_t lhsWords,
            const ap_private<_AP_W, _AP_S>& RHS, uint32_t rhsWords,
            ap_private<_AP_W, _AP_S>* Quotient,
            ap_private<_AP_W, _AP_S>* Remainder) {

#899 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 (void) ((!!(
#899 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
 lhsWords >= rhsWords && "Fractional result"
#899 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 )) || (_assert(
#899 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
 "lhsWords >= rhsWords && \"Fractional result\""
#899 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",899),0))
#899 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                    ;
  enum { APINT_BITS_PER_WORD = 64 };







  uint64_t mask = ~0ull >> (sizeof(uint32_t) * 8);
  uint32_t n = rhsWords * 2;
  uint32_t m = (lhsWords * 2) - n;



  uint32_t SPACE[128];
  uint32_t* __U = 0;
  uint32_t* __V = 0;
  uint32_t* __Q = 0;
  uint32_t* __R = 0;
  if ((Remainder ? 4 : 3) * n + 2 * m + 1 <= 128) {
    __U = &SPACE[0];
    __V = &SPACE[m + n + 1];
    __Q = &SPACE[(m + n + 1) + n];
    if (Remainder) __R = &SPACE[(m + n + 1) + n + (m + n)];
  } else {
    __U = new uint32_t[m + n + 1];
    __V = new uint32_t[n];
    __Q = new uint32_t[m + n];
    if (Remainder) __R = new uint32_t[n];
  }


  memset(__U, 0, (m + n + 1) * sizeof(uint32_t));
  for (unsigned i = 0; i < lhsWords; ++i) {
    uint64_t tmp = LHS.get_pVal(i);
    __U[i * 2] = (uint32_t)(tmp & mask);
    __U[i * 2 + 1] = (tmp) >> (sizeof(uint32_t) * 8);
  }
  __U[m + n] = 0;


  memset(__V, 0, (n) * sizeof(uint32_t));
  for (unsigned i = 0; i < rhsWords; ++i) {
    uint64_t tmp = RHS.get_pVal(i);
    __V[i * 2] = (uint32_t)(tmp & mask);
    __V[i * 2 + 1] = (tmp) >> (sizeof(uint32_t) * 8);
  }


  memset(__Q, 0, (m + n) * sizeof(uint32_t));
  if (Remainder) memset(__R, 0, n * sizeof(uint32_t));





  for (unsigned i = n; i > 0 && __V[i - 1] == 0; i--) {
    n--;
    m++;
  }
  for (unsigned i = m + n; i > 0 && __U[i - 1] == 0; i--) m--;








#968 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 (void) ((!!(
#968 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
 n != 0 && "Divide by zero?"
#968 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 )) || (_assert(
#968 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
 "n != 0 && \"Divide by zero?\""
#968 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",968),0))
#968 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                    ;
  if (n == 1) {
    uint32_t divisor = __V[0];
    uint32_t remainder = 0;
    for (int i = m + n - 1; i >= 0; i--) {
      uint64_t partial_dividend = (uint64_t(remainder)) << 32 | __U[i];
      if (partial_dividend == 0) {
        __Q[i] = 0;
        remainder = 0;
      } else if (partial_dividend < divisor) {
        __Q[i] = 0;
        remainder = (uint32_t)partial_dividend;
      } else if (partial_dividend == divisor) {
        __Q[i] = 1;
        remainder = 0;
      } else {
        __Q[i] = (uint32_t)(partial_dividend / divisor);
        remainder = (uint32_t)(partial_dividend - (__Q[i] * divisor));
      }
    }
    if (__R) __R[0] = remainder;
  } else {


    KnuthDiv(__U, __V, __Q, __R, m, n);
  }


  if (Quotient) {

    if (Quotient->BitWidth != LHS.BitWidth) {
      if (Quotient->isSingleWord()) Quotient->set_VAL(0);
    } else
      Quotient->clear();



    if (lhsWords == 1) {
      uint64_t tmp =
          uint64_t(__Q[0]) | ((uint64_t(__Q[1])) << (APINT_BITS_PER_WORD / 2));
      Quotient->set_VAL(tmp);
    } else {

#1010 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     (void) ((!!(
#1010 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
     !Quotient->isSingleWord() && "Quotient ap_private not large enough"
#1010 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     )) || (_assert(
#1010 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
     "!Quotient->isSingleWord() && \"Quotient ap_private not large enough\""
#1010 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     ,
                                                   "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
#1010 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
      ,
                                                   1011
#1010 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
      ),0))

#1011 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                   ;
      for (unsigned i = 0; i < lhsWords; ++i)
        Quotient->set_pVal(
            i, uint64_t(__Q[i * 2]) |
                   ((uint64_t(__Q[i * 2 + 1])) << (APINT_BITS_PER_WORD / 2)));
    }
    Quotient->clearUnusedBits();
  }


  if (Remainder) {

    if (Remainder->BitWidth != RHS.BitWidth) {
      if (Remainder->isSingleWord()) Remainder->set_VAL(0);
    } else
      Remainder->clear();



    if (rhsWords == 1) {
      uint64_t tmp =
          uint64_t(__R[0]) | ((uint64_t(__R[1])) << (APINT_BITS_PER_WORD / 2));
      Remainder->set_VAL(tmp);
    } else {

#1035 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     (void) ((!!(
#1035 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
     !Remainder->isSingleWord() && "Remainder ap_private not large enough"
#1035 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     )) || (_assert(
#1035 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
     "!Remainder->isSingleWord() && \"Remainder ap_private not large enough\""
#1035 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     ,
                                                    "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
#1035 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
      ,
                                                    1036
#1035 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
      ),0))

#1036 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                    ;
      for (unsigned i = 0; i < rhsWords; ++i)
        Remainder->set_pVal(
            i, uint64_t(__R[i * 2]) |
                   ((uint64_t(__R[i * 2 + 1])) << (APINT_BITS_PER_WORD / 2)));
    }
    Remainder->clearUnusedBits();
  }


  if (__U != &SPACE[0]) {
    delete[] __U;
    delete[] __V;
    delete[] __Q;
    delete[] __R;
  }
}

template <int _AP_W, bool _AP_S>
void divide(const ap_private<_AP_W, _AP_S>& LHS, uint32_t lhsWords,
            uint64_t RHS, ap_private<_AP_W, _AP_S>* Quotient,
            ap_private<_AP_W, _AP_S>* Remainder) {
  uint32_t rhsWords = 1;

#1059 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 (void) ((!!(
#1059 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
 lhsWords >= rhsWords && "Fractional result"
#1059 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 )) || (_assert(
#1059 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
 "lhsWords >= rhsWords && \"Fractional result\""
#1059 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",1059),0))
#1059 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                    ;
  enum { APINT_BITS_PER_WORD = 64 };







  uint64_t mask = ~0ull >> (sizeof(uint32_t) * 8);
  uint32_t n = 2;
  uint32_t m = (lhsWords * 2) - n;



  uint32_t SPACE[128];
  uint32_t* __U = 0;
  uint32_t* __V = 0;
  uint32_t* __Q = 0;
  uint32_t* __R = 0;
  if ((Remainder ? 4 : 3) * n + 2 * m + 1 <= 128) {
    __U = &SPACE[0];
    __V = &SPACE[m + n + 1];
    __Q = &SPACE[(m + n + 1) + n];
    if (Remainder) __R = &SPACE[(m + n + 1) + n + (m + n)];
  } else {
    __U = new uint32_t[m + n + 1];
    __V = new uint32_t[n];
    __Q = new uint32_t[m + n];
    if (Remainder) __R = new uint32_t[n];
  }


  memset(__U, 0, (m + n + 1) * sizeof(uint32_t));
  for (unsigned i = 0; i < lhsWords; ++i) {
    uint64_t tmp = LHS.get_pVal(i);
    __U[i * 2] = tmp & mask;
    __U[i * 2 + 1] = (tmp) >> (sizeof(uint32_t) * 8);
  }
  __U[m + n] = 0;


  memset(__V, 0, (n) * sizeof(uint32_t));
  __V[0] = RHS & mask;
  __V[1] = (RHS) >> (sizeof(uint32_t) * 8);


  memset(__Q, 0, (m + n) * sizeof(uint32_t));
  if (Remainder) memset(__R, 0, n * sizeof(uint32_t));





  for (unsigned i = n; i > 0 && __V[i - 1] == 0; i--) {
    n--;
    m++;
  }
  for (unsigned i = m + n; i > 0 && __U[i - 1] == 0; i--) m--;








#1125 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 (void) ((!!(
#1125 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
 n != 0 && "Divide by zero?"
#1125 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 )) || (_assert(
#1125 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
 "n != 0 && \"Divide by zero?\""
#1125 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",1125),0))
#1125 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                    ;
  if (n == 1) {
    uint32_t divisor = __V[0];
    uint32_t remainder = 0;
    for (int i = m + n - 1; i >= 0; i--) {
      uint64_t partial_dividend = (uint64_t(remainder)) << 32 | __U[i];
      if (partial_dividend == 0) {
        __Q[i] = 0;
        remainder = 0;
      } else if (partial_dividend < divisor) {
        __Q[i] = 0;
        remainder = partial_dividend;
      } else if (partial_dividend == divisor) {
        __Q[i] = 1;
        remainder = 0;
      } else {
        __Q[i] = partial_dividend / divisor;
        remainder = partial_dividend - (__Q[i] * divisor);
      }
    }
    if (__R) __R[0] = remainder;
  } else {


    KnuthDiv(__U, __V, __Q, __R, m, n);
  }


  if (Quotient) {

    if (Quotient->BitWidth != LHS.BitWidth) {
      if (Quotient->isSingleWord()) Quotient->set_VAL(0);
    } else
      Quotient->clear();



    if (lhsWords == 1) {
      uint64_t tmp =
          uint64_t(__Q[0]) | ((uint64_t(__Q[1])) << (APINT_BITS_PER_WORD / 2));
      Quotient->set_VAL(tmp);
    } else {

#1167 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     (void) ((!!(
#1167 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
     !Quotient->isSingleWord() && "Quotient ap_private not large enough"
#1167 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     )) || (_assert(
#1167 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
     "!Quotient->isSingleWord() && \"Quotient ap_private not large enough\""
#1167 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     ,
                                                   "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
#1167 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
      ,
                                                   1168
#1167 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
      ),0))

#1168 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                   ;
      for (unsigned i = 0; i < lhsWords; ++i)
        Quotient->set_pVal(
            i, uint64_t(__Q[i * 2]) |
                   ((uint64_t(__Q[i * 2 + 1])) << (APINT_BITS_PER_WORD / 2)));
    }
    Quotient->clearUnusedBits();
  }


  if (Remainder) {

    if (Remainder->BitWidth != 64 ) {
      if (Remainder->isSingleWord()) Remainder->set_VAL(0);
    } else
      Remainder->clear();



    if (rhsWords == 1) {
      uint64_t tmp =
          uint64_t(__R[0]) | ((uint64_t(__R[1])) << (APINT_BITS_PER_WORD / 2));
      Remainder->set_VAL(tmp);
    } else {

#1192 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     (void) ((!!(
#1192 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
     !Remainder->isSingleWord() && "Remainder ap_private not large enough"
#1192 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     )) || (_assert(
#1192 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
     "!Remainder->isSingleWord() && \"Remainder ap_private not large enough\""
#1192 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     ,
                                                    "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
#1192 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
      ,
                                                    1193
#1192 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
      ),0))

#1193 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                    ;
      for (unsigned i = 0; i < rhsWords; ++i)
        Remainder->set_pVal(
            i, uint64_t(__R[i * 2]) |
                   ((uint64_t(__R[i * 2 + 1])) << (APINT_BITS_PER_WORD / 2)));
    }
    Remainder->clearUnusedBits();
  }


  if (__U != &SPACE[0]) {
    delete[] __U;
    delete[] __V;
    delete[] __Q;
    delete[] __R;
  }
}


template <int _AP_W, bool _AP_S, bool _AP_C>
inline ap_private<_AP_W, _AP_S, _AP_C> lshr(
    const ap_private<_AP_W, _AP_S, _AP_C>& LHS, uint32_t shiftAmt) {
  return LHS.lshr(shiftAmt);
}



template <int _AP_W, bool _AP_S, bool _AP_C>
inline ap_private<_AP_W, _AP_S, _AP_C> shl(
    const ap_private<_AP_W, _AP_S, _AP_C>& LHS, uint32_t shiftAmt) {
  return LHS.shl(shiftAmt);
}

}





enum {
  MIN_INT_BITS = 1,

  MAX_INT_BITS = (1 << 23) - 1

};
#1280 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
typedef unsigned long long ap_ulong;
typedef signed long long ap_slong;

template <int _AP_N8, bool _AP_S>
struct valtype;

template <int _AP_N8>
struct valtype<_AP_N8, false> {
  typedef uint64_t Type;
};

template <int _AP_N8>
struct valtype<_AP_N8, true> {
  typedef int64_t Type;
};

template <>
struct valtype<1, false> {
  typedef unsigned char Type;
};
template <>
struct valtype<2, false> {
  typedef unsigned short Type;
};
template <>
struct valtype<3, false> {
  typedef unsigned int Type;
};
template <>
struct valtype<4, false> {
  typedef unsigned int Type;
};
template <>
struct valtype<1, true> {
  typedef signed char Type;
};
template <>
struct valtype<2, true> {
  typedef short Type;
};
template <>
struct valtype<3, true> {
  typedef int Type;
};
template <>
struct valtype<4, true> {
  typedef int Type;
};

template <bool enable>
struct ap_private_enable_if {};
template <>
struct ap_private_enable_if<true> {
  static const bool isValid = true;
};


template <int _AP_W, bool _AP_S>
class ap_private<_AP_W, _AP_S, true> {

  const static bool valid = ap_private_enable_if<_AP_W <= 64>::isValid;




 public:
  typedef typename valtype<(_AP_W + 7) / 8, _AP_S>::Type ValType;
  typedef ap_private<_AP_W, _AP_S> Type;
  template <int _AP_W2, bool _AP_S2>
  struct RType {
    enum {
      mult_w = _AP_W + _AP_W2,
      mult_s = _AP_S || _AP_S2,
      plus_w =
          ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))) + 1,
      plus_s = _AP_S || _AP_S2,
      minus_w =
          ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))) + 1,
      minus_s = true,
      div_w = _AP_W + _AP_S2,
      div_s = _AP_S || _AP_S2,
      mod_w = ((_AP_W) < (_AP_W2 + (!_AP_S2 && _AP_S)) ? (_AP_W) : (_AP_W2 + (!_AP_S2 && _AP_S))),
      mod_s = _AP_S,
      logic_w = ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))),
      logic_s = _AP_S || _AP_S2
    };
    typedef ap_private<mult_w, mult_s> mult;
    typedef ap_private<plus_w, plus_s> plus;
    typedef ap_private<minus_w, minus_s> minus;
    typedef ap_private<logic_w, logic_s> logic;
    typedef ap_private<div_w, div_s> div;
    typedef ap_private<mod_w, mod_s> mod;
    typedef ap_private<_AP_W, _AP_S> arg1;
    typedef bool reduce;
  };
  enum { APINT_BITS_PER_WORD = sizeof(uint64_t) * 8 };
  enum {
    excess_bits = (_AP_W % APINT_BITS_PER_WORD)
                      ? APINT_BITS_PER_WORD - (_AP_W % APINT_BITS_PER_WORD)
                      : 0
  };
  static const uint64_t mask = ((uint64_t)~0ULL >> (excess_bits));
  static const uint64_t not_mask = ~mask;
  static const uint64_t sign_bit_mask = 1ULL << (APINT_BITS_PER_WORD - 1);
  template <int _AP_W1>
  struct sign_ext_mask {
    static const uint64_t mask = ~0ULL << _AP_W1;
  };
  static const int width = _AP_W;

  enum {
    BitWidth = _AP_W,
    _AP_N = 1,
  };
  ValType VAL;





  void check_canary() {}
  void set_canary() {}


  inline ValType& get_VAL(void) { return VAL; }
  inline ValType get_VAL(void) const { return VAL; }
  inline ValType get_VAL(void) const volatile { return VAL; }
  inline void set_VAL(uint64_t value) { VAL = (ValType)value; }
  inline ValType& get_pVal(int i) { return VAL; }
  inline ValType get_pVal(int i) const { return VAL; }
  inline const uint64_t* get_pVal() const {

#1411 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#1411 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   0 && "invalid usage"
#1411 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#1411 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "0 && \"invalid usage\""
#1411 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",1411),0))
#1411 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                               ;
    return 0;
  }
  inline ValType get_pVal(int i) const volatile { return VAL; }
  inline uint64_t* get_pVal() const volatile {

#1416 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#1416 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   0 && "invalid usage"
#1416 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#1416 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "0 && \"invalid usage\""
#1416 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",1416),0))
#1416 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                               ;
    return 0;
  }
  inline void set_pVal(int i, uint64_t value) { VAL = (ValType)value; }

  inline uint32_t getBitWidth() const { return BitWidth; }

  template <int _AP_W1, bool _AP_S1>
  ap_private<_AP_W, _AP_S>& operator=(const ap_private<_AP_W1, _AP_S1>& RHS) {
    VAL = (ValType)(RHS.get_VAL());
    clearUnusedBits();
    return *this;
  }

  template <int _AP_W1, bool _AP_S1>
  ap_private<_AP_W, _AP_S>& operator=(
      const volatile ap_private<_AP_W1, _AP_S1>& RHS) {
    VAL = (ValType)(RHS.get_VAL());
    clearUnusedBits();
    return *this;
  }

  void operator=(const ap_private& RHS) volatile {

    VAL = RHS.get_VAL();
  }

  ap_private& operator=(const ap_private& RHS) {

    VAL = RHS.get_VAL();
    return *this;
  }

  void operator=(const volatile ap_private& RHS) volatile {

    VAL = RHS.get_VAL();
  }

  ap_private& operator=(const volatile ap_private& RHS) {

    VAL = RHS.get_VAL();
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_private& operator=(const _private_range_ref<_AP_W2, _AP_S2>& op2) {
    *this = ap_private<_AP_W2, false>(op2);
    return *this;
  }
#1475 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
inline ap_private& operator=(const bool v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }
inline ap_private& operator=(const char v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }
inline ap_private& operator=(const signed char v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }
inline ap_private& operator=(const unsigned char v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }
inline ap_private& operator=(const short v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }
inline ap_private& operator=(const unsigned short v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }
inline ap_private& operator=(const int v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }
inline ap_private& operator=(const unsigned int v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }
inline ap_private& operator=(const long v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }
inline ap_private& operator=(const unsigned long v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }
inline ap_private& operator=(const ap_slong v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }
inline ap_private& operator=(const ap_ulong v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }
inline ap_private& operator=(const half v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }

inline ap_private& operator=(const float v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }
inline ap_private& operator=(const double v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }



  inline ap_private& operator=(const char* s) {
    ap_private tmp(s);
    operator=(tmp);
    return *this;
  }

 private:
  explicit inline ap_private(uint64_t* val) : VAL(val[0]) {
    set_canary();
    clearUnusedBits();
    check_canary();
  }

  inline bool isSingleWord() const { return true; }

 public:
  inline void fromString(const char* strStart, uint32_t slen, uint8_t radix) {
    bool isNeg = strStart[0] == '-';
    if (isNeg) {
      strStart++;
      slen--;
    }

    if (strStart[0] == '0' && (strStart[1] == 'b' || strStart[1] == 'B')) {

      do { if ((radix != 2)) { fprintf(
#1519 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     (&__iob_func()[2])
#1519 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
     , "WARNING: " "%s seems to have base %d, but %d given.", strStart, 2, radix); fprintf(
#1519 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     (&__iob_func()[2])
#1519 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
     , "\n"); } } while (0);
      strStart += 2;
      slen -=2;
    } else if (strStart[0] == '0' && (strStart[1] == 'o' || strStart[1] == 'O')) {

      do { if ((radix != 8)) { fprintf(
#1524 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     (&__iob_func()[2])
#1524 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
     , "WARNING: " "%s seems to have base %d, but %d given.", strStart, 8, radix); fprintf(
#1524 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     (&__iob_func()[2])
#1524 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
     , "\n"); } } while (0);
      strStart += 2;
      slen -=2;
    } else if (strStart[0] == '0' && (strStart[1] == 'x' || strStart[1] == 'X')) {

      do { if ((radix != 16)) { fprintf(
#1529 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     (&__iob_func()[2])
#1529 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
     , "WARNING: " "%s seems to have base %d, but %d given.", strStart, 16, radix); fprintf(
#1529 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     (&__iob_func()[2])
#1529 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
     , "\n"); } } while (0);
      strStart += 2;
      slen -=2;
    } else if (strStart[0] == '0' && (strStart[1] == 'd' || strStart[1] == 'D')) {

      do { if ((radix != 10)) { fprintf(
#1534 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     (&__iob_func()[2])
#1534 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
     , "WARNING: " "%s seems to have base %d, but %d given.", strStart, 10, radix); fprintf(
#1534 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     (&__iob_func()[2])
#1534 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
     , "\n"); } } while (0);
      strStart += 2;
      slen -=2;
    } else if (radix == 0) {

    }



#1542 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#1542 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   (radix == 10 || radix == 8 || radix == 16 || radix == 2) && "Radix should be 2, 8, 10, or 16!"
#1542 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#1542 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "(radix == 10 || radix == 8 || radix == 16 || radix == 2) && \"Radix should be 2, 8, 10, or 16!\""
#1542 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,
                                             "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
#1542 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
    ,
                                             1543
#1542 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
    ),0))

#1543 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                             ;

#1544 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#1544 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   strStart && "String is null?"
#1544 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#1544 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "strStart && \"String is null?\""
#1544 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",1544),0))
#1544 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                        ;


    uint64_t tmpVAL = VAL = 0;

    switch (radix) {
      case 2:


        for (; *strStart; ++strStart) {

#1554 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
         (void) ((!!(
#1554 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
         (*strStart == '0' || *strStart == '1') && ("Wrong binary number")
#1554 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
         )) || (_assert(
#1554 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
         "(*strStart == '0' || *strStart == '1') && (\"Wrong binary number\")"
#1554 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
         ,
                                        "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
#1554 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
          ,
                                        1555
#1554 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
          ),0))

#1555 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                        ;
          tmpVAL <<= 1;
          tmpVAL |= (*strStart - '0');
        }
        break;
      case 8:






        sscanf(strStart, "%llo", &tmpVAL);


        break;
      case 10:






        sscanf(strStart, "%llu", &tmpVAL);


        break;
      case 16:






        sscanf(strStart, "%llx", &tmpVAL);


        break;
      default:

#1594 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
       (void) ((!!(
#1594 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
       true && "Unknown radix"
#1594 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
       )) || (_assert(
#1594 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
       "true && \"Unknown radix\""
#1594 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
       ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",1594),0))
#1594 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                      ;

    }
    VAL = isNeg ? (ValType)(-tmpVAL) : (ValType)(tmpVAL);

    clearUnusedBits();
  }

 private:
  inline ap_private(const std::string& val, uint8_t radix = 2) : VAL(0) {

#1604 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#1604 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   !val.empty() && "String empty?"
#1604 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#1604 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "!val.empty() && \"String empty?\""
#1604 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",1604),0))
#1604 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                          ;
    set_canary();
    fromString(val.c_str(), val.size(), radix);
    check_canary();
  }

  inline ap_private(const char strStart[], uint32_t slen, uint8_t radix)
      : VAL(0) {
    set_canary();
    fromString(strStart, slen, radix);
    check_canary();
  }

  inline ap_private(uint32_t numWords, const uint64_t bigVal[])
      : VAL(bigVal[0]) {
    set_canary();
    clearUnusedBits();
    check_canary();
  }

 public:
  inline ap_private() {
    set_canary();
    clearUnusedBits();
    check_canary();
  }







  inline ap_private(bool v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(char v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(signed char v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(unsigned char v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(short v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(unsigned short v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(int v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(unsigned int v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(long v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(unsigned long v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(ap_slong v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(ap_ulong v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(half v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(float v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(double v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }


  template <int _AP_W1, bool _AP_S1, bool _AP_OPT>
  inline ap_private(const ap_private<_AP_W1, _AP_S1, _AP_OPT>& that)
      : VAL((ValType)that.get_VAL()) {
    set_canary();
    clearUnusedBits();
    check_canary();
  }

  template <int _AP_W1, bool _AP_S1, bool _AP_OPT>
  inline ap_private(const volatile ap_private<_AP_W1, _AP_S1, _AP_OPT>& that)
      : VAL((ValType)that.get_VAL()) {
    set_canary();
    clearUnusedBits();
    check_canary();
  }

  explicit inline ap_private(const char* val) {
    set_canary();
    unsigned char radix = 10;
    std::string str = ap_private_ops::parseString(val, radix);
    std::string::size_type pos = str.find('.');

    if (pos != std::string::npos) str = str.substr(pos);

    ap_private<_AP_W, _AP_S> ap_private_val(str, radix);
    operator=(ap_private_val);
    check_canary();
  }

  inline ap_private(const char* val, signed char rd) {
    set_canary();
    unsigned char radix = rd;
    std::string str = ap_private_ops::parseString(val, radix);
    std::string::size_type pos = str.find('.');

    if (pos != std::string::npos) str = str.substr(pos);

    ap_private<_AP_W, _AP_S> ap_private_val(str, radix);
    operator=(ap_private_val);
    check_canary();
  }

  inline ~ap_private() { check_canary(); }

  inline bool isNegative() const {
    static const uint64_t sign_mask = 1ULL << (_AP_W - 1);
    return _AP_S && (sign_mask & VAL);
  }

  inline bool isPositive() const { return !isNegative(); }

  inline bool isStrictlyPositive() const { return !isNegative() && VAL != 0; }

  inline bool isAllOnesValue() const { return (mask & VAL) == mask; }

  inline bool operator==(const ap_private<_AP_W, _AP_S>& RHS) const {
    return VAL == RHS.get_VAL();
  }
  inline bool operator==(const ap_private<_AP_W, !_AP_S>& RHS) const {
    return (uint64_t)VAL == (uint64_t)RHS.get_VAL();
  }

  inline bool operator==(uint64_t Val) const { return ((uint64_t)VAL == Val); }
  inline bool operator!=(uint64_t Val) const { return ((uint64_t)VAL != Val); }
  inline bool operator!=(const ap_private<_AP_W, _AP_S>& RHS) const {
    return VAL != RHS.get_VAL();
  }
  inline bool operator!=(const ap_private<_AP_W, !_AP_S>& RHS) const {
    return (uint64_t)VAL != (uint64_t)RHS.get_VAL();
  }


  const ap_private operator++(int) {
    ap_private orig(*this);
    VAL++;
    clearUnusedBits();
    return orig;
  }


  const ap_private operator++() {
    ++VAL;
    clearUnusedBits();
    return *this;
  }


  const ap_private operator--(int) {
    ap_private orig(*this);
    --VAL;
    clearUnusedBits();
    return orig;
  }


  const ap_private operator--() {
    --VAL;
    clearUnusedBits();
    return *this;
  }


  inline ap_private<_AP_W + !_AP_S, true> operator~() const {
    ap_private<_AP_W + !_AP_S, true> Result(*this);
    Result.flip();
    return Result;
  }


  inline typename RType<1, false>::minus operator-() const {
    return ap_private<1, false>(0) - (*this);
  }


  inline bool operator!() const { return !VAL; }

  inline std::string toString(uint8_t radix, bool wantSigned) const;
  inline std::string toStringUnsigned(uint8_t radix = 10) const {
    return toString(radix, false);
  }
  inline std::string toStringSigned(uint8_t radix = 10) const {
    return toString(radix, true);
  }
  inline void clear() { VAL = 0; }
  inline ap_private& clear(uint32_t bitPosition) {
    VAL &= ~(1ULL << (bitPosition));
    clearUnusedBits();
    return *this;
  }

  inline ap_private ashr(uint32_t shiftAmt) const {
    if (_AP_S)
      return ap_private((shiftAmt == BitWidth) ? 0
                                               : ((int64_t)VAL) >> (shiftAmt));
    else
      return ap_private((shiftAmt == BitWidth) ? 0
                                               : ((uint64_t)VAL) >> (shiftAmt));
  }

  inline ap_private lshr(uint32_t shiftAmt) const {
    return ap_private((shiftAmt == BitWidth)
                          ? ap_private(0)
                          : ap_private((VAL & mask) >> (shiftAmt)));
  }

  inline ap_private shl(uint32_t shiftAmt) const




  {
    if (shiftAmt > BitWidth) {
      if (!isNegative())
        return ap_private(0);
      else
        return ap_private(-1);
    }
    if (shiftAmt == BitWidth)
      return ap_private(0);
    else
      return ap_private((VAL) << (shiftAmt));


  }

  inline int64_t getSExtValue() const { return VAL; }


  inline uint64_t getZExtValue() const { return VAL & mask; }

  template <int _AP_W2, bool _AP_S2>
  inline ap_private(const _private_range_ref<_AP_W2, _AP_S2>& ref) {
    set_canary();
    *this = ref.get();
    check_canary();
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_private(const _private_bit_ref<_AP_W2, _AP_S2>& ref) {
    set_canary();
    *this = ((uint64_t)(bool)ref);
    check_canary();
  }
#1863 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
  inline void write(const ap_private<_AP_W, _AP_S>& op2) volatile {
    *this = (op2);
  }



  inline operator ValType() const { return get_VAL(); }

  inline int to_uchar() const { return (unsigned char)get_VAL(); }

  inline int to_char() const { return (signed char)get_VAL(); }

  inline int to_ushort() const { return (unsigned short)get_VAL(); }

  inline int to_short() const { return (short)get_VAL(); }

  inline int to_int() const {

    return (int)get_VAL();
  }

  inline unsigned to_uint() const { return (unsigned)get_VAL(); }

  inline long to_long() const { return (long)get_VAL(); }

  inline unsigned long to_ulong() const { return (unsigned long)get_VAL(); }

  inline ap_slong to_int64() const { return (ap_slong)get_VAL(); }

  inline ap_ulong to_uint64() const { return (ap_ulong)get_VAL(); }

  inline double to_double() const {
    if (isNegative())
      return roundToDouble(true);
    else
      return roundToDouble(false);
  }

  inline unsigned length() const { return _AP_W; }

  inline bool isMinValue() const { return VAL == 0; }
  template <int _AP_W1, bool _AP_S1>
  inline ap_private& operator&=(const ap_private<_AP_W1, _AP_S1>& RHS) {
    VAL = (ValType)(((uint64_t)VAL) & RHS.get_VAL());
    clearUnusedBits();
    return *this;
  }

  template <int _AP_W1, bool _AP_S1>
  inline ap_private& operator|=(const ap_private<_AP_W1, _AP_S1>& RHS) {
    VAL = (ValType)(((uint64_t)VAL) | RHS.get_VAL());
    clearUnusedBits();
    return *this;
  }

  template <int _AP_W1, bool _AP_S1>
  inline ap_private& operator^=(const ap_private<_AP_W1, _AP_S1>& RHS) {
    VAL = (ValType)(((uint64_t)VAL) ^ RHS.get_VAL());
    clearUnusedBits();
    return *this;
  }

  template <int _AP_W1, bool _AP_S1>
  inline ap_private& operator*=(const ap_private<_AP_W1, _AP_S1>& RHS) {
    VAL = (ValType)(((uint64_t)VAL) * RHS.get_VAL());
    clearUnusedBits();
    return *this;
  }

  template <int _AP_W1, bool _AP_S1>
  inline ap_private& operator+=(const ap_private<_AP_W1, _AP_S1>& RHS) {
    VAL = (ValType)(((uint64_t)VAL) + RHS.get_VAL());
    clearUnusedBits();
    return *this;
  }

  template <int _AP_W1, bool _AP_S1>
  inline ap_private& operator-=(const ap_private<_AP_W1, _AP_S1>& RHS) {
    VAL = (ValType)(((uint64_t)VAL) - RHS.get_VAL());
    clearUnusedBits();
    return *this;
  }

  template <int _AP_W1, bool _AP_S1>
  inline typename RType<_AP_W1, _AP_S1>::logic operator&(
      const ap_private<_AP_W1, _AP_S1>& RHS) const {
    if (RType<_AP_W1, _AP_S1>::logic_w <= 64) {
      typename RType<_AP_W1, _AP_S1>::logic Ret(((uint64_t)VAL) &
                                                RHS.get_VAL());
      return Ret;
    } else {
      typename RType<_AP_W1, _AP_S1>::logic Ret = *this;
      return Ret & RHS;
    }
  }

  template <int _AP_W1, bool _AP_S1>
  inline typename RType<_AP_W1, _AP_S1>::logic operator^(
      const ap_private<_AP_W1, _AP_S1>& RHS) const {
    if (RType<_AP_W1, _AP_S1>::logic_w <= 64) {
      typename RType<_AP_W1, _AP_S1>::logic Ret(((uint64_t)VAL) ^
                                                RHS.get_VAL());
      return Ret;
    } else {
      typename RType<_AP_W1, _AP_S1>::logic Ret = *this;
      return Ret ^ RHS;
    }
  }

  template <int _AP_W1, bool _AP_S1>
  inline typename RType<_AP_W1, _AP_S1>::logic operator|(
      const ap_private<_AP_W1, _AP_S1>& RHS) const {
    if (RType<_AP_W1, _AP_S1>::logic_w <= 64) {
      typename RType<_AP_W1, _AP_S1>::logic Ret(((uint64_t)VAL) |
                                                RHS.get_VAL());
      return Ret;
    } else {
      typename RType<_AP_W1, _AP_S1>::logic Ret = *this;
      return Ret | RHS;
    }
  }

  inline ap_private And(const ap_private& RHS) const {
    return ap_private(VAL & RHS.get_VAL());
  }

  inline ap_private Or(const ap_private& RHS) const {
    return ap_private(VAL | RHS.get_VAL());
  }

  inline ap_private Xor(const ap_private& RHS) const {
    return ap_private(VAL ^ RHS.get_VAL());
  }

  template <int _AP_W1, bool _AP_S1>
  inline typename RType<_AP_W1, _AP_S1>::mult operator*(
      const ap_private<_AP_W1, _AP_S1>& RHS) const {
    if (RType<_AP_W1, _AP_S1>::mult_w <= 64) {
      typename RType<_AP_W1, _AP_S1>::mult Result(((uint64_t)VAL) *
                                                  RHS.get_VAL());
      return Result;
    } else {
      typename RType<_AP_W1, _AP_S1>::mult Result(*this);
      Result *= RHS;
      return Result;
    }
  }

  inline ap_private Mul(const ap_private& RHS) const {
    return ap_private(VAL * RHS.get_VAL());
  }

  inline ap_private Add(const ap_private& RHS) const {
    return ap_private(VAL + RHS.get_VAL());
  }

  inline ap_private Sub(const ap_private& RHS) const {
    return ap_private(VAL - RHS.get_VAL());
  }

  inline ap_private& operator&=(uint64_t RHS) {
    VAL &= (ValType)RHS;
    clearUnusedBits();
    return *this;
  }
  inline ap_private& operator|=(uint64_t RHS) {
    VAL |= (ValType)RHS;
    clearUnusedBits();
    return *this;
  }
  inline ap_private& operator^=(uint64_t RHS) {
    VAL ^= (ValType)RHS;
    clearUnusedBits();
    return *this;
  }
  inline ap_private& operator*=(uint64_t RHS) {
    VAL *= (ValType)RHS;
    clearUnusedBits();
    return *this;
  }
  inline ap_private& operator+=(uint64_t RHS) {
    VAL += (ValType)RHS;
    clearUnusedBits();
    return *this;
  }
  inline ap_private& operator-=(uint64_t RHS) {
    VAL -= (ValType)RHS;
    clearUnusedBits();
    return *this;
  }

  inline bool isMinSignedValue() const {
    static const uint64_t min_mask = ~(~0ULL << (_AP_W - 1));
    return BitWidth == 1 ? VAL == 1
                         : (ap_private_ops::isNegative<_AP_W>(*this) &&
                            ((min_mask & VAL) == 0));
  }

  template <int _AP_W1, bool _AP_S1>
  inline typename RType<_AP_W1, _AP_S1>::plus operator+(
      const ap_private<_AP_W1, _AP_S1>& RHS) const {
    if (RType<_AP_W1, _AP_S1>::plus_w <= 64)
      return typename RType<_AP_W1, _AP_S1>::plus(
          RType<_AP_W1, _AP_S1>::plus_s
              ? int64_t(((uint64_t)VAL) + RHS.get_VAL())
              : uint64_t(((uint64_t)VAL) + RHS.get_VAL()));
    typename RType<_AP_W1, _AP_S1>::plus Result = RHS;
    Result += VAL;
    return Result;
  }

  template <int _AP_W1, bool _AP_S1>
  inline typename RType<_AP_W1, _AP_S1>::minus operator-(
      const ap_private<_AP_W1, _AP_S1>& RHS) const {
    if (RType<_AP_W1, _AP_S1>::minus_w <= 64)
      return typename RType<_AP_W1, _AP_S1>::minus(
          int64_t(((uint64_t)VAL) - RHS.get_VAL()));
    typename RType<_AP_W1, _AP_S1>::minus Result = *this;
    Result -= RHS;
    return Result;
  }

  inline uint32_t countPopulation() const {
    return ap_private_ops::CountPopulation_64(VAL);
  }
  inline uint32_t countLeadingZeros() const {
    int remainder = BitWidth % 64;
    int excessBits = (64 - remainder) % 64;
    uint32_t Count = ap_private_ops::CountLeadingZeros_64(VAL);
    if (Count) Count -= excessBits;
    return AESL_std::min(Count, (uint32_t)_AP_W);
  }


  inline ap_private<_AP_W, _AP_S> getHiBits(uint32_t numBits) const {
    ap_private<_AP_W, _AP_S> ret(*this);
    ret = (ret) >> (BitWidth - numBits);
    return ret;
  }


  inline ap_private<_AP_W, _AP_S> getLoBits(uint32_t numBits) const {
    ap_private<_AP_W, _AP_S> ret(((uint64_t)VAL) << (BitWidth - numBits));
    ret = (ret) >> (BitWidth - numBits);
    return ret;


  }

  inline ap_private<_AP_W, _AP_S>& set(uint32_t bitPosition) {
    VAL |= (1ULL << (bitPosition));
    clearUnusedBits();
    return *this;
  }

  inline void set() {
    VAL = (ValType)~0ULL;
    clearUnusedBits();
  }

  template <int _AP_W3>
  inline void set(const ap_private<_AP_W3, false>& val) {
    operator=(ap_private<_AP_W3, _AP_S>(val));
  }

  inline void set(const ap_private& val) { operator=(val); }

  inline void clearUnusedBits(void)




  {
    enum { excess_bits = (_AP_W % 64) ? 64 - _AP_W % 64 : 0 };
    VAL = (ValType)(
        _AP_S
            ? ((((int64_t)VAL) << (excess_bits)) >> (excess_bits))
            : (excess_bits ? (((uint64_t)VAL) << (excess_bits)) >> (excess_bits)
                           : (uint64_t)VAL));
  }

  inline void clearUnusedBitsToZero(void) {
    enum { excess_bits = (_AP_W % 64) ? 64 - _AP_W % 64 : 0 };
    static uint64_t mask = ~0ULL >> (excess_bits);
    VAL &= mask;
  }

  inline ap_private udiv(const ap_private& RHS) const {
    return ap_private((uint64_t)VAL / RHS.get_VAL());
  }



  inline ap_private sdiv(const ap_private& RHS) const {
    if (isNegative())
      if (RHS.isNegative())
        return ((uint64_t)(0 - (*this))) / (uint64_t)(0 - RHS);
      else
        return 0 - ((uint64_t)(0 - (*this)) / (uint64_t)(RHS));
    else if (RHS.isNegative())
      return 0 - (this->udiv((ap_private)(0 - RHS)));
    return this->udiv(RHS);
  }

  template <bool _AP_S2>
  inline ap_private urem(const ap_private<_AP_W, _AP_S2>& RHS) const {

#2169 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#2169 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   RHS.get_VAL() != 0 && "Divide by 0"
#2169 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#2169 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "RHS.get_VAL() != 0 && \"Divide by 0\""
#2169 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",2169),0))
#2169 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                              ;
    return ap_private(((uint64_t)VAL) % ((uint64_t)RHS.get_VAL()));
  }



  template <bool _AP_S2>
  inline ap_private srem(const ap_private<_AP_W, _AP_S2>& RHS) const {
    if (isNegative()) {
      ap_private lhs = 0 - (*this);
      if (RHS.isNegative()) {
        ap_private rhs = 0 - RHS;
        return 0 - (lhs.urem(rhs));
      } else
        return 0 - (lhs.urem(RHS));
    } else if (RHS.isNegative()) {
      ap_private rhs = 0 - RHS;
      return this->urem(rhs);
    }
    return this->urem(RHS);
  }

  template <int _AP_W1, bool _AP_S1>
  inline bool eq(const ap_private<_AP_W1, _AP_S1>& RHS) const {
    return (*this) == RHS;
  }

  template <int _AP_W1, bool _AP_S1>
  inline bool ne(const ap_private<_AP_W1, _AP_S1>& RHS) const {
    return !((*this) == RHS);
  }





  template <int _AP_W1, bool _AP_S1>
  inline bool ult(const ap_private<_AP_W1, _AP_S1>& RHS) const {
    if (_AP_W1 <= 64) {
      uint64_t lhsZext = ((uint64_t(VAL)) << (64 - _AP_W)) >> (64 - _AP_W);
      uint64_t rhsZext =
          ((uint64_t(RHS.get_VAL())) << (64 - _AP_W1)) >> (64 - _AP_W1);
      return lhsZext < rhsZext;
    } else
      return RHS.uge(*this);
  }





  template <int _AP_W1, bool _AP_S1>
  inline bool slt(const ap_private<_AP_W1, _AP_S1>& RHS) const




  {
    if (_AP_W1 <= 64) {
      int64_t lhsSext = ((int64_t(VAL)) << (64 - _AP_W)) >> (64 - _AP_W);
      int64_t rhsSext =
          ((int64_t(RHS.get_VAL())) << (64 - _AP_W1)) >> (64 - _AP_W1);
      return lhsSext < rhsSext;
    } else
      return RHS.sge(*this);
  }





  template <int _AP_W1, bool _AP_S1>
  inline bool ule(const ap_private<_AP_W1, _AP_S1>& RHS) const {
    return ult(RHS) || eq(RHS);
  }





  template <int _AP_W1, bool _AP_S1>
  inline bool sle(const ap_private<_AP_W1, _AP_S1>& RHS) const {
    return slt(RHS) || eq(RHS);
  }





  template <int _AP_W1, bool _AP_S1>
  inline bool ugt(const ap_private<_AP_W1, _AP_S1>& RHS) const {
    return !ult(RHS) && !eq(RHS);
  }





  template <int _AP_W1, bool _AP_S1>
  inline bool sgt(const ap_private<_AP_W1, _AP_S1>& RHS) const {
    return !slt(RHS) && !eq(RHS);
  }





  template <int _AP_W1, bool _AP_S1>
  inline bool uge(const ap_private<_AP_W1, _AP_S1>& RHS) const {
    return !ult(RHS);
  }





  template <int _AP_W1, bool _AP_S1>
  inline bool sge(const ap_private<_AP_W1, _AP_S1>& RHS) const {
    return !slt(RHS);
  }

  inline ap_private abs() const {
    if (isNegative()) return -(*this);
    return *this;
  }

  inline ap_private<_AP_W, false> get() const {
    ap_private<_AP_W, false> ret(*this);
    return ret;
  }

  inline static uint32_t getBitsNeeded(const char* str, uint32_t slen,
                                       uint8_t radix) {
    return _AP_W;
  }

  inline uint32_t getActiveBits() const {
    uint32_t bits = _AP_W - countLeadingZeros();
    return bits ? bits : 1;
  }

  inline double roundToDouble(bool isSigned = false) const {
    return isSigned ? double((int64_t)VAL) : double((uint64_t)VAL);
  }



  inline ap_private& reverse() {
    for (int i = 0; i < _AP_W / 2; ++i) {
      bool tmp = operator[](i);
      if (operator[](_AP_W - 1 - i))
        set(i);
      else
        clear(i);
      if (tmp)
        set(_AP_W - 1 - i);
      else
        clear(_AP_W - 1 - i);
    }
    clearUnusedBits();
    return *this;
  }


  inline bool iszero() const { return isMinValue(); }

  inline bool to_bool() const { return !iszero(); }


  inline bool sign() const {
    if (isNegative()) return true;
    return false;
  }


  inline void invert(int i) {

#2345 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#2345 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   i >= 0 && "Attempting to read bit with negative index"
#2345 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#2345 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "i >= 0 && \"Attempting to read bit with negative index\""
#2345 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",2345),0))
#2345 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                                 ;

#2346 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#2346 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   i < _AP_W && "Attempting to read bit beyond MSB"
#2346 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#2346 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "i < _AP_W && \"Attempting to read bit beyond MSB\""
#2346 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",2346),0))
#2346 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                           ;
    flip(i);
  }


  inline bool test(int i) const {

#2352 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#2352 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   i >= 0 && "Attempting to read bit with negative index"
#2352 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#2352 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "i >= 0 && \"Attempting to read bit with negative index\""
#2352 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",2352),0))
#2352 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                                 ;

#2353 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#2353 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   i < _AP_W && "Attempting to read bit beyond MSB"
#2353 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#2353 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "i < _AP_W && \"Attempting to read bit beyond MSB\""
#2353 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",2353),0))
#2353 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                           ;
    return operator[](i);
  }



  inline void lrotate(int n) {

#2360 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#2360 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   n >= 0 && "Attempting to shift negative index"
#2360 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#2360 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "n >= 0 && \"Attempting to shift negative index\""
#2360 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",2360),0))
#2360 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                         ;

#2361 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#2361 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   n < _AP_W && "Shift value larger than bit width"
#2361 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#2361 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "n < _AP_W && \"Shift value larger than bit width\""
#2361 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",2361),0))
#2361 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                           ;
    operator=(shl(n) | lshr(_AP_W - n));
  }



  inline void rrotate(int n) {

#2368 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#2368 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   n >= 0 && "Attempting to shift negative index"
#2368 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#2368 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "n >= 0 && \"Attempting to shift negative index\""
#2368 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",2368),0))
#2368 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                         ;

#2369 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#2369 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   n < _AP_W && "Shift value larger than bit width"
#2369 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#2369 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "n < _AP_W && \"Shift value larger than bit width\""
#2369 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",2369),0))
#2369 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                           ;
    operator=(lshr(n) | shl(_AP_W - n));
  }


  inline void set(int i, bool v) {

#2375 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#2375 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   i >= 0 && "Attempting to write bit with negative index"
#2375 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#2375 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "i >= 0 && \"Attempting to write bit with negative index\""
#2375 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",2375),0))
#2375 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                                  ;

#2376 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#2376 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   i < _AP_W && "Attempting to write bit beyond MSB"
#2376 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#2376 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "i < _AP_W && \"Attempting to write bit beyond MSB\""
#2376 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",2376),0))
#2376 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                            ;
    v ? set(i) : clear(i);
  }


  inline void set_bit(int i, bool v) {

#2382 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#2382 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   i >= 0 && "Attempting to write bit with negative index"
#2382 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#2382 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "i >= 0 && \"Attempting to write bit with negative index\""
#2382 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",2382),0))
#2382 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                                  ;

#2383 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#2383 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   i < _AP_W && "Attempting to write bit beyond MSB"
#2383 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#2383 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "i < _AP_W && \"Attempting to write bit beyond MSB\""
#2383 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",2383),0))
#2383 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                            ;
    v ? set(i) : clear(i);
  }


  inline bool get_bit(int i) const {

#2389 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#2389 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   i >= 0 && "Attempting to read bit with negative index"
#2389 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#2389 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "i >= 0 && \"Attempting to read bit with negative index\""
#2389 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",2389),0))
#2389 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                                 ;

#2390 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#2390 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   i < _AP_W && "Attempting to read bit beyond MSB"
#2390 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#2390 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "i < _AP_W && \"Attempting to read bit beyond MSB\""
#2390 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",2390),0))
#2390 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                           ;
    return (((1ULL << i) & VAL) != 0);
  }


  inline ap_private& flip() {
    VAL = (ValType)((~0ULL ^ VAL) & mask);
    clearUnusedBits();
    return *this;
  }


  inline ap_private& flip(uint32_t bitPosition) {

#2403 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#2403 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   bitPosition < BitWidth && "Out of the bit-width range!"
#2403 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#2403 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "bitPosition < BitWidth && \"Out of the bit-width range!\""
#2403 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",2403),0))
#2403 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                                  ;
    set_bit(bitPosition, !get_bit(bitPosition));
    return *this;
  }


  inline void b_not() { flip(); }
#2428 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
  template <int _AP_W2, bool _AP_S2>
  inline typename RType<_AP_W2, _AP_S2>::div operator/(
      const ap_private<_AP_W2, _AP_S2>& op) const {
    ap_private<((_AP_W + (_AP_S || _AP_S2)) > (_AP_W2 + (_AP_S || _AP_S2)) ? (_AP_W + (_AP_S || _AP_S2)) : (_AP_W2 + (_AP_S || _AP_S2))),
               (_AP_W > _AP_W2 ? _AP_S
                               : (_AP_W2 > _AP_W ? _AP_S2 : _AP_S || _AP_S2))>
        lhs = *this;
    ap_private<((_AP_W + (_AP_S || _AP_S2)) > (_AP_W2 + (_AP_S || _AP_S2)) ? (_AP_W + (_AP_S || _AP_S2)) : (_AP_W2 + (_AP_S || _AP_S2))),
               (_AP_W > _AP_W2 ? _AP_S
                               : (_AP_W2 > _AP_W ? _AP_S2 : _AP_S || _AP_S2))>
        rhs = op;
    return typename RType<_AP_W2, _AP_S2>::div(
        (_AP_S || _AP_S2) ? lhs.sdiv(rhs) : lhs.udiv(rhs));
  }

  template <int _AP_W2, bool _AP_S2>
  inline typename RType<_AP_W2, _AP_S2>::mod operator%(
      const ap_private<_AP_W2, _AP_S2>& op) const {
    ap_private<((_AP_W + (_AP_S || _AP_S2)) > (_AP_W2 + (_AP_S || _AP_S2)) ? (_AP_W + (_AP_S || _AP_S2)) : (_AP_W2 + (_AP_S || _AP_S2))),
               (_AP_W > _AP_W2 ? _AP_S
                               : (_AP_W2 > _AP_W ? _AP_S2 : _AP_S || _AP_S2))>
        lhs = *this;
    ap_private<((_AP_W + (_AP_S || _AP_S2)) > (_AP_W2 + (_AP_S || _AP_S2)) ? (_AP_W + (_AP_S || _AP_S2)) : (_AP_W2 + (_AP_S || _AP_S2))),
               (_AP_W > _AP_W2 ? _AP_S
                               : (_AP_W2 > _AP_W ? _AP_S2 : _AP_S || _AP_S2))>
        rhs = op;
    typename RType<_AP_W2, _AP_S2>::mod res =
        typename RType<_AP_W2, _AP_S2>::mod(_AP_S ? lhs.srem(rhs)
                                                  : lhs.urem(rhs));
    return res;
  }
#2468 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
  template <int _AP_W2, bool _AP_S2> inline ap_private<_AP_W, _AP_S>& operator /=( const ap_private<_AP_W2, _AP_S2>& op) { *this = operator /(op); return *this; }
  template <int _AP_W2, bool _AP_S2> inline ap_private<_AP_W, _AP_S>& operator %=( const ap_private<_AP_W2, _AP_S2>& op) { *this = operator %(op); return *this; }
#2486 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
  inline ap_private operator<<(const char op) const { if (op >= _AP_W) return ap_private(0); if (CHAR_IS_SIGNED && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const signed char op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const unsigned char op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const short op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const unsigned short op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const int op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const unsigned int op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const long op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const unsigned long op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const long long op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const unsigned long long op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const half op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const float op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const double op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }



  template <int _AP_W2, bool _AP_S2>
  inline ap_private operator<<(const ap_private<_AP_W2, _AP_S2>& op2) const {
    if (_AP_S2 == false) {
      uint32_t sh = op2.to_uint();
      return *this << sh;
    } else {
      int sh = op2.to_int();
      return *this << sh;
    }
  }
#2530 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
  inline ap_private operator>>(const char op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((CHAR_IS_SIGNED) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const signed char op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((true) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const unsigned char op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const short op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((true) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const unsigned short op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const int op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((true) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const unsigned int op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((true) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const unsigned long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const unsigned long long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const long long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((true) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const half op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const float op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const double op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }



  template <int _AP_W2, bool _AP_S2>
  inline ap_private operator>>(const ap_private<_AP_W2, _AP_S2>& op2) const {
    if (_AP_S2 == false) {
      uint32_t sh = op2.to_uint();
      return *this >> sh;
    } else {
      int sh = op2.to_int();
      return *this >> sh;
    }
  }
#2586 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
  template <int _AP_W2, bool _AP_S2> inline ap_private& operator >>=(int op) { *this = operator >>(op); clearUnusedBits(); return *this; } inline ap_private& operator >>=(unsigned int op) { *this = operator >>(op); clearUnusedBits(); return *this; } template <int _AP_W2, bool _AP_S2> inline ap_private& operator >>=(const ap_private<_AP_W2, _AP_S2>& op) { *this = operator >>(op); clearUnusedBits(); return *this; }
  template <int _AP_W2, bool _AP_S2> inline ap_private& operator <<=(int op) { *this = operator <<(op); clearUnusedBits(); return *this; } inline ap_private& operator <<=(unsigned int op) { *this = operator <<(op); clearUnusedBits(); return *this; } template <int _AP_W2, bool _AP_S2> inline ap_private& operator <<=(const ap_private<_AP_W2, _AP_S2>& op) { *this = operator <<(op); clearUnusedBits(); return *this; }




  template <int _AP_W1, bool _AP_S1>
  inline bool operator==(const ap_private<_AP_W1, _AP_S1>& op) const {
    enum { _AP_MAX_W = ((((_AP_W) > (_AP_W1) ? (_AP_W) : (_AP_W1))) > (32) ? (((_AP_W) > (_AP_W1) ? (_AP_W) : (_AP_W1))) : (32)) };
    ap_private<_AP_MAX_W, false> lhs(*this);
    ap_private<_AP_MAX_W, false> rhs(op);
    if (_AP_MAX_W <= 64) {
      return (uint64_t)lhs.get_VAL() == (uint64_t)rhs.get_VAL();
    } else
      return lhs == rhs;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator!=(const ap_private<_AP_W2, _AP_S2>& op) const {
    return !(*this == op);
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator>(const ap_private<_AP_W2, _AP_S2>& op) const {
    enum {
      _AP_MAX_W = ((_AP_W + (_AP_S || _AP_S2)) > (_AP_W2 + (_AP_S || _AP_S2)) ? (_AP_W + (_AP_S || _AP_S2)) : (_AP_W2 + (_AP_S || _AP_S2)))
    };
    ap_private<_AP_MAX_W, _AP_S> lhs(*this);
    ap_private<_AP_MAX_W, _AP_S2> rhs(op);


    if (_AP_S == _AP_S2)
      return _AP_S ? lhs.sgt(rhs) : lhs.ugt(rhs);
    else if (_AP_W < 32 && _AP_W2 < 32)

      return lhs.sgt(rhs);
    else


        if (_AP_S)
      if (_AP_W2 >= _AP_W)
        return lhs.ugt(rhs);
      else
        return lhs.sgt(rhs);
    else if (_AP_W >= _AP_W2)
      return lhs.ugt(rhs);
    else
      return lhs.sgt(rhs);
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator<=(const ap_private<_AP_W2, _AP_S2>& op) const {
    return !(*this > op);
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator<(const ap_private<_AP_W2, _AP_S2>& op) const {
    enum {
      _AP_MAX_W = ((_AP_W + (_AP_S || _AP_S2)) > (_AP_W2 + (_AP_S || _AP_S2)) ? (_AP_W + (_AP_S || _AP_S2)) : (_AP_W2 + (_AP_S || _AP_S2)))
    };
    ap_private<_AP_MAX_W, _AP_S> lhs(*this);
    ap_private<_AP_MAX_W, _AP_S2> rhs(op);
    if (_AP_S == _AP_S2)
      return _AP_S ? lhs.slt(rhs) : lhs.ult(rhs);
    else if (_AP_W < 32 && _AP_W2 < 32)
      return lhs.slt(rhs);
    else if (_AP_S)
      if (_AP_W2 >= _AP_W)
        return lhs.ult(rhs);
      else
        return lhs.slt(rhs);
    else if (_AP_W >= _AP_W2)
      return lhs.ult(rhs);
    else
      return lhs.slt(rhs);
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator>=(const ap_private<_AP_W2, _AP_S2>& op) const {
    return !(*this < op);
  }




  inline _private_range_ref<_AP_W, _AP_S> operator()(int Hi, int Lo) {
    return _private_range_ref<_AP_W, _AP_S>(this, Hi, Lo);
  }

  inline _private_range_ref<_AP_W, _AP_S> operator()(int Hi, int Lo) const {
    return _private_range_ref<_AP_W, _AP_S>(
        const_cast<ap_private<_AP_W, _AP_S>*>(this), Hi, Lo);
  }

  inline _private_range_ref<_AP_W, _AP_S> range(int Hi, int Lo) const {
    return _private_range_ref<_AP_W, _AP_S>(
        (const_cast<ap_private<_AP_W, _AP_S>*>(this)), Hi, Lo);
  }

  inline _private_range_ref<_AP_W, _AP_S> range(int Hi, int Lo) {
    return _private_range_ref<_AP_W, _AP_S>(this, Hi, Lo);
  }

  inline _private_bit_ref<_AP_W, _AP_S> operator[](int index) {
    return _private_bit_ref<_AP_W, _AP_S>(*this, index);
  }

  template <int _AP_W2, bool _AP_S2>
  inline _private_bit_ref<_AP_W, _AP_S> operator[](
      const ap_private<_AP_W2, _AP_S2>& index) {
    return _private_bit_ref<_AP_W, _AP_S>(*this, index.to_int());
  }

  inline const _private_bit_ref<_AP_W, _AP_S> operator[](int index) const {
    return _private_bit_ref<_AP_W, _AP_S>(
        const_cast<ap_private<_AP_W, _AP_S>&>(*this), index);
  }

  template <int _AP_W2, bool _AP_S2>
  inline const _private_bit_ref<_AP_W, _AP_S> operator[](
      const ap_private<_AP_W2, _AP_S2>& index) const {
    return _private_bit_ref<_AP_W, _AP_S>(
        const_cast<ap_private<_AP_W, _AP_S>&>(*this), index.to_int());
  }

  inline _private_bit_ref<_AP_W, _AP_S> bit(int index) {
    return _private_bit_ref<_AP_W, _AP_S>(*this, index);
  }

  template <int _AP_W2, bool _AP_S2>
  inline _private_bit_ref<_AP_W, _AP_S> bit(const ap_private<_AP_W2, _AP_S2>& index) {
    return _private_bit_ref<_AP_W, _AP_S>(*this, index.to_int());
  }

  inline const _private_bit_ref<_AP_W, _AP_S> bit(int index) const {
    return _private_bit_ref<_AP_W, _AP_S>(
        const_cast<ap_private<_AP_W, _AP_S>&>(*this), index);
  }

  template <int _AP_W2, bool _AP_S2>
  inline const _private_bit_ref<_AP_W, _AP_S> bit(
      const ap_private<_AP_W2, _AP_S2>& index) const {
    return _private_bit_ref<_AP_W, _AP_S>(
        const_cast<ap_private<_AP_W, _AP_S>&>(*this), index.to_int());
  }
#2911 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
  inline bool and_reduce() const { return (VAL & mask) == mask; }

  inline bool nand_reduce() const { return (VAL & mask) != mask; }

  inline bool or_reduce() const { return (bool)VAL; }

  inline bool nor_reduce() const { return VAL == 0; }

  inline bool xor_reduce() const {
    unsigned int i = countPopulation();
    return (i % 2) ? true : false;
  }

  inline bool xnor_reduce() const {
    unsigned int i = countPopulation();
    return (i % 2) ? false : true;
  }

  inline std::string to_string(uint8_t radix = 2, bool sign = false) const {
    return toString(radix, radix == 10 ? _AP_S : sign);
  }
};

template <int _AP_W, bool _AP_S>
std::string ap_private<_AP_W, _AP_S, true>::toString(uint8_t radix,
                                                     bool wantSigned) const {

#2937 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 (void) ((!!(
#2937 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
 (radix == 10 || radix == 8 || radix == 16 || radix == 2) && "Radix should be 2, 8, 10, or 16!"
#2937 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 )) || (_assert(
#2937 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
 "(radix == 10 || radix == 8 || radix == 16 || radix == 2) && \"Radix should be 2, 8, 10, or 16!\""
#2937 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 ,
                                           "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
#2937 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
  ,
                                           2938
#2937 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
  ),0))

#2938 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                           ;
  static const char* digits[] = {"0", "1", "2", "3", "4", "5", "6", "7",
                                 "8", "9", "a", "b", "c", "d", "e", "f"};
  std::string result;
  if (radix != 10) {





    if (*this == (uint64_t)(0)) {


      switch (radix) {
        case 2:
          result = "0b0";
          break;
        case 8:
          result = "0o0";
          break;
        case 16:
          result = "0x0";
          break;
        default:

#2962 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
         (void) ((!!(
#2962 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
         "invalid radix" && 0
#2962 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
         )) || (_assert(
#2962 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
         "\"invalid radix\" && 0"
#2962 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
         ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",2962),0))
#2962 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                     ;
      }
    } else {
      ap_private<_AP_W, false, true> tmp(*this);
      size_t insert_at = 0;
      bool leading_zero = true;
      if (wantSigned && isNegative()) {



        tmp.flip();
        tmp++;
        result = "-";
        insert_at = 1;
        leading_zero = false;
      }
      switch (radix) {
        case 2:
          result += "0b";
          break;
        case 8:
          result += "0o";
          break;
        case 16:
          result += "0x";
          break;
        default:

#2989 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
         (void) ((!!(
#2989 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
         "invalid radix" && 0
#2989 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
         )) || (_assert(
#2989 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
         "\"invalid radix\" && 0"
#2989 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
         ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",2989),0))
#2989 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                     ;
      }
      insert_at += 2;


      uint32_t shift = (radix == 16 ? 4 : (radix == 8 ? 3 : 1));
      uint64_t mask = radix - 1;
      ap_private<_AP_W, false, true> zero(0);
      unsigned bits = 0;
      bool msb = false;
      while (tmp.ne(zero)) {
        unsigned digit = (unsigned)(tmp.get_VAL() & mask);
        result.insert(insert_at, digits[digit]);
        tmp = tmp.lshr(shift);
        bits++;
        msb = (digit >> (shift - 1)) == 1;
      }
      bits *= shift;
      if (bits < _AP_W && leading_zero && msb)
        result.insert(insert_at, digits[0]);
    }
    return result;
  }

  ap_private<_AP_W, false, true> tmp(*this);
  ap_private<6, false, true> divisor(radix);
  ap_private<_AP_W, _AP_S, true> zero(0);
  size_t insert_at = 0;
  if (wantSigned && isNegative()) {



    tmp.flip();
    tmp++;
    result = "-";
    insert_at = 1;
  }
  if (tmp == ap_private<_AP_W, false, true>(0ULL))
    result = "0";
  else
    while (tmp.ne(zero)) {
      ap_private<_AP_W, false, true> APdigit = tmp % divisor;
      ap_private<_AP_W, false, true> tmp2 = tmp / divisor;
      uint32_t digit = (uint32_t)(APdigit.getZExtValue());

#3033 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     (void) ((!!(
#3033 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
     digit < radix && "divide failed"
#3033 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     )) || (_assert(
#3033 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
     "digit < radix && \"divide failed\""
#3033 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",3033),0))
#3033 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                             ;
      result.insert(insert_at, digits[digit]);
      tmp = tmp2;
    }
  return result;

}


template <int _AP_W, bool _AP_S>
class ap_private<_AP_W, _AP_S, false> {

  const static bool valid = ap_private_enable_if<(_AP_W > 64)>::isValid;




 public:
  enum { BitWidth = _AP_W, _AP_N = (_AP_W + 63) / 64 };
  static const int width = _AP_W;

 private:
#3065 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
  inline ap_private(uint32_t numWords, const uint64_t bigVal[]) {
    set_canary();

#3067 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#3067 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   bigVal && "Null pointer detected!"
#3067 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#3067 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "bigVal && \"Null pointer detected!\""
#3067 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",3067),0))
#3067 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                             ;
    {

      memset(pVal, 0, _AP_N * sizeof(uint64_t));


      uint32_t words = AESL_std::min<uint32_t>(numWords, _AP_N);

      memcpy(pVal, bigVal, words * APINT_WORD_SIZE);
      if (words >= _AP_W) clearUnusedBits();

    }
    check_canary();
  }
#3090 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
  inline ap_private(const std::string& val, uint8_t radix = 2) {
    set_canary();

#3092 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#3092 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   !val.empty() && "The input string is empty."
#3092 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#3092 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "!val.empty() && \"The input string is empty.\""
#3092 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",3092),0))
#3092 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                       ;
    const char* c_str = val.c_str();
    fromString(c_str, val.size(), radix);
    check_canary();
  }
#3108 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
  inline ap_private(const char strStart[], uint32_t slen, uint8_t radix) {
    set_canary();
    fromString(strStart, slen, radix);
    check_canary();
  }

  inline void report() {
    do { if ((_AP_W > ((1024 + 1023) / 1024) * 1024)) { fprintf(
#3115 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (&__iob_func()[2])
#3115 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   , "ERROR: " "ap_%sint<%d>: Bitwidth exceeds the " "default max value %d. Please use macro " "AP_INT_MAX_W to set a larger max value.", _AP_S ? "" : "u", _AP_W, ((1024 + 1023) / 1024) * 1024); fprintf(
#3115 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (&__iob_func()[2])
#3115 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   , "\n"); abort(); } } while (0)



                                                                     ;
  }





  uint64_t pVal[_AP_N];





  inline void check_canary() {}
  inline void set_canary() {}


 public:
  typedef typename valtype<8, _AP_S>::Type ValType;
  typedef ap_private<_AP_W, _AP_S> Type;

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  friend struct ap_fixed_base;


  template <int _AP_W2, bool _AP_S2>
  struct RType {
    enum {
      mult_w = _AP_W + _AP_W2,
      mult_s = _AP_S || _AP_S2,
      plus_w =
          ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))) + 1,
      plus_s = _AP_S || _AP_S2,
      minus_w =
          ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))) + 1,
      minus_s = true,
      div_w = _AP_W + _AP_S2,
      div_s = _AP_S || _AP_S2,
      mod_w = ((_AP_W) < (_AP_W2 + (!_AP_S2 && _AP_S)) ? (_AP_W) : (_AP_W2 + (!_AP_S2 && _AP_S))),
      mod_s = _AP_S,
      logic_w = ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))),
      logic_s = _AP_S || _AP_S2
    };
    typedef ap_private<mult_w, mult_s> mult;
    typedef ap_private<plus_w, plus_s> plus;
    typedef ap_private<minus_w, minus_s> minus;
    typedef ap_private<logic_w, logic_s> logic;
    typedef ap_private<div_w, div_s> div;
    typedef ap_private<mod_w, mod_s> mod;
    typedef ap_private<_AP_W, _AP_S> arg1;
    typedef bool reduce;
  };

  inline uint64_t& get_VAL(void) { return pVal[0]; }
  inline uint64_t get_VAL(void) const { return pVal[0]; }
  inline uint64_t get_VAL(void) const volatile { return pVal[0]; }
  inline void set_VAL(uint64_t value) { pVal[0] = value; }
  inline uint64_t& get_pVal(int index) { return pVal[index]; }
  inline uint64_t* get_pVal() { return pVal; }
  inline const uint64_t* get_pVal() const { return pVal; }
  inline uint64_t get_pVal(int index) const { return pVal[index]; }
  inline uint64_t* get_pVal() const volatile { return pVal; }
  inline uint64_t get_pVal(int index) const volatile { return pVal[index]; }
  inline void set_pVal(int i, uint64_t value) { pVal[i] = value; }


  enum {
    APINT_BITS_PER_WORD = sizeof(uint64_t) * 8,
    APINT_WORD_SIZE = sizeof(uint64_t)
  };

  enum {
    excess_bits = (_AP_W % APINT_BITS_PER_WORD)
                      ? APINT_BITS_PER_WORD - (_AP_W % APINT_BITS_PER_WORD)
                      : 0
  };
  static const uint64_t mask = ((uint64_t)~0ULL >> (excess_bits));

 public:

  explicit inline ap_private(const char* val) {
    set_canary();
    unsigned char radix = 10;
    std::string str = ap_private_ops::parseString(val, radix);
    std::string::size_type pos = str.find('.');
    if (pos != std::string::npos) str = str.substr(pos);
    ap_private ap_private_val(str, radix);
    operator=(ap_private_val);
    report();
    check_canary();
  }

  inline ap_private(const char* val, unsigned char rd) {
    set_canary();
    unsigned char radix = rd;
    std::string str = ap_private_ops::parseString(val, radix);
    std::string::size_type pos = str.find('.');
    if (pos != std::string::npos) str = str.substr(pos);
    ap_private ap_private_val(str, radix);
    operator=(ap_private_val);
    report();

    report();
    check_canary();
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_private(const _private_range_ref<_AP_W2, _AP_S2>& ref) {
    set_canary();
    *this = ref.get();
    report();
    check_canary();
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_private(const _private_bit_ref<_AP_W2, _AP_S2>& ref) {
    set_canary();
    *this = ((uint64_t)(bool)ref);
    report();
    check_canary();
  }
#3272 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
  inline ap_private(const ap_private& that) {
      set_canary();
      memcpy(pVal, that.get_pVal(), _AP_N * APINT_WORD_SIZE);
      clearUnusedBits();
      check_canary();
  }

  template <int _AP_W1, bool _AP_S1>
  inline ap_private(const ap_private<_AP_W1, _AP_S1, false>& that) {
    set_canary();
    operator=(that);
    check_canary();
  }

  template <int _AP_W1, bool _AP_S1>
  inline ap_private(const volatile ap_private<_AP_W1, _AP_S1, false>& that) {
    set_canary();
    operator=(const_cast<const ap_private<_AP_W1, _AP_S1, false>&>(that));
    check_canary();
  }

  template <int _AP_W1, bool _AP_S1>
  inline ap_private(const ap_private<_AP_W1, _AP_S1, true>& that) {
    set_canary();
    static const uint64_t that_sign_ext_mask =
        (_AP_W1 == APINT_BITS_PER_WORD)
            ? 0
            : ~0ULL >> (_AP_W1 % APINT_BITS_PER_WORD)
                           << (_AP_W1 % APINT_BITS_PER_WORD);
    if (that.isNegative()) {
      pVal[0] = that.get_VAL() | that_sign_ext_mask;
      memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1));
    } else {
      pVal[0] = that.get_VAL();
      memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1));
    }
    clearUnusedBits();
    check_canary();
  }

  template <int _AP_W1, bool _AP_S1>
  inline ap_private(const volatile ap_private<_AP_W1, _AP_S1, true>& that) {
    set_canary();
    operator=(const_cast<const ap_private<_AP_W1, _AP_S1, true>&>(that));
    check_canary();
  }



  inline ~ap_private() { check_canary(); }







  inline ap_private() {
    set_canary();
    clearUnusedBits();
    check_canary();
  }

  inline ap_private(uint64_t* val, uint32_t bits = _AP_W) { 
#3335 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
                                                           (void) ((!!(
#3335 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                           0
#3335 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
                                                           )) || (_assert(
#3335 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                           "0"
#3335 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
                                                           ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",3335),0))
#3335 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                                    ; }
  inline ap_private(const uint64_t* const val, uint32_t bits) { 
#3336 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
                                                               (void) ((!!(
#3336 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                               0
#3336 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
                                                               )) || (_assert(
#3336 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                               "0"
#3336 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
                                                               ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",3336),0))
#3336 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                                        ; }
#3359 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
  inline ap_private(bool val, bool isSigned = false) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(char val, bool isSigned = CHAR_IS_SIGNED) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(signed char val, bool isSigned = true) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(unsigned char val, bool isSigned = false) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(short val, bool isSigned = true) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(unsigned short val, bool isSigned = false) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(int val, bool isSigned = true) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(unsigned int val, bool isSigned = false) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(long val, bool isSigned = true) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(unsigned long val, bool isSigned = false) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(ap_slong val, bool isSigned = true) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(ap_ulong val, bool isSigned = false) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(half val, bool isSigned = false) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(float val, bool isSigned = false) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(double val, bool isSigned = false) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }




  inline bool isSingleWord() const { return false; }



  static inline uint32_t whichWord(uint32_t bitPosition) {

    return (bitPosition) >> 6;
  }




  static inline uint32_t whichBit(uint32_t bitPosition) {

    return bitPosition & 0x3f;
  }





  static inline uint64_t maskBit(uint32_t bitPosition) {
    return 1ULL << (whichBit(bitPosition));
  }



  inline uint64_t getWord(uint32_t bitPosition) const {
    return pVal[whichWord(bitPosition)];
  }






  inline void clearUnusedBits(void)




  {
    pVal[_AP_N - 1] =
        _AP_S ? ((((int64_t)pVal[_AP_N - 1]) << (excess_bits)) >> excess_bits)
              : (excess_bits
                     ? ((pVal[_AP_N - 1]) << (excess_bits)) >> (excess_bits)
                     : pVal[_AP_N - 1]);
  }

  inline void clearUnusedBitsToZero(void) { pVal[_AP_N - 1] &= mask; }

  inline void clearUnusedBitsToOne(void) { pVal[_AP_N - 1] |= mask; }



  inline void fromString(const char* str, uint32_t slen, uint8_t radix) {
    enum { numbits = _AP_W };
    bool isNeg = str[0] == '-';
    if (isNeg) {
      str++;
      slen--;
    }

    if (str[0] == '0' && (str[1] == 'b' || str[1] == 'B')) {

      do { if ((radix != 2)) { fprintf(
#3443 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     (&__iob_func()[2])
#3443 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
     , "WARNING: " "%s seems to have base %d, but %d given.", str, 2, radix); fprintf(
#3443 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     (&__iob_func()[2])
#3443 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
     , "\n"); } } while (0);
      str += 2;
      slen -=2;
    } else if (str[0] == '0' && (str[1] == 'o' || str[1] == 'O')) {

      do { if ((radix != 8)) { fprintf(
#3448 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     (&__iob_func()[2])
#3448 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
     , "WARNING: " "%s seems to have base %d, but %d given.", str, 8, radix); fprintf(
#3448 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     (&__iob_func()[2])
#3448 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
     , "\n"); } } while (0);
      str += 2;
      slen -=2;
    } else if (str[0] == '0' && (str[1] == 'x' || str[1] == 'X')) {

      do { if ((radix != 16)) { fprintf(
#3453 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     (&__iob_func()[2])
#3453 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
     , "WARNING: " "%s seems to have base %d, but %d given.", str, 16, radix); fprintf(
#3453 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     (&__iob_func()[2])
#3453 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
     , "\n"); } } while (0);
      str += 2;
      slen -=2;
    } else if (str[0] == '0' && (str[1] == 'd' || str[1] == 'D')) {

      do { if ((radix != 10)) { fprintf(
#3458 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     (&__iob_func()[2])
#3458 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
     , "WARNING: " "%s seems to have base %d, but %d given.", str, 10, radix); fprintf(
#3458 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     (&__iob_func()[2])
#3458 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
     , "\n"); } } while (0);
      str += 2;
      slen -=2;
    } else if (radix == 0) {

    }



#3466 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#3466 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   (radix == 10 || radix == 8 || radix == 16 || radix == 2) && "Radix should be 2, 8, 10, or 16!"
#3466 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#3466 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "(radix == 10 || radix == 8 || radix == 16 || radix == 2) && \"Radix should be 2, 8, 10, or 16!\""
#3466 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,
                                             "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
#3466 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
    ,
                                             3467
#3466 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
    ),0))

#3467 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                             ;

#3468 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#3468 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   str && "String is null?"
#3468 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#3468 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "str && \"String is null?\""
#3468 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",3468),0))
#3468 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                   ;


    while (*str == '0' && *(str + 1) != '\0') {
      str++;
      slen--;
    }

#3475 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#3475 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   (slen <= numbits || radix != 2) && "Insufficient bit width"
#3475 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#3475 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "(slen <= numbits || radix != 2) && \"Insufficient bit width\""
#3475 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",3475),0))
#3475 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                                      ;

#3476 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#3476 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   ((slen - 1) * 3 <= numbits || radix != 8) && "Insufficient bit width"
#3476 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#3476 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "((slen - 1) * 3 <= numbits || radix != 8) && \"Insufficient bit width\""
#3476 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,
                                   "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
#3476 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
    ,
                                   3477
#3476 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
    ),0))

#3477 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                   ;

#3478 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#3478 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   ((slen - 1) * 4 <= numbits || radix != 16) && "Insufficient bit width"
#3478 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#3478 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "((slen - 1) * 4 <= numbits || radix != 16) && \"Insufficient bit width\""
#3478 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,
                                   "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
#3478 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
    ,
                                   3479
#3478 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
    ),0))

#3479 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                   ;

#3480 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#3480 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   (((slen - 1) * 64) / 22 <= numbits || radix != 10) && "Insufficient bit width"
#3480 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#3480 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "(((slen - 1) * 64) / 22 <= numbits || radix != 10) && \"Insufficient bit width\""
#3480 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,
                                   "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
#3480 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
    ,
                                   3481
#3480 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
    ),0))

#3481 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                   ;


    memset(pVal, 0, _AP_N * sizeof(uint64_t));


    uint32_t shift = (radix == 16 ? 4 : radix == 8 ? 3 : radix == 2 ? 1 : 0);



    uint64_t bigVal[_AP_N];
    memset(bigVal, 0, _AP_N * sizeof(uint64_t));
    ap_private<_AP_W, _AP_S> apdigit(getBitWidth(), bigVal);
    ap_private<_AP_W, _AP_S> apradix(radix);


    for (unsigned i = 0; i < slen; i++) {

      uint32_t digit = 0;
      char cdigit = str[i];
      if (radix == 16) {




        if (!(((cdigit) >= '0' && (cdigit) <= '9') || ((cdigit) >= 'a' && (cdigit) <= 'f') || ((cdigit) >= 'A' && (cdigit) <= 'F'))) 
#3506 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
                              (void) ((!!(
#3506 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                              0 && "Invalid hex digit in string"
#3506 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
                              )) || (_assert(
#3506 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                              "0 && \"Invalid hex digit in string\""
#3506 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
                              ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",3506),0))
#3506 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                                        ;
        if (((cdigit) >= '0' && (cdigit) <= '9'))
          digit = cdigit - '0';
        else if (cdigit >= 'a')
          digit = cdigit - 'a' + 10;
        else if (cdigit >= 'A')
          digit = cdigit - 'A' + 10;
        else

#3514 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
         (void) ((!!(
#3514 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
         0 && "huh? we shouldn't get here"
#3514 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
         )) || (_assert(
#3514 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
         "0 && \"huh? we shouldn't get here\""
#3514 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
         ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",3514),0))
#3514 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                  ;
      } else if (((cdigit) >= '0' && (cdigit) <= '9')) {
        digit = cdigit - '0';
      } else if (cdigit != '\0') {

#3518 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
       (void) ((!!(
#3518 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
       0 && "Invalid character in digit string"
#3518 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
       )) || (_assert(
#3518 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
       "0 && \"Invalid character in digit string\""
#3518 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
       ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",3518),0))
#3518 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                       ;
      }



      if (shift)
        *this <<= shift;
      else
        *this *= apradix;


      apdigit.set_VAL(digit);
      *this += apdigit;
    }

    if (isNeg) {
      (*this)--;
      this->flip();
    }
    clearUnusedBits();
  }

  inline ap_private read() volatile { return *this; }

  inline void write(const ap_private& op2) volatile { *this = (op2); }

  inline operator ValType() const { return get_VAL(); }

  inline int to_uchar() const { return (unsigned char)get_VAL(); }

  inline int to_char() const { return (signed char)get_VAL(); }

  inline int to_ushort() const { return (unsigned short)get_VAL(); }

  inline int to_short() const { return (short)get_VAL(); }

  inline int to_int() const { return (int)get_VAL(); }

  inline unsigned to_uint() const { return (unsigned)get_VAL(); }

  inline long to_long() const { return (long)get_VAL(); }

  inline unsigned long to_ulong() const { return (unsigned long)get_VAL(); }

  inline ap_slong to_int64() const { return (ap_slong)get_VAL(); }

  inline ap_ulong to_uint64() const { return (ap_ulong)get_VAL(); }

  inline double to_double() const {
    if (isNegative())
      return roundToDouble(true);
    else
      return roundToDouble(false);
  }

  inline unsigned length() const { return _AP_W; }



  inline ap_private& reverse() {
    for (int i = 0; i < _AP_W / 2; ++i) {
      bool tmp = operator[](i);
      if (operator[](_AP_W - 1 - i))
        set(i);
      else
        clear(i);
      if (tmp)
        set(_AP_W - 1 - i);
      else
        clear(_AP_W - 1 - i);
    }
    clearUnusedBits();
    return *this;
  }


  inline bool iszero() const { return isMinValue(); }

  inline bool to_bool() const { return !iszero(); }


  inline bool sign() const {
    if (isNegative()) return true;
    return false;
  }


  inline void invert(int i) {

#3606 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#3606 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   i >= 0 && "Attempting to read bit with negative index"
#3606 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#3606 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "i >= 0 && \"Attempting to read bit with negative index\""
#3606 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",3606),0))
#3606 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                                 ;

#3607 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#3607 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   i < _AP_W && "Attempting to read bit beyond MSB"
#3607 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#3607 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "i < _AP_W && \"Attempting to read bit beyond MSB\""
#3607 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",3607),0))
#3607 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                           ;
    flip(i);
  }


  inline bool test(int i) const {

#3613 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#3613 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   i >= 0 && "Attempting to read bit with negative index"
#3613 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#3613 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "i >= 0 && \"Attempting to read bit with negative index\""
#3613 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",3613),0))
#3613 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                                 ;

#3614 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#3614 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   i < _AP_W && "Attempting to read bit beyond MSB"
#3614 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#3614 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "i < _AP_W && \"Attempting to read bit beyond MSB\""
#3614 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",3614),0))
#3614 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                           ;
    return operator[](i);
  }


  inline void set(int i, bool v) {

#3620 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#3620 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   i >= 0 && "Attempting to write bit with negative index"
#3620 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#3620 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "i >= 0 && \"Attempting to write bit with negative index\""
#3620 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",3620),0))
#3620 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                                  ;

#3621 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#3621 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   i < _AP_W && "Attempting to write bit beyond MSB"
#3621 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#3621 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "i < _AP_W && \"Attempting to write bit beyond MSB\""
#3621 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",3621),0))
#3621 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                            ;
    v ? set(i) : clear(i);
  }


  inline void set_bit(int i, bool v) {

#3627 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#3627 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   i >= 0 && "Attempting to write bit with negative index"
#3627 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#3627 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "i >= 0 && \"Attempting to write bit with negative index\""
#3627 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",3627),0))
#3627 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                                  ;

#3628 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#3628 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   i < _AP_W && "Attempting to write bit beyond MSB"
#3628 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#3628 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "i < _AP_W && \"Attempting to write bit beyond MSB\""
#3628 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",3628),0))
#3628 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                            ;
    v ? set(i) : clear(i);
  }


  inline ap_private& set(uint32_t bitPosition) {
    pVal[whichWord(bitPosition)] |= maskBit(bitPosition);
    clearUnusedBits();
    return *this;
  }

  inline void set() {
    for (int i = 0; i < _AP_N; ++i) pVal[i] = ~0ULL;
    clearUnusedBits();
  }


  inline bool get(int i) const {

#3646 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#3646 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   i >= 0 && "Attempting to read bit with negative index"
#3646 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#3646 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "i >= 0 && \"Attempting to read bit with negative index\""
#3646 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",3646),0))
#3646 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                                 ;

#3647 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#3647 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   i < _AP_W && "Attempting to read bit beyond MSB"
#3647 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#3647 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "i < _AP_W && \"Attempting to read bit beyond MSB\""
#3647 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",3647),0))
#3647 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                           ;
    return ((maskBit(i) & (pVal[whichWord(i)])) != 0);
  }


  inline bool get_bit(int i) const {

#3653 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#3653 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   i >= 0 && "Attempting to read bit with negative index"
#3653 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#3653 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "i >= 0 && \"Attempting to read bit with negative index\""
#3653 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",3653),0))
#3653 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                                 ;

#3654 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#3654 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   i < _AP_W && "Attempting to read bit beyond MSB"
#3654 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#3654 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "i < _AP_W && \"Attempting to read bit beyond MSB\""
#3654 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",3654),0))
#3654 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                           ;
    return ((maskBit(i) & (pVal[whichWord(i)])) != 0);
  }



  inline void lrotate(int n) {

#3661 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#3661 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   n >= 0 && "Attempting to shift negative index"
#3661 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#3661 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "n >= 0 && \"Attempting to shift negative index\""
#3661 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",3661),0))
#3661 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                         ;

#3662 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#3662 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   n < _AP_W && "Shift value larger than bit width"
#3662 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#3662 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "n < _AP_W && \"Shift value larger than bit width\""
#3662 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",3662),0))
#3662 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                           ;
    operator=(shl(n) | lshr(_AP_W - n));
  }



  inline void rrotate(int n) {

#3669 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#3669 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   n >= 0 && "Attempting to shift negative index"
#3669 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#3669 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "n >= 0 && \"Attempting to shift negative index\""
#3669 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",3669),0))
#3669 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                         ;

#3670 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#3670 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   n < _AP_W && "Shift value larger than bit width"
#3670 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#3670 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "n < _AP_W && \"Shift value larger than bit width\""
#3670 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",3670),0))
#3670 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                           ;
    operator=(lshr(n) | shl(_AP_W - n));
  }



  inline ap_private& clear(uint32_t bitPosition) {
    pVal[whichWord(bitPosition)] &= ~maskBit(bitPosition);
    clearUnusedBits();
    return *this;
  }


  inline void clear() { memset(pVal, 0, _AP_N * APINT_WORD_SIZE); }


  ap_private& flip() {
    for (int i = 0; i < _AP_N; ++i) pVal[i] ^= ~0ULL;
    clearUnusedBits();
    return *this;
  }


  inline ap_private& flip(uint32_t bitPosition) {

#3694 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#3694 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   bitPosition < BitWidth && "Out of the bit-width range!"
#3694 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#3694 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "bitPosition < BitWidth && \"Out of the bit-width range!\""
#3694 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",3694),0))
#3694 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                                  ;
    set_bit(bitPosition, !get_bit(bitPosition));
    return *this;
  }


  inline void b_not() { flip(); }

  inline ap_private getLoBits(uint32_t numBits) const {
    return ap_private_ops::lshr(ap_private_ops::shl(*this, _AP_W - numBits),
                                _AP_W - numBits);
  }

  inline ap_private getHiBits(uint32_t numBits) const {
    return ap_private_ops::lshr(*this, _AP_W - numBits);
  }
#3753 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
  template <int _AP_W1, bool _AP_S1> inline ap_private& operator &=(const ap_private<_AP_W1, _AP_S1>& RHS) { const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N; uint32_t numWords = AESL_std::min((int)_AP_N, _AP_N1); uint32_t i; if (_AP_W != _AP_W1) fprintf(
#3753 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 (&__iob_func()[2])
#3753 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
 , "Warning! Bitsize mismach for ap_[u]int " "&=" " ap_[u]int.\n"); for (i = 0; i < numWords; ++i) pVal[i] &= RHS.get_pVal(i); if (_AP_N1 < _AP_N) { uint64_t ext = RHS.isNegative() ? ~0ULL : 0; for (; i < _AP_N; i++) pVal[i] &= ext; } clearUnusedBits(); return *this; };
  template <int _AP_W1, bool _AP_S1> inline ap_private& operator |=(const ap_private<_AP_W1, _AP_S1>& RHS) { const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N; uint32_t numWords = AESL_std::min((int)_AP_N, _AP_N1); uint32_t i; if (_AP_W != _AP_W1) fprintf(
#3754 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 (&__iob_func()[2])
#3754 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
 , "Warning! Bitsize mismach for ap_[u]int " "|=" " ap_[u]int.\n"); for (i = 0; i < numWords; ++i) pVal[i] |= RHS.get_pVal(i); if (_AP_N1 < _AP_N) { uint64_t ext = RHS.isNegative() ? ~0ULL : 0; for (; i < _AP_N; i++) pVal[i] |= ext; } clearUnusedBits(); return *this; };
  template <int _AP_W1, bool _AP_S1> inline ap_private& operator ^=(const ap_private<_AP_W1, _AP_S1>& RHS) { const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N; uint32_t numWords = AESL_std::min((int)_AP_N, _AP_N1); uint32_t i; if (_AP_W != _AP_W1) fprintf(
#3755 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 (&__iob_func()[2])
#3755 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
 , "Warning! Bitsize mismach for ap_[u]int " "^=" " ap_[u]int.\n"); for (i = 0; i < numWords; ++i) pVal[i] ^= RHS.get_pVal(i); if (_AP_N1 < _AP_N) { uint64_t ext = RHS.isNegative() ? ~0ULL : 0; for (; i < _AP_N; i++) pVal[i] ^= ext; } clearUnusedBits(); return *this; };





  template <int _AP_W1, bool _AP_S1>
  inline ap_private& operator+=(const ap_private<_AP_W1, _AP_S1>& RHS) {
    const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N;
    uint64_t RHSpVal[_AP_N1];
    for (int i = 0; i < _AP_N1; ++i) RHSpVal[i] = RHS.get_pVal(i);
    ap_private_ops::add(pVal, pVal, RHSpVal, _AP_N, _AP_N, _AP_N1, _AP_S,
                        _AP_S1);
    clearUnusedBits();
    return *this;
  }

  template <int _AP_W1, bool _AP_S1>
  inline ap_private& operator-=(const ap_private<_AP_W1, _AP_S1>& RHS) {
    const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N;
    uint64_t RHSpVal[_AP_N1];
    for (int i = 0; i < _AP_N1; ++i) RHSpVal[i] = RHS.get_pVal(i);
    ap_private_ops::sub(pVal, pVal, RHSpVal, _AP_N, _AP_N, _AP_N1, _AP_S,
                        _AP_S1);
    clearUnusedBits();
    return *this;
  }

  template <int _AP_W1, bool _AP_S1>
  inline ap_private& operator*=(const ap_private<_AP_W1, _AP_S1>& RHS) {

    uint32_t lhsBits = getActiveBits();
    uint32_t lhsWords = !lhsBits ? 0 : whichWord(lhsBits - 1) + 1;
    if (!lhsWords) {

      return *this;
    }

    ap_private dupRHS = RHS;

    uint32_t rhsBits = dupRHS.getActiveBits();
    uint32_t rhsWords = !rhsBits ? 0 : whichWord(rhsBits - 1) + 1;
    if (!rhsWords) {

      clear();
      return *this;
    }


    uint32_t destWords = rhsWords + lhsWords;
    uint64_t* dest = (uint64_t*)malloc(destWords * sizeof(uint64_t));


    ap_private_ops::mul(dest, pVal, lhsWords, dupRHS.get_pVal(), rhsWords,
                        destWords);


    clear();
    uint32_t wordsToCopy = destWords >= _AP_N ? _AP_N : destWords;

    memcpy(pVal, dest, wordsToCopy * APINT_WORD_SIZE);

    uint64_t ext = (isNegative() ^ RHS.isNegative()) ? ~0ULL : 0ULL;
    for (int i = wordsToCopy; i < _AP_N; i++) pVal[i] = ext;
    clearUnusedBits();

    free(dest);
    return *this;
  }
#3832 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
  template <int _AP_W2, bool _AP_S2> inline ap_private& operator /=(const ap_private<_AP_W2, _AP_S2>& op) { *this = operator /(op); return *this; }
  template <int _AP_W2, bool _AP_S2> inline ap_private& operator %=(const ap_private<_AP_W2, _AP_S2>& op) { *this = operator %(op); return *this; }
#3872 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
  template <int _AP_W1, bool _AP_S1> inline typename RType<_AP_W1, _AP_S1>::logic operator |( const ap_private<_AP_W1, _AP_S1>& RHS) const { enum { numWords = (RType<_AP_W1, _AP_S1>::logic_w + APINT_BITS_PER_WORD - 1) / APINT_BITS_PER_WORD }; typename RType<_AP_W1, _AP_S1>::logic Result; uint32_t i; const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N; uint32_t min_N = std::min((int)_AP_N, _AP_N1); uint32_t max_N = std::max((int)_AP_N, _AP_N1); for (i = 0; i < min_N; ++i) Result.set_pVal(i, pVal[i] | RHS.get_pVal(i)); if (numWords > i) { uint64_t ext = ((_AP_N < _AP_N1 && isNegative()) || (_AP_N1 < _AP_N && RHS.isNegative())) ? ~0ULL : 0; if (_AP_N > _AP_N1) for (; i < max_N; i++) Result.set_pVal(i, pVal[i] | ext); else for (; i < max_N; i++) Result.set_pVal(i, RHS.get_pVal(i) | ext); if (numWords > i) { uint64_t ext2 = ((_AP_N > _AP_N1 && isNegative()) || (_AP_N1 > _AP_N && RHS.isNegative())) ? ~0ULL : 0; Result.set_pVal(i, ext | ext2); } } Result.clearUnusedBits(); return Result; };
  template <int _AP_W1, bool _AP_S1> inline typename RType<_AP_W1, _AP_S1>::logic operator &( const ap_private<_AP_W1, _AP_S1>& RHS) const { enum { numWords = (RType<_AP_W1, _AP_S1>::logic_w + APINT_BITS_PER_WORD - 1) / APINT_BITS_PER_WORD }; typename RType<_AP_W1, _AP_S1>::logic Result; uint32_t i; const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N; uint32_t min_N = std::min((int)_AP_N, _AP_N1); uint32_t max_N = std::max((int)_AP_N, _AP_N1); for (i = 0; i < min_N; ++i) Result.set_pVal(i, pVal[i] & RHS.get_pVal(i)); if (numWords > i) { uint64_t ext = ((_AP_N < _AP_N1 && isNegative()) || (_AP_N1 < _AP_N && RHS.isNegative())) ? ~0ULL : 0; if (_AP_N > _AP_N1) for (; i < max_N; i++) Result.set_pVal(i, pVal[i] & ext); else for (; i < max_N; i++) Result.set_pVal(i, RHS.get_pVal(i) & ext); if (numWords > i) { uint64_t ext2 = ((_AP_N > _AP_N1 && isNegative()) || (_AP_N1 > _AP_N && RHS.isNegative())) ? ~0ULL : 0; Result.set_pVal(i, ext & ext2); } } Result.clearUnusedBits(); return Result; };
  template <int _AP_W1, bool _AP_S1> inline typename RType<_AP_W1, _AP_S1>::logic operator ^( const ap_private<_AP_W1, _AP_S1>& RHS) const { enum { numWords = (RType<_AP_W1, _AP_S1>::logic_w + APINT_BITS_PER_WORD - 1) / APINT_BITS_PER_WORD }; typename RType<_AP_W1, _AP_S1>::logic Result; uint32_t i; const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N; uint32_t min_N = std::min((int)_AP_N, _AP_N1); uint32_t max_N = std::max((int)_AP_N, _AP_N1); for (i = 0; i < min_N; ++i) Result.set_pVal(i, pVal[i] ^ RHS.get_pVal(i)); if (numWords > i) { uint64_t ext = ((_AP_N < _AP_N1 && isNegative()) || (_AP_N1 < _AP_N && RHS.isNegative())) ? ~0ULL : 0; if (_AP_N > _AP_N1) for (; i < max_N; i++) Result.set_pVal(i, pVal[i] ^ ext); else for (; i < max_N; i++) Result.set_pVal(i, RHS.get_pVal(i) ^ ext); if (numWords > i) { uint64_t ext2 = ((_AP_N > _AP_N1 && isNegative()) || (_AP_N1 > _AP_N && RHS.isNegative())) ? ~0ULL : 0; Result.set_pVal(i, ext ^ ext2); } } Result.clearUnusedBits(); return Result; };



  template <int _AP_W1, bool _AP_S1>
  inline typename RType<_AP_W1, _AP_S1>::plus operator+(
      const ap_private<_AP_W1, _AP_S1>& RHS) const {
    typename RType<_AP_W1, _AP_S1>::plus Result, lhs(*this), rhs(RHS);
    const int Result_AP_N = (RType<_AP_W1, _AP_S1>::plus_w + 63) / 64;
    ap_private_ops::add(Result.get_pVal(), lhs.get_pVal(), rhs.get_pVal(),
                        Result_AP_N, Result_AP_N, Result_AP_N, _AP_S, _AP_S1);
    Result.clearUnusedBits();
    return Result;
  }

  template <int _AP_W1, bool _AP_S1>
  inline typename RType<_AP_W1, _AP_S1>::minus operator-(
      const ap_private<_AP_W1, _AP_S1>& RHS) const {
    typename RType<_AP_W1, _AP_S1>::minus Result, lhs(*this), rhs(RHS);
    const int Result_AP_N = (RType<_AP_W1, _AP_S1>::minus_w + 63) / 64;
    ap_private_ops::sub(Result.get_pVal(), lhs.get_pVal(), rhs.get_pVal(),
                        Result_AP_N, Result_AP_N, Result_AP_N, _AP_S, _AP_S1);
    Result.clearUnusedBits();
    return Result;
  }

  template <int _AP_W1, bool _AP_S1>
  inline typename RType<_AP_W1, _AP_S1>::mult operator*(
      const ap_private<_AP_W1, _AP_S1>& RHS) const {
    typename RType<_AP_W1, _AP_S1>::mult temp = *this;
    temp *= RHS;
    return temp;
  }

  template <int _AP_W2, bool _AP_S2>
  inline typename RType<_AP_W2, _AP_S2>::div operator/(
      const ap_private<_AP_W2, _AP_S2>& op) const {
    ap_private<((_AP_W + (_AP_S || _AP_S2)) > (_AP_W2 + (_AP_S || _AP_S2)) ? (_AP_W + (_AP_S || _AP_S2)) : (_AP_W2 + (_AP_S || _AP_S2))),
               (_AP_W > _AP_W2 ? _AP_S
                               : (_AP_W2 > _AP_W ? _AP_S2 : _AP_S || _AP_S2))>
        lhs = *this;
    ap_private<((_AP_W + (_AP_S || _AP_S2)) > (_AP_W2 + (_AP_S || _AP_S2)) ? (_AP_W + (_AP_S || _AP_S2)) : (_AP_W2 + (_AP_S || _AP_S2))),
               (_AP_W > _AP_W2 ? _AP_S
                               : (_AP_W2 > _AP_W ? _AP_S2 : _AP_S || _AP_S2))>
        rhs = op;
    return typename RType<_AP_W2, _AP_S2>::div(
        (_AP_S || _AP_S2) ? lhs.sdiv(rhs) : lhs.udiv(rhs));
  }

  template <int _AP_W2, bool _AP_S2>
  inline typename RType<_AP_W2, _AP_S2>::mod operator%(
      const ap_private<_AP_W2, _AP_S2>& op) const {
    ap_private<((_AP_W + (_AP_S || _AP_S2)) > (_AP_W2 + (_AP_S || _AP_S2)) ? (_AP_W + (_AP_S || _AP_S2)) : (_AP_W2 + (_AP_S || _AP_S2))),
               (_AP_W > _AP_W2 ? _AP_S
                               : (_AP_W2 > _AP_W ? _AP_S2 : _AP_S || _AP_S2))>
        lhs = *this;
    ap_private<((_AP_W + (_AP_S || _AP_S2)) > (_AP_W2 + (_AP_S || _AP_S2)) ? (_AP_W + (_AP_S || _AP_S2)) : (_AP_W2 + (_AP_S || _AP_S2))),
               (_AP_W > _AP_W2 ? _AP_S
                               : (_AP_W2 > _AP_W ? _AP_S2 : _AP_S || _AP_S2))>
        rhs = op;
    typename RType<_AP_W2, _AP_S2>::mod res =
        typename RType<_AP_W2, _AP_S2>::mod(_AP_S ? lhs.srem(rhs)
                                                  : lhs.urem(rhs));
    return res;
  }
#3947 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
  inline ap_private operator<<(const int op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0 - op); return shl(op); }

  inline ap_private operator<<(const signed char op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const unsigned char op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const short op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const unsigned short op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const unsigned int op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const long op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const unsigned long op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const unsigned long long op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const long long op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const half op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const float op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const double op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }


  template <int _AP_W2, bool _AP_S2>
  inline ap_private operator<<(const ap_private<_AP_W2, _AP_S2>& op2) const {
    if (_AP_S2 == false) {
      uint32_t sh = op2.to_uint();
      return *this << sh;
    } else {
      int sh = op2.to_int();
      return *this << sh;
    }
  }
#3990 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
  inline ap_private operator>>(const char op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((CHAR_IS_SIGNED) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const signed char op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((true) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const unsigned char op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const short op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((true) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const unsigned short op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const int op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((true) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const unsigned int op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((true) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const unsigned long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const unsigned long long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const long long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((true) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const half op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const float op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const double op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }


  template <int _AP_W2, bool _AP_S2>
  inline ap_private operator>>(const ap_private<_AP_W2, _AP_S2>& op2) const {
    if (_AP_S2 == false) {
      uint32_t sh = op2.to_uint();
      return *this >> sh;
    } else {
      int sh = op2.to_int();
      return *this >> sh;
    }
  }
#4035 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
  template <int _AP_W2, bool _AP_S2> inline ap_private& operator >>=(int op) { *this = operator >>(op); return *this; } inline ap_private& operator >>=(unsigned int op) { *this = operator >>(op); return *this; } template <int _AP_W2, bool _AP_S2> inline ap_private& operator >>=(const ap_private<_AP_W2, _AP_S2>& op) { *this = operator >>(op); return *this; }
  template <int _AP_W2, bool _AP_S2> inline ap_private& operator <<=(int op) { *this = operator <<(op); return *this; } inline ap_private& operator <<=(unsigned int op) { *this = operator <<(op); return *this; } template <int _AP_W2, bool _AP_S2> inline ap_private& operator <<=(const ap_private<_AP_W2, _AP_S2>& op) { *this = operator <<(op); return *this; }




  inline bool operator==(const ap_private& RHS) const {

    uint32_t n1 = getActiveBits();
    uint32_t n2 = RHS.getActiveBits();


    if (n1 != n2) return false;



    if (n1 <= APINT_BITS_PER_WORD) return pVal[0] == RHS.get_pVal(0);


    for (int i = whichWord(n1 - 1); i >= 0; --i)
      if (pVal[i] != RHS.get_pVal(i)) return false;
    return true;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator==(const ap_private<_AP_W2, _AP_S2>& op) const {
    enum {
      _AP_MAX_W = ((_AP_W) > (_AP_W2) ? (_AP_W) : (_AP_W2)),
    };
    ap_private<_AP_MAX_W, false> lhs(*this);
    ap_private<_AP_MAX_W, false> rhs(op);
    return lhs == rhs;
  }

  inline bool operator==(uint64_t Val) const {
    uint32_t n = getActiveBits();
    if (n <= APINT_BITS_PER_WORD)
      return pVal[0] == Val;
    else
      return false;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator!=(const ap_private<_AP_W2, _AP_S2>& op) const {
    return !(*this == op);
  }

  template <bool _AP_S1>
  inline bool operator!=(const ap_private<_AP_W, _AP_S1>& RHS) const {
    return !((*this) == RHS);
  }

  inline bool operator!=(uint64_t Val) const { return !((*this) == Val); }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator<=(const ap_private<_AP_W2, _AP_S2>& op) const {
    return !(*this > op);
  }

  inline bool operator<(const ap_private& op) const {
    return _AP_S ? slt(op) : ult(op);
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator<(const ap_private<_AP_W2, _AP_S2>& op) const {
    enum {
      _AP_MAX_W = ((_AP_W + (_AP_S || _AP_S2)) > (_AP_W2 + (_AP_S || _AP_S2)) ? (_AP_W + (_AP_S || _AP_S2)) : (_AP_W2 + (_AP_S || _AP_S2)))
    };
    ap_private<_AP_MAX_W, _AP_S> lhs(*this);
    ap_private<_AP_MAX_W, _AP_S2> rhs(op);
    if (_AP_S == _AP_S2)
      return _AP_S ? lhs.slt(rhs) : lhs.ult(rhs);
    else if (_AP_S)
      if (_AP_W2 >= _AP_W)
        return lhs.ult(rhs);
      else
        return lhs.slt(rhs);
    else if (_AP_W >= _AP_W2)
      return lhs.ult(rhs);
    else
      return lhs.slt(rhs);
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator>=(const ap_private<_AP_W2, _AP_S2>& op) const {
    return !(*this < op);
  }

  inline bool operator>(const ap_private& op) const {
    return _AP_S ? sgt(op) : ugt(op);
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator>(const ap_private<_AP_W2, _AP_S2>& op) const {
    enum {
      _AP_MAX_W = ((_AP_W + (_AP_S || _AP_S2)) > (_AP_W2 + (_AP_S || _AP_S2)) ? (_AP_W + (_AP_S || _AP_S2)) : (_AP_W2 + (_AP_S || _AP_S2)))
    };
    ap_private<_AP_MAX_W, _AP_S> lhs(*this);
    ap_private<_AP_MAX_W, _AP_S2> rhs(op);
    if (_AP_S == _AP_S2)
      return _AP_S ? lhs.sgt(rhs) : lhs.ugt(rhs);
    else if (_AP_S)
      if (_AP_W2 >= _AP_W)
        return lhs.ugt(rhs);
      else
        return lhs.sgt(rhs);
    else if (_AP_W >= _AP_W2)
      return lhs.ugt(rhs);
    else
      return lhs.sgt(rhs);
  }



  inline _private_range_ref<_AP_W, _AP_S> operator()(int Hi, int Lo) {
    return _private_range_ref<_AP_W, _AP_S>(this, Hi, Lo);
  }

  inline _private_range_ref<_AP_W, _AP_S> operator()(int Hi, int Lo) const {
    return _private_range_ref<_AP_W, _AP_S>(
        const_cast<ap_private<_AP_W, _AP_S>*>(this), Hi, Lo);
  }

  inline _private_range_ref<_AP_W, _AP_S> range(int Hi, int Lo) const {
    return _private_range_ref<_AP_W, _AP_S>(
        (const_cast<ap_private<_AP_W, _AP_S>*>(this)), Hi, Lo);
  }

  inline _private_range_ref<_AP_W, _AP_S> range(int Hi, int Lo) {
    return _private_range_ref<_AP_W, _AP_S>(this, Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline _private_range_ref<_AP_W, _AP_S> range(
      const ap_private<_AP_W2, _AP_S2>& HiIdx,
      const ap_private<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return _private_range_ref<_AP_W, _AP_S>(this, Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline _private_range_ref<_AP_W, _AP_S> operator()(
      const ap_private<_AP_W2, _AP_S2>& HiIdx,
      const ap_private<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return _private_range_ref<_AP_W, _AP_S>(this, Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline _private_range_ref<_AP_W, _AP_S> range(
      const ap_private<_AP_W2, _AP_S2>& HiIdx,
      const ap_private<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return _private_range_ref<_AP_W, _AP_S>(const_cast<ap_private*>(this), Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline _private_range_ref<_AP_W, _AP_S> operator()(
      const ap_private<_AP_W2, _AP_S2>& HiIdx,
      const ap_private<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  inline _private_bit_ref<_AP_W, _AP_S> operator[](int index) {
    return _private_bit_ref<_AP_W, _AP_S>(*this, index);
  }

  template <int _AP_W2, bool _AP_S2>
  inline _private_bit_ref<_AP_W, _AP_S> operator[](
      const ap_private<_AP_W2, _AP_S2>& index) {
    return _private_bit_ref<_AP_W, _AP_S>(*this, index.to_int());
  }

  template <int _AP_W2, bool _AP_S2>
  inline const _private_bit_ref<_AP_W, _AP_S> operator[](
      const ap_private<_AP_W2, _AP_S2>& index) const {
    return _private_bit_ref<_AP_W, _AP_S>(
        const_cast<ap_private<_AP_W, _AP_S>&>(*this), index.to_int());
  }

  inline const _private_bit_ref<_AP_W, _AP_S> operator[](int index) const {
    return _private_bit_ref<_AP_W, _AP_S>(
        const_cast<ap_private<_AP_W, _AP_S>&>(*this), index);
  }

  inline _private_bit_ref<_AP_W, _AP_S> bit(int index) {
    return _private_bit_ref<_AP_W, _AP_S>(*this, index);
  }

  template <int _AP_W2, bool _AP_S2>
  inline _private_bit_ref<_AP_W, _AP_S> bit(const ap_private<_AP_W2, _AP_S2>& index) {
    return _private_bit_ref<_AP_W, _AP_S>(*this, index.to_int());
  }

  inline const _private_bit_ref<_AP_W, _AP_S> bit(int index) const {
    return _private_bit_ref<_AP_W, _AP_S>(
        const_cast<ap_private<_AP_W, _AP_S>&>(*this), index);
  }

  template <int _AP_W2, bool _AP_S2>
  inline const _private_bit_ref<_AP_W, _AP_S> bit(
      const ap_private<_AP_W2, _AP_S2>& index) const {
    return _private_bit_ref<_AP_W, _AP_S>(
        const_cast<ap_private<_AP_W, _AP_S>&>(*this), index.to_int());
  }
#4405 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
  inline ap_private<_AP_W, false> get() const {
    ap_private<_AP_W, false> ret(*this);
    return ret;
  }

  template <int _AP_W3>
  inline void set(const ap_private<_AP_W3, false>& val) {
    operator=(ap_private<_AP_W3, _AP_S>(val));
  }







  inline bool isNegative() const {

    enum { shift = (_AP_W - APINT_BITS_PER_WORD * (_AP_N - 1) - 1) };
    static const uint64_t mask = 1ULL << (shift);
    return _AP_S && (pVal[_AP_N - 1] & mask);
  }



  inline bool isPositive() const { return !isNegative(); }




  inline bool isStrictlyPositive() const {
    return isPositive() && (*this) != 0;
  }




  inline bool isAllOnesValue() const { return countPopulation() == _AP_W; }




  inline bool isMaxValue() const { return countPopulation() == _AP_W; }




  inline bool isMaxSignedValue() const {
    return !isNegative() && countPopulation() == _AP_W - 1;
  }




  inline bool isMinValue() const { return countPopulation() == 0; }




  inline bool isMinSignedValue() const {
    return isNegative() && countPopulation() == 1;
  }




  inline const uint64_t* getRawData() const { return &pVal[0]; }
#4480 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
  inline ap_private sqrt() const {

    uint32_t magnitude = getActiveBits();



    if (magnitude <= 5) {
      static const uint8_t results[32] = {
                      0,
                      1, 1,
                      2, 2, 2, 2,
                      3, 3, 3, 3, 3, 3,
                      4, 4, 4, 4, 4, 4, 4, 4,
                      5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                      6};
      return ap_private<_AP_W, _AP_S>( results[get_VAL()]);
    }





    if (magnitude < 52) {






      return ap_private<_AP_W, _AP_S>(
                                      uint64_t(
                                          ::round(::sqrt(double(get_VAL())))));

    }






    uint32_t nbits = BitWidth, i = 4;
    ap_private<_AP_W, _AP_S> testy(16);
    ap_private<_AP_W, _AP_S> x_old( 1);
    ap_private<_AP_W, _AP_S> x_new(0);
    ap_private<_AP_W, _AP_S> two( 2);


    for (;; i += 2, testy = testy.shl(2))
      if (i >= nbits || this->ule(testy)) {
        x_old = x_old.shl(i / 2);
        break;
      }


    for (;;) {
      x_new = (this->udiv(x_old) + x_old).udiv(two);
      if (x_old.ule(x_new)) break;
      x_old = x_new;
    }
#4547 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
    ap_private<_AP_W, _AP_S> square(x_old * x_old);
    ap_private<_AP_W, _AP_S> nextSquare((x_old + 1) * (x_old + 1));
    if (this->ult(square))
      return x_old;
    else if (this->ule(nextSquare)) {
      ap_private<_AP_W, _AP_S> midpoint((nextSquare - square).udiv(two));
      ap_private<_AP_W, _AP_S> offset(*this - square);
      if (offset.ult(midpoint))
        return x_old;
      else
        return x_old + 1;
    } else

#4559 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     (void) ((!!(
#4559 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
     0 && "Error in ap_private<_AP_W, _AP_S>::sqrt computation"
#4559 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     )) || (_assert(
#4559 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
     "0 && \"Error in ap_private<_AP_W, _AP_S>::sqrt computation\""
#4559 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",4559),0))
#4559 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                                       ;
    return x_old + 1;
  }






  inline ap_private& operator=(const ap_private& RHS) {
    if (this != &RHS) memcpy(pVal, RHS.get_pVal(), _AP_N * APINT_WORD_SIZE);
    return *this;
  }
  inline ap_private& operator=(const volatile ap_private& RHS) {
    if (this != &RHS)
      for (int i = 0; i < _AP_N; ++i) pVal[i] = RHS.get_pVal(i);
    return *this;
  }
  inline void operator=(const ap_private& RHS) volatile {
    if (this != &RHS)
      for (int i = 0; i < _AP_N; ++i) pVal[i] = RHS.get_pVal(i);
  }
  inline void operator=(const volatile ap_private& RHS) volatile {
    if (this != &RHS)
      for (int i = 0; i < _AP_N; ++i) pVal[i] = RHS.get_pVal(i);
  }

  template <int _AP_W1, bool _AP_S1>
  inline ap_private& operator=(const ap_private<_AP_W1, _AP_S1>& RHS) {
    if (_AP_S1)
      cpSextOrTrunc(RHS);
    else
      cpZextOrTrunc(RHS);
    clearUnusedBits();
    return *this;
  }

  template <int _AP_W1, bool _AP_S1>
  inline ap_private& operator=(const volatile ap_private<_AP_W1, _AP_S1>& RHS) {
    if (_AP_S1)
      cpSextOrTrunc(RHS);
    else
      cpZextOrTrunc(RHS);
    clearUnusedBits();
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_private& operator=(const _private_range_ref<_AP_W2, _AP_S2>& op2) {
    *this = ap_private<_AP_W2, false>(op2);
    return *this;
  }
#4650 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
  inline ap_private& operator=(const bool rhs) { ap_private<(1), (false)> tmp = rhs; operator=(tmp); return *this; }
  inline ap_private& operator=(const char rhs) { ap_private<(8), (CHAR_IS_SIGNED)> tmp = rhs; operator=(tmp); return *this; }
  inline ap_private& operator=(const signed char rhs) { ap_private<(8), (true)> tmp = rhs; operator=(tmp); return *this; }
  inline ap_private& operator=(const unsigned char rhs) { ap_private<(8), (false)> tmp = rhs; operator=(tmp); return *this; }
  inline ap_private& operator=(const short rhs) { ap_private<(sizeof(short) * 8), (true)> tmp = rhs; operator=(tmp); return *this; }
  inline ap_private& operator=(const unsigned short rhs) { ap_private<(sizeof(unsigned short) * 8), (false)> tmp = rhs; operator=(tmp); return *this; }
  inline ap_private& operator=(const int rhs) { ap_private<(sizeof(int) * 8), (true)> tmp = rhs; operator=(tmp); return *this; }
  inline ap_private& operator=(const unsigned int rhs) { ap_private<(sizeof(unsigned int) * 8), (false)> tmp = rhs; operator=(tmp); return *this; }
  inline ap_private& operator=(const long rhs) { ap_private<(sizeof(long) * 8), (true)> tmp = rhs; operator=(tmp); return *this; }
  inline ap_private& operator=(const unsigned long rhs) { ap_private<(sizeof(unsigned long) * 8), (false)> tmp = rhs; operator=(tmp); return *this; }
  inline ap_private& operator=(const ap_slong rhs) { ap_private<(sizeof(ap_slong) * 8), (true)> tmp = rhs; operator=(tmp); return *this; }
  inline ap_private& operator=(const ap_ulong rhs) { ap_private<(sizeof(ap_ulong) * 8), (false)> tmp = rhs; operator=(tmp); return *this; }




  inline ap_private& operator=(const char* s) {
    ap_private tmp(s);
    operator=(tmp);
    return *this;
  }






  inline const ap_private operator++(int) {
    ap_private API(*this);
    ++(*this);
    return API;
  }



  inline ap_private& operator++() {
    ap_private_ops::add_1(pVal, pVal, _AP_N, 1);
    clearUnusedBits();
    return *this;
  }



  inline const ap_private operator--(int) {
    ap_private API(*this);
    --(*this);
    return API;
  }



  inline ap_private& operator--() {
    ap_private_ops::sub_1(pVal, _AP_N, 1);
    clearUnusedBits();
    return *this;
  }




  inline ap_private<_AP_W + !_AP_S, true> operator~() const {
    ap_private<_AP_W + !_AP_S, true> Result(*this);
    Result.flip();
    return Result;
  }




  inline typename RType<1, false>::minus operator-() const {
    return ap_private<1, false>(0) - (*this);
  }




  inline bool operator!() const {
    for (int i = 0; i < _AP_N; ++i)
      if (pVal[i]) return false;
    return true;
  }

  template <bool _AP_S1>
  inline ap_private<_AP_W, _AP_S || _AP_S1> And(
      const ap_private<_AP_W, _AP_S1>& RHS) const {
    return this->operator&(RHS);
  }
  template <bool _AP_S1>
  inline ap_private Or(const ap_private<_AP_W, _AP_S1>& RHS) const {
    return this->operator|(RHS);
  }
  template <bool _AP_S1>
  inline ap_private Xor(const ap_private<_AP_W, _AP_S1>& RHS) const {
    return this->operator^(RHS);
  }

  inline ap_private Mul(const ap_private& RHS) const {
    ap_private Result(*this);
    Result *= RHS;
    return Result;
  }

  inline ap_private Add(const ap_private& RHS) const {
    ap_private Result(0);
    ap_private_ops::add(Result.get_pVal(), pVal, RHS.get_pVal(), _AP_N, _AP_N,
                        _AP_N, _AP_S, _AP_S);
    Result.clearUnusedBits();
    return Result;
  }

  inline ap_private Sub(const ap_private& RHS) const {
    ap_private Result(0);
    ap_private_ops::sub(Result.get_pVal(), pVal, RHS.get_pVal(), _AP_N, _AP_N,
                        _AP_N, _AP_S, _AP_S);
    Result.clearUnusedBits();
    return Result;
  }



  inline ap_private ashr(uint32_t shiftAmt) const {

#4771 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#4771 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   shiftAmt <= BitWidth && "Invalid shift amount, too big"
#4771 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#4771 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "shiftAmt <= BitWidth && \"Invalid shift amount, too big\""
#4771 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",4771),0))
#4771 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                                  ;

    if (shiftAmt == 0) return ap_private(*this);





    if (shiftAmt == BitWidth) {
      if (isNegative())
        return ap_private(-1);
      else
        return ap_private(0);
    }


    ap_private Retval(0);
    uint64_t* val = Retval.get_pVal();


    uint32_t wordShift =
        shiftAmt % APINT_BITS_PER_WORD;
    uint32_t offset = shiftAmt / APINT_BITS_PER_WORD;
    uint32_t breakWord = _AP_N - 1 - offset;
    uint32_t bitsInWord = whichBit(BitWidth);
    if (bitsInWord == 0) bitsInWord = APINT_BITS_PER_WORD;


    if (wordShift == 0) {

      for (uint32_t i = 0; i <= breakWord; ++i)
        val[i] = pVal[i + offset];


      if (isNegative())
        if (bitsInWord < APINT_BITS_PER_WORD)
          val[breakWord] |= ~0ULL << (bitsInWord);
    } else {

      for (uint32_t i = 0; i < breakWord; ++i) {


        val[i] = ((pVal[i + offset]) >> (wordShift));
        val[i] |= ((pVal[i + offset + 1]) << (APINT_BITS_PER_WORD - wordShift));
      }



      val[breakWord] = (pVal[breakWord + offset]) >> (wordShift);




      if (isNegative()) {
        if (wordShift > bitsInWord) {
          if (breakWord > 0)
            val[breakWord - 1] |=
                ~0ULL << (APINT_BITS_PER_WORD - (wordShift - bitsInWord));
          val[breakWord] |= ~0ULL;
        } else
          val[breakWord] |= (~0ULL << (bitsInWord - wordShift));
      }
    }


    uint64_t fillValue = (isNegative() ? ~0ULL : 0);
    for (int i = breakWord + 1; i < _AP_N; ++i) val[i] = fillValue;
    Retval.clearUnusedBits();
    return Retval;
  }



  inline ap_private lshr(uint32_t shiftAmt) const {



    if (shiftAmt == BitWidth) return ap_private(0);




    if (shiftAmt == 0) return ap_private(*this);


    ap_private Retval(0);
    uint64_t* val = Retval.get_pVal();



    if (shiftAmt < APINT_BITS_PER_WORD) {
      uint64_t carry = 0;
      for (int i = _AP_N - 1; i >= 0; --i) {
        val[i] = ((pVal[i]) >> (shiftAmt)) | carry;
        carry = (pVal[i]) << (APINT_BITS_PER_WORD - shiftAmt);
      }
      Retval.clearUnusedBits();
      return Retval;
    }


    uint32_t wordShift = shiftAmt % APINT_BITS_PER_WORD;
    uint32_t offset = shiftAmt / APINT_BITS_PER_WORD;


    if (wordShift == 0) {
      for (uint32_t i = 0; i < _AP_N - offset; ++i) val[i] = pVal[i + offset];
      for (uint32_t i = _AP_N - offset; i < _AP_N; i++) val[i] = 0;
      Retval.clearUnusedBits();
      return Retval;
    }


    uint32_t breakWord = _AP_N - offset - 1;
    for (uint32_t i = 0; i < breakWord; ++i)
      val[i] = ((pVal[i + offset]) >> (wordShift)) |
               ((pVal[i + offset + 1]) << (APINT_BITS_PER_WORD - wordShift));

    val[breakWord] = (pVal[breakWord + offset]) >> (wordShift);


    for (int i = breakWord + 1; i < _AP_N; ++i) val[i] = 0;
    Retval.clearUnusedBits();
    return Retval;
  }



  inline ap_private shl(uint32_t shiftAmt) const {

#4900 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#4900 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   shiftAmt <= BitWidth && "Invalid shift amount, too big"
#4900 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#4900 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "shiftAmt <= BitWidth && \"Invalid shift amount, too big\""
#4900 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",4900),0))
#4900 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                                  ;



    if (shiftAmt == BitWidth) return ap_private(0);





    if (shiftAmt == 0) return ap_private(*this);


    ap_private Retval(0);
    uint64_t* val = Retval.get_pVal();

    if (shiftAmt < APINT_BITS_PER_WORD) {
      uint64_t carry = 0;
      for (int i = 0; i < _AP_N; i++) {
        val[i] = ((pVal[i]) << (shiftAmt)) | carry;
        carry = (pVal[i]) >> (APINT_BITS_PER_WORD - shiftAmt);
      }
      Retval.clearUnusedBits();
      return Retval;
    }


    uint32_t wordShift = shiftAmt % APINT_BITS_PER_WORD;
    uint32_t offset = shiftAmt / APINT_BITS_PER_WORD;


    if (wordShift == 0) {
      for (uint32_t i = 0; i < offset; i++) val[i] = 0;
      for (int i = offset; i < _AP_N; i++) val[i] = pVal[i - offset];
      Retval.clearUnusedBits();
      return Retval;
    }


    uint32_t i = _AP_N - 1;
    for (; i > offset; --i)
      val[i] = (pVal[i - offset]) << (wordShift) |
               (pVal[i - offset - 1]) >> (APINT_BITS_PER_WORD - wordShift);
    val[offset] = (pVal[0]) << (wordShift);
    for (i = 0; i < offset; ++i) val[i] = 0;
    Retval.clearUnusedBits();
    return Retval;
  }

  inline ap_private rotl(uint32_t rotateAmt) const {
    if (rotateAmt == 0) return ap_private(*this);

    ap_private hi(*this);
    ap_private lo(*this);
    hi.shl(rotateAmt);
    lo.lshr(BitWidth - rotateAmt);
    return hi | lo;
  }

  inline ap_private rotr(uint32_t rotateAmt) const {
    if (rotateAmt == 0) return ap_private(*this);

    ap_private hi(*this);
    ap_private lo(*this);
    lo.lshr(rotateAmt);
    hi.shl(BitWidth - rotateAmt);
    return hi | lo;
  }






  inline ap_private udiv(const ap_private& RHS) const {

    uint32_t rhsBits = RHS.getActiveBits();
    uint32_t rhsWords = !rhsBits ? 0 : (whichWord(rhsBits - 1) + 1);

#4978 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#4978 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   rhsWords && "Divided by zero???"
#4978 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#4978 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "rhsWords && \"Divided by zero???\""
#4978 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",4978),0))
#4978 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                           ;
    uint32_t lhsBits = this->getActiveBits();
    uint32_t lhsWords = !lhsBits ? 0 : (whichWord(lhsBits - 1) + 1);


    if (!lhsWords)

      return ap_private(0);
    else if (lhsWords < rhsWords || this->ult(RHS)) {

      return ap_private(0);
    } else if (*this == RHS) {

      return ap_private(1);
    } else if (lhsWords == 1 && rhsWords == 1) {

      return ap_private(this->pVal[0] / RHS.get_pVal(0));
    }


    ap_private Quotient(0);
    ap_private_ops::divide(*this, lhsWords, RHS, rhsWords, &Quotient,
                           (ap_private*)0);
    return Quotient;
  }



  inline ap_private sdiv(const ap_private& RHS) const {
    if (isNegative())
      if (RHS.isNegative())
        return (-(*this)).udiv(-RHS);
      else
        return -((-(*this)).udiv(RHS));
    else if (RHS.isNegative())
      return -(this->udiv((ap_private)(-RHS)));
    return this->udiv(RHS);
  }
#5025 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
  inline ap_private urem(const ap_private& RHS) const {

    uint32_t lhsBits = getActiveBits();
    uint32_t lhsWords = !lhsBits ? 0 : (whichWord(lhsBits - 1) + 1);


    uint32_t rhsBits = RHS.getActiveBits();
    uint32_t rhsWords = !rhsBits ? 0 : (whichWord(rhsBits - 1) + 1);

#5033 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#5033 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   rhsWords && "Performing remainder operation by zero ???"
#5033 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#5033 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "rhsWords && \"Performing remainder operation by zero ???\""
#5033 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",5033),0))
#5033 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                                   ;


    if (lhsWords == 0) {

      return ap_private(0);
    } else if (lhsWords < rhsWords || this->ult(RHS)) {

      return *this;
    } else if (*this == RHS) {

      return ap_private(0);
    } else if (lhsWords == 1) {

      return ap_private(pVal[0] % RHS.get_pVal(0));
    }


    ap_private Remainder(0);
    ap_private_ops::divide(*this, lhsWords, RHS, rhsWords, (ap_private*)(0),
                           &Remainder);
    return Remainder;
  }

  inline ap_private urem(uint64_t RHS) const {

    uint32_t lhsBits = getActiveBits();
    uint32_t lhsWords = !lhsBits ? 0 : (whichWord(lhsBits - 1) + 1);

    uint32_t rhsWords = 1;


#5064 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#5064 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   rhsWords && "Performing remainder operation by zero ???"
#5064 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#5064 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "rhsWords && \"Performing remainder operation by zero ???\""
#5064 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",5064),0))
#5064 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                                   ;

    if (lhsWords == 0) {

      return ap_private(0);
    } else if (lhsWords < rhsWords || this->ult(RHS)) {

      return *this;
    } else if (*this == RHS) {

      return ap_private(0);
    } else if (lhsWords == 1) {

      return ap_private(pVal[0] % RHS);
    }


    ap_private Remainder(0);
    divide(*this, lhsWords, RHS, (ap_private*)(0), &Remainder);
    return Remainder;
  }



  inline ap_private srem(const ap_private& RHS) const {
    if (isNegative()) {
      ap_private lhs = -(*this);
      if (RHS.isNegative()) {
        ap_private rhs = -RHS;
        return -(lhs.urem(rhs));
      } else
        return -(lhs.urem(RHS));
    } else if (RHS.isNegative()) {
      ap_private rhs = -RHS;
      return this->urem(rhs);
    }
    return this->urem(RHS);
  }



  inline ap_private srem(int64_t RHS) const {
    if (isNegative())
      if (RHS < 0)
        return -((-(*this)).urem(-RHS));
      else
        return -((-(*this)).urem(RHS));
    else if (RHS < 0)
      return this->urem(-RHS);
    return this->urem(RHS);
  }





  template <bool _AP_S1>
  inline bool eq(const ap_private<_AP_W, _AP_S1>& RHS) const {
    return (*this) == RHS;
  }





  template <bool _AP_S1>
  inline bool ne(const ap_private<_AP_W, _AP_S1>& RHS) const {
    return !((*this) == RHS);
  }





  template <bool _AP_S1>
  inline bool ult(const ap_private<_AP_W, _AP_S1>& RHS) const {

    uint32_t n1 = getActiveBits();
    uint32_t n2 = RHS.getActiveBits();


    if (n1 < n2) return true;


    if (n2 < n1) return false;


    if (n1 <= APINT_BITS_PER_WORD && n2 <= APINT_BITS_PER_WORD)
      return pVal[0] < RHS.get_pVal(0);


    uint32_t topWord = whichWord(AESL_std::max(n1, n2) - 1);
    for (int i = topWord; i >= 0; --i) {
      if (pVal[i] > RHS.get_pVal(i)) return false;
      if (pVal[i] < RHS.get_pVal(i)) return true;
    }
    return false;
  }

  inline bool ult(uint64_t RHS) const {

    uint32_t n1 = getActiveBits();
    uint32_t n2 =
        64 - ap_private_ops::CountLeadingZeros_64(RHS);


    if (n1 < n2) return true;


    if (n2 < n1) return false;


    if (n1 <= APINT_BITS_PER_WORD && n2 <= APINT_BITS_PER_WORD)
      return pVal[0] < RHS;

#5178 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#5178 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   0
#5178 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#5178 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "0"
#5178 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",5178),0))
#5178 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
            ;
  }

  template <bool _AP_S1>
  inline bool slt(const ap_private<_AP_W, _AP_S1>& RHS) const {
    ap_private lhs(*this);
    ap_private<_AP_W, _AP_S1> rhs(RHS);
    bool lhsNeg = isNegative();
    bool rhsNeg = rhs.isNegative();
    if (lhsNeg) {

      lhs.flip();
      lhs++;
    }
    if (rhsNeg) {

      rhs.flip();
      rhs++;
    }



    if (lhsNeg)
      if (rhsNeg)
        return lhs.ugt(rhs);
      else
        return true;
    else if (rhsNeg)
      return false;
    else
      return lhs.ult(rhs);
  }





  template <bool _AP_S1>
  inline bool ule(const ap_private<_AP_W, _AP_S1>& RHS) const {
    return ult(RHS) || eq(RHS);
  }





  template <bool _AP_S1>
  inline bool sle(const ap_private<_AP_W, _AP_S1>& RHS) const {
    return slt(RHS) || eq(RHS);
  }





  template <bool _AP_S1>
  inline bool ugt(const ap_private<_AP_W, _AP_S1>& RHS) const {
    return !ult(RHS) && !eq(RHS);
  }





  template <bool _AP_S1>
  inline bool sgt(const ap_private<_AP_W, _AP_S1>& RHS) const {
    return !slt(RHS) && !eq(RHS);
  }





  template <bool _AP_S1>
  inline bool uge(const ap_private<_AP_W, _AP_S>& RHS) const {
    return !ult(RHS);
  }





  template <bool _AP_S1>
  inline bool sge(const ap_private<_AP_W, _AP_S1>& RHS) const {
    return !slt(RHS);
  }


  template <int _AP_W1, bool _AP_S1>
  inline void cpSext(const ap_private<_AP_W1, _AP_S1>& that) {

#5268 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#5268 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   _AP_W1 < BitWidth && "Invalid ap_private SignExtend request"
#5268 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#5268 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "_AP_W1 < BitWidth && \"Invalid ap_private SignExtend request\""
#5268 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",5268),0))
#5268 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                                       ;

#5269 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#5269 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   _AP_W1 <= MAX_INT_BITS && "Too many bits"
#5269 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#5269 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "_AP_W1 <= MAX_INT_BITS && \"Too many bits\""
#5269 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",5269),0))
#5269 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                    ;

    if (!that.isNegative()) {
      cpZext(that);
      return;
    }


    enum { wordBits = _AP_W1 % APINT_BITS_PER_WORD };
    const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N;

    if (_AP_N1 == _AP_N) {
      enum { newWordBits = _AP_W % APINT_BITS_PER_WORD };

      static const uint64_t mask = wordBits ? (~0ULL << (wordBits)) : 0ULL;
      for (int i = 0; i < _AP_N; ++i) pVal[i] = that.get_pVal(i);
      pVal[_AP_N - 1] |= mask;
      return;
    }

    enum { newWordBits = _AP_W % APINT_BITS_PER_WORD };

    static const uint64_t mask = wordBits ? (~0ULL << (wordBits)) : 0ULL;
    int i;
    for (i = 0; i < _AP_N1; ++i) pVal[i] = that.get_pVal(i);
    pVal[i - 1] |= mask;
    for (; i < _AP_N - 1; i++) pVal[i] = ~0ULL;
    pVal[i] = ~0ULL;
    clearUnusedBits();
    return;
  }


  template <int _AP_W1, bool _AP_S1>
  inline void cpZext(const ap_private<_AP_W1, _AP_S1>& that) {

#5304 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#5304 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   _AP_W1 < BitWidth && "Invalid ap_private ZeroExtend request"
#5304 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#5304 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "_AP_W1 < BitWidth && \"Invalid ap_private ZeroExtend request\""
#5304 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",5304),0))
#5304 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                                       ;

#5305 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#5305 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   _AP_W1 <= MAX_INT_BITS && "Too many bits"
#5305 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#5305 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "_AP_W1 <= MAX_INT_BITS && \"Too many bits\""
#5305 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",5305),0))
#5305 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                    ;
    const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N;
    int i = 0;
    for (; i < _AP_N1; ++i) pVal[i] = that.get_pVal(i);
    for (; i < _AP_N; ++i) pVal[i] = 0;
    clearUnusedBits();
  }

  template <int _AP_W1, bool _AP_S1>
  inline void cpZextOrTrunc(const ap_private<_AP_W1, _AP_S1>& that) {
    if (BitWidth > _AP_W1)
      cpZext(that);
    else {
      for (int i = 0; i < _AP_N; ++i) pVal[i] = that.get_pVal(i);
      clearUnusedBits();
    }
  }

  template <int _AP_W1, bool _AP_S1>
  inline void cpSextOrTrunc(const ap_private<_AP_W1, _AP_S1>& that) {
    if (BitWidth > _AP_W1)
      cpSext(that);
    else {
      for (int i = 0; i < _AP_N; ++i) pVal[i] = that.get_pVal(i);
      clearUnusedBits();
    }
  }






  inline uint32_t getBitWidth() const { return BitWidth; }




  inline uint32_t getNumWords() const {
    return (BitWidth + APINT_BITS_PER_WORD - 1) / APINT_BITS_PER_WORD;
  }





  inline uint32_t getActiveBits() const {
    uint32_t bits = BitWidth - countLeadingZeros();
    return bits ? bits : 1;
  }






  inline uint64_t getZExtValue() const {

#5362 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#5362 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   getActiveBits() <= 64 && "Too many bits for uint64_t"
#5362 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#5362 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "getActiveBits() <= 64 && \"Too many bits for uint64_t\""
#5362 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",5362),0))
#5362 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                                ;
    return *pVal;
  }






  inline int64_t getSExtValue() const {

#5372 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#5372 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   getActiveBits() <= 64 && "Too many bits for int64_t"
#5372 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#5372 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "getActiveBits() <= 64 && \"Too many bits for int64_t\""
#5372 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",5372),0))
#5372 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                               ;
    return int64_t(pVal[0]);
  }




  inline static uint32_t getBitsNeeded(const char* str, uint32_t slen,
                                       uint8_t radix) {

#5381 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#5381 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   str != 0 && "Invalid value string"
#5381 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#5381 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "str != 0 && \"Invalid value string\""
#5381 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",5381),0))
#5381 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                             ;

#5382 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#5382 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   slen > 0 && "Invalid string length"
#5382 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#5382 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "slen > 0 && \"Invalid string length\""
#5382 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",5382),0))
#5382 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                              ;


    uint32_t isNegative = str[0] == '-';
    if (isNegative) {
      slen--;
      str++;
    }


    if (radix == 2) return slen + isNegative;
    if (radix == 8) return slen * 3 + isNegative;
    if (radix == 16) return slen * 4 + isNegative;



#5397 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (void) ((!!(
#5397 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   radix == 10 && "Invalid radix"
#5397 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   )) || (_assert(
#5397 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   "radix == 10 && \"Invalid radix\""
#5397 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",5397),0))
#5397 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                         ;






    return isNegative + slen * 4;
  }







  inline uint32_t countLeadingZeros() const {
    enum {
      msw_bits = (BitWidth % APINT_BITS_PER_WORD)
                     ? (BitWidth % APINT_BITS_PER_WORD)
                     : APINT_BITS_PER_WORD,
      excessBits = APINT_BITS_PER_WORD - msw_bits
    };
    uint32_t Count = ap_private_ops::CountLeadingZeros_64(pVal[_AP_N - 1]);
    if (Count >= excessBits) Count -= excessBits;
    if (!pVal[_AP_N - 1]) {
      for (int i = _AP_N - 1; i; --i) {
        if (!pVal[i - 1])
          Count += APINT_BITS_PER_WORD;
        else {
          Count += ap_private_ops::CountLeadingZeros_64(pVal[i - 1]);
          break;
        }
      }
    }
    return Count;
  }






  inline uint32_t countLeadingOnes() const {
    if (isSingleWord())
      return countLeadingOnes_64(get_VAL(), APINT_BITS_PER_WORD - BitWidth);

    uint32_t highWordBits = BitWidth % APINT_BITS_PER_WORD;
    uint32_t shift =
        (highWordBits == 0 ? 0 : APINT_BITS_PER_WORD - highWordBits);
    int i = _AP_N - 1;
    uint32_t Count = countLeadingOnes_64(get_pVal(i), shift);
    if (Count == highWordBits) {
      for (i--; i >= 0; --i) {
        if (get_pVal(i) == ~0ULL)
          Count += APINT_BITS_PER_WORD;
        else {
          Count += countLeadingOnes_64(get_pVal(i), 0);
          break;
        }
      }
    }
    return Count;
  }
#5469 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
  inline uint32_t countTrailingZeros() const {
    uint32_t Count = 0;
    uint32_t i = 0;
    for (; i < _AP_N && get_pVal(i) == 0; ++i) Count += APINT_BITS_PER_WORD;
    if (i < _AP_N) Count += ap_private_ops::CountTrailingZeros_64(get_pVal(i));
    return AESL_std::min(Count, BitWidth);
  }






  inline uint32_t countPopulation() const {
    uint32_t Count = 0;
    for (int i = 0; i < _AP_N - 1; ++i)
      Count += ap_private_ops::CountPopulation_64(pVal[i]);
    Count += ap_private_ops::CountPopulation_64(pVal[_AP_N - 1] & mask);
    return Count;
  }







  inline std::string toString(uint8_t radix, bool wantSigned) const;






  inline std::string toStringUnsigned(uint8_t radix = 10) const {
    return toString(radix, false);
  }






  inline std::string toStringSigned(uint8_t radix = 10) const {
    return toString(radix, true);
  }


  inline double roundToDouble(bool isSigned) const {

    if (isSingleWord() || getActiveBits() <= APINT_BITS_PER_WORD) {
      uint64_t val = pVal[0];
      if (isSigned) {
        int64_t sext = ((int64_t(val)) << (64 - BitWidth)) >> (64 - BitWidth);
        return double(sext);
      } else
        return double(val);
    }


    bool isNeg = isSigned ? (*this)[BitWidth - 1] : false;


    ap_private<_AP_W, _AP_S> Tmp(isNeg ? -(*this) : (*this));


    uint32_t n = Tmp.getActiveBits();




    uint64_t exp = n;


    if (exp > 1023) {
      if (!isSigned || !isNeg)
        return std::numeric_limits<double>::infinity();
      else
        return -std::numeric_limits<double>::infinity();
    }
    exp += 1023;



    uint64_t mantissa;
    unsigned hiWord = whichWord(n - 1);
    if (hiWord == 0) {
      mantissa = Tmp.get_pVal(0);
      if (n > 52)
        (mantissa) >>= (n - 52);
    } else {

#5560 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     (void) ((!!(
#5560 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
     hiWord > 0 && "High word is negative?"
#5560 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     )) || (_assert(
#5560 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
     "hiWord > 0 && \"High word is negative?\""
#5560 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",5560),0))
#5560 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                                   ;
      uint64_t hibits = (Tmp.get_pVal(hiWord))
                        << (52 - n % APINT_BITS_PER_WORD);
      uint64_t lobits =
          (Tmp.get_pVal(hiWord - 1)) >> (11 + n % APINT_BITS_PER_WORD);
      mantissa = hibits | lobits;
    }


    uint64_t sign = isNeg ? (1ULL << (APINT_BITS_PER_WORD - 1)) : 0;
    union {
      double __D;
      uint64_t __I;
    } __T;
    __T.__I = sign | ((exp) << 52) | mantissa;
    return __T.__D;
  }


  inline double roundToDouble() const { return roundToDouble(false); }


  inline double signedRoundToDouble() const { return roundToDouble(true); }





  inline double bitsToDouble() const {
    union {
      uint64_t __I;
      double __D;
    } __T;
    __T.__I = pVal[0];
    return __T.__D;
  }





  inline float bitsToFloat() const {
    union {
      uint32_t __I;
      float __F;
    } __T;
    __T.__I = uint32_t(pVal[0]);
    return __T.__F;
  }





  inline ap_private& doubleToBits(double __V) {
    union {
      uint64_t __I;
      double __D;
    } __T;
    __T.__D = __V;
    pVal[0] = __T.__I;
    return *this;
  }





  inline ap_private& floatToBits(float __V) {
    union {
      uint32_t __I;
      float __F;
    } __T;
    __T.__F = __V;
    pVal[0] = __T.__I;
  }



  inline bool and_reduce() const { return isMaxValue(); }

  inline bool nand_reduce() const { return isMinValue(); }

  inline bool or_reduce() const { return (bool)countPopulation(); }

  inline bool nor_reduce() const { return countPopulation() == 0; }

  inline bool xor_reduce() const {
    unsigned int i = countPopulation();
    return (i % 2) ? true : false;
  }

  inline bool xnor_reduce() const {
    unsigned int i = countPopulation();
    return (i % 2) ? false : true;
  }
  inline std::string to_string(uint8_t radix = 16, bool sign = false) const {
    return toString(radix, radix == 10 ? _AP_S : sign);
  }
};

namespace ap_private_ops {

enum { APINT_BITS_PER_WORD = 64 };
template <int _AP_W, bool _AP_S>
inline bool operator==(uint64_t V1, const ap_private<_AP_W, _AP_S>& V2) {
  return V2 == V1;
}

template <int _AP_W, bool _AP_S>
inline bool operator!=(uint64_t V1, const ap_private<_AP_W, _AP_S>& V2) {
  return V2 != V1;
}

template <int _AP_W, bool _AP_S, int index>
inline bool get(const ap_private<_AP_W, _AP_S>& a) {
  static const uint64_t mask = 1ULL << (index & 0x3f);
  return ((mask & a.get_pVal((index) >> 6)) != 0);
}

template <int _AP_W, bool _AP_S, int msb_index, int lsb_index>
inline void set(ap_private<_AP_W, _AP_S>& a,
                const ap_private<((msb_index) > (1) ? (msb_index) : (1)), true>& mark1 = 0,
                const ap_private<((lsb_index) > (1) ? (lsb_index) : (1)), true>& mark2 = 0) {
  enum {
    APINT_BITS_PER_WORD = 64,
    lsb_word = lsb_index / APINT_BITS_PER_WORD,
    msb_word = msb_index / APINT_BITS_PER_WORD,
    msb = msb_index % APINT_BITS_PER_WORD,
    lsb = lsb_index % APINT_BITS_PER_WORD
  };
  if (msb_word == lsb_word) {
    const uint64_t mask = ~0ULL >>
                          (lsb) << (APINT_BITS_PER_WORD - msb + lsb - 1) >>
                          (APINT_BITS_PER_WORD - msb - 1);

    a.get_pVal(msb_word) |= mask;
  } else {
    const uint64_t lsb_mask = ~0ULL >> (lsb) << (lsb);
    const uint64_t msb_mask = ~0ULL << (APINT_BITS_PER_WORD - msb - 1) >>
                              (APINT_BITS_PER_WORD - msb - 1);

    a.get_pVal(lsb_word) |= lsb_mask;
    for (int i = lsb_word + 1; i < msb_word; i++) {
      a.set_pVal(i, ~0ULL);

    }


    a.get_pVal(msb_word) |= msb_mask;
  }
  a.clearUnusedBits();
}

template <int _AP_W, bool _AP_S, int msb_index, int lsb_index>
inline void clear(ap_private<_AP_W, _AP_S>& a,
                  const ap_private<((msb_index) > (1) ? (msb_index) : (1)), true>& mark1 = 0,
                  const ap_private<((lsb_index) > (1) ? (lsb_index) : (1)), true>& mark2 = 0) {
  enum {
    APINT_BITS_PER_WORD = 64,
    lsb_word = lsb_index / APINT_BITS_PER_WORD,
    msb_word = msb_index / APINT_BITS_PER_WORD,
    msb = msb_index % APINT_BITS_PER_WORD,
    lsb = lsb_index % APINT_BITS_PER_WORD
  };
  if (msb_word == lsb_word) {
    const uint64_t mask =
        ~(~0ULL >> (lsb) << (APINT_BITS_PER_WORD - msb + lsb - 1) >>
          (APINT_BITS_PER_WORD - msb - 1));

    a.get_pVal(msb_word) &= mask;
  } else {
    const uint64_t lsb_mask = ~(~0ULL >> (lsb) << (lsb));
    const uint64_t msb_mask = ~(~0ULL << (APINT_BITS_PER_WORD - msb - 1) >>
                                (APINT_BITS_PER_WORD - msb - 1));

    a.get_pVal(lsb_word) &= lsb_mask;
    for (int i = lsb_word + 1; i < msb_word; i++) {

      a.get_pVal(i) = 0;
    }

    a.get_pVal(msb_word) &= msb_mask;
  }
  a.clearUnusedBits();
}

template <int _AP_W, bool _AP_S, int index>
inline void set(ap_private<_AP_W, _AP_S>& a,
                const ap_private<((index) > (1) ? (index) : (1)), true>& mark = 0) {
  enum { APINT_BITS_PER_WORD = 64, word = index / APINT_BITS_PER_WORD };
  static const uint64_t mask = 1ULL << (index % APINT_BITS_PER_WORD);

  a.get_pVal(word) |= mask;
  a.clearUnusedBits();
}

template <int _AP_W, bool _AP_S, int index>
inline void clear(ap_private<_AP_W, _AP_S>& a,
                  const ap_private<((index) > (1) ? (index) : (1)), true>& mark = 0) {
  enum { APINT_BITS_PER_WORD = 64, word = index / APINT_BITS_PER_WORD };
  static const uint64_t mask = ~(1ULL << (index % APINT_BITS_PER_WORD));

  a.get_pVal(word) &= mask;
  a.clearUnusedBits();
}

}

template <int _AP_W, bool _AP_S>
inline std::string ap_private<_AP_W, _AP_S, false>::toString(
    uint8_t radix, bool wantSigned) const {

#5772 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 (void) ((!!(
#5772 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
 (radix == 10 || radix == 8 || radix == 16 || radix == 2) && "Radix should be 2, 8, 10, or 16!"
#5772 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 )) || (_assert(
#5772 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
 "(radix == 10 || radix == 8 || radix == 16 || radix == 2) && \"Radix should be 2, 8, 10, or 16!\""
#5772 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
 ,
                                           "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
#5772 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
  ,
                                           5773
#5772 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
  ),0))

#5773 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                           ;
  static const char* digits[] = {"0", "1", "2", "3", "4", "5", "6", "7",
                                 "8", "9", "A", "B", "C", "D", "E", "F"};
  std::string result;

  if (radix != 10) {





    if (*this == (uint64_t)(0))
      result = "0";
    else {
      ap_private<_AP_W, false> tmp(*this);
      size_t insert_at = 0;
      bool leading_zero = true;
      if (wantSigned && isNegative()) {



        tmp.flip();
        tmp++;
        tmp.clearUnusedBitsToZero();
        result = "-";
        insert_at = 1;
        leading_zero = false;
      }
      switch (radix) {
        case 2:
          result += "0b";
          break;
        case 8:
          result += "0o";
          break;
        case 16:
          result += "0x";
          break;
        default:

#5812 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
         (void) ((!!(
#5812 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
         "invalid radix" && 0
#5812 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
         )) || (_assert(
#5812 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
         "\"invalid radix\" && 0"
#5812 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
         ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",5812),0))
#5812 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                     ;
      }
      insert_at += 2;

      uint32_t shift = (radix == 16 ? 4 : (radix == 8 ? 3 : 1));
      uint64_t mask = radix - 1;
      ap_private<_AP_W, false> zero(0);
      unsigned bits = 0;
      while (tmp.ne(zero)) {
        uint64_t digit = tmp.get_VAL() & mask;
        result.insert(insert_at, digits[digit]);
        tmp = tmp.lshr(shift);
        ++bits;
      }
      bits *= shift;
      if (bits < _AP_W && leading_zero) result.insert(insert_at, digits[0]);
    }
    return result;
  }

  ap_private<_AP_W, false> tmp(*this);
  ap_private<_AP_W, false> divisor(radix);
  ap_private<_AP_W, false> zero(0);
  size_t insert_at = 0;
  if (wantSigned && isNegative()) {



    tmp.flip();
    tmp++;
    tmp.clearUnusedBitsToZero();
    result = "-";
    insert_at = 1;
  }
  if (tmp == ap_private<_AP_W, false>(0))
    result = "0";
  else
    while (tmp.ne(zero)) {
      ap_private<_AP_W, false> APdigit(0);
      ap_private<_AP_W, false> tmp2(0);
      ap_private_ops::divide(tmp, tmp.getNumWords(), divisor,
                             divisor.getNumWords(), &tmp2, &APdigit);
      uint64_t digit = APdigit.getZExtValue();

#5855 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     (void) ((!!(
#5855 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
     digit < radix && "divide failed"
#5855 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     )) || (_assert(
#5855 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
     "digit < radix && \"divide failed\""
#5855 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
     ,"C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h",5855),0))
#5855 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
                                             ;
      result.insert(insert_at, digits[digit]);
      tmp = tmp2;
    }

  return result;
}

template <int _AP_W, bool _AP_S>
std::ostream &operator<<(std::ostream &os, const ap_private<_AP_W, _AP_S> &x) {
  std::ios_base::fmtflags ff = std::cout.flags();
  if (ff & std::cout.hex) {
    os << x.toString(16, false);
  } else if (ff & std::cout.oct) {
    os << x.toString(8, false);
  } else {
    os << x.toString(10, _AP_S);
  }
  return os;
}
#6120 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
template <int _AP_W, bool _AP_S>
struct _private_range_ref {



  ap_private<_AP_W, _AP_S>& d_bv;
  int l_index;
  int h_index;

 public:

  inline _private_range_ref(const _private_range_ref<_AP_W, _AP_S>& ref)
      : d_bv(ref.d_bv), l_index(ref.l_index), h_index(ref.h_index) {}


  inline _private_range_ref(ap_private<_AP_W, _AP_S>* bv, int h, int l)
      : d_bv(*bv), l_index(l), h_index(h) {
    do { if ((h < 0 || l < 0)) { fprintf(
#6137 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (&__iob_func()[2])
#6137 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   , "WARNING: " "Higher bound (%d) and lower bound (%d) cannot be " "negative.", h, l); fprintf(
#6137 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (&__iob_func()[2])
#6137 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   , "\n"); } } while (0)


                     ;
    do { if ((h >= _AP_W || l >= _AP_W)) { fprintf(
#6141 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (&__iob_func()[2])
#6141 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   , "WARNING: " "Higher bound (%d) or lower bound (%d) out of range (%d).", h, l, _AP_W); fprintf(
#6141 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (&__iob_func()[2])
#6141 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   , "\n"); } } while (0)

                      ;
  }


  template <int _AP_W2, bool _AP_S2>
  inline _private_range_ref<_AP_W, _AP_S>& operator|=(
      const _private_range_ref<_AP_W2, _AP_S2>& ref) {
    do { if (((h_index - l_index) != (ref.h_index - ref.l_index))) { fprintf(
#6150 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (&__iob_func()[2])
#6150 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   , "WARNING: " "Bitsize mismach for ap_private<>.range() &= " "ap_private<>.range()."); fprintf(
#6150 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (&__iob_func()[2])
#6150 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   , "\n"); } } while (0)

                                        ;
    this->d_bv |= ref.d_bv;
    return *this;
  }


  template <int _AP_W2, bool _AP_S2>
  inline _private_range_ref<_AP_W, _AP_S>& operator|=(
      const ssdm_int_sim<_AP_W2, _AP_S2>& ref) {
    do { if (((h_index - l_index + 1) != _AP_W2)) { fprintf(
#6161 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (&__iob_func()[2])
#6161 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   , "WARNING: " "Bitsize mismach for ap_private<>.range() |= _AP_ROOT_TYPE<>."); fprintf(
#6161 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (&__iob_func()[2])
#6161 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   , "\n"); } } while (0)
                                                                               ;
    this->d_bv |= ref.V;
    return *this;
  }


  template <int _AP_W2, bool _AP_S2>
  inline _private_range_ref<_AP_W, _AP_S>& operator&=(
      const _private_range_ref<_AP_W2, _AP_S2>& ref) {
    do { if (((h_index - l_index) != (ref.h_index - ref.l_index))) { fprintf(
#6171 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (&__iob_func()[2])
#6171 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   , "WARNING: " "Bitsize mismach for ap_private<>.range() &= " "ap_private<>.range()."); fprintf(
#6171 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (&__iob_func()[2])
#6171 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   , "\n"); } } while (0)

                                        ;
    this->d_bv &= ref.d_bv;
    return *this;
  };


  template <int _AP_W2, bool _AP_S2>
  inline _private_range_ref<_AP_W, _AP_S>& operator&=(
      const ssdm_int_sim<_AP_W2, _AP_S2>& ref) {
    do { if (((h_index - l_index + 1) != _AP_W2)) { fprintf(
#6182 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (&__iob_func()[2])
#6182 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   , "WARNING: " "Bitsize mismach for ap_private<>.range() &= _AP_ROOT_TYPE<>."); fprintf(
#6182 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (&__iob_func()[2])
#6182 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   , "\n"); } } while (0)
                                                                               ;
    this->d_bv &= ref.V;
    return *this;
  }


  template <int _AP_W2, bool _AP_S2>
  inline _private_range_ref<_AP_W, _AP_S>& operator^=(
      const _private_range_ref<_AP_W2, _AP_S2>& ref) {
    do { if (((h_index - l_index) != (ref.h_index - ref.l_index))) { fprintf(
#6192 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (&__iob_func()[2])
#6192 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   , "WARNING: " "Bitsize mismach for ap_private<>.range() ^= " "ap_private<>.range()."); fprintf(
#6192 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (&__iob_func()[2])
#6192 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   , "\n"); } } while (0)

                                        ;
    this->d_bv ^= ref.d_bv;
    return *this;
  };


  template <int _AP_W2, bool _AP_S2>
  inline _private_range_ref<_AP_W, _AP_S>& operator^=(
      const ssdm_int_sim<_AP_W2, _AP_S2>& ref) {
    do { if (((h_index - l_index + 1) != _AP_W2)) { fprintf(
#6203 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (&__iob_func()[2])
#6203 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   , "WARNING: " "Bitsize mismach for ap_private<>.range() ^= _AP_ROOT_TYPE<>."); fprintf(
#6203 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (&__iob_func()[2])
#6203 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   , "\n"); } } while (0)
                                                                               ;
    this->d_bv ^= ref.V;
    return *this;
  }



  inline operator ap_private<_AP_W, false>() const {
    ap_private<_AP_W, false> val(0);
    if (h_index >= l_index) {
      if (_AP_W > 64) {
        val = d_bv;
        ap_private<_AP_W, false> mask(-1);
        mask >>= _AP_W - (h_index - l_index + 1);
        val >>= l_index;
        val &= mask;
      } else {
        const static uint64_t mask = (~0ULL >> (64 > _AP_W ? (64 - _AP_W) : 0));
        val = (d_bv >> l_index) & (mask >> (_AP_W - (h_index - l_index + 1)));
      }
    } else {
      for (int i = 0, j = l_index; j >= 0 && j >= h_index; j--, i++)
        if ((d_bv)[j]) val.set(i);
    }
    return val;
  }

  inline operator unsigned long long() const { return to_uint64(); }


  template <int _AP_W2, bool _AP_S2>
  inline _private_range_ref& operator=(const ap_private<_AP_W2, _AP_S2>& val) {
    ap_private<_AP_W, false> vval = ap_private<_AP_W, false>(val);
    if (l_index > h_index) {
      for (int i = 0, j = l_index; j >= 0 && j >= h_index; j--, i++)
        (vval)[i] ? d_bv.set(j) : d_bv.clear(j);
    } else {
      if (_AP_W > 64) {
        ap_private<_AP_W, false> mask(-1);
        if (l_index > 0) {
          mask <<= l_index;
          vval <<= l_index;
        }
        if (h_index < _AP_W - 1) {
          ap_private<_AP_W, false> mask2(-1);
          mask2 >>= _AP_W - h_index - 1;
          mask &= mask2;
          vval &= mask2;
        }
        mask.flip();
        d_bv &= mask;
        d_bv |= vval;
      } else {
        unsigned shift = 64 - _AP_W;
        uint64_t mask = ~0ULL >> (shift);
        if (l_index > 0) {
          vval = mask & vval << l_index;
          mask = mask & mask << l_index;
        }
        if (h_index < _AP_W - 1) {
          uint64_t mask2 = mask;
          mask2 >>= (_AP_W - h_index - 1);
          mask &= mask2;
          vval &= mask2;
        }
        mask = ~mask;
        d_bv &= mask;
        d_bv |= vval;
      }
    }
    return *this;
  }

  inline _private_range_ref& operator=(unsigned long long val) {
    const ap_private<_AP_W, _AP_S> vval = val;
    return operator=(vval);
  }

  template <int _AP_W2, bool _AP_S2>
  inline _private_range_ref& operator=(
      const _private_bit_ref<_AP_W2, _AP_S2>& val) {
    return operator=((unsigned long long)(bool)val);
  }

  template <int _AP_W2, bool _AP_S2>
  inline _private_range_ref& operator=(
      const _private_range_ref<_AP_W2, _AP_S2>& val) {
    const ap_private<_AP_W, false> tmpVal(val);
    return operator=(tmpVal);
  }
#6304 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline _private_range_ref& operator=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=(val.to_ap_int_base().V);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline _private_range_ref& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=(val.operator ap_int_base<_AP_W2, false>().V);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline _private_range_ref& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=((unsigned long long)(bool)val);
  }
#6397 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
  template <int _AP_W2, bool _AP_S2>
  inline bool operator==(const _private_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_private<_AP_W, false> lhs = get();
    ap_private<_AP_W2, false> rhs = op2.get();
    return lhs == rhs;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator!=(const _private_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_private<_AP_W, false> lhs = get();
    ap_private<_AP_W2, false> rhs = op2.get();
    return lhs != rhs;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator>(const _private_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_private<_AP_W, false> lhs = get();
    ap_private<_AP_W2, false> rhs = op2.get();
    return lhs > rhs;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator>=(const _private_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_private<_AP_W, false> lhs = get();
    ap_private<_AP_W2, false> rhs = op2.get();
    return lhs >= rhs;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator<(const _private_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_private<_AP_W, false> lhs = get();
    ap_private<_AP_W2, false> rhs = op2.get();
    return lhs < rhs;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator<=(const _private_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_private<_AP_W, false> lhs = get();
    ap_private<_AP_W2, false> rhs = op2.get();
    return lhs <= rhs;
  }

  template <int _AP_W2>
  inline void set(const ap_private<_AP_W2, false>& val) {
    ap_private<_AP_W, _AP_S> vval = val;
    if (l_index > h_index) {
      for (int i = 0, j = l_index; j >= 0 && j >= h_index; j--, i++)
        (vval)[i] ? d_bv.set(j) : d_bv.clear(j);
    } else {
      if (_AP_W > 64) {
        ap_private<_AP_W, _AP_S> mask(-1);
        if (l_index > 0) {
          ap_private<_AP_W, false> mask1(-1);
          mask1 >>= _AP_W - l_index;
          mask1.flip();
          mask = mask1;

          vval <<= l_index;
        }
        if (h_index < _AP_W - 1) {
          ap_private<_AP_W, false> mask2(-1);
          mask2 <<= h_index + 1;
          mask2.flip();
          mask &= mask2;
          vval &= mask2;
        }
        mask.flip();
        d_bv &= mask;
        d_bv |= vval;
      } else {
        uint64_t mask = ~0ULL >> (64 - _AP_W);
        if (l_index > 0) {
          uint64_t mask1 = mask;
          mask1 = mask & (mask1 >> (_AP_W - l_index));
          vval = mask & (vval << l_index);
          mask = ~mask1 & mask;

        }
        if (h_index < _AP_W - 1) {
          uint64_t mask2 = ~0ULL >> (64 - _AP_W);
          mask2 = mask & (mask2 << (h_index + 1));
          mask &= ~mask2;
          vval &= ~mask2;
        }
        d_bv &= (~mask & (~0ULL >> (64 - _AP_W)));
        d_bv |= vval;
      }
    }
  }

  inline ap_private<_AP_W, false> get() const {
    ap_private<_AP_W, false> val(0);
    if (h_index < l_index) {
      for (int i = 0, j = l_index; j >= 0 && j >= h_index; j--, i++)
        if ((d_bv)[j]) val.set(i);
    } else {
      val = d_bv;
      val >>= l_index;
      if (h_index < _AP_W - 1) {
        if (_AP_W <= 64) {
          const static uint64_t mask =
              (~0ULL >> (64 > _AP_W ? (64 - _AP_W) : 0));
          val &= (mask >> (_AP_W - (h_index - l_index + 1)));
        } else {
          ap_private<_AP_W, false> mask(-1);
          mask >>= _AP_W - (h_index - l_index + 1);
          val &= mask;
        }
      }
    }
    return val;
  }

  inline ap_private<_AP_W, false> get() {
    ap_private<_AP_W, false> val(0);
    if (h_index < l_index) {
      for (int i = 0, j = l_index; j >= 0 && j >= h_index; j--, i++)
        if ((d_bv)[j]) val.set(i);
    } else {
      val = d_bv;
      val >>= l_index;
      if (h_index < _AP_W - 1) {
        if (_AP_W <= 64) {
          static const uint64_t mask = ~0ULL >> (64 > _AP_W ? (64 - _AP_W) : 0);
          return val &= ((mask) >> (_AP_W - (h_index - l_index + 1)));
        } else {
          ap_private<_AP_W, false> mask(-1);
          mask >>= _AP_W - (h_index - l_index + 1);
          val &= mask;
        }
      }
    }
    return val;
  }

  inline int length() const {
    return h_index >= l_index ? h_index - l_index + 1 : l_index - h_index + 1;
  }

  inline int to_int() const {
    ap_private<_AP_W, false> val = get();
    return val.to_int();
  }

  inline unsigned int to_uint() const {
    ap_private<_AP_W, false> val = get();
    return val.to_uint();
  }

  inline long to_long() const {
    ap_private<_AP_W, false> val = get();
    return val.to_long();
  }

  inline unsigned long to_ulong() const {
    ap_private<_AP_W, false> val = get();
    return val.to_ulong();
  }

  inline ap_slong to_int64() const {
    ap_private<_AP_W, false> val = get();
    return val.to_int64();
  }

  inline ap_ulong to_uint64() const {
    ap_private<_AP_W, false> val = get();
    return val.to_uint64();
  }

  inline std::string to_string(uint8_t radix = 2) const {
    return get().to_string(radix);
  }

  inline bool and_reduce() {
    bool ret = true;
    bool reverse = l_index > h_index;
    unsigned low = reverse ? h_index : l_index;
    unsigned high = reverse ? l_index : h_index;
    for (unsigned i = low; i != high; ++i) ret &= d_bv[i];
    return ret;
  }

  inline bool or_reduce() {
    bool ret = false;
    bool reverse = l_index > h_index;
    unsigned low = reverse ? h_index : l_index;
    unsigned high = reverse ? l_index : h_index;
    for (unsigned i = low; i != high; ++i) ret |= d_bv[i];
    return ret;
  }

  inline bool xor_reduce() {
    bool ret = false;
    bool reverse = l_index > h_index;
    unsigned low = reverse ? h_index : l_index;
    unsigned high = reverse ? l_index : h_index;
    for (unsigned i = low; i != high; ++i) ret ^= d_bv[i];
    return ret;
  }
};





template <int _AP_W, bool _AP_S>
struct _private_bit_ref {



  ap_private<_AP_W, _AP_S>& d_bv;
  int d_index;

 public:

  inline _private_bit_ref(const _private_bit_ref<_AP_W, _AP_S>& ref)
      : d_bv(ref.d_bv), d_index(ref.d_index) {}


  inline _private_bit_ref(ap_private<_AP_W, _AP_S>& bv, int index = 0)
      : d_bv(bv), d_index(index) {
    do { if ((d_index < 0)) { fprintf(
#6618 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (&__iob_func()[2])
#6618 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   , "WARNING: " "Index of bit vector  (%d) cannot be negative.\n", d_index); fprintf(
#6618 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (&__iob_func()[2])
#6618 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   , "\n"); } } while (0)
                        ;
    do { if ((d_index >= _AP_W)) { fprintf(
#6620 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (&__iob_func()[2])
#6620 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   , "WARNING: " "Index of bit vector (%d) out of range (%d).\n", d_index, _AP_W); fprintf(
#6620 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h" 3
   (&__iob_func()[2])
#6620 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
   , "\n"); } } while (0)
                                                                                ;
  }

  inline operator bool() const { return d_bv.get_bit(d_index); }

  inline bool to_bool() const { return operator bool(); }

  template <typename T>
  inline _private_bit_ref& operator=(const T& val) {
    if (!!val)
      d_bv.set(d_index);
    else
      d_bv.clear(d_index);
    return *this;
  }
#6722 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
  template <int _AP_W2, bool _AP_S2>
  inline bool operator==(const _private_bit_ref<_AP_W2, _AP_S2>& op) const {
    return get() == op.get();
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator!=(const _private_bit_ref<_AP_W2, _AP_S2>& op) const {
    return get() != op.get();
  }

  inline bool get() const { return operator bool(); }
#6744 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
  inline int length() const { return 1; }






};
#6772 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline PTR_TYPE* operator +(PTR_TYPE* i_op, const ap_private<_AP_W, _AP_S>& op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return i_op + op2; } template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline PTR_TYPE* operator +(const ap_private<_AP_W, _AP_S>& op, PTR_TYPE* i_op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return op2 + i_op; }
template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline PTR_TYPE* operator -(PTR_TYPE* i_op, const ap_private<_AP_W, _AP_S>& op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return i_op - op2; } template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline PTR_TYPE* operator -(const ap_private<_AP_W, _AP_S>& op, PTR_TYPE* i_op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return op2 - i_op; }
#6798 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
template <int _AP_W, bool _AP_S> inline float operator *(float i_op, const ap_private<_AP_W, _AP_S>& op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return i_op * op2; } template <int _AP_W, bool _AP_S> inline float operator *(const ap_private<_AP_W, _AP_S>& op, float i_op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return op2 * i_op; } template <int _AP_W, bool _AP_S> inline float operator /(float i_op, const ap_private<_AP_W, _AP_S>& op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return i_op / op2; } template <int _AP_W, bool _AP_S> inline float operator /(const ap_private<_AP_W, _AP_S>& op, float i_op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return op2 / i_op; } template <int _AP_W, bool _AP_S> inline float operator +(float i_op, const ap_private<_AP_W, _AP_S>& op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return i_op + op2; } template <int _AP_W, bool _AP_S> inline float operator +(const ap_private<_AP_W, _AP_S>& op, float i_op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return op2 + i_op; } template <int _AP_W, bool _AP_S> inline float operator -(float i_op, const ap_private<_AP_W, _AP_S>& op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return i_op - op2; } template <int _AP_W, bool _AP_S> inline float operator -(const ap_private<_AP_W, _AP_S>& op, float i_op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return op2 - i_op; }
template <int _AP_W, bool _AP_S> inline double operator *(double i_op, const ap_private<_AP_W, _AP_S>& op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return i_op * op2; } template <int _AP_W, bool _AP_S> inline double operator *(const ap_private<_AP_W, _AP_S>& op, double i_op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return op2 * i_op; } template <int _AP_W, bool _AP_S> inline double operator /(double i_op, const ap_private<_AP_W, _AP_S>& op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return i_op / op2; } template <int _AP_W, bool _AP_S> inline double operator /(const ap_private<_AP_W, _AP_S>& op, double i_op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return op2 / i_op; } template <int _AP_W, bool _AP_S> inline double operator +(double i_op, const ap_private<_AP_W, _AP_S>& op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return i_op + op2; } template <int _AP_W, bool _AP_S> inline double operator +(const ap_private<_AP_W, _AP_S>& op, double i_op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return op2 + i_op; } template <int _AP_W, bool _AP_S> inline double operator -(double i_op, const ap_private<_AP_W, _AP_S>& op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return i_op - op2; } template <int _AP_W, bool _AP_S> inline double operator -(const ap_private<_AP_W, _AP_S>& op, double i_op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return op2 - i_op; }
#6903 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, _AP_S>::mult operator *(bool i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(i_op).operator *(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(1), (false)>::mult operator *(const ap_private<_AP_W, _AP_S>& op, bool i_op) { return op.operator *(ap_private<(1), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, _AP_S>::plus operator +(bool i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(i_op).operator +(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(1), (false)>::plus operator +(const ap_private<_AP_W, _AP_S>& op, bool i_op) { return op.operator +(ap_private<(1), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, _AP_S>::minus operator -(bool i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(i_op).operator -(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(1), (false)>::minus operator -(const ap_private<_AP_W, _AP_S>& op, bool i_op) { return op.operator -(ap_private<(1), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, _AP_S>::div operator /(bool i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(i_op).operator /(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(1), (false)>::div operator /(const ap_private<_AP_W, _AP_S>& op, bool i_op) { return op.operator /(ap_private<(1), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, _AP_S>::mod operator %(bool i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(i_op).operator %(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(1), (false)>::mod operator %(const ap_private<_AP_W, _AP_S>& op, bool i_op) { return op.operator %(ap_private<(1), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, _AP_S>::logic operator &(bool i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(i_op).operator &(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(1), (false)>::logic operator &(const ap_private<_AP_W, _AP_S>& op, bool i_op) { return op.operator &(ap_private<(1), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, _AP_S>::logic operator |(bool i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(i_op).operator |(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(1), (false)>::logic operator |(const ap_private<_AP_W, _AP_S>& op, bool i_op) { return op.operator |(ap_private<(1), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, _AP_S>::logic operator ^(bool i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(i_op).operator ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(1), (false)>::logic operator ^(const ap_private<_AP_W, _AP_S>& op, bool i_op) { return op.operator ^(ap_private<(1), (false)>(i_op)); } template <int _AP_W, bool _AP_S> bool operator >>(bool i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op >>(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(1), (false)>::arg1 operator >>(const ap_private<_AP_W, _AP_S>& op, bool i_op) { return op.operator >>(i_op); } template <int _AP_W, bool _AP_S> bool operator <<(bool i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op <<(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(1), (false)>::arg1 operator <<(const ap_private<_AP_W, _AP_S>& op, bool i_op) { return op.operator <<(i_op); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator +=( ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator +=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator -=( ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator -=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator *=( ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator *=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator /=( ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator /=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator %=( ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator %=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator &=( ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator &=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator |=( ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator |=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator ^=( ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator ^=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator >>=( ap_private<_AP_W, _AP_S>& op, bool op2) { op = op.operator>>(op2); return op; } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator <<=( ap_private<_AP_W, _AP_S>& op, bool op2) { op = op.operator<<(op2); return op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator >(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(bool op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(1), (false)>(op2).operator >(op); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator <(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(bool op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(1), (false)>(op2).operator <(op); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator >=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(bool op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(1), (false)>(op2).operator >=(op); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator <=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(bool op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(1), (false)>(op2).operator <=(op); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator ==(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(bool op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(1), (false)>(op2).operator ==(op); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator !=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(bool op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(1), (false)>(op2).operator !=(op); }
template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, _AP_S>::mult operator *(char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(i_op).operator *(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (CHAR_IS_SIGNED)>::mult operator *(const ap_private<_AP_W, _AP_S>& op, char i_op) { return op.operator *(ap_private<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, _AP_S>::plus operator +(char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(i_op).operator +(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (CHAR_IS_SIGNED)>::plus operator +(const ap_private<_AP_W, _AP_S>& op, char i_op) { return op.operator +(ap_private<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, _AP_S>::minus operator -(char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(i_op).operator -(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (CHAR_IS_SIGNED)>::minus operator -(const ap_private<_AP_W, _AP_S>& op, char i_op) { return op.operator -(ap_private<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, _AP_S>::div operator /(char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(i_op).operator /(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (CHAR_IS_SIGNED)>::div operator /(const ap_private<_AP_W, _AP_S>& op, char i_op) { return op.operator /(ap_private<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, _AP_S>::mod operator %(char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(i_op).operator %(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (CHAR_IS_SIGNED)>::mod operator %(const ap_private<_AP_W, _AP_S>& op, char i_op) { return op.operator %(ap_private<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, _AP_S>::logic operator &(char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(i_op).operator &(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator &(const ap_private<_AP_W, _AP_S>& op, char i_op) { return op.operator &(ap_private<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, _AP_S>::logic operator |(char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(i_op).operator |(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator |(const ap_private<_AP_W, _AP_S>& op, char i_op) { return op.operator |(ap_private<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, _AP_S>::logic operator ^(char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(i_op).operator ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator ^(const ap_private<_AP_W, _AP_S>& op, char i_op) { return op.operator ^(ap_private<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, bool _AP_S> char operator >>(char i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op >>(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (CHAR_IS_SIGNED)>::arg1 operator >>(const ap_private<_AP_W, _AP_S>& op, char i_op) { return op.operator >>(i_op); } template <int _AP_W, bool _AP_S> char operator <<(char i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op <<(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (CHAR_IS_SIGNED)>::arg1 operator <<(const ap_private<_AP_W, _AP_S>& op, char i_op) { return op.operator <<(i_op); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator +=( ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator +=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator -=( ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator -=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator *=( ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator *=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator /=( ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator /=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator %=( ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator %=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator &=( ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator &=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator |=( ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator |=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator ^=( ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator ^=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator >>=( ap_private<_AP_W, _AP_S>& op, char op2) { op = op.operator>>(op2); return op; } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator <<=( ap_private<_AP_W, _AP_S>& op, char op2) { op = op.operator<<(op2); return op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator >(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator >(op); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator <(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator <(op); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator >=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator >=(op); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator <=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator <=(op); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator ==(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator ==(op); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator !=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator !=(op); }
template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, _AP_S>::mult operator *(signed char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(i_op).operator *(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (true)>::mult operator *(const ap_private<_AP_W, _AP_S>& op, signed char i_op) { return op.operator *(ap_private<(8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, _AP_S>::plus operator +(signed char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(i_op).operator +(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (true)>::plus operator +(const ap_private<_AP_W, _AP_S>& op, signed char i_op) { return op.operator +(ap_private<(8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, _AP_S>::minus operator -(signed char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(i_op).operator -(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (true)>::minus operator -(const ap_private<_AP_W, _AP_S>& op, signed char i_op) { return op.operator -(ap_private<(8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, _AP_S>::div operator /(signed char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(i_op).operator /(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (true)>::div operator /(const ap_private<_AP_W, _AP_S>& op, signed char i_op) { return op.operator /(ap_private<(8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, _AP_S>::mod operator %(signed char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(i_op).operator %(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (true)>::mod operator %(const ap_private<_AP_W, _AP_S>& op, signed char i_op) { return op.operator %(ap_private<(8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, _AP_S>::logic operator &(signed char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(i_op).operator &(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (true)>::logic operator &(const ap_private<_AP_W, _AP_S>& op, signed char i_op) { return op.operator &(ap_private<(8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, _AP_S>::logic operator |(signed char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(i_op).operator |(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (true)>::logic operator |(const ap_private<_AP_W, _AP_S>& op, signed char i_op) { return op.operator |(ap_private<(8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, _AP_S>::logic operator ^(signed char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(i_op).operator ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (true)>::logic operator ^(const ap_private<_AP_W, _AP_S>& op, signed char i_op) { return op.operator ^(ap_private<(8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> signed char operator >>(signed char i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op >>(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (true)>::arg1 operator >>(const ap_private<_AP_W, _AP_S>& op, signed char i_op) { return op.operator >>(i_op); } template <int _AP_W, bool _AP_S> signed char operator <<(signed char i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op <<(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (true)>::arg1 operator <<(const ap_private<_AP_W, _AP_S>& op, signed char i_op) { return op.operator <<(i_op); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator +=( ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator +=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator -=( ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator -=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator *=( ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator *=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator /=( ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator /=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator %=( ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator %=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator &=( ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator &=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator |=( ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator |=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator ^=( ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator ^=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator >>=( ap_private<_AP_W, _AP_S>& op, signed char op2) { op = op.operator>>(op2); return op; } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator <<=( ap_private<_AP_W, _AP_S>& op, signed char op2) { op = op.operator<<(op2); return op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator >(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(signed char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (true)>(op2).operator >(op); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator <(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(signed char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (true)>(op2).operator <(op); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator >=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(signed char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (true)>(op2).operator >=(op); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator <=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(signed char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (true)>(op2).operator <=(op); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator ==(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(signed char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (true)>(op2).operator ==(op); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator !=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(signed char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (true)>(op2).operator !=(op); }
template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, _AP_S>::mult operator *(unsigned char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(i_op).operator *(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (false)>::mult operator *(const ap_private<_AP_W, _AP_S>& op, unsigned char i_op) { return op.operator *(ap_private<(8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, _AP_S>::plus operator +(unsigned char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(i_op).operator +(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (false)>::plus operator +(const ap_private<_AP_W, _AP_S>& op, unsigned char i_op) { return op.operator +(ap_private<(8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, _AP_S>::minus operator -(unsigned char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(i_op).operator -(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (false)>::minus operator -(const ap_private<_AP_W, _AP_S>& op, unsigned char i_op) { return op.operator -(ap_private<(8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, _AP_S>::div operator /(unsigned char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(i_op).operator /(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (false)>::div operator /(const ap_private<_AP_W, _AP_S>& op, unsigned char i_op) { return op.operator /(ap_private<(8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, _AP_S>::mod operator %(unsigned char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(i_op).operator %(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (false)>::mod operator %(const ap_private<_AP_W, _AP_S>& op, unsigned char i_op) { return op.operator %(ap_private<(8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, _AP_S>::logic operator &(unsigned char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(i_op).operator &(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (false)>::logic operator &(const ap_private<_AP_W, _AP_S>& op, unsigned char i_op) { return op.operator &(ap_private<(8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, _AP_S>::logic operator |(unsigned char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(i_op).operator |(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (false)>::logic operator |(const ap_private<_AP_W, _AP_S>& op, unsigned char i_op) { return op.operator |(ap_private<(8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, _AP_S>::logic operator ^(unsigned char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(i_op).operator ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (false)>::logic operator ^(const ap_private<_AP_W, _AP_S>& op, unsigned char i_op) { return op.operator ^(ap_private<(8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> unsigned char operator >>(unsigned char i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op >>(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (false)>::arg1 operator >>(const ap_private<_AP_W, _AP_S>& op, unsigned char i_op) { return op.operator >>(i_op); } template <int _AP_W, bool _AP_S> unsigned char operator <<(unsigned char i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op <<(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (false)>::arg1 operator <<(const ap_private<_AP_W, _AP_S>& op, unsigned char i_op) { return op.operator <<(i_op); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator +=( ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator +=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator -=( ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator -=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator *=( ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator *=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator /=( ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator /=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator %=( ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator %=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator &=( ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator &=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator |=( ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator |=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator ^=( ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator ^=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator >>=( ap_private<_AP_W, _AP_S>& op, unsigned char op2) { op = op.operator>>(op2); return op; } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator <<=( ap_private<_AP_W, _AP_S>& op, unsigned char op2) { op = op.operator<<(op2); return op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator >(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (false)>(op2).operator >(op); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator <(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (false)>(op2).operator <(op); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator >=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (false)>(op2).operator >=(op); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator <=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (false)>(op2).operator <=(op); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator ==(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (false)>(op2).operator ==(op); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator !=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (false)>(op2).operator !=(op); }
template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, _AP_S>::mult operator *(short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(i_op).operator *(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(short) * 8), (true)>::mult operator *(const ap_private<_AP_W, _AP_S>& op, short i_op) { return op.operator *(ap_private<(sizeof(short) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, _AP_S>::plus operator +(short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(i_op).operator +(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(short) * 8), (true)>::plus operator +(const ap_private<_AP_W, _AP_S>& op, short i_op) { return op.operator +(ap_private<(sizeof(short) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, _AP_S>::minus operator -(short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(i_op).operator -(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(short) * 8), (true)>::minus operator -(const ap_private<_AP_W, _AP_S>& op, short i_op) { return op.operator -(ap_private<(sizeof(short) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, _AP_S>::div operator /(short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(i_op).operator /(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(short) * 8), (true)>::div operator /(const ap_private<_AP_W, _AP_S>& op, short i_op) { return op.operator /(ap_private<(sizeof(short) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, _AP_S>::mod operator %(short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(i_op).operator %(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(short) * 8), (true)>::mod operator %(const ap_private<_AP_W, _AP_S>& op, short i_op) { return op.operator %(ap_private<(sizeof(short) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, _AP_S>::logic operator &(short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(i_op).operator &(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(short) * 8), (true)>::logic operator &(const ap_private<_AP_W, _AP_S>& op, short i_op) { return op.operator &(ap_private<(sizeof(short) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, _AP_S>::logic operator |(short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(i_op).operator |(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(short) * 8), (true)>::logic operator |(const ap_private<_AP_W, _AP_S>& op, short i_op) { return op.operator |(ap_private<(sizeof(short) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, _AP_S>::logic operator ^(short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(i_op).operator ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(short) * 8), (true)>::logic operator ^(const ap_private<_AP_W, _AP_S>& op, short i_op) { return op.operator ^(ap_private<(sizeof(short) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> short operator >>(short i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op >>(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(short) * 8), (true)>::arg1 operator >>(const ap_private<_AP_W, _AP_S>& op, short i_op) { return op.operator >>(i_op); } template <int _AP_W, bool _AP_S> short operator <<(short i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op <<(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(short) * 8), (true)>::arg1 operator <<(const ap_private<_AP_W, _AP_S>& op, short i_op) { return op.operator <<(i_op); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator +=( ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator +=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator -=( ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator -=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator *=( ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator *=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator /=( ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator /=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator %=( ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator %=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator &=( ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator &=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator |=( ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator |=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator ^=( ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator ^=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator >>=( ap_private<_AP_W, _AP_S>& op, short op2) { op = op.operator>>(op2); return op; } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator <<=( ap_private<_AP_W, _AP_S>& op, short op2) { op = op.operator<<(op2); return op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator >(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(short op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator >(op); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator <(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(short op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator <(op); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator >=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(short op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator >=(op); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator <=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(short op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator <=(op); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator ==(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(short op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator ==(op); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator !=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(short op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator !=(op); }
template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, _AP_S>::mult operator *(unsigned short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(i_op).operator *(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned short) * 8), (false)>::mult operator *(const ap_private<_AP_W, _AP_S>& op, unsigned short i_op) { return op.operator *(ap_private<(sizeof(unsigned short) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, _AP_S>::plus operator +(unsigned short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(i_op).operator +(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned short) * 8), (false)>::plus operator +(const ap_private<_AP_W, _AP_S>& op, unsigned short i_op) { return op.operator +(ap_private<(sizeof(unsigned short) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, _AP_S>::minus operator -(unsigned short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(i_op).operator -(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned short) * 8), (false)>::minus operator -(const ap_private<_AP_W, _AP_S>& op, unsigned short i_op) { return op.operator -(ap_private<(sizeof(unsigned short) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, _AP_S>::div operator /(unsigned short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(i_op).operator /(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned short) * 8), (false)>::div operator /(const ap_private<_AP_W, _AP_S>& op, unsigned short i_op) { return op.operator /(ap_private<(sizeof(unsigned short) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, _AP_S>::mod operator %(unsigned short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(i_op).operator %(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned short) * 8), (false)>::mod operator %(const ap_private<_AP_W, _AP_S>& op, unsigned short i_op) { return op.operator %(ap_private<(sizeof(unsigned short) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, _AP_S>::logic operator &(unsigned short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(i_op).operator &(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned short) * 8), (false)>::logic operator &(const ap_private<_AP_W, _AP_S>& op, unsigned short i_op) { return op.operator &(ap_private<(sizeof(unsigned short) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, _AP_S>::logic operator |(unsigned short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(i_op).operator |(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned short) * 8), (false)>::logic operator |(const ap_private<_AP_W, _AP_S>& op, unsigned short i_op) { return op.operator |(ap_private<(sizeof(unsigned short) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, _AP_S>::logic operator ^(unsigned short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(i_op).operator ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned short) * 8), (false)>::logic operator ^(const ap_private<_AP_W, _AP_S>& op, unsigned short i_op) { return op.operator ^(ap_private<(sizeof(unsigned short) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> unsigned short operator >>(unsigned short i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op >>(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned short) * 8), (false)>::arg1 operator >>(const ap_private<_AP_W, _AP_S>& op, unsigned short i_op) { return op.operator >>(i_op); } template <int _AP_W, bool _AP_S> unsigned short operator <<(unsigned short i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op <<(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned short) * 8), (false)>::arg1 operator <<(const ap_private<_AP_W, _AP_S>& op, unsigned short i_op) { return op.operator <<(i_op); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator +=( ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator +=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator -=( ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator -=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator *=( ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator *=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator /=( ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator /=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator %=( ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator %=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator &=( ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator &=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator |=( ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator |=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator ^=( ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator ^=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator >>=( ap_private<_AP_W, _AP_S>& op, unsigned short op2) { op = op.operator>>(op2); return op; } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator <<=( ap_private<_AP_W, _AP_S>& op, unsigned short op2) { op = op.operator<<(op2); return op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator >(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned short op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator >(op); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator <(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned short op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator <(op); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator >=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned short op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator >=(op); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator <=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned short op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator <=(op); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator ==(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned short op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator ==(op); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator !=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned short op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator !=(op); }
template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, _AP_S>::mult operator *(int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(i_op).operator *(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(int) * 8), (true)>::mult operator *(const ap_private<_AP_W, _AP_S>& op, int i_op) { return op.operator *(ap_private<(sizeof(int) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, _AP_S>::plus operator +(int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(i_op).operator +(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(int) * 8), (true)>::plus operator +(const ap_private<_AP_W, _AP_S>& op, int i_op) { return op.operator +(ap_private<(sizeof(int) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, _AP_S>::minus operator -(int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(i_op).operator -(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(int) * 8), (true)>::minus operator -(const ap_private<_AP_W, _AP_S>& op, int i_op) { return op.operator -(ap_private<(sizeof(int) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, _AP_S>::div operator /(int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(i_op).operator /(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(int) * 8), (true)>::div operator /(const ap_private<_AP_W, _AP_S>& op, int i_op) { return op.operator /(ap_private<(sizeof(int) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, _AP_S>::mod operator %(int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(i_op).operator %(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(int) * 8), (true)>::mod operator %(const ap_private<_AP_W, _AP_S>& op, int i_op) { return op.operator %(ap_private<(sizeof(int) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, _AP_S>::logic operator &(int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(i_op).operator &(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(int) * 8), (true)>::logic operator &(const ap_private<_AP_W, _AP_S>& op, int i_op) { return op.operator &(ap_private<(sizeof(int) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, _AP_S>::logic operator |(int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(i_op).operator |(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(int) * 8), (true)>::logic operator |(const ap_private<_AP_W, _AP_S>& op, int i_op) { return op.operator |(ap_private<(sizeof(int) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, _AP_S>::logic operator ^(int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(i_op).operator ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(int) * 8), (true)>::logic operator ^(const ap_private<_AP_W, _AP_S>& op, int i_op) { return op.operator ^(ap_private<(sizeof(int) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> int operator >>(int i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op >>(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(int) * 8), (true)>::arg1 operator >>(const ap_private<_AP_W, _AP_S>& op, int i_op) { return op.operator >>(i_op); } template <int _AP_W, bool _AP_S> int operator <<(int i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op <<(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(int) * 8), (true)>::arg1 operator <<(const ap_private<_AP_W, _AP_S>& op, int i_op) { return op.operator <<(i_op); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator +=( ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator +=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator -=( ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator -=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator *=( ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator *=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator /=( ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator /=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator %=( ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator %=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator &=( ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator &=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator |=( ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator |=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator ^=( ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator ^=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator >>=( ap_private<_AP_W, _AP_S>& op, int op2) { op = op.operator>>(op2); return op; } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator <<=( ap_private<_AP_W, _AP_S>& op, int op2) { op = op.operator<<(op2); return op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator >(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(int op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator >(op); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator <(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(int op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator <(op); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator >=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(int op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator >=(op); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator <=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(int op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator <=(op); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator ==(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(int op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator ==(op); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator !=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(int op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator !=(op); }
template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, _AP_S>::mult operator *(unsigned int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(i_op).operator *(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned int) * 8), (false)>::mult operator *(const ap_private<_AP_W, _AP_S>& op, unsigned int i_op) { return op.operator *(ap_private<(sizeof(unsigned int) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, _AP_S>::plus operator +(unsigned int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(i_op).operator +(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned int) * 8), (false)>::plus operator +(const ap_private<_AP_W, _AP_S>& op, unsigned int i_op) { return op.operator +(ap_private<(sizeof(unsigned int) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, _AP_S>::minus operator -(unsigned int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(i_op).operator -(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned int) * 8), (false)>::minus operator -(const ap_private<_AP_W, _AP_S>& op, unsigned int i_op) { return op.operator -(ap_private<(sizeof(unsigned int) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, _AP_S>::div operator /(unsigned int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(i_op).operator /(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned int) * 8), (false)>::div operator /(const ap_private<_AP_W, _AP_S>& op, unsigned int i_op) { return op.operator /(ap_private<(sizeof(unsigned int) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, _AP_S>::mod operator %(unsigned int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(i_op).operator %(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned int) * 8), (false)>::mod operator %(const ap_private<_AP_W, _AP_S>& op, unsigned int i_op) { return op.operator %(ap_private<(sizeof(unsigned int) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, _AP_S>::logic operator &(unsigned int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(i_op).operator &(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned int) * 8), (false)>::logic operator &(const ap_private<_AP_W, _AP_S>& op, unsigned int i_op) { return op.operator &(ap_private<(sizeof(unsigned int) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, _AP_S>::logic operator |(unsigned int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(i_op).operator |(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned int) * 8), (false)>::logic operator |(const ap_private<_AP_W, _AP_S>& op, unsigned int i_op) { return op.operator |(ap_private<(sizeof(unsigned int) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, _AP_S>::logic operator ^(unsigned int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(i_op).operator ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned int) * 8), (false)>::logic operator ^(const ap_private<_AP_W, _AP_S>& op, unsigned int i_op) { return op.operator ^(ap_private<(sizeof(unsigned int) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> unsigned int operator >>(unsigned int i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op >>(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned int) * 8), (false)>::arg1 operator >>(const ap_private<_AP_W, _AP_S>& op, unsigned int i_op) { return op.operator >>(i_op); } template <int _AP_W, bool _AP_S> unsigned int operator <<(unsigned int i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op <<(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned int) * 8), (false)>::arg1 operator <<(const ap_private<_AP_W, _AP_S>& op, unsigned int i_op) { return op.operator <<(i_op); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator +=( ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator +=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator -=( ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator -=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator *=( ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator *=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator /=( ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator /=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator %=( ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator %=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator &=( ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator &=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator |=( ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator |=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator ^=( ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator ^=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator >>=( ap_private<_AP_W, _AP_S>& op, unsigned int op2) { op = op.operator>>(op2); return op; } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator <<=( ap_private<_AP_W, _AP_S>& op, unsigned int op2) { op = op.operator<<(op2); return op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator >(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned int op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator >(op); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator <(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned int op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator <(op); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator >=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned int op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator >=(op); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator <=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned int op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator <=(op); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator ==(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned int op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator ==(op); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator !=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned int op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator !=(op); }
template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, _AP_S>::mult operator *(long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(i_op).operator *(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(long) * 8), (true)>::mult operator *(const ap_private<_AP_W, _AP_S>& op, long i_op) { return op.operator *(ap_private<(sizeof(long) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, _AP_S>::plus operator +(long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(i_op).operator +(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(long) * 8), (true)>::plus operator +(const ap_private<_AP_W, _AP_S>& op, long i_op) { return op.operator +(ap_private<(sizeof(long) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, _AP_S>::minus operator -(long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(i_op).operator -(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(long) * 8), (true)>::minus operator -(const ap_private<_AP_W, _AP_S>& op, long i_op) { return op.operator -(ap_private<(sizeof(long) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, _AP_S>::div operator /(long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(i_op).operator /(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(long) * 8), (true)>::div operator /(const ap_private<_AP_W, _AP_S>& op, long i_op) { return op.operator /(ap_private<(sizeof(long) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, _AP_S>::mod operator %(long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(i_op).operator %(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(long) * 8), (true)>::mod operator %(const ap_private<_AP_W, _AP_S>& op, long i_op) { return op.operator %(ap_private<(sizeof(long) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, _AP_S>::logic operator &(long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(i_op).operator &(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(long) * 8), (true)>::logic operator &(const ap_private<_AP_W, _AP_S>& op, long i_op) { return op.operator &(ap_private<(sizeof(long) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, _AP_S>::logic operator |(long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(i_op).operator |(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(long) * 8), (true)>::logic operator |(const ap_private<_AP_W, _AP_S>& op, long i_op) { return op.operator |(ap_private<(sizeof(long) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, _AP_S>::logic operator ^(long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(i_op).operator ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(long) * 8), (true)>::logic operator ^(const ap_private<_AP_W, _AP_S>& op, long i_op) { return op.operator ^(ap_private<(sizeof(long) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> long operator >>(long i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op >>(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(long) * 8), (true)>::arg1 operator >>(const ap_private<_AP_W, _AP_S>& op, long i_op) { return op.operator >>(i_op); } template <int _AP_W, bool _AP_S> long operator <<(long i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op <<(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(long) * 8), (true)>::arg1 operator <<(const ap_private<_AP_W, _AP_S>& op, long i_op) { return op.operator <<(i_op); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator +=( ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator +=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator -=( ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator -=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator *=( ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator *=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator /=( ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator /=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator %=( ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator %=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator &=( ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator &=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator |=( ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator |=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator ^=( ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator ^=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator >>=( ap_private<_AP_W, _AP_S>& op, long op2) { op = op.operator>>(op2); return op; } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator <<=( ap_private<_AP_W, _AP_S>& op, long op2) { op = op.operator<<(op2); return op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator >(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(long op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator >(op); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator <(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(long op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator <(op); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator >=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(long op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator >=(op); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator <=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(long op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator <=(op); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator ==(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(long op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator ==(op); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator !=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(long op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator !=(op); }
template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, _AP_S>::mult operator *(unsigned long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(i_op).operator *(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned long) * 8), (false)>::mult operator *(const ap_private<_AP_W, _AP_S>& op, unsigned long i_op) { return op.operator *(ap_private<(sizeof(unsigned long) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, _AP_S>::plus operator +(unsigned long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(i_op).operator +(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned long) * 8), (false)>::plus operator +(const ap_private<_AP_W, _AP_S>& op, unsigned long i_op) { return op.operator +(ap_private<(sizeof(unsigned long) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, _AP_S>::minus operator -(unsigned long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(i_op).operator -(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned long) * 8), (false)>::minus operator -(const ap_private<_AP_W, _AP_S>& op, unsigned long i_op) { return op.operator -(ap_private<(sizeof(unsigned long) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, _AP_S>::div operator /(unsigned long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(i_op).operator /(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned long) * 8), (false)>::div operator /(const ap_private<_AP_W, _AP_S>& op, unsigned long i_op) { return op.operator /(ap_private<(sizeof(unsigned long) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, _AP_S>::mod operator %(unsigned long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(i_op).operator %(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned long) * 8), (false)>::mod operator %(const ap_private<_AP_W, _AP_S>& op, unsigned long i_op) { return op.operator %(ap_private<(sizeof(unsigned long) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, _AP_S>::logic operator &(unsigned long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(i_op).operator &(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned long) * 8), (false)>::logic operator &(const ap_private<_AP_W, _AP_S>& op, unsigned long i_op) { return op.operator &(ap_private<(sizeof(unsigned long) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, _AP_S>::logic operator |(unsigned long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(i_op).operator |(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned long) * 8), (false)>::logic operator |(const ap_private<_AP_W, _AP_S>& op, unsigned long i_op) { return op.operator |(ap_private<(sizeof(unsigned long) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, _AP_S>::logic operator ^(unsigned long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(i_op).operator ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned long) * 8), (false)>::logic operator ^(const ap_private<_AP_W, _AP_S>& op, unsigned long i_op) { return op.operator ^(ap_private<(sizeof(unsigned long) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> unsigned long operator >>(unsigned long i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op >>(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned long) * 8), (false)>::arg1 operator >>(const ap_private<_AP_W, _AP_S>& op, unsigned long i_op) { return op.operator >>(i_op); } template <int _AP_W, bool _AP_S> unsigned long operator <<(unsigned long i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op <<(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned long) * 8), (false)>::arg1 operator <<(const ap_private<_AP_W, _AP_S>& op, unsigned long i_op) { return op.operator <<(i_op); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator +=( ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator +=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator -=( ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator -=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator *=( ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator *=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator /=( ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator /=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator %=( ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator %=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator &=( ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator &=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator |=( ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator |=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator ^=( ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator ^=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator >>=( ap_private<_AP_W, _AP_S>& op, unsigned long op2) { op = op.operator>>(op2); return op; } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator <<=( ap_private<_AP_W, _AP_S>& op, unsigned long op2) { op = op.operator<<(op2); return op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator >(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned long op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator >(op); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator <(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned long op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator <(op); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator >=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned long op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator >=(op); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator <=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned long op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator <=(op); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator ==(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned long op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator ==(op); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator !=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned long op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator !=(op); }
template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, _AP_S>::mult operator *(ap_slong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(i_op).operator *(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_slong) * 8), (true)>::mult operator *(const ap_private<_AP_W, _AP_S>& op, ap_slong i_op) { return op.operator *(ap_private<(sizeof(ap_slong) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, _AP_S>::plus operator +(ap_slong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(i_op).operator +(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_slong) * 8), (true)>::plus operator +(const ap_private<_AP_W, _AP_S>& op, ap_slong i_op) { return op.operator +(ap_private<(sizeof(ap_slong) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, _AP_S>::minus operator -(ap_slong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(i_op).operator -(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_slong) * 8), (true)>::minus operator -(const ap_private<_AP_W, _AP_S>& op, ap_slong i_op) { return op.operator -(ap_private<(sizeof(ap_slong) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, _AP_S>::div operator /(ap_slong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(i_op).operator /(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_slong) * 8), (true)>::div operator /(const ap_private<_AP_W, _AP_S>& op, ap_slong i_op) { return op.operator /(ap_private<(sizeof(ap_slong) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, _AP_S>::mod operator %(ap_slong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(i_op).operator %(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_slong) * 8), (true)>::mod operator %(const ap_private<_AP_W, _AP_S>& op, ap_slong i_op) { return op.operator %(ap_private<(sizeof(ap_slong) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, _AP_S>::logic operator &(ap_slong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(i_op).operator &(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_slong) * 8), (true)>::logic operator &(const ap_private<_AP_W, _AP_S>& op, ap_slong i_op) { return op.operator &(ap_private<(sizeof(ap_slong) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, _AP_S>::logic operator |(ap_slong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(i_op).operator |(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_slong) * 8), (true)>::logic operator |(const ap_private<_AP_W, _AP_S>& op, ap_slong i_op) { return op.operator |(ap_private<(sizeof(ap_slong) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, _AP_S>::logic operator ^(ap_slong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(i_op).operator ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_slong) * 8), (true)>::logic operator ^(const ap_private<_AP_W, _AP_S>& op, ap_slong i_op) { return op.operator ^(ap_private<(sizeof(ap_slong) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> ap_slong operator >>(ap_slong i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op >>(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_slong) * 8), (true)>::arg1 operator >>(const ap_private<_AP_W, _AP_S>& op, ap_slong i_op) { return op.operator >>(i_op); } template <int _AP_W, bool _AP_S> ap_slong operator <<(ap_slong i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op <<(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_slong) * 8), (true)>::arg1 operator <<(const ap_private<_AP_W, _AP_S>& op, ap_slong i_op) { return op.operator <<(i_op); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator +=( ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator +=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator -=( ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator -=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator *=( ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator *=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator /=( ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator /=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator %=( ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator %=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator &=( ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator &=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator |=( ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator |=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator ^=( ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator ^=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator >>=( ap_private<_AP_W, _AP_S>& op, ap_slong op2) { op = op.operator>>(op2); return op; } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator <<=( ap_private<_AP_W, _AP_S>& op, ap_slong op2) { op = op.operator<<(op2); return op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator >(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(ap_slong op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator >(op); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator <(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(ap_slong op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator <(op); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator >=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(ap_slong op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator >=(op); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator <=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(ap_slong op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator <=(op); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator ==(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(ap_slong op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator ==(op); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator !=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(ap_slong op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator !=(op); }
template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, _AP_S>::mult operator *(ap_ulong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op).operator *(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_ulong) * 8), (false)>::mult operator *(const ap_private<_AP_W, _AP_S>& op, ap_ulong i_op) { return op.operator *(ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, _AP_S>::plus operator +(ap_ulong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op).operator +(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_ulong) * 8), (false)>::plus operator +(const ap_private<_AP_W, _AP_S>& op, ap_ulong i_op) { return op.operator +(ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, _AP_S>::minus operator -(ap_ulong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op).operator -(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_ulong) * 8), (false)>::minus operator -(const ap_private<_AP_W, _AP_S>& op, ap_ulong i_op) { return op.operator -(ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, _AP_S>::div operator /(ap_ulong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op).operator /(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_ulong) * 8), (false)>::div operator /(const ap_private<_AP_W, _AP_S>& op, ap_ulong i_op) { return op.operator /(ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, _AP_S>::mod operator %(ap_ulong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op).operator %(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_ulong) * 8), (false)>::mod operator %(const ap_private<_AP_W, _AP_S>& op, ap_ulong i_op) { return op.operator %(ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, _AP_S>::logic operator &(ap_ulong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op).operator &(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_ulong) * 8), (false)>::logic operator &(const ap_private<_AP_W, _AP_S>& op, ap_ulong i_op) { return op.operator &(ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, _AP_S>::logic operator |(ap_ulong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op).operator |(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_ulong) * 8), (false)>::logic operator |(const ap_private<_AP_W, _AP_S>& op, ap_ulong i_op) { return op.operator |(ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, _AP_S>::logic operator ^(ap_ulong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op).operator ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_ulong) * 8), (false)>::logic operator ^(const ap_private<_AP_W, _AP_S>& op, ap_ulong i_op) { return op.operator ^(ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> ap_ulong operator >>(ap_ulong i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op >>(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_ulong) * 8), (false)>::arg1 operator >>(const ap_private<_AP_W, _AP_S>& op, ap_ulong i_op) { return op.operator >>(i_op); } template <int _AP_W, bool _AP_S> ap_ulong operator <<(ap_ulong i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op <<(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_ulong) * 8), (false)>::arg1 operator <<(const ap_private<_AP_W, _AP_S>& op, ap_ulong i_op) { return op.operator <<(i_op); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator +=( ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator +=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator -=( ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator -=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator *=( ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator *=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator /=( ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator /=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator %=( ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator %=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator &=( ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator &=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator |=( ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator |=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator ^=( ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator ^=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator >>=( ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { op = op.operator>>(op2); return op; } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator <<=( ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { op = op.operator<<(op2); return op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator >(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(ap_ulong op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator >(op); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator <(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(ap_ulong op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator <(op); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator >=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(ap_ulong op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator >=(op); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator <=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(ap_ulong op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator <=(op); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator ==(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(ap_ulong op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator ==(op); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator !=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(ap_ulong op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator !=(op); }
#6969 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::plus operator +(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator +(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::plus operator +(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator +(ap_private<_AP_W2, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::minus operator -(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator -(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::minus operator -(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator -(ap_private<_AP_W2, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mult operator *(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator *(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mult operator *(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator *(ap_private<_AP_W2, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::div operator /(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator /(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::div operator /(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator /(ap_private<_AP_W2, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mod operator %(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator %(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mod operator %(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator %(ap_private<_AP_W2, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator &(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator &(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator &(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator &(ap_private<_AP_W2, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator |(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator |(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator |(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator |(ap_private<_AP_W2, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator ^(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator ^(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator ^(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator ^(ap_private<_AP_W2, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator >>(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator >>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator >>(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >>(ap_private<_AP_W2, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator <<(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator <<(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator <<(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <<(ap_private<_AP_W2, false>(op2)); }


template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator +=( ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator +=(ap_private<_AP_W2, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_range_ref<_AP_W1, _AP_S1>& operator +=( _private_range_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator +=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator -=( ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator -=(ap_private<_AP_W2, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_range_ref<_AP_W1, _AP_S1>& operator -=( _private_range_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator -=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator *=( ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator *=(ap_private<_AP_W2, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_range_ref<_AP_W1, _AP_S1>& operator *=( _private_range_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator *=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator /=( ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator /=(ap_private<_AP_W2, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_range_ref<_AP_W1, _AP_S1>& operator /=( _private_range_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator /=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator %=( ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator %=(ap_private<_AP_W2, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_range_ref<_AP_W1, _AP_S1>& operator %=( _private_range_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator %=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator &=( ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator &=(ap_private<_AP_W2, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_range_ref<_AP_W1, _AP_S1>& operator &=( _private_range_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator &=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator |=( ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator |=(ap_private<_AP_W2, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_range_ref<_AP_W1, _AP_S1>& operator |=( _private_range_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator |=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator ^=( ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator ^=(ap_private<_AP_W2, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_range_ref<_AP_W1, _AP_S1>& operator ^=( _private_range_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator ^=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator >>=( ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >>=(ap_private<_AP_W2, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_range_ref<_AP_W1, _AP_S1>& operator >>=( _private_range_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator >>=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator <<=( ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <<=(ap_private<_AP_W2, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_range_ref<_AP_W1, _AP_S1>& operator <<=( _private_range_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator <<=(op2); op1 = tmp; return op1; }


template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator >(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >(op2.operator ap_private<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator <(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <(op2.operator ap_private<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >=(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator >=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >=(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >=(op2.operator ap_private<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <=(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator <=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <=(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <=(op2.operator ap_private<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator ==(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator ==(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator ==(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator ==(op2.operator ap_private<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator !=(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator !=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator !=(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator !=(op2.operator ap_private<_AP_W2, false>()); }
#7044 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator +=( ap_private<_AP_W1, _AP_S1>& op1, _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator +=(ap_private<1, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_bit_ref<_AP_W1, _AP_S1>& operator +=( _private_bit_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator +=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator -=( ap_private<_AP_W1, _AP_S1>& op1, _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator -=(ap_private<1, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_bit_ref<_AP_W1, _AP_S1>& operator -=( _private_bit_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator -=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator *=( ap_private<_AP_W1, _AP_S1>& op1, _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator *=(ap_private<1, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_bit_ref<_AP_W1, _AP_S1>& operator *=( _private_bit_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator *=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator /=( ap_private<_AP_W1, _AP_S1>& op1, _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator /=(ap_private<1, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_bit_ref<_AP_W1, _AP_S1>& operator /=( _private_bit_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator /=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator %=( ap_private<_AP_W1, _AP_S1>& op1, _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator %=(ap_private<1, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_bit_ref<_AP_W1, _AP_S1>& operator %=( _private_bit_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator %=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator &=( ap_private<_AP_W1, _AP_S1>& op1, _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator &=(ap_private<1, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_bit_ref<_AP_W1, _AP_S1>& operator &=( _private_bit_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator &=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator |=( ap_private<_AP_W1, _AP_S1>& op1, _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator |=(ap_private<1, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_bit_ref<_AP_W1, _AP_S1>& operator |=( _private_bit_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator |=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator ^=( ap_private<_AP_W1, _AP_S1>& op1, _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator ^=(ap_private<1, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_bit_ref<_AP_W1, _AP_S1>& operator ^=( _private_bit_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator ^=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator >>=( ap_private<_AP_W1, _AP_S1>& op1, _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >>=(ap_private<1, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_bit_ref<_AP_W1, _AP_S1>& operator >>=( _private_bit_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator >>=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator <<=( ap_private<_AP_W1, _AP_S1>& op1, _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <<=(ap_private<1, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_bit_ref<_AP_W1, _AP_S1>& operator <<=( _private_bit_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator <<=(op2); op1 = tmp; return op1; }


template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2, _AP_S2>::plus operator +(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<1, false>(op1).operator +(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<1, false>::plus operator +(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator +(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2, _AP_S2>::minus operator -(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<1, false>(op1).operator -(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<1, false>::minus operator -(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator -(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2, _AP_S2>::mult operator *(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<1, false>(op1).operator *(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<1, false>::mult operator *(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator *(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2, _AP_S2>::div operator /(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<1, false>(op1).operator /(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<1, false>::div operator /(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator /(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2, _AP_S2>::mod operator %(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<1, false>(op1).operator %(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<1, false>::mod operator %(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator %(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2, _AP_S2>::logic operator &(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<1, false>(op1).operator &(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<1, false>::logic operator &(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator &(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2, _AP_S2>::logic operator |(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<1, false>(op1).operator |(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<1, false>::logic operator |(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator |(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2, _AP_S2>::logic operator ^(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<1, false>(op1).operator ^(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<1, false>::logic operator ^(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator ^(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2, _AP_S2>::arg1 operator >>(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<1, false>(op1).operator >>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<1, false>::arg1 operator >>(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >>(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2, _AP_S2>::arg1 operator <<(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<1, false>(op1).operator <<(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<1, false>::arg1 operator <<(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <<(ap_private<1, false>(op2)); }


template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator >(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator <(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <=(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator <=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <=(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <=(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >=(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator >=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >=(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >=(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator ==(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator ==(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator ==(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator ==(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator !=(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator !=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator !=(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator !=(ap_private<1, false>(op2)); }
#7109 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
template <int _AP_W, bool _AP_S> inline bool operator >(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator >(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator >( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >(const _private_bit_ref<_AP_W, _AP_S>& op, bool op2) { return (bool(op))> op2; } template <int _AP_W, bool _AP_S> inline bool operator >(bool op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator <(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator <( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_bit_ref<_AP_W, _AP_S>& op, bool op2) { return (bool(op))< op2; } template <int _AP_W, bool _AP_S> inline bool operator <(bool op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator >=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator >=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_bit_ref<_AP_W, _AP_S>& op, bool op2) { return (bool(op))>= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(bool op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator <=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator <=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_bit_ref<_AP_W, _AP_S>& op, bool op2) { return (bool(op))<= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(bool op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator ==(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator ==( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_bit_ref<_AP_W, _AP_S>& op, bool op2) { return (bool(op))== op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(bool op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 ==(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator !=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator !=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_bit_ref<_AP_W, _AP_S>& op, bool op2) { return (bool(op))!= op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(bool op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 !=(bool(op)); }
template <int _AP_W, bool _AP_S> inline bool operator >(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator >(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator >( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >(const _private_bit_ref<_AP_W, _AP_S>& op, char op2) { return (bool(op))> op2; } template <int _AP_W, bool _AP_S> inline bool operator >(char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator <(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator <( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_bit_ref<_AP_W, _AP_S>& op, char op2) { return (bool(op))< op2; } template <int _AP_W, bool _AP_S> inline bool operator <(char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator >=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator >=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_bit_ref<_AP_W, _AP_S>& op, char op2) { return (bool(op))>= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator <=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator <=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_bit_ref<_AP_W, _AP_S>& op, char op2) { return (bool(op))<= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator ==(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator ==( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_bit_ref<_AP_W, _AP_S>& op, char op2) { return (bool(op))== op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 ==(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator !=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator !=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_bit_ref<_AP_W, _AP_S>& op, char op2) { return (bool(op))!= op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 !=(bool(op)); }
template <int _AP_W, bool _AP_S> inline bool operator >(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator >(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator >( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >(const _private_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return (bool(op))> op2; } template <int _AP_W, bool _AP_S> inline bool operator >(signed char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator <(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator <( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return (bool(op))< op2; } template <int _AP_W, bool _AP_S> inline bool operator <(signed char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator >=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator >=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return (bool(op))>= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(signed char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator <=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator <=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return (bool(op))<= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(signed char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator ==(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator ==( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return (bool(op))== op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(signed char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 ==(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator !=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator !=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return (bool(op))!= op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(signed char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 !=(bool(op)); }
template <int _AP_W, bool _AP_S> inline bool operator >(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator >(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator >( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (bool(op))> op2; } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator <(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator <( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (bool(op))< op2; } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator >=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator >=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (bool(op))>= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator <=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator <=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (bool(op))<= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator ==(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator ==( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (bool(op))== op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 ==(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator !=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator !=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (bool(op))!= op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 !=(bool(op)); }
template <int _AP_W, bool _AP_S> inline bool operator >(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator >(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator >( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >(const _private_bit_ref<_AP_W, _AP_S>& op, short op2) { return (bool(op))> op2; } template <int _AP_W, bool _AP_S> inline bool operator >(short op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator <(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator <( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_bit_ref<_AP_W, _AP_S>& op, short op2) { return (bool(op))< op2; } template <int _AP_W, bool _AP_S> inline bool operator <(short op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator >=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator >=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_bit_ref<_AP_W, _AP_S>& op, short op2) { return (bool(op))>= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(short op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator <=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator <=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_bit_ref<_AP_W, _AP_S>& op, short op2) { return (bool(op))<= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(short op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator ==(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator ==( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_bit_ref<_AP_W, _AP_S>& op, short op2) { return (bool(op))== op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(short op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 ==(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator !=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator !=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_bit_ref<_AP_W, _AP_S>& op, short op2) { return (bool(op))!= op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(short op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 !=(bool(op)); }
template <int _AP_W, bool _AP_S> inline bool operator >(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator >(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator >( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (bool(op))> op2; } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned short op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator <(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator <( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (bool(op))< op2; } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned short op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator >=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator >=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (bool(op))>= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned short op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator <=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator <=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (bool(op))<= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned short op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator ==(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator ==( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (bool(op))== op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned short op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 ==(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator !=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator !=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (bool(op))!= op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned short op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 !=(bool(op)); }
template <int _AP_W, bool _AP_S> inline bool operator >(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator >(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator >( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >(const _private_bit_ref<_AP_W, _AP_S>& op, int op2) { return (bool(op))> op2; } template <int _AP_W, bool _AP_S> inline bool operator >(int op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator <(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator <( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_bit_ref<_AP_W, _AP_S>& op, int op2) { return (bool(op))< op2; } template <int _AP_W, bool _AP_S> inline bool operator <(int op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator >=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator >=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_bit_ref<_AP_W, _AP_S>& op, int op2) { return (bool(op))>= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(int op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator <=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator <=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_bit_ref<_AP_W, _AP_S>& op, int op2) { return (bool(op))<= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(int op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator ==(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator ==( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_bit_ref<_AP_W, _AP_S>& op, int op2) { return (bool(op))== op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(int op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 ==(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator !=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator !=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_bit_ref<_AP_W, _AP_S>& op, int op2) { return (bool(op))!= op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(int op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 !=(bool(op)); }
template <int _AP_W, bool _AP_S> inline bool operator >(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator >(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator >( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (bool(op))> op2; } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned int op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator <(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator <( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (bool(op))< op2; } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned int op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator >=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator >=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (bool(op))>= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned int op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator <=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator <=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (bool(op))<= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned int op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator ==(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator ==( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (bool(op))== op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned int op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 ==(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator !=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator !=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (bool(op))!= op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned int op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 !=(bool(op)); }
template <int _AP_W, bool _AP_S> inline bool operator >(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator >(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator >( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >(const _private_bit_ref<_AP_W, _AP_S>& op, long op2) { return (bool(op))> op2; } template <int _AP_W, bool _AP_S> inline bool operator >(long op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator <(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator <( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_bit_ref<_AP_W, _AP_S>& op, long op2) { return (bool(op))< op2; } template <int _AP_W, bool _AP_S> inline bool operator <(long op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator >=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator >=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_bit_ref<_AP_W, _AP_S>& op, long op2) { return (bool(op))>= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(long op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator <=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator <=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_bit_ref<_AP_W, _AP_S>& op, long op2) { return (bool(op))<= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(long op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator ==(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator ==( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_bit_ref<_AP_W, _AP_S>& op, long op2) { return (bool(op))== op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(long op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 ==(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator !=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator !=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_bit_ref<_AP_W, _AP_S>& op, long op2) { return (bool(op))!= op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(long op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 !=(bool(op)); }
template <int _AP_W, bool _AP_S> inline bool operator >(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator >(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator >( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (bool(op))> op2; } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned long op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator <(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator <( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (bool(op))< op2; } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned long op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator >=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator >=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (bool(op))>= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned long op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator <=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator <=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (bool(op))<= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned long op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator ==(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator ==( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (bool(op))== op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned long op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 ==(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator !=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator !=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (bool(op))!= op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned long op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 !=(bool(op)); }
template <int _AP_W, bool _AP_S> inline bool operator >(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator >(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator >( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >(const _private_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (bool(op))> op2; } template <int _AP_W, bool _AP_S> inline bool operator >(ap_slong op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator <(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator <( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (bool(op))< op2; } template <int _AP_W, bool _AP_S> inline bool operator <(ap_slong op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator >=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator >=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (bool(op))>= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(ap_slong op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator <=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator <=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (bool(op))<= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(ap_slong op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator ==(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator ==( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (bool(op))== op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(ap_slong op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 ==(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator !=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator !=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (bool(op))!= op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(ap_slong op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 !=(bool(op)); }
template <int _AP_W, bool _AP_S> inline bool operator >(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator >(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator >( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >(const _private_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (bool(op))> op2; } template <int _AP_W, bool _AP_S> inline bool operator >(ap_ulong op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator <(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator <( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (bool(op))< op2; } template <int _AP_W, bool _AP_S> inline bool operator <(ap_ulong op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator >=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator >=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (bool(op))>= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(ap_ulong op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator <=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator <=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (bool(op))<= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(ap_ulong op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator ==(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator ==( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (bool(op))== op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(ap_ulong op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 ==(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator !=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator !=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (bool(op))!= op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(ap_ulong op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 !=(bool(op)); }
#7155 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(1), (false)>::plus operator +(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator +(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, false>::plus operator +(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator +( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(1), (false)>::minus operator -(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator -(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, false>::minus operator -(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator -( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(1), (false)>::mult operator *(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator *(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, false>::mult operator *(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator *( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(1), (false)>::div operator /(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator /(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, false>::div operator /(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator /( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(1), (false)>::mod operator %(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator %(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, false>::mod operator %(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator %( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(1), (false)>::logic operator &(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator &(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, false>::logic operator &(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator &( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(1), (false)>::logic operator |(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator |(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, false>::logic operator |(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator |( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(1), (false)>::logic operator ^(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator ^(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, false>::logic operator ^(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator ^( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(1), (false)>::arg1 operator >>(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator >>(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, false>::arg1 operator >>(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator >>( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(1), (false)>::arg1 operator <<(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator <<(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, false>::arg1 operator <<(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator <<( ap_private<_AP_W, false>(op)); }
template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::plus operator +(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator +(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::plus operator +(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator +( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::minus operator -(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator -(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::minus operator -(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator -( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::mult operator *(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator *(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::mult operator *(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator *( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::div operator /(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator /(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::div operator /(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator /( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::mod operator %(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator %(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::mod operator %(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator %( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator &(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator &(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::logic operator &(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator &( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator |(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator |(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::logic operator |(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator |( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator ^(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator ^(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::logic operator ^(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator ^( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::arg1 operator >>(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator >>(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::arg1 operator >>(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator >>( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::arg1 operator <<(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator <<(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::arg1 operator <<(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator <<( ap_private<_AP_W, false>(op)); }
template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (true)>::plus operator +(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator +(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, false>::plus operator +(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator +( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (true)>::minus operator -(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator -(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, false>::minus operator -(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator -( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (true)>::mult operator *(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator *(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, false>::mult operator *(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator *( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (true)>::div operator /(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator /(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, false>::div operator /(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator /( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (true)>::mod operator %(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator %(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, false>::mod operator %(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator %( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (true)>::logic operator &(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator &(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, false>::logic operator &(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator &( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (true)>::logic operator |(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator |(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, false>::logic operator |(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator |( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (true)>::logic operator ^(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator ^(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, false>::logic operator ^(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator ^( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (true)>::arg1 operator >>(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator >>(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, false>::arg1 operator >>(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator >>( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (true)>::arg1 operator <<(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator <<(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, false>::arg1 operator <<(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator <<( ap_private<_AP_W, false>(op)); }
template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (false)>::plus operator +(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator +(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, false>::plus operator +(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator +( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (false)>::minus operator -(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator -(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, false>::minus operator -(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator -( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (false)>::mult operator *(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator *(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, false>::mult operator *(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator *( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (false)>::div operator /(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator /(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, false>::div operator /(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator /( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (false)>::mod operator %(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator %(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, false>::mod operator %(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator %( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (false)>::logic operator &(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator &(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, false>::logic operator &(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator &( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (false)>::logic operator |(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator |(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, false>::logic operator |(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator |( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (false)>::logic operator ^(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator ^(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator ^( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (false)>::arg1 operator >>(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator >>(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator >>( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (false)>::arg1 operator <<(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator <<(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator <<( ap_private<_AP_W, false>(op)); }
template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(short) * 8), (true)>::plus operator +(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator +(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, false>::plus operator +(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator +( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(short) * 8), (true)>::minus operator -(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator -(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, false>::minus operator -(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator -( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(short) * 8), (true)>::mult operator *(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator *(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, false>::mult operator *(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator *( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(short) * 8), (true)>::div operator /(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator /(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, false>::div operator /(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator /( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(short) * 8), (true)>::mod operator %(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator %(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, false>::mod operator %(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator %( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(short) * 8), (true)>::logic operator &(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator &(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, false>::logic operator &(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator &( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(short) * 8), (true)>::logic operator |(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator |(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, false>::logic operator |(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator |( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(short) * 8), (true)>::logic operator ^(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator ^(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, false>::logic operator ^(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator ^( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(short) * 8), (true)>::arg1 operator >>(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator >>(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, false>::arg1 operator >>(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator >>( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(short) * 8), (true)>::arg1 operator <<(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator <<(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, false>::arg1 operator <<(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator <<( ap_private<_AP_W, false>(op)); }
template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned short) * 8), (false)>::plus operator +(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator +(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, false>::plus operator +(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator +( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned short) * 8), (false)>::minus operator -(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator -(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, false>::minus operator -(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator -( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned short) * 8), (false)>::mult operator *(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator *(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, false>::mult operator *(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator *( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned short) * 8), (false)>::div operator /(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator /(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, false>::div operator /(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator /( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned short) * 8), (false)>::mod operator %(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator %(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, false>::mod operator %(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator %( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned short) * 8), (false)>::logic operator &(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator &(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, false>::logic operator &(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator &( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned short) * 8), (false)>::logic operator |(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator |(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, false>::logic operator |(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator |( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned short) * 8), (false)>::logic operator ^(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator ^(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator ^( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned short) * 8), (false)>::arg1 operator >>(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator >>(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator >>( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned short) * 8), (false)>::arg1 operator <<(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator <<(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator <<( ap_private<_AP_W, false>(op)); }
template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(int) * 8), (true)>::plus operator +(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator +(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, false>::plus operator +(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator +( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(int) * 8), (true)>::minus operator -(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator -(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, false>::minus operator -(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator -( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(int) * 8), (true)>::mult operator *(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator *(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, false>::mult operator *(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator *( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(int) * 8), (true)>::div operator /(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator /(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, false>::div operator /(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator /( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(int) * 8), (true)>::mod operator %(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator %(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, false>::mod operator %(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator %( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(int) * 8), (true)>::logic operator &(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator &(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, false>::logic operator &(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator &( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(int) * 8), (true)>::logic operator |(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator |(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, false>::logic operator |(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator |( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(int) * 8), (true)>::logic operator ^(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator ^(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, false>::logic operator ^(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator ^( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(int) * 8), (true)>::arg1 operator >>(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator >>(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, false>::arg1 operator >>(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator >>( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(int) * 8), (true)>::arg1 operator <<(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator <<(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, false>::arg1 operator <<(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator <<( ap_private<_AP_W, false>(op)); }
template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned int) * 8), (false)>::plus operator +(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator +(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, false>::plus operator +(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator +( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned int) * 8), (false)>::minus operator -(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator -(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, false>::minus operator -(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator -( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned int) * 8), (false)>::mult operator *(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator *(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, false>::mult operator *(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator *( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned int) * 8), (false)>::div operator /(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator /(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, false>::div operator /(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator /( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned int) * 8), (false)>::mod operator %(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator %(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, false>::mod operator %(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator %( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned int) * 8), (false)>::logic operator &(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator &(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, false>::logic operator &(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator &( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned int) * 8), (false)>::logic operator |(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator |(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, false>::logic operator |(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator |( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned int) * 8), (false)>::logic operator ^(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator ^(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator ^( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned int) * 8), (false)>::arg1 operator >>(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator >>(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator >>( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned int) * 8), (false)>::arg1 operator <<(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator <<(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator <<( ap_private<_AP_W, false>(op)); }
template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(long) * 8), (true)>::plus operator +(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator +(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, false>::plus operator +(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator +( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(long) * 8), (true)>::minus operator -(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator -(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, false>::minus operator -(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator -( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(long) * 8), (true)>::mult operator *(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator *(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, false>::mult operator *(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator *( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(long) * 8), (true)>::div operator /(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator /(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, false>::div operator /(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator /( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(long) * 8), (true)>::mod operator %(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator %(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, false>::mod operator %(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator %( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(long) * 8), (true)>::logic operator &(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator &(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, false>::logic operator &(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator &( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(long) * 8), (true)>::logic operator |(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator |(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, false>::logic operator |(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator |( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(long) * 8), (true)>::logic operator ^(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator ^(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, false>::logic operator ^(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator ^( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(long) * 8), (true)>::arg1 operator >>(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator >>(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, false>::arg1 operator >>(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator >>( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(long) * 8), (true)>::arg1 operator <<(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator <<(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, false>::arg1 operator <<(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator <<( ap_private<_AP_W, false>(op)); }
template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned long) * 8), (false)>::plus operator +(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator +(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, false>::plus operator +(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator +( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned long) * 8), (false)>::minus operator -(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator -(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, false>::minus operator -(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator -( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned long) * 8), (false)>::mult operator *(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator *(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, false>::mult operator *(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator *( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned long) * 8), (false)>::div operator /(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator /(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, false>::div operator /(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator /( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned long) * 8), (false)>::mod operator %(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator %(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, false>::mod operator %(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator %( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned long) * 8), (false)>::logic operator &(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator &(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, false>::logic operator &(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator &( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned long) * 8), (false)>::logic operator |(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator |(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, false>::logic operator |(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator |( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned long) * 8), (false)>::logic operator ^(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator ^(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator ^( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned long) * 8), (false)>::arg1 operator >>(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator >>(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator >>( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned long) * 8), (false)>::arg1 operator <<(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator <<(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator <<( ap_private<_AP_W, false>(op)); }
template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_slong) * 8), (true)>::plus operator +(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator +(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, false>::plus operator +(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator +( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_slong) * 8), (true)>::minus operator -(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator -(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, false>::minus operator -(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator -( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_slong) * 8), (true)>::mult operator *(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator *(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, false>::mult operator *(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator *( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_slong) * 8), (true)>::div operator /(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator /(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, false>::div operator /(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator /( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_slong) * 8), (true)>::mod operator %(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator %(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, false>::mod operator %(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator %( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_slong) * 8), (true)>::logic operator &(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator &(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, false>::logic operator &(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator &( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_slong) * 8), (true)>::logic operator |(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator |(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, false>::logic operator |(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator |( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_slong) * 8), (true)>::logic operator ^(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator ^(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, false>::logic operator ^(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator ^( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_slong) * 8), (true)>::arg1 operator >>(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator >>(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, false>::arg1 operator >>(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator >>( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_slong) * 8), (true)>::arg1 operator <<(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator <<(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, false>::arg1 operator <<(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator <<( ap_private<_AP_W, false>(op)); }
template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_ulong) * 8), (false)>::plus operator +(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator +(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, false>::plus operator +(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator +( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_ulong) * 8), (false)>::minus operator -(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator -(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, false>::minus operator -(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator -( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_ulong) * 8), (false)>::mult operator *(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator *(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, false>::mult operator *(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator *( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_ulong) * 8), (false)>::div operator /(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator /(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, false>::div operator /(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator /( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_ulong) * 8), (false)>::mod operator %(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator %(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, false>::mod operator %(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator %( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_ulong) * 8), (false)>::logic operator &(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator &(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, false>::logic operator &(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator &( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_ulong) * 8), (false)>::logic operator |(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator |(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, false>::logic operator |(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator |( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_ulong) * 8), (false)>::logic operator ^(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator ^(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, false>::logic operator ^(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator ^( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_ulong) * 8), (false)>::arg1 operator >>(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator >>(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, false>::arg1 operator >>(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator >>( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_ulong) * 8), (false)>::arg1 operator <<(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator <<(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, false>::arg1 operator <<(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator <<( ap_private<_AP_W, false>(op)); }
#7180 "C:/Xilinx/Vivado/2018.3/include/etc/ap_private.h"
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::plus operator +(const _private_range_ref<_AP_W, _AP_S>& lhs, const _private_range_ref<_AP_W2, _AP_S2>& rhs) { return ap_private<_AP_W, false>(lhs).operator +( ap_private<_AP_W2, false>(rhs)); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::minus operator -(const _private_range_ref<_AP_W, _AP_S>& lhs, const _private_range_ref<_AP_W2, _AP_S2>& rhs) { return ap_private<_AP_W, false>(lhs).operator -( ap_private<_AP_W2, false>(rhs)); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::mult operator *(const _private_range_ref<_AP_W, _AP_S>& lhs, const _private_range_ref<_AP_W2, _AP_S2>& rhs) { return ap_private<_AP_W, false>(lhs).operator *( ap_private<_AP_W2, false>(rhs)); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::div operator /(const _private_range_ref<_AP_W, _AP_S>& lhs, const _private_range_ref<_AP_W2, _AP_S2>& rhs) { return ap_private<_AP_W, false>(lhs).operator /( ap_private<_AP_W2, false>(rhs)); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::mod operator %(const _private_range_ref<_AP_W, _AP_S>& lhs, const _private_range_ref<_AP_W2, _AP_S2>& rhs) { return ap_private<_AP_W, false>(lhs).operator %( ap_private<_AP_W2, false>(rhs)); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::logic operator &(const _private_range_ref<_AP_W, _AP_S>& lhs, const _private_range_ref<_AP_W2, _AP_S2>& rhs) { return ap_private<_AP_W, false>(lhs).operator &( ap_private<_AP_W2, false>(rhs)); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::logic operator |(const _private_range_ref<_AP_W, _AP_S>& lhs, const _private_range_ref<_AP_W2, _AP_S2>& rhs) { return ap_private<_AP_W, false>(lhs).operator |( ap_private<_AP_W2, false>(rhs)); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::logic operator ^(const _private_range_ref<_AP_W, _AP_S>& lhs, const _private_range_ref<_AP_W2, _AP_S2>& rhs) { return ap_private<_AP_W, false>(lhs).operator ^( ap_private<_AP_W2, false>(rhs)); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::arg1 operator >>(const _private_range_ref<_AP_W, _AP_S>& lhs, const _private_range_ref<_AP_W2, _AP_S2>& rhs) { return ap_private<_AP_W, false>(lhs).operator >>( ap_private<_AP_W2, false>(rhs)); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::arg1 operator <<(const _private_range_ref<_AP_W, _AP_S>& lhs, const _private_range_ref<_AP_W2, _AP_S2>& rhs) { return ap_private<_AP_W, false>(lhs).operator <<( ap_private<_AP_W2, false>(rhs)); }
#642 "C:/Xilinx/Vivado/2018.3/include/ap_common.h" 2


template <typename _Tp1, typename _Tp2, typename _Tp3>
inline _Tp1 _AP_ROOT_op_concat(const _Tp1& Ret, const _Tp2& X, const _Tp3& Y) {
  _Tp1 r = (X).operator,(Y);
  return r;
}

template <typename _Tp1, typename _Tp2, typename _Tp3>
inline _Tp1& _AP_ROOT_op_set_bit(_Tp1& Val, const _Tp2& Bit, const _Tp3& Repl) {
  (Val).set_bit((Bit), (Repl));
  return Val;
}



template <typename _Tp1, typename _Tp2, typename _Tp3, typename _Tp4>
inline _Tp1& _AP_ROOT_op_set_range(_Tp1& Val, const _Tp2& Lo, const _Tp3& Hi,
                                   const _Tp4& Repl) {
  (Val).range((Hi), (Lo)) = Repl;
  return (Val);
}
#691 "C:/Xilinx/Vivado/2018.3/include/ap_common.h"
inline ap_ulong doubleToRawBits(double pf) {
  union {
    ap_ulong __L;
    double __D;
  } LD;
  LD.__D = pf;
  return LD.__L;
}

inline unsigned int floatToRawBits(float pf) {
  union {
    unsigned int __L;
    float __D;
  } LD;
  LD.__D = pf;
  return LD.__L;
}

inline unsigned short halfToRawBits(half pf) {
#718 "C:/Xilinx/Vivado/2018.3/include/ap_common.h"
  return pf.get_bits();

}


inline double rawBitsToDouble(ap_ulong pi) {
  union {
    ap_ulong __L;
    double __D;
  } LD;
  LD.__L = pi;
  return LD.__D;
}


inline float rawBitsToFloat(unsigned long pi) {
  union {
    unsigned int __L;
    float __D;
  } LD;
  LD.__L = pi;
  return LD.__D;
}


inline half rawBitsToHalf(unsigned short pi) {
#753 "C:/Xilinx/Vivado/2018.3/include/ap_common.h"
  half __D;
  __D.set_bits(pi);
  return __D;

}
#55 "C:/Xilinx/Vivado/2018.3/include/ap_fixed.h" 2
#1 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 1
#61 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
#1 "C:/Xilinx/Vivado/2018.3/include/ap_int.h" 1
#55 "C:/Xilinx/Vivado/2018.3/include/ap_int.h"
#1 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 1
#82 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
template <int _AP_N, bool _AP_S>
struct retval;


template <int _AP_N>
struct retval<_AP_N, true> {
  typedef ap_slong Type;
};

template <int _AP_N>
struct retval<_AP_N, false> {
  typedef ap_ulong Type;
};


template <>
struct retval<1, true> {
  typedef signed char Type;
};

template <>
struct retval<1, false> {
  typedef unsigned char Type;
};


template <>
struct retval<2, true> {
  typedef short Type;
};

template <>
struct retval<2, false> {
  typedef unsigned short Type;
};


template <>
struct retval<3, true> {
  typedef long Type;
};

template <>
struct retval<3, false> {
  typedef unsigned long Type;
};

template <>
struct retval<4, true> {
  typedef long Type;
};

template <>
struct retval<4, false> {
  typedef unsigned long Type;
};




template <int _AP_W2, bool _AP_S2>
struct _ap_int_factory;
template <int _AP_W2>
struct _ap_int_factory<_AP_W2,true> { typedef ap_int<_AP_W2> type; };
template <int _AP_W2>
struct _ap_int_factory<_AP_W2,false> { typedef ap_uint<_AP_W2> type; };

template <int _AP_W, bool _AP_S>
struct ap_int_base : public ssdm_int_sim<_AP_W, _AP_S> {
 public:
  typedef ssdm_int_sim<_AP_W, _AP_S> Base;







  typedef typename retval<(((_AP_W + 7) / 8) > (8) ? ((_AP_W + 7) / 8) : (8)), _AP_S>::Type RetType;

  static const int width = _AP_W;

  template <int _AP_W2, bool _AP_S2>
  struct RType {
    enum {
      mult_w = _AP_W + _AP_W2,
      mult_s = _AP_S || _AP_S2,
      plus_w =
          ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))) + 1,
      plus_s = _AP_S || _AP_S2,
      minus_w =
          ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))) + 1,
      minus_s = true,
      div_w = _AP_W + _AP_S2,
      div_s = _AP_S || _AP_S2,
      mod_w = ((_AP_W) < (_AP_W2 + (!_AP_S2 && _AP_S)) ? (_AP_W) : (_AP_W2 + (!_AP_S2 && _AP_S))),
      mod_s = _AP_S,
      logic_w = ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))),
      logic_s = _AP_S || _AP_S2
    };


    typedef ap_int_base<mult_w, mult_s> mult_base;
    typedef ap_int_base<plus_w, plus_s> plus_base;
    typedef ap_int_base<minus_w, minus_s> minus_base;
    typedef ap_int_base<logic_w, logic_s> logic_base;
    typedef ap_int_base<div_w, div_s> div_base;
    typedef ap_int_base<mod_w, mod_s> mod_base;
    typedef ap_int_base<_AP_W, _AP_S> arg1_base;

    typedef typename _ap_int_factory<mult_w, mult_s>::type mult;
    typedef typename _ap_int_factory<plus_w, plus_s>::type plus;
    typedef typename _ap_int_factory<minus_w, minus_s>::type minus;
    typedef typename _ap_int_factory<logic_w, logic_s>::type logic;
    typedef typename _ap_int_factory<div_w, div_s>::type div;
    typedef typename _ap_int_factory<mod_w, mod_s>::type mod;
    typedef typename _ap_int_factory<_AP_W, _AP_S>::type arg1;
    typedef bool reduce;
  };





  inline ap_int_base() {





  }


  template <int _AP_W2, bool _AP_S2>
  inline ap_int_base(const ap_int_base<_AP_W2, _AP_S2>& op) {
    Base::V = op.V;
  }


  template <int _AP_W2, bool _AP_S2>
  inline ap_int_base(const volatile ap_int_base<_AP_W2, _AP_S2>& op) {
    Base::V = op.V;
  }
#239 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
  inline ap_int_base(const bool op) { Base::V = op; }
  inline ap_int_base(const char op) { Base::V = op; }
  inline ap_int_base(const signed char op) { Base::V = op; }
  inline ap_int_base(const unsigned char op) { Base::V = op; }
  inline ap_int_base(const short op) { Base::V = op; }
  inline ap_int_base(const unsigned short op) { Base::V = op; }
  inline ap_int_base(const int op) { Base::V = op; }
  inline ap_int_base(const unsigned int op) { Base::V = op; }
  inline ap_int_base(const long op) { Base::V = op; }
  inline ap_int_base(const unsigned long op) { Base::V = op; }
  inline ap_int_base(const ap_slong op) { Base::V = op; }
  inline ap_int_base(const ap_ulong op) { Base::V = op; }




  inline ap_int_base(half op) {
    ap_int_base<_AP_W, _AP_S> t((float)op);
    Base::V = t.V;
  }


  inline ap_int_base(float op) {
    const int BITS = 23 + 8 + 1;
    ap_int_base<BITS, false> reg;
    reg.V = floatToRawBits(op);
    bool is_neg = (reg.V).get_bit((BITS - 1));

    ap_int_base<8 + 1, true> exp = 0;
    exp.V = (reg.V).range((BITS - 2), (23));
    exp = exp - ((1L << (8 - 1L)) - 1L);

    ap_int_base<23 + 2, true> man;
    man.V = (reg.V).range((23 - 1), (0));

    do { if ((exp == ((unsigned char)(((1L << (8 - 1L)) - 1L) + 1)) && man.V != 0)) { fprintf(
#274 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   (&__iob_func()[2])
#274 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   , "WARNING: " "assign NaN to ap integer value"); fprintf(
#274 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   (&__iob_func()[2])
#274 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   , "\n"); } } while (0)
                                                 ;

    man.V = _AP_ROOT_op_set_bit(man.V, 23, 1);


    if ((reg.V & 0x7ffffffful) == 0) {
      Base::V = 0;
    } else {
      int sh_amt = 23 - exp.V;
      if (sh_amt == 0) {
        Base::V = man.V;
      } else if (sh_amt > 0) {
        if (sh_amt < 23 + 2) {
          Base::V = man.V >> sh_amt;
        } else {
          if (is_neg)
            Base::V = -1;
          else
            Base::V = 0;
        }
      } else {
        sh_amt = -sh_amt;
        if (sh_amt < _AP_W) {
          Base::V = man.V;
          Base::V <<= sh_amt;
        } else {
          Base::V = 0;
        }
      }
    }
    if (is_neg) *this = -(*this);
  }


  inline ap_int_base(double op) {
    const int BITS = 52 + 11 + 1;
    ap_int_base<BITS, false> reg;
    reg.V = doubleToRawBits(op);
    bool is_neg = (reg.V).get_bit((BITS - 1));

    ap_int_base<11 + 1, true> exp = 0;
    exp.V = (reg.V).range((BITS - 2), (52));
    exp = exp - ((1L << (11 - 1L)) - 1L);

    ap_int_base<52 + 2, true> man;
    man.V = (reg.V).range((52 - 1), (0));

    do { if ((exp == ((unsigned char)(((1L << (11 - 1L)) - 1L) + 1)) && man.V != 0)) { fprintf(
#322 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   (&__iob_func()[2])
#322 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   , "WARNING: " "assign NaN to ap integer value"); fprintf(
#322 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   (&__iob_func()[2])
#322 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   , "\n"); } } while (0)
                                                 ;

    man.V = _AP_ROOT_op_set_bit(man.V, 52, 1);


    if ((reg.V & 0x7fffffffffffffffull) == 0) {
      Base::V = 0;
    } else {
      int sh_amt = 52 - exp.V;
      if (sh_amt == 0) {
        Base::V = man.V;
      } else if (sh_amt > 0) {
        if (sh_amt < 52 + 2) {
          Base::V = man.V >> sh_amt;
        } else {
          if (is_neg)
            Base::V = -1;
          else
            Base::V = 0;
        }
      } else {
        sh_amt = -sh_amt;
        if (sh_amt < _AP_W) {
          Base::V = man.V;
          Base::V <<= sh_amt;
        } else {
          Base::V = 0;
        }
      }
    }
    if (is_neg) *this = -(*this);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_int_base(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    Base::V = op.to_ap_int_base().V;
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_int_base(const ap_range_ref<_AP_W2, _AP_S2>& ref) {
    Base::V = (ref.get()).V;
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_int_base(const ap_bit_ref<_AP_W2, _AP_S2>& ref) {
    Base::V = ref.operator bool();
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_int_base(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref) {
    const ap_int_base<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>::_AP_WR,
                      false>
        tmp = ref.get();
    Base::V = tmp.V;
  }




  inline ap_int_base(const char* s, signed char rd = 0) {
    if (rd == 0)
      rd = guess_radix(s);
    unsigned int length = strlen(s);
    Base::V.fromString(s, length, rd);
  }
#407 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_int_base(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    Base::V = (val.get()).V;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_int_base(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    Base::V = val.operator bool();
  }

  inline ap_int_base read() volatile {

    ap_int_base ret;
    ret.V = Base::V;
    return ret;
  }

  inline void write(const ap_int_base<_AP_W, _AP_S>& op2) volatile {

    Base::V = op2.V;
  }


  template <int _AP_W2, bool _AP_S2>
  inline void operator=(
      const volatile ap_int_base<_AP_W2, _AP_S2>& op2) volatile {
    Base::V = op2.V;
  }

  inline void operator=(
      const volatile ap_int_base<_AP_W, _AP_S>& op2) volatile {
    Base::V = op2.V;
  }

  template <int _AP_W2, bool _AP_S2>
  inline void operator=(const ap_int_base<_AP_W2, _AP_S2>& op2) volatile {
    Base::V = op2.V;
  }

  inline void operator=(const ap_int_base<_AP_W, _AP_S>& op2) volatile {
    Base::V = op2.V;
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_int_base& operator=(
      const volatile ap_int_base<_AP_W2, _AP_S2>& op2) {
    Base::V = op2.V;
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_int_base& operator=(const ap_int_base<_AP_W2, _AP_S2>& op2) {
    Base::V = op2.V;
    return *this;
  }

  inline ap_int_base& operator=(const volatile ap_int_base<_AP_W, _AP_S>& op2) {
    Base::V = op2.V;
    return *this;
  }

  inline ap_int_base& operator=(const ap_int_base<_AP_W, _AP_S>& op2) {
    Base::V = op2.V;
    return *this;
  }
#484 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
  inline ap_int_base& operator=(bool op) { Base::V = op; return *this; }
  inline ap_int_base& operator=(char op) { Base::V = op; return *this; }
  inline ap_int_base& operator=(signed char op) { Base::V = op; return *this; }
  inline ap_int_base& operator=(unsigned char op) { Base::V = op; return *this; }
  inline ap_int_base& operator=(short op) { Base::V = op; return *this; }
  inline ap_int_base& operator=(unsigned short op) { Base::V = op; return *this; }
  inline ap_int_base& operator=(int op) { Base::V = op; return *this; }
  inline ap_int_base& operator=(unsigned int op) { Base::V = op; return *this; }
  inline ap_int_base& operator=(long op) { Base::V = op; return *this; }
  inline ap_int_base& operator=(unsigned long op) { Base::V = op; return *this; }
  inline ap_int_base& operator=(ap_slong op) { Base::V = op; return *this; }
  inline ap_int_base& operator=(ap_ulong op) { Base::V = op; return *this; }



  template <int _AP_W2, bool _AP_S2>
  inline ap_int_base& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& op2) {
    Base::V = (bool)op2;
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_int_base& operator=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    Base::V = (ap_int_base<_AP_W2, false>(op2)).V;
    return *this;
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_int_base& operator=(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op2) {
    Base::V = op2.get().V;
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_int_base& operator=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    Base::V = op.to_ap_int_base().V;
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_int_base& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    Base::V = (bool)op;
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_int_base& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    Base::V = ((const ap_int_base<_AP_W2, false>)(op)).V;
    return *this;
  }





  inline operator RetType() const { return (RetType)(Base::V); }




  inline bool to_bool() const { return (bool)(Base::V); }
  inline char to_char() const { return (char)(Base::V); }
  inline signed char to_schar() const { return (signed char)(Base::V); }
  inline unsigned char to_uchar() const { return (unsigned char)(Base::V); }
  inline short to_short() const { return (short)(Base::V); }
  inline unsigned short to_ushort() const { return (unsigned short)(Base::V); }
  inline int to_int() const { return (int)(Base::V); }
  inline unsigned to_uint() const { return (unsigned)(Base::V); }
  inline long to_long() const { return (long)(Base::V); }
  inline unsigned long to_ulong() const { return (unsigned long)(Base::V); }
  inline ap_slong to_int64() const { return (ap_slong)(Base::V); }
  inline ap_ulong to_uint64() const { return (ap_ulong)(Base::V); }
  inline float to_float() const { return (float)(Base::V); }
  inline double to_double() const { return (double)(Base::V); }
#588 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
  inline int length() const volatile { return _AP_W; }


  inline bool iszero() const { return Base::V == 0; }


  inline bool is_zero() const { return Base::V == 0; }


  inline bool sign() const {
    if (_AP_S &&
        (Base::V).get_bit((_AP_W - 1)))
      return true;
    else
      return false;
  }


  inline void clear(int i) {

#607 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   (void) ((!!(
#607 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   (i >= 0 && i < _AP_W) && ("position out of range")
#607 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   )) || (_assert(
#607 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   "(i >= 0 && i < _AP_W) && (\"position out of range\")"
#607 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/ap_int_base.h",607),0))
#607 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
                                                          ;
    Base::V = _AP_ROOT_op_set_bit(Base::V, i, 0);
  }


  inline void invert(int i) {

#613 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   (void) ((!!(
#613 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   (i >= 0 && i < _AP_W) && ("position out of range")
#613 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   )) || (_assert(
#613 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   "(i >= 0 && i < _AP_W) && (\"position out of range\")"
#613 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/ap_int_base.h",613),0))
#613 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
                                                          ;
    bool val = (Base::V).get_bit((i));
    if (val)
      Base::V = _AP_ROOT_op_set_bit(Base::V, i, 0);
    else
      Base::V = _AP_ROOT_op_set_bit(Base::V, i, 1);
  }

  inline bool test(int i) const {

#622 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   (void) ((!!(
#622 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   (i >= 0 && i < _AP_W) && ("position out of range")
#622 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   )) || (_assert(
#622 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   "(i >= 0 && i < _AP_W) && (\"position out of range\")"
#622 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/ap_int_base.h",622),0))
#622 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
                                                          ;
    return (Base::V).get_bit((i));
  }


  inline ap_int_base& get() { return *this; }


  inline void set(int i) {

#631 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   (void) ((!!(
#631 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   (i >= 0 && i < _AP_W) && ("position out of range")
#631 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   )) || (_assert(
#631 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   "(i >= 0 && i < _AP_W) && (\"position out of range\")"
#631 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/ap_int_base.h",631),0))
#631 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
                                                          ;
    Base::V = _AP_ROOT_op_set_bit(Base::V, i, 1);
  }


  inline void set(int i, bool v) {

#637 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   (void) ((!!(
#637 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   (i >= 0 && i < _AP_W) && ("position out of range")
#637 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   )) || (_assert(
#637 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   "(i >= 0 && i < _AP_W) && (\"position out of range\")"
#637 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/ap_int_base.h",637),0))
#637 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
                                                          ;
    Base::V = _AP_ROOT_op_set_bit(Base::V, i, v);
  }



  inline ap_int_base& lrotate(int n) {

#644 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   (void) ((!!(
#644 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   (n >= 0 && n < _AP_W) && ("shift value out of range")
#644 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   )) || (_assert(
#644 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   "(n >= 0 && n < _AP_W) && (\"shift value out of range\")"
#644 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/ap_int_base.h",644),0))
#644 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
                                                             ;






    Base::V.lrotate(n);

    return *this;
  }



  inline ap_int_base& rrotate(int n) {

#659 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   (void) ((!!(
#659 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   (n >= 0 && n < _AP_W) && ("shift value out of range")
#659 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   )) || (_assert(
#659 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   "(n >= 0 && n < _AP_W) && (\"shift value out of range\")"
#659 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/ap_int_base.h",659),0))
#659 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
                                                             ;






    Base::V.rrotate(n);

    return *this;
  }



  inline ap_int_base& reverse() {
    Base::V = (Base::V).range((0), (_AP_W - 1));
    return *this;
  }


  inline void set_bit(int i, bool v) {
    Base::V = _AP_ROOT_op_set_bit(Base::V, i, v);
  }


  inline bool get_bit(int i) const {
    return (bool)(Base::V).get_bit((i));
  }


  inline void b_not() { Base::V = ~Base::V; }
#701 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
  template <int _AP_W2, bool _AP_S2> inline ap_int_base& operator *=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V *= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline ap_int_base& operator +=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V += op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline ap_int_base& operator -=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V -= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline ap_int_base& operator /=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V /= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline ap_int_base& operator %=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V %= op2.V; return *this; }
#719 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
  template <int _AP_W2, bool _AP_S2> inline ap_int_base& operator &=(const ap_int_base<_AP_W2, _AP_S2>& op2) { do { if (((_AP_W != _AP_W2))) { fprintf(
#719 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
 (&__iob_func()[2])
#719 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
 , "WARNING: " "Bitsize mismatch for ap_[u]int" "&=" "ap_[u]int."); fprintf(
#719 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
 (&__iob_func()[2])
#719 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
 , "\n"); } } while (0); Base::V &= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline ap_int_base& operator |=(const ap_int_base<_AP_W2, _AP_S2>& op2) { do { if (((_AP_W != _AP_W2))) { fprintf(
#720 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
 (&__iob_func()[2])
#720 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
 , "WARNING: " "Bitsize mismatch for ap_[u]int" "|=" "ap_[u]int."); fprintf(
#720 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
 (&__iob_func()[2])
#720 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
 , "\n"); } } while (0); Base::V |= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline ap_int_base& operator ^=(const ap_int_base<_AP_W2, _AP_S2>& op2) { do { if (((_AP_W != _AP_W2))) { fprintf(
#721 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
 (&__iob_func()[2])
#721 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
 , "WARNING: " "Bitsize mismatch for ap_[u]int" "^=" "ap_[u]int."); fprintf(
#721 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
 (&__iob_func()[2])
#721 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
 , "\n"); } } while (0); Base::V ^= op2.V; return *this; }





  inline ap_int_base& operator++() {
    operator+=((ap_int_base<1, false>)1);
    return *this;
  }
  inline ap_int_base& operator--() {
    operator-=((ap_int_base<1, false>)1);
    return *this;
  }




  inline const typename RType<_AP_W,_AP_S>::arg1 operator++(int) {
    ap_int_base t = *this;
    operator+=((ap_int_base<1, false>)1);
    return t;
  }
  inline const typename RType<_AP_W,_AP_S>::arg1 operator--(int) {
    ap_int_base t = *this;
    operator-=((ap_int_base<1, false>)1);
    return t;
  }




  inline typename RType<_AP_W,_AP_S>::arg1 operator+() const { return *this; }


  inline typename RType<1, false>::minus operator-() const {
    return ap_int_base<1, false>(0) - *this;
  }




  inline bool operator!() const { return Base::V == 0; }





  inline typename RType<_AP_W,_AP_S>::arg1 operator~() const {
    ap_int_base<_AP_W, _AP_S> r;
    r.V = ~Base::V;
    return r;
  }




  template <int _AP_W2>
  inline typename RType<_AP_W,_AP_S>::arg1 operator<<(const ap_int_base<_AP_W2, true>& op2) const {
    bool isNeg = (op2.V).get_bit((_AP_W2 - 1));
    ap_int_base<_AP_W2, false> sh = op2;
    if (isNeg) {
      sh = -op2;
      return operator>>(sh);
    } else
      return operator<<(sh);
  }

  template <int _AP_W2>
  inline typename RType<_AP_W,_AP_S>::arg1 operator<<(const ap_int_base<_AP_W2, false>& op2) const {
    ap_int_base r;
    r.V = Base::V << op2.to_uint();
    return r;
  }

  template <int _AP_W2>
  inline typename RType<_AP_W,_AP_S>::arg1 operator>>(const ap_int_base<_AP_W2, true>& op2) const {
    bool isNeg = (op2.V).get_bit((_AP_W2 - 1));
    ap_int_base<_AP_W2, false> sh = op2;
    if (isNeg) {
      sh = -op2;
      return operator<<(sh);
    }
    return operator>>(sh);
  }

  template <int _AP_W2>
  inline typename RType<_AP_W,_AP_S>::arg1 operator>>(const ap_int_base<_AP_W2, false>& op2) const {
    ap_int_base r;
    r.V = Base::V >> op2.to_uint();
    return r;
  }
#830 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
  template <int _AP_W2>
  inline ap_int_base& operator<<=(const ap_int_base<_AP_W2, true>& op2) {
    bool isNeg = (op2.V).get_bit((_AP_W2 - 1));
    ap_int_base<_AP_W2, false> sh = op2;
    if (isNeg) {
      sh = -op2;
      return operator>>=(sh);
    } else
      return operator<<=(sh);
  }

  template <int _AP_W2>
  inline ap_int_base& operator<<=(const ap_int_base<_AP_W2, false>& op2) {
    Base::V <<= op2.to_uint();
    return *this;
  }

  template <int _AP_W2>
  inline ap_int_base& operator>>=(const ap_int_base<_AP_W2, true>& op2) {
    bool isNeg = (op2.V).get_bit((_AP_W2 - 1));
    ap_int_base<_AP_W2, false> sh = op2;
    if (isNeg) {
      sh = -op2;
      return operator<<=(sh);
    }
    return operator>>=(sh);
  }

  template <int _AP_W2>
  inline ap_int_base& operator>>=(const ap_int_base<_AP_W2, false>& op2) {
    Base::V >>= op2.to_uint();
    return *this;
  }
#879 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
  template <int _AP_W2, bool _AP_S2>
  inline bool operator==(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V == op2.V;
  }
  template <int _AP_W2, bool _AP_S2>
  inline bool operator!=(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return !(Base::V == op2.V);
  }
  template <int _AP_W2, bool _AP_S2>
  inline bool operator<(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V < op2.V;
  }
  template <int _AP_W2, bool _AP_S2>
  inline bool operator>=(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V >= op2.V;
  }
  template <int _AP_W2, bool _AP_S2>
  inline bool operator>(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V > op2.V;
  }
  template <int _AP_W2, bool _AP_S2>
  inline bool operator<=(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V <= op2.V;
  }




  inline ap_range_ref<_AP_W, _AP_S> range(int Hi, int Lo) {
    do { if ((Hi >= _AP_W)) { fprintf(
#908 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   (&__iob_func()[2])
#908 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   , "ERROR: " "Hi(%d)out of bound(%d) in range()", Hi, _AP_W); fprintf(
#908 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   (&__iob_func()[2])
#908 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   , "\n"); abort(); } } while (0);
    do { if ((Lo >= _AP_W)) { fprintf(
#909 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   (&__iob_func()[2])
#909 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   , "ERROR: " "Lo(%d)out of bound(%d) in range()", Lo, _AP_W); fprintf(
#909 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   (&__iob_func()[2])
#909 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   , "\n"); abort(); } } while (0);
    return ap_range_ref<_AP_W, _AP_S>(this, Hi, Lo);
  }


  inline ap_range_ref<_AP_W, _AP_S> range(int Hi, int Lo) const {
    do { if ((Hi >= _AP_W)) { fprintf(
#915 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   (&__iob_func()[2])
#915 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   , "ERROR: " "Hi(%d)out of bound(%d) in range()", Hi, _AP_W); fprintf(
#915 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   (&__iob_func()[2])
#915 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   , "\n"); abort(); } } while (0);
    do { if ((Lo >= _AP_W)) { fprintf(
#916 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   (&__iob_func()[2])
#916 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   , "ERROR: " "Lo(%d)out of bound(%d) in range()", Lo, _AP_W); fprintf(
#916 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   (&__iob_func()[2])
#916 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   , "\n"); abort(); } } while (0);
    return ap_range_ref<_AP_W, _AP_S>(const_cast<ap_int_base*>(this), Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline ap_range_ref<_AP_W, _AP_S> range(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline ap_range_ref<_AP_W, _AP_S> range(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  inline ap_range_ref<_AP_W, _AP_S> range() {
    return this->range(_AP_W - 1, 0);
  }

  inline ap_range_ref<_AP_W, _AP_S> range() const {
    return this->range(_AP_W - 1, 0);
  }

  inline ap_range_ref<_AP_W, _AP_S> operator()(int Hi, int Lo) {
    return this->range(Hi, Lo);
  }

  inline ap_range_ref<_AP_W, _AP_S> operator()(int Hi, int Lo) const {
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline ap_range_ref<_AP_W, _AP_S> operator()(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline ap_range_ref<_AP_W, _AP_S> operator()(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }
#988 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
  inline ap_bit_ref<_AP_W, _AP_S> operator[](int index) {

#989 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   (void) ((!!(
#989 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   (index >= 0) && ("Attempting to read bit with negative index")
#989 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   )) || (_assert(
#989 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   "(index >= 0) && (\"Attempting to read bit with negative index\")"
#989 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/ap_int_base.h",989),0))
#989 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
                                                                      ;

#990 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   (void) ((!!(
#990 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   (index < _AP_W) && ("Attempting to read bit beyond MSB")
#990 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   )) || (_assert(
#990 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   "(index < _AP_W) && (\"Attempting to read bit beyond MSB\")"
#990 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/ap_int_base.h",990),0))
#990 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
                                                                ;
    ap_bit_ref<_AP_W, _AP_S> bvh(this, index);
    return bvh;
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_bit_ref<_AP_W, _AP_S> operator[](
      const ap_int_base<_AP_W2, _AP_S2>& index) {

#998 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   (void) ((!!(
#998 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   (index >= 0) && ("Attempting to read bit with negative index")
#998 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   )) || (_assert(
#998 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   "(index >= 0) && (\"Attempting to read bit with negative index\")"
#998 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/ap_int_base.h",998),0))
#998 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
                                                                      ;

#999 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   (void) ((!!(
#999 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   (index < _AP_W) && ("Attempting to read bit beyond MSB")
#999 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   )) || (_assert(
#999 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   "(index < _AP_W) && (\"Attempting to read bit beyond MSB\")"
#999 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/ap_int_base.h",999),0))
#999 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
                                                                ;
    ap_bit_ref<_AP_W, _AP_S> bvh(this, index.to_int());
    return bvh;
  }

  inline bool operator[](int index) const {

#1005 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   (void) ((!!(
#1005 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   (index >= 0) && ("Attempting to read bit with negative index")
#1005 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   )) || (_assert(
#1005 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   "(index >= 0) && (\"Attempting to read bit with negative index\")"
#1005 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/ap_int_base.h",1005),0))
#1005 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
                                                                      ;

#1006 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   (void) ((!!(
#1006 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   (index < _AP_W) && ("Attempting to read bit beyond MSB")
#1006 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   )) || (_assert(
#1006 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   "(index < _AP_W) && (\"Attempting to read bit beyond MSB\")"
#1006 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/ap_int_base.h",1006),0))
#1006 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
                                                                ;
    ap_bit_ref<_AP_W, _AP_S> br(this, index);
    return br.to_bool();
  }
  template <int _AP_W2, bool _AP_S2>
  inline bool operator[](const ap_int_base<_AP_W2, _AP_S2>& index) const {

#1012 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   (void) ((!!(
#1012 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   (index < _AP_W) && ("Attempting to read bit beyond MSB")
#1012 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   )) || (_assert(
#1012 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   "(index < _AP_W) && (\"Attempting to read bit beyond MSB\")"
#1012 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/ap_int_base.h",1012),0))
#1012 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
                                                                ;
    ap_bit_ref<_AP_W, _AP_S> br(this, index.to_int());
    return br.to_bool();
  }

  inline ap_bit_ref<_AP_W, _AP_S> bit(int index) {

#1018 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   (void) ((!!(
#1018 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   (index >= 0) && ("Attempting to read bit with negative index")
#1018 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   )) || (_assert(
#1018 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   "(index >= 0) && (\"Attempting to read bit with negative index\")"
#1018 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/ap_int_base.h",1018),0))
#1018 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
                                                                      ;

#1019 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   (void) ((!!(
#1019 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   (index < _AP_W) && ("Attempting to read bit beyond MSB")
#1019 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   )) || (_assert(
#1019 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   "(index < _AP_W) && (\"Attempting to read bit beyond MSB\")"
#1019 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/ap_int_base.h",1019),0))
#1019 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
                                                                ;
    ap_bit_ref<_AP_W, _AP_S> bvh(this, index);
    return bvh;
  }
  template <int _AP_W2, bool _AP_S2>
  inline ap_bit_ref<_AP_W, _AP_S> bit(
      const ap_int_base<_AP_W2, _AP_S2>& index) {

#1026 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   (void) ((!!(
#1026 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   (index >= 0) && ("Attempting to read bit with negative index")
#1026 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   )) || (_assert(
#1026 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   "(index >= 0) && (\"Attempting to read bit with negative index\")"
#1026 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/ap_int_base.h",1026),0))
#1026 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
                                                                      ;

#1027 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   (void) ((!!(
#1027 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   (index < _AP_W) && ("Attempting to read bit beyond MSB")
#1027 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   )) || (_assert(
#1027 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   "(index < _AP_W) && (\"Attempting to read bit beyond MSB\")"
#1027 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/ap_int_base.h",1027),0))
#1027 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
                                                                ;
    ap_bit_ref<_AP_W, _AP_S> bvh(this, index.to_int());
    return bvh;
  }

  inline bool bit(int index) const {

#1033 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   (void) ((!!(
#1033 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   (index >= 0) && ("Attempting to read bit with negative index")
#1033 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   )) || (_assert(
#1033 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   "(index >= 0) && (\"Attempting to read bit with negative index\")"
#1033 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/ap_int_base.h",1033),0))
#1033 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
                                                                      ;

#1034 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   (void) ((!!(
#1034 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   (index < _AP_W) && ("Attempting to read bit beyond MSB")
#1034 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   )) || (_assert(
#1034 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
   "(index < _AP_W) && (\"Attempting to read bit beyond MSB\")"
#1034 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/ap_int_base.h",1034),0))
#1034 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
                                                                ;
    ap_bit_ref<_AP_W, _AP_S> br(this, index);
    return br.to_bool();
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool bit(const ap_int_base<_AP_W2, _AP_S2>& index) const {
    return bit(index.to_int());
  }
#1055 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
  inline int countLeadingZeros() {
#1090 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
    return (Base::V).countLeadingZeros();

  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  concat(const ap_int_base<_AP_W2, _AP_S2>& a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  concat(ap_int_base<_AP_W2, _AP_S2>& a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(*this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline
      ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
      operator,(const ap_range_ref<_AP_W2, _AP_S2> &a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_range_ref<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_range_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline
      ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
      operator,(ap_range_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_range_ref<_AP_W2, _AP_S2> >(*this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(const ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(ap_int_base<_AP_W2, _AP_S2> &a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this), a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(const ap_int_base<_AP_W2, _AP_S2> &a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(*this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >
  operator,(const ap_bit_ref<_AP_W2, _AP_S2> &a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_bit_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >
  operator,(ap_bit_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        *this, a2);
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_concat_ref<_AP_W, ap_int_base, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(a2));
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_concat_ref<_AP_W, ap_int_base, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this,
                                                                         a2);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_concat_ref<
      _AP_W, ap_int_base, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>
                &a2) const {
    return ap_concat_ref<
        _AP_W, ap_int_base, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<
            af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_concat_ref<
      _AP_W, ap_int_base, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {
    return ap_concat_ref<
        _AP_W, ap_int_base, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
                                                                       a2);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline
      ap_concat_ref<_AP_W, ap_int_base, 1,
                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>
                    &a2) const {
    return ap_concat_ref<
        _AP_W, ap_int_base, 1,
        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline
      ap_concat_ref<_AP_W, ap_int_base, 1,
                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(
          af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {
    return ap_concat_ref<
        _AP_W, ap_int_base, 1,
        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this, a2);
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_int_base<((_AP_W2 + _AP_W3) > (_AP_W) ? (_AP_W2 + _AP_W3) : (_AP_W)), _AP_S> operator&(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
    return *this & a2.get();
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_int_base<((_AP_W2 + _AP_W3) > (_AP_W) ? (_AP_W2 + _AP_W3) : (_AP_W)), _AP_S> operator|(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
    return *this | a2.get();
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_int_base<((_AP_W2 + _AP_W3) > (_AP_W) ? (_AP_W2 + _AP_W3) : (_AP_W)), _AP_S> operator^(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
    return *this ^ a2.get();
  }

  template <int _AP_W3>
  inline void set(const ap_int_base<_AP_W3, false>& val) {
    Base::V = val.V;
  }





  inline bool and_reduce() const { return (Base::V).and_reduce(); }
  inline bool nand_reduce() const { return (Base::V).nand_reduce(); }
  inline bool or_reduce() const { return (Base::V).or_reduce(); }
  inline bool nor_reduce() const { return !((Base::V).or_reduce()); }
  inline bool xor_reduce() const { return (Base::V).xor_reduce(); }
  inline bool xnor_reduce() const {
    return !((Base::V).xor_reduce());
  }





  std::string to_string(signed char rd = 2, bool sign = _AP_S) const {


    if (rd == 2) sign = false;
    return (Base::V).to_string(rd, sign);
  }





};




template <int _AP_W, bool _AP_S>
inline std::ostream& operator<<(std::ostream& os,
                                const ap_int_base<_AP_W, _AP_S>& x) {
  std::ios_base::fmtflags ff = std::cout.flags();
  if (ff & std::cout.hex) {
    os << x.to_string(16);
  } else if (ff & std::cout.oct) {
    os << x.to_string(8);
  } else {
    os << x.to_string(10);
  }
  return os;
}



template <int _AP_W, bool _AP_S>
inline std::istream& operator>>(std::istream& in,
                                ap_int_base<_AP_W, _AP_S>& op) {
  std::string str;
  in >> str;
  const std::ios_base::fmtflags basefield = in.flags() & std::ios_base::basefield;
  unsigned radix = (basefield == std::ios_base::dec) ? 0 : (
                     (basefield == std::ios_base::oct) ? 8 : (
                       (basefield == std::ios_base::hex) ? 16 : 0));
  op = ap_int_base<_AP_W, _AP_S>(str.c_str(), radix);
  return in;
}
#1354 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::mult_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::mult_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::mult_base ret; ret.V = lhs.V * rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::plus_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::plus_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::plus_base ret; ret.V = lhs.V + rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::minus_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::minus_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::minus_base ret; ret.V = lhs.V - rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base ret; ret.V = lhs.V & rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base ret; ret.V = lhs.V | rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base ret; ret.V = lhs.V ^ rhs.V; return ret; }
#1373 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::div_base ret; ret.V = op.V / op2.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::mod_base ret; ret.V = op.V % op2.V; return ret; }
#1401 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline PTR_TYPE* operator +(PTR_TYPE* i_op, const ap_int_base<_AP_W, _AP_S>& op) { std::ptrdiff_t op2 = op.to_long(); return i_op + op2; } template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline PTR_TYPE* operator +(const ap_int_base<_AP_W, _AP_S>& op, PTR_TYPE* i_op) { std::ptrdiff_t op2 = op.to_long(); return op2 + i_op; }
template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline PTR_TYPE* operator -(PTR_TYPE* i_op, const ap_int_base<_AP_W, _AP_S>& op) { std::ptrdiff_t op2 = op.to_long(); return i_op - op2; } template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline PTR_TYPE* operator -(const ap_int_base<_AP_W, _AP_S>& op, PTR_TYPE* i_op) { std::ptrdiff_t op2 = op.to_long(); return op2 - i_op; }
#1429 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline half operator *(half i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op * op2; } template <int _AP_W, bool _AP_S> inline half operator *(const ap_int_base<_AP_W, _AP_S>& op, half i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 * i_op; } template <int _AP_W, bool _AP_S> inline half operator /(half i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op / op2; } template <int _AP_W, bool _AP_S> inline half operator /(const ap_int_base<_AP_W, _AP_S>& op, half i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 / i_op; } template <int _AP_W, bool _AP_S> inline half operator +(half i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op + op2; } template <int _AP_W, bool _AP_S> inline half operator +(const ap_int_base<_AP_W, _AP_S>& op, half i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 + i_op; } template <int _AP_W, bool _AP_S> inline half operator -(half i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op - op2; } template <int _AP_W, bool _AP_S> inline half operator -(const ap_int_base<_AP_W, _AP_S>& op, half i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 - i_op; }
template <int _AP_W, bool _AP_S> inline float operator *(float i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op * op2; } template <int _AP_W, bool _AP_S> inline float operator *(const ap_int_base<_AP_W, _AP_S>& op, float i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 * i_op; } template <int _AP_W, bool _AP_S> inline float operator /(float i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op / op2; } template <int _AP_W, bool _AP_S> inline float operator /(const ap_int_base<_AP_W, _AP_S>& op, float i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 / i_op; } template <int _AP_W, bool _AP_S> inline float operator +(float i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op + op2; } template <int _AP_W, bool _AP_S> inline float operator +(const ap_int_base<_AP_W, _AP_S>& op, float i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 + i_op; } template <int _AP_W, bool _AP_S> inline float operator -(float i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op - op2; } template <int _AP_W, bool _AP_S> inline float operator -(const ap_int_base<_AP_W, _AP_S>& op, float i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 - i_op; }
template <int _AP_W, bool _AP_S> inline double operator *(double i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op * op2; } template <int _AP_W, bool _AP_S> inline double operator *(const ap_int_base<_AP_W, _AP_S>& op, double i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 * i_op; } template <int _AP_W, bool _AP_S> inline double operator /(double i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op / op2; } template <int _AP_W, bool _AP_S> inline double operator /(const ap_int_base<_AP_W, _AP_S>& op, double i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 / i_op; } template <int _AP_W, bool _AP_S> inline double operator +(double i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op + op2; } template <int _AP_W, bool _AP_S> inline double operator +(const ap_int_base<_AP_W, _AP_S>& op, double i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 + i_op; } template <int _AP_W, bool _AP_S> inline double operator -(double i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op - op2; } template <int _AP_W, bool _AP_S> inline double operator -(const ap_int_base<_AP_W, _AP_S>& op, double i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 - i_op; }
#1463 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::mult operator *(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op * ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::plus operator +(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op + ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::minus operator -(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op - ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::div operator /(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op / ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::mod operator %(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op % ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator &(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op & ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator |(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op | ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator ^(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op ^ ap_int_base<1, false>(i_op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::mult operator *(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op * ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::plus operator +(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op + ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::minus operator -(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op - ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::div operator /(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op / ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::mod operator %(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op % ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator &(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op & ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator |(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op | ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator ^(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op ^ ap_int_base<8, CHAR_IS_SIGNED>(i_op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::mult operator *(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op * ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::plus operator +(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op + ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::minus operator -(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op - ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::div operator /(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op / ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::mod operator %(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op % ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator &(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op & ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator |(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op | ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator ^(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op ^ ap_int_base<8, true>(i_op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::mult operator *(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op * ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::plus operator +(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op + ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::minus operator -(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op - ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::div operator /(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op / ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::mod operator %(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op % ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator &(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op & ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator |(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op | ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator ^(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op ^ ap_int_base<8, false>(i_op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::mult operator *(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op * ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::plus operator +(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op + ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::minus operator -(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op - ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::div operator /(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op / ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::mod operator %(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op % ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator &(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op & ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator |(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op | ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator ^(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op ^ ap_int_base<_AP_SIZE_short, true>(i_op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::mult operator *(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op * ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::plus operator +(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op + ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::minus operator -(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op - ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::div operator /(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op / ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::mod operator %(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op % ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator &(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op & ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator |(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op | ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator ^(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op ^ ap_int_base<_AP_SIZE_short, false>(i_op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::mult operator *(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op * ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::plus operator +(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op + ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::minus operator -(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op - ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::div operator /(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op / ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::mod operator %(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op % ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator &(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op & ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator |(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op | ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator ^(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op ^ ap_int_base<_AP_SIZE_int, true>(i_op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::mult operator *(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op * ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::plus operator +(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op + ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::minus operator -(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op - ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::div operator /(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op / ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::mod operator %(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op % ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator &(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op & ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator |(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op | ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator ^(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op ^ ap_int_base<_AP_SIZE_int, false>(i_op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::mult operator *(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op * ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::plus operator +(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op + ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::minus operator -(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op - ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::div operator /(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op / ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::mod operator %(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op % ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator &(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op & ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator |(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op | ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator ^(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op ^ ap_int_base<_AP_SIZE_long, true>(i_op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::mult operator *(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op * ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::plus operator +(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op + ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::minus operator -(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op - ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::div operator /(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op / ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::mod operator %(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op % ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator &(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op & ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator |(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op | ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator ^(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op ^ ap_int_base<_AP_SIZE_long, false>(i_op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::mult operator *(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op * ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::plus operator +(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op + ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::minus operator -(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op - ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::div operator /(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op / ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::mod operator %(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op % ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator &(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op & ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator |(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op | ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator ^(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op ^ ap_int_base<_AP_SIZE_ap_slong, true>(i_op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::mult operator *(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op * ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::plus operator +(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op + ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::minus operator -(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op - ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::div operator /(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op / ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::mod operator %(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op % ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator &(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op & ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator |(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op | ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator ^(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op ^ ap_int_base<_AP_SIZE_ap_slong, false>(i_op); }
#1502 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, char op2) { ap_int_base<_AP_W, _AP_S> r; if (CHAR_IS_SIGNED) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, char op2) { ap_int_base<_AP_W, _AP_S> r; if (CHAR_IS_SIGNED) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, short op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, short op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, int op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, int op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, long op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, long op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
#1526 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, bool op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, bool op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V >> op2; return r; }
#1557 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op += ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op -= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op *= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op /= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op %= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op &= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op |= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op ^= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op >>= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op <<= ap_int_base<1, false>(op2); }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op += ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op -= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op *= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op /= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op %= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op &= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op |= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op ^= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op >>= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op <<= ap_int_base<8, CHAR_IS_SIGNED>(op2); }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op += ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op -= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op *= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op /= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op %= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op &= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op |= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op ^= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op >>= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op <<= ap_int_base<8, true>(op2); }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op += ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op -= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op *= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op /= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op %= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op &= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op |= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op ^= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op >>= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op <<= ap_int_base<8, false>(op2); }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op += ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op -= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op *= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op /= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op %= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op &= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op |= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op ^= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op >>= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op <<= ap_int_base<_AP_SIZE_short, true>(op2); }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op += ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op -= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op *= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op /= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op %= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op &= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op |= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op ^= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op >>= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op <<= ap_int_base<_AP_SIZE_short, false>(op2); }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op += ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op -= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op *= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op /= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op %= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op &= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op |= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op ^= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op >>= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op <<= ap_int_base<_AP_SIZE_int, true>(op2); }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op += ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op -= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op *= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op /= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op %= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op &= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op |= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op ^= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op >>= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op <<= ap_int_base<_AP_SIZE_int, false>(op2); }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op += ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op -= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op *= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op /= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op %= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op &= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op |= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op ^= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op >>= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op <<= ap_int_base<_AP_SIZE_long, true>(op2); }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op += ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op -= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op *= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op /= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op %= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op &= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op |= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op ^= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op >>= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op <<= ap_int_base<_AP_SIZE_long, false>(op2); }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op += ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op -= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op *= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op /= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op %= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op &= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op |= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op ^= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op >>= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op <<= ap_int_base<_AP_SIZE_ap_slong, true>(op2); }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op += ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op -= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op *= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op /= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op %= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op &= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op |= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op ^= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op >>= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op <<= ap_int_base<_AP_SIZE_ap_slong, false>(op2); }
#1594 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline bool operator >(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op > ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op < ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op >= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op <= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op == ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op != ap_int_base<1, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) > op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op > ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) < op; } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op < ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op >= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op <= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) == op; } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op == ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) != op; } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op != ap_int_base<8, CHAR_IS_SIGNED>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op > ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op < ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op >= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op <= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op == ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op != ap_int_base<8, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op > ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op < ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op >= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op <= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op == ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op != ap_int_base<8, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op > ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op < ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op >= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op <= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op == ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op != ap_int_base<_AP_SIZE_short, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op > ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op < ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op >= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op <= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op == ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op != ap_int_base<_AP_SIZE_short, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op > ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op < ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op >= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op <= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op == ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op != ap_int_base<_AP_SIZE_int, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op > ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op < ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op >= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op <= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op == ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op != ap_int_base<_AP_SIZE_int, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op > ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op < ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op >= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op <= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op == ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op != ap_int_base<_AP_SIZE_long, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op > ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op < ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op >= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op <= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op == ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op != ap_int_base<_AP_SIZE_long, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op > ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op < ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op >= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op <= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op == ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op != ap_int_base<_AP_SIZE_ap_slong, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op > ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op < ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op >= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op <= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op == ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op != ap_int_base<_AP_SIZE_ap_slong, false>(op2); }
#1631 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
  template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() > op2 ; } template <int _AP_W, bool _AP_S> inline bool operator >(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 > op2.to_double() ; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() > op2 ; } template <int _AP_W, bool _AP_S> inline bool operator >(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 > op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() < op2 ; } template <int _AP_W, bool _AP_S> inline bool operator <(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 < op2.to_double() ; } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() < op2 ; } template <int _AP_W, bool _AP_S> inline bool operator <(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 < op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() >= op2 ; } template <int _AP_W, bool _AP_S> inline bool operator >=(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 >= op2.to_double() ; } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() >= op2 ; } template <int _AP_W, bool _AP_S> inline bool operator >=(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 >= op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() <= op2 ; } template <int _AP_W, bool _AP_S> inline bool operator <=(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 <= op2.to_double() ; } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() <= op2 ; } template <int _AP_W, bool _AP_S> inline bool operator <=(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 <= op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() == op2 ; } template <int _AP_W, bool _AP_S> inline bool operator ==(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 == op2.to_double() ; } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() == op2 ; } template <int _AP_W, bool _AP_S> inline bool operator ==(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 == op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() != op2 ; } template <int _AP_W, bool _AP_S> inline bool operator !=(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 != op2.to_double() ; } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() != op2 ; } template <int _AP_W, bool _AP_S> inline bool operator !=(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 != op2.to_double() ; }
#1661 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::plus operator +(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) + op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::plus operator +(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 + ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::minus operator -(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) - op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::minus operator -(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 - ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mult operator *(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) * op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mult operator *(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 * ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::div operator /(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) / op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::div operator /(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 / ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mod operator %(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) % op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mod operator %(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 % ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator &(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) & op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator &(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 & ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator |(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) | op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator |(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 | ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator ^(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) ^ op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator ^(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 ^ ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator >>(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) >> op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator >>(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 >> ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator <<(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) << op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator <<(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 << ap_int_base<_AP_W2, false>(op2); }
#1690 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator +=( ap_int_base<_AP_W1, _AP_S1>& op1, ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 += ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1, _AP_S1>& operator +=( ap_range_ref<_AP_W1, _AP_S1>& op1, ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp += op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator -=( ap_int_base<_AP_W1, _AP_S1>& op1, ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 -= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1, _AP_S1>& operator -=( ap_range_ref<_AP_W1, _AP_S1>& op1, ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp -= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator *=( ap_int_base<_AP_W1, _AP_S1>& op1, ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 *= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1, _AP_S1>& operator *=( ap_range_ref<_AP_W1, _AP_S1>& op1, ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp *= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator /=( ap_int_base<_AP_W1, _AP_S1>& op1, ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 /= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1, _AP_S1>& operator /=( ap_range_ref<_AP_W1, _AP_S1>& op1, ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp /= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator %=( ap_int_base<_AP_W1, _AP_S1>& op1, ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 %= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1, _AP_S1>& operator %=( ap_range_ref<_AP_W1, _AP_S1>& op1, ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp %= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator &=( ap_int_base<_AP_W1, _AP_S1>& op1, ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 &= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1, _AP_S1>& operator &=( ap_range_ref<_AP_W1, _AP_S1>& op1, ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp &= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator |=( ap_int_base<_AP_W1, _AP_S1>& op1, ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 |= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1, _AP_S1>& operator |=( ap_range_ref<_AP_W1, _AP_S1>& op1, ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp |= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator ^=( ap_int_base<_AP_W1, _AP_S1>& op1, ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 ^= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1, _AP_S1>& operator ^=( ap_range_ref<_AP_W1, _AP_S1>& op1, ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp ^= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator >>=( ap_int_base<_AP_W1, _AP_S1>& op1, ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 >>= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1, _AP_S1>& operator >>=( ap_range_ref<_AP_W1, _AP_S1>& op1, ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp >>= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator <<=( ap_int_base<_AP_W1, _AP_S1>& op1, ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 <<= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1, _AP_S1>& operator <<=( ap_range_ref<_AP_W1, _AP_S1>& op1, ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp <<= op2; op1 = tmp; return op1; }
#1716 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator ==(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator ==(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator ==(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator ==(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator !=(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator !=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator !=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator !=(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator >(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >=(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator >=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >=(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator <(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <=(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator <=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <=(op2.operator ap_int_base<_AP_W2, false>()); }
#1743 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::plus operator +(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 + ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::plus operator +(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) + op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::minus operator -(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 - ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::minus operator -(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) - op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::mult operator *(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 * ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::mult operator *(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) * op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::div operator /(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 / ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::div operator /(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) / op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::mod operator %(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 % ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::mod operator %(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) % op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::logic operator &(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 & ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::logic operator &(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) & op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::logic operator |(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 | ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::logic operator |(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) | op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::logic operator ^(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 ^ ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::logic operator ^(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) ^ op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::arg1 operator >>(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 >> ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::arg1 operator >>(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) >> op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::arg1 operator <<(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 << ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::arg1 operator <<(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) << op2; }
#1772 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator +=( ap_int_base<_AP_W1, _AP_S1>& op1, ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 += ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1, _AP_S1>& operator +=( ap_bit_ref<_AP_W1, _AP_S1>& op1, ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp += op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator -=( ap_int_base<_AP_W1, _AP_S1>& op1, ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 -= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1, _AP_S1>& operator -=( ap_bit_ref<_AP_W1, _AP_S1>& op1, ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp -= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator *=( ap_int_base<_AP_W1, _AP_S1>& op1, ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 *= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1, _AP_S1>& operator *=( ap_bit_ref<_AP_W1, _AP_S1>& op1, ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp *= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator /=( ap_int_base<_AP_W1, _AP_S1>& op1, ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 /= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1, _AP_S1>& operator /=( ap_bit_ref<_AP_W1, _AP_S1>& op1, ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp /= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator %=( ap_int_base<_AP_W1, _AP_S1>& op1, ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 %= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1, _AP_S1>& operator %=( ap_bit_ref<_AP_W1, _AP_S1>& op1, ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp %= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator &=( ap_int_base<_AP_W1, _AP_S1>& op1, ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 &= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1, _AP_S1>& operator &=( ap_bit_ref<_AP_W1, _AP_S1>& op1, ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp &= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator |=( ap_int_base<_AP_W1, _AP_S1>& op1, ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 |= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1, _AP_S1>& operator |=( ap_bit_ref<_AP_W1, _AP_S1>& op1, ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp |= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator ^=( ap_int_base<_AP_W1, _AP_S1>& op1, ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 ^= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1, _AP_S1>& operator ^=( ap_bit_ref<_AP_W1, _AP_S1>& op1, ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp ^= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator >>=( ap_int_base<_AP_W1, _AP_S1>& op1, ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 >>= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1, _AP_S1>& operator >>=( ap_bit_ref<_AP_W1, _AP_S1>& op1, ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp >>= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator <<=( ap_int_base<_AP_W1, _AP_S1>& op1, ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 <<= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1, _AP_S1>& operator <<=( ap_bit_ref<_AP_W1, _AP_S1>& op1, ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp <<= op2; op1 = tmp; return op1; }
#1798 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator ==(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 == ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator ==(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) == op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator !=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 != ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator !=(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) != op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 > ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) > op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 >= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >=(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) >= op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 < ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) < op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 <= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <=(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) <= op2; }
#1906 "C:/Xilinx/Vivado/2018.3/include/ap_int_base.h"
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline bool operator ==( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 == op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline bool operator ==( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() == op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline bool operator !=( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 != op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline bool operator !=( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() != op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline bool operator >( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 > op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline bool operator >( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() > op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline bool operator >=( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 >= op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline bool operator >=( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() >= op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline bool operator <( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 < op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline bool operator <( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() < op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline bool operator <=( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 <= op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline bool operator <=( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() <= op2; }
#56 "C:/Xilinx/Vivado/2018.3/include/ap_int.h" 2
#1 "C:/Xilinx/Vivado/2018.3/include/ap_int_ref.h" 1
#72 "C:/Xilinx/Vivado/2018.3/include/ap_int_ref.h"
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2>
struct ap_concat_ref {
  enum {
    _AP_WR = _AP_W1 + _AP_W2,
  };

  _AP_T1& mbv1;
  _AP_T2& mbv2;

  inline ap_concat_ref(const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& ref)
      : mbv1(ref.mbv1), mbv2(ref.mbv2) {}

  inline ap_concat_ref(_AP_T1& bv1, _AP_T2& bv2) : mbv1(bv1), mbv2(bv2) {}

  template <int _AP_W3, bool _AP_S3>
  inline ap_concat_ref& operator=(const ap_int_base<_AP_W3, _AP_S3>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> vval(val);
    int W_ref1 = mbv1.length();
    int W_ref2 = mbv2.length();
    ap_int_base<_AP_W1, false> Part1;
    Part1.V = (vval.V).range((W_ref1 + W_ref2 - 1), (W_ref2));
    mbv1.set(Part1);
    ap_int_base<_AP_W2, false> Part2;
    Part2.V = (vval.V).range((W_ref2 - 1), (0));
    mbv2.set(Part2);
    return *this;
  }
#115 "C:/Xilinx/Vivado/2018.3/include/ap_int_ref.h"
  inline ap_concat_ref& operator=(bool val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(char val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(signed char val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(unsigned char val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(short val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(unsigned short val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(int val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(unsigned int val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(long val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(unsigned long val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(ap_slong val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(ap_ulong val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(half val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(float val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(double val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }





  inline ap_concat_ref& operator=(
      const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);
    return operator=(tmpVal);
  }

  template <int _AP_W3, typename _AP_T3, int _AP_W4, typename _AP_T4>
  inline ap_concat_ref& operator=(
      const ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);
    return operator=(tmpVal);
  }

  template <int _AP_W3, bool _AP_S3>
  inline ap_concat_ref& operator=(const ap_bit_ref<_AP_W3, _AP_S3>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);
    return operator=(tmpVal);
  }
  template <int _AP_W3, bool _AP_S3>
  inline ap_concat_ref& operator=(const ap_range_ref<_AP_W3, _AP_S3>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);
    return operator=(tmpVal);
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline ap_concat_ref& operator=(
      const af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>& val) {
    return operator=((const ap_int_base<_AP_W3, false>)(val));
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline ap_concat_ref& operator=(
      const ap_fixed_base<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>&
          val) {
    return operator=(val.to_ap_int_base());
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline ap_concat_ref& operator=(
      const af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>& val) {
    return operator=((ap_ulong)(bool)(val));
  }

  inline operator ap_int_base<_AP_WR, false>() const { return get(); }

  inline operator ap_ulong() const { return get().to_uint64(); }

  template <int _AP_W3, bool _AP_S3>
  inline ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                       ap_range_ref<_AP_W3, _AP_S3> >
  operator,(const ap_range_ref<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_range_ref<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_range_ref<_AP_W3, _AP_S3>&>(a2));
  }

  template <int _AP_W3, bool _AP_S3>
  inline
      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
      operator,(ap_int_base<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_int_base<_AP_W3, _AP_S3> >(*this, a2);
  }

  template <int _AP_W3, bool _AP_S3>
  inline
      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
      operator,(volatile ap_int_base<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_int_base<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_int_base<_AP_W3, _AP_S3>&>(a2));
  }

  template <int _AP_W3, bool _AP_S3>
  inline
      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
      operator,(const ap_int_base<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_int_base<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_int_base<_AP_W3, _AP_S3>&>(a2));
  }

  template <int _AP_W3, bool _AP_S3>
  inline
      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
      operator,(const volatile ap_int_base<_AP_W3, _AP_S3> &a2) {

    ap_int_base<_AP_W3, _AP_S3> op(a2);
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_int_base<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_int_base<_AP_W3, _AP_S3>&>(op));
  }

  template <int _AP_W3, bool _AP_S3>
  inline ap_concat_ref<_AP_WR, ap_concat_ref, 1, ap_bit_ref<_AP_W3, _AP_S3> >
  operator,(const ap_bit_ref<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, 1, ap_bit_ref<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_bit_ref<_AP_W3, _AP_S3>&>(a2));
  }

  template <int _AP_W3, typename _AP_T3, int _AP_W4, typename _AP_T4>
  inline ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3 + _AP_W4,
                       ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4> >
  operator,(const ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3 + _AP_W4,
                         ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4> >(
        *this, const_cast<ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4>&>(a2));
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline ap_concat_ref<
      _AP_WR, ap_concat_ref, _AP_W3,
      af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >
  operator,(
      const af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> &a2) {
    return ap_concat_ref<
        _AP_WR, ap_concat_ref, _AP_W3,
        af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >(
        *this,
        const_cast<
            af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>&>(a2));
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline
      ap_concat_ref<_AP_WR, ap_concat_ref, 1,
                    af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >
      operator,(const af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>
                    &a2) {
    return ap_concat_ref<
        _AP_WR, ap_concat_ref, 1,
        af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >(
        *this,
        const_cast<af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>&>(
            a2));
  }

  template <int _AP_W3, bool _AP_S3>
  inline ap_int_base<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3> operator&(
      const ap_int_base<_AP_W3, _AP_S3>& a2) {
    return get() & a2;
  }

  template <int _AP_W3, bool _AP_S3>
  inline ap_int_base<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3> operator|(
      const ap_int_base<_AP_W3, _AP_S3>& a2) {
    return get() | a2;
  }

  template <int _AP_W3, bool _AP_S3>
  inline ap_int_base<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3> operator^(
      const ap_int_base<_AP_W3, _AP_S3>& a2) {
    return get() ^ a2;
  }
#303 "C:/Xilinx/Vivado/2018.3/include/ap_int_ref.h"
  inline ap_int_base<_AP_WR, false> get() const {
    ap_int_base<_AP_WR, false> tmpVal(0);
    int W_ref1 = mbv1.length();
    int W_ref2 = mbv2.length();
    ap_int_base<_AP_W2, false> v2(mbv2);
    ap_int_base<_AP_W1, false> v1(mbv1);
    tmpVal.V = _AP_ROOT_op_set_range(tmpVal.V, 0, W_ref2 - 1, v2.V);
    tmpVal.V =
        _AP_ROOT_op_set_range(tmpVal.V, W_ref2, W_ref1 + W_ref2 - 1, v1.V);
    return tmpVal;
  }

  template <int _AP_W3>
  inline void set(const ap_int_base<_AP_W3, false>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> vval(val);
    int W_ref1 = mbv1.length();
    int W_ref2 = mbv2.length();
    ap_int_base<_AP_W1, false> tmpVal1;
    tmpVal1.V = (vval.V).range((W_ref1 + W_ref2 - 1), (W_ref2));
    mbv1.set(tmpVal1);
    ap_int_base<_AP_W2, false> tmpVal2;
    tmpVal2.V = (vval.V).range((W_ref2 - 1), (0));
    mbv2.set(tmpVal2);
  }

  inline int length() const { return mbv1.length() + mbv2.length(); }
};




template <int _AP_W, bool _AP_S>
struct ap_range_ref {



  typedef ap_int_base<_AP_W, _AP_S> ref_type;
  ref_type& d_bv;
  int l_index;
  int h_index;

 public:
  inline ap_range_ref(const ap_range_ref<_AP_W, _AP_S>& ref)
      : d_bv(ref.d_bv), l_index(ref.l_index), h_index(ref.h_index) {}

  inline ap_range_ref(ref_type* bv, int h, int l)
      : d_bv(*bv), l_index(l), h_index(h) {}

  inline ap_range_ref(const ref_type* bv, int h, int l)
      : d_bv(*const_cast<ref_type*>(bv)), l_index(l), h_index(h) {}

  inline operator ap_int_base<_AP_W, false>() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = (d_bv.V).range((h_index), (l_index));
    return ret;
  }

  inline operator ap_ulong() const { return to_uint64(); }
#384 "C:/Xilinx/Vivado/2018.3/include/ap_int_ref.h"
  inline ap_range_ref& operator=(bool val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(char val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(signed char val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(unsigned char val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(short val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(unsigned short val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(int val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(unsigned int val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(long val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(unsigned long val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(ap_slong val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(ap_ulong val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(half val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(float val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(double val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }




  inline ap_range_ref& operator=(const char* val) {
    const ap_int_base<_AP_W, false> tmp(val);
    d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V);
    return *this;
  }


  template <int _AP_W2, bool _AP_S2>
  inline ap_range_ref& operator=(const ap_int_base<_AP_W2, _AP_S2>& val) {
    ap_int_base<_AP_W, false> tmp(val);
    d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V);
    return *this;
  }




  inline ap_range_ref& operator=(const ap_range_ref& val) {
    return operator=((const ap_int_base<_AP_W, false>)val);
  }


  template <int _AP_W2, bool _AP_S2>
  inline ap_range_ref& operator=(const ap_range_ref<_AP_W2, _AP_S2>& val) {
    return operator=((const ap_int_base<_AP_W2, false>)val);
  }


  template <int _AP_W2, bool _AP_S2>
  inline ap_range_ref& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& val) {
    return operator=((ap_ulong)(bool)(val));
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_range_ref& operator=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          val) {
    return operator=(val.to_ap_int_base());
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_range_ref& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=((const ap_int_base<_AP_W2, false>)val);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_range_ref& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=((ap_ulong)(bool)(val));
  }


  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_range_ref& operator=(
      const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
    return operator=((const ap_int_base<_AP_W2 + _AP_W3, false>)(val));
  }


  template <int _AP_W2, bool _AP_S2>
  inline
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
      operator,(const ap_range_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_range_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_range_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(*this, a2);
  }

  inline
  ap_concat_ref<_AP_W, ap_range_ref, _AP_W, ap_int_base<_AP_W, _AP_S> >
  operator,(ap_int_base<_AP_W, _AP_S>& a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W,
                         ap_int_base<_AP_W, _AP_S> >(*this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(volatile ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(const ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(const volatile ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<_AP_W, ap_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >
  operator,(const ap_bit_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_bit_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_concat_ref<_AP_W, ap_range_ref, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(
        *this, const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_concat_ref<
      _AP_W, ap_range_ref, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> a2) {
    return ap_concat_ref<
        _AP_W, ap_range_ref, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<
            af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline
      ap_concat_ref<_AP_W, ap_range_ref, 1,
                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>
                    &a2) {
    return ap_concat_ref<
        _AP_W, ap_range_ref, 1,
        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator==(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> hop(op2);
    return lop == hop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator!=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator==(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator<(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> hop(op2);
    return lop < hop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator<=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> hop(op2);
    return lop <= hop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator>(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator<=(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator>=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator<(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_range_ref<_AP_W, _AP_S>& operator|=(
      const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V |= (op2.d_bv).V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline ap_range_ref<_AP_W, _AP_S>& operator|=(
      const ap_int_base<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V |= op2.V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline ap_range_ref<_AP_W, _AP_S>& operator&=(
      const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V &= (op2.d_bv).V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline ap_range_ref<_AP_W, _AP_S>& operator&=(
      const ap_int_base<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V &= op2.V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline ap_range_ref<_AP_W, _AP_S>& operator^=(
      const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V ^= (op2.d_bv).V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline ap_range_ref<_AP_W, _AP_S>& operator^=(
      const ap_int_base<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V ^= op2.V;
    return *this;
  };

  inline ap_int_base<_AP_W, false> get() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = (d_bv.V).range((h_index), (l_index));
    return ret;
  }

  template <int _AP_W2>
  inline void set(const ap_int_base<_AP_W2, false>& val) {
    d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, val.V);
  }

  inline int length() const {
    return h_index >= l_index ? h_index - l_index + 1 : l_index - h_index + 1;
  }

  inline int to_int() const {
    return (int)((d_bv.V).range((h_index), (l_index)));
  }

  inline unsigned to_uint() const {
    return (unsigned)((d_bv.V).range((h_index), (l_index)));
  }

  inline long to_long() const {
    return (long)((d_bv.V).range((h_index), (l_index)));
  }

  inline unsigned long to_ulong() const {
    return (unsigned long)((d_bv.V).range((h_index), (l_index)));
  }

  inline ap_slong to_int64() const {
    return (ap_slong)((d_bv.V).range((h_index), (l_index)));
  }

  inline ap_ulong to_uint64() const {
    return (ap_ulong)((d_bv.V).range((h_index), (l_index)));
  }

  inline bool and_reduce() const {
    bool ret = true;
    bool reverse = l_index > h_index;
    unsigned low = reverse ? h_index : l_index;
    unsigned high = reverse ? l_index : h_index;
    for (unsigned i = low; i != high; ++i) {



      ret &= (d_bv.V).get_bit((i));
    }
    return ret;
  }

  inline bool or_reduce() const {
    bool ret = false;
    bool reverse = l_index > h_index;
    unsigned low = reverse ? h_index : l_index;
    unsigned high = reverse ? l_index : h_index;
    for (unsigned i = low; i != high; ++i) {



      ret |= (d_bv.V).get_bit((i));
    }
    return ret;
  }

  inline bool xor_reduce() const {
    bool ret = false;
    bool reverse = l_index > h_index;
    unsigned low = reverse ? h_index : l_index;
    unsigned high = reverse ? l_index : h_index;
    for (unsigned i = low; i != high; ++i) {



      ret ^= (d_bv.V).get_bit((i));
    }
    return ret;
  }

  std::string to_string(signed char radix = 2) const {
    ap_int_base<_AP_W, false> ret;
    ret.V = (d_bv.V).range((h_index), (l_index));
    return ret.to_string(radix);
  }






};




template <int _AP_W, bool _AP_S>
inline std::ostream& operator<<(std::ostream& os,
                                const ap_range_ref<_AP_W, _AP_S>& x) {
  std::ios_base::fmtflags ff = std::cout.flags();
  if (ff & std::cout.hex) {
    os << x.to_string(16);
  } else if (ff & std::cout.oct) {
    os << x.to_string(8);
  } else {
    os << x.to_string(10);
  }
  return os;
}



template <int _AP_W, bool _AP_S>
inline std::istream& operator>>(std::istream& in,
                                ap_range_ref<_AP_W, _AP_S>& op) {
  std::string str;
  in >> str;
  op = ap_int_base<_AP_W, _AP_S>(str.c_str());
  return in;
}






template <int _AP_W, bool _AP_S>
struct ap_bit_ref {



  typedef ap_int_base<_AP_W, _AP_S> ref_type;
  ref_type& d_bv;
  int d_index;

 public:

  inline ap_bit_ref(const ap_bit_ref<_AP_W, _AP_S>& ref)
      : d_bv(ref.d_bv), d_index(ref.d_index) {}

  inline ap_bit_ref(ref_type* bv, int index = 0) : d_bv(*bv), d_index(index) {}

  inline ap_bit_ref(const ref_type* bv, int index = 0)
      : d_bv(*const_cast<ref_type*>(bv)), d_index(index) {}

  inline operator bool() const { return (d_bv.V).get_bit((d_index)); }
  inline bool to_bool() const { return (d_bv.V).get_bit((d_index)); }
#809 "C:/Xilinx/Vivado/2018.3/include/ap_int_ref.h"
  inline ap_bit_ref& operator=(bool val) { d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val); return *this; }
  inline ap_bit_ref& operator=(char val) { d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val); return *this; }
  inline ap_bit_ref& operator=(signed char val) { d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val); return *this; }
  inline ap_bit_ref& operator=(unsigned char val) { d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val); return *this; }
  inline ap_bit_ref& operator=(short val) { d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val); return *this; }
  inline ap_bit_ref& operator=(unsigned short val) { d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val); return *this; }
  inline ap_bit_ref& operator=(int val) { d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val); return *this; }
  inline ap_bit_ref& operator=(unsigned int val) { d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val); return *this; }
  inline ap_bit_ref& operator=(long val) { d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val); return *this; }
  inline ap_bit_ref& operator=(unsigned long val) { d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val); return *this; }
  inline ap_bit_ref& operator=(ap_slong val) { d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val); return *this; }
  inline ap_bit_ref& operator=(ap_ulong val) { d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val); return *this; }
#831 "C:/Xilinx/Vivado/2018.3/include/ap_int_ref.h"
  inline ap_bit_ref& operator=(half val) { bool tmp_val = val; d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index,tmp_val); return *this; }
  inline ap_bit_ref& operator=(float val) { bool tmp_val = val; d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index,tmp_val); return *this; }
  inline ap_bit_ref& operator=(double val) { bool tmp_val = val; d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index,tmp_val); return *this; }




  template <int _AP_W2, bool _AP_S2>
  inline ap_bit_ref& operator=(const ap_int_base<_AP_W2, _AP_S2>& val) {
    return operator=((ap_ulong)(val.V != 0));
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_bit_ref& operator=(const ap_range_ref<_AP_W2, _AP_S2>& val) {
    return operator=((ap_int_base<_AP_W2, false>)val);
  }



  inline ap_bit_ref& operator=(const ap_bit_ref& val) {
    return operator=((ap_ulong)(bool)val);
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_bit_ref& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& val) {
    return operator=((ap_ulong)(bool)val);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_bit_ref& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=((const ap_int_base<_AP_W2, false>)val);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_bit_ref& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=((ap_ulong)(bool)val);
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_bit_ref& operator=(
      const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
    return operator=((const ap_int_base<_AP_W2 + _AP_W3, false>)val);
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(volatile ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(const ap_int_base<_AP_W2, _AP_S2> &a2) {
    ap_int_base<_AP_W2, _AP_S2> op(a2);
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(op));
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(const volatile ap_int_base<_AP_W2, _AP_S2> &a2) {
    ap_int_base<_AP_W2, _AP_S2> op(a2);
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(op));
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
  operator,(const ap_range_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_range_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<1, ap_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> > operator,(
      const ap_bit_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_bit_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_concat_ref<1, ap_bit_ref, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
    return ap_concat_ref<1, ap_bit_ref, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(
        *this, const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_concat_ref<
      1, ap_bit_ref, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {
    return ap_concat_ref<
        1, ap_bit_ref, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<
            af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_concat_ref<1, ap_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                                    _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                                      _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator==(const ap_bit_ref<_AP_W2, _AP_S2>& op) {
    return get() == op.get();
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator!=(const ap_bit_ref<_AP_W2, _AP_S2>& op) {
    return get() != op.get();
  }

  inline bool get() const { return (d_bv.V).get_bit((d_index)); }

  inline bool get() { return (d_bv.V).get_bit((d_index)); }

  template <int _AP_W3>
  inline void set(const ap_int_base<_AP_W3, false>& val) {
    operator=(val);
  }

  inline bool operator~() const {
    bool bit = (d_bv.V).get_bit((d_index));
    return bit ? false : true;
  }

  inline int length() const { return 1; }


  std::string to_string() const { return get() ? "1" : "0"; }




};
#1029 "C:/Xilinx/Vivado/2018.3/include/ap_int_ref.h"
template <int _AP_W, bool _AP_S> inline bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline bool operator >(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline bool operator <(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<1, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline bool operator >(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline bool operator <(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<8, CHAR_IS_SIGNED>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline bool operator >(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline bool operator <(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<8, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<8, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline bool operator >(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline bool operator <(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_short, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_short, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline bool operator >(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline bool operator <(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_int, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_int, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline bool operator >(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline bool operator <(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_long, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_long, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline bool operator >(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline bool operator <(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_ap_slong, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline bool operator >(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline bool operator <(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_ap_slong, false>(op2); }






template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<1, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<8, CHAR_IS_SIGNED>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<8, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<8, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_short, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_short, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_int, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_int, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_long, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_long, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_ap_slong, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_ap_slong, false>(op2); }
#1088 "C:/Xilinx/Vivado/2018.3/include/ap_int_ref.h"
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::plus operator +(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::minus operator -(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::mult operator *(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::div operator /(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::mod operator %(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::plus operator +(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::minus operator -(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::mult operator *(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::div operator /(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::mod operator %(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::plus operator +(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::minus operator -(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::mult operator *(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::div operator /(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::mod operator %(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::plus operator +(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::minus operator -(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::mult operator *(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::div operator /(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::mod operator %(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::plus operator +(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::minus operator -(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::mult operator *(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::div operator /(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::mod operator %(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::plus operator +(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::minus operator -(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::mult operator *(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::div operator /(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::mod operator %(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::plus operator +(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::minus operator -(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::mult operator *(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::div operator /(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::mod operator %(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::plus operator +(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::minus operator -(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::mult operator *(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::div operator /(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::mod operator %(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::plus operator +(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::minus operator -(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::mult operator *(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::div operator /(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::mod operator %(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::plus operator +(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::minus operator -(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::mult operator *(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::div operator /(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::mod operator %(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::plus operator +(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::minus operator -(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::mult operator *(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::div operator /(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::mod operator %(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::plus operator +(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::minus operator -(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::mult operator *(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::div operator /(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::mod operator %(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
#1111 "C:/Xilinx/Vivado/2018.3/include/ap_int_ref.h"
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::logic operator &(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::logic operator |(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::logic operator ^(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::arg1 operator >>(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::arg1 operator <<(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::logic operator &(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::logic operator |(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::logic operator ^(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::arg1 operator >>(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::arg1 operator <<(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::logic operator &(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::logic operator |(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::logic operator ^(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::arg1 operator >>(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::arg1 operator <<(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::logic operator &(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::logic operator |(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::logic operator &(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::logic operator |(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::logic operator ^(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::arg1 operator >>(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::arg1 operator <<(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::logic operator &(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::logic operator |(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::logic operator &(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::logic operator |(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::logic operator ^(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::arg1 operator >>(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::arg1 operator <<(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::logic operator &(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::logic operator |(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::logic operator &(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::logic operator |(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::logic operator ^(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::arg1 operator >>(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::arg1 operator <<(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::logic operator &(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::logic operator |(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::logic operator &(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::logic operator |(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::logic operator ^(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::arg1 operator >>(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::arg1 operator <<(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::logic operator &(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::logic operator |(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::logic operator ^(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::arg1 operator >>(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::arg1 operator <<(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
#1139 "C:/Xilinx/Vivado/2018.3/include/ap_int_ref.h"
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())+( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())-( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())*( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::div operator /(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())/( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())%( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())&( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())|( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())^( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())>>( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())<<( rhs.operator ap_int_base<_AP_W2, false>()); }
#1188 "C:/Xilinx/Vivado/2018.3/include/ap_int_ref.h"
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::plus operator +( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() + rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::minus operator -( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() - rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::mult operator *( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() * rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::div operator /( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() / rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::mod operator %( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() % rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::logic operator &( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() & rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::logic operator |( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() | rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::logic operator ^( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() ^ rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::arg1 operator >>( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() >> rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::arg1 operator <<( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() << rhs.get(); }
#1335 "C:/Xilinx/Vivado/2018.3/include/ap_int_ref.h"
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 1, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, bool op2) { ap_int_base<1 + _AP_W, false> val(op2); ap_int_base<1 + _AP_W, false> ret(op1); ret <<= 1; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 1, false> operator,( bool op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<1 + _AP_W, false> val(op1); ap_int_base<1 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 1; ret >>= 1; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 1, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, bool op2) { ap_int_base<1 + _AP_W, false> val(op2); ap_int_base<1 + _AP_W, false> ret(op1); ret <<= 1; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 1, false> operator,( bool op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<1 + _AP_W, false> val(op1); ap_int_base<1 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<1 + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, bool op2) { ap_int_base<1 + 1, false> val(op2); val[1] = op1; return val; } template <int _AP_W, bool _AP_S> inline ap_int_base<1 + 1, false> operator,( bool op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<1 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + 1, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, bool op2) { ap_int_base<1 + _AP_W + _AP_W2, false> val(op2); ap_int_base<1 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 1; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + 1, false> operator,( bool op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<1 + _AP_W + _AP_W2, false> val(op1); ap_int_base<1 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + 1, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, bool op2) { ap_int_base<1 + _AP_W, false> val(op2); ap_int_base<1 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 1; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + 1, false> operator,( bool op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<1 + _AP_W, false> val(op1); ap_int_base<1 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + 1, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, bool op2) { ap_int_base<1 + 1, false> val(op2); val[1] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + 1, false> operator,( bool op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<1 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 8, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (CHAR_IS_SIGNED) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 8, false> operator,( char op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 8; ret >>= 8; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 8, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (CHAR_IS_SIGNED) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 8, false> operator,( char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<8 + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, char op2) { ap_int_base<8 + 1, false> val(op2); val[8] = op1; return val; } template <int _AP_W, bool _AP_S> inline ap_int_base<8 + 1, false> operator,( char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, char op2) { ap_int_base<8 + _AP_W + _AP_W2, CHAR_IS_SIGNED> val(op2); ap_int_base<8 + _AP_W + _AP_W2, CHAR_IS_SIGNED> ret(op1); if (CHAR_IS_SIGNED) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<8 + _AP_W + _AP_W2, CHAR_IS_SIGNED> val(op1); ap_int_base<8 + _AP_W + _AP_W2, CHAR_IS_SIGNED> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + 8, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); if (CHAR_IS_SIGNED) { val <<= _AP_W; val >>= _AP_W; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + 8, false> operator,( char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + 8, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, char op2) { ap_int_base<8 + 1, CHAR_IS_SIGNED> val(op2); val[8] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + 8, false> operator,( char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + 1, CHAR_IS_SIGNED> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 8, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, signed char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 8, false> operator,( signed char op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 8; ret >>= 8; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 8, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, signed char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 8, false> operator,( signed char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<8 + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, signed char op2) { ap_int_base<8 + 1, false> val(op2); val[8] = op1; return val; } template <int _AP_W, bool _AP_S> inline ap_int_base<8 + 1, false> operator,( signed char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, signed char op2) { ap_int_base<8 + _AP_W + _AP_W2, true> val(op2); ap_int_base<8 + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( signed char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<8 + _AP_W + _AP_W2, true> val(op1); ap_int_base<8 + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + 8, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, signed char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + 8, false> operator,( signed char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + 8, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, signed char op2) { ap_int_base<8 + 1, true> val(op2); val[8] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + 8, false> operator,( signed char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 8, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, unsigned char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 8, false> operator,( unsigned char op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 8; ret >>= 8; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 8, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, unsigned char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 8, false> operator,( unsigned char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<8 + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned char op2) { ap_int_base<8 + 1, false> val(op2); val[8] = op1; return val; } template <int _AP_W, bool _AP_S> inline ap_int_base<8 + 1, false> operator,( unsigned char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned char op2) { ap_int_base<8 + _AP_W + _AP_W2, false> val(op2); ap_int_base<8 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( unsigned char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<8 + _AP_W + _AP_W2, false> val(op1); ap_int_base<8 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + 8, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + 8, false> operator,( unsigned char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + 8, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned char op2) { ap_int_base<8 + 1, false> val(op2); val[8] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + 8, false> operator,( unsigned char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); ret <<= _AP_SIZE_short; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( short op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_short; ret >>= _AP_SIZE_short; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); ret <<= _AP_SIZE_short; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( short op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_short + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, short op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op2); val[_AP_SIZE_short] = op1; return val; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_short + 1, false> operator,( short op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_short, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, short op2) { ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, true> val(op2); ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_short; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_short, false> operator,( short op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, true> val(op1); ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_short; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( short op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_short, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, short op2) { ap_int_base<_AP_SIZE_short + 1, true> val(op2); val[_AP_SIZE_short] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_short, false> operator,( short op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_short + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); ret <<= _AP_SIZE_short; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( unsigned short op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_short; ret >>= _AP_SIZE_short; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); ret <<= _AP_SIZE_short; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( unsigned short op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_short + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op2); val[_AP_SIZE_short] = op1; return val; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_short + 1, false> operator,( unsigned short op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_short, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_short; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_short, false> operator,( unsigned short op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_short; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( unsigned short op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_short, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op2); val[_AP_SIZE_short] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_short, false> operator,( unsigned short op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); ret <<= _AP_SIZE_int; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( int op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_int; ret >>= _AP_SIZE_int; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); ret <<= _AP_SIZE_int; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( int op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_int + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, int op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op2); val[_AP_SIZE_int] = op1; return val; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_int + 1, false> operator,( int op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_int, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, int op2) { ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, true> val(op2); ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_int; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_int, false> operator,( int op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, true> val(op1); ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_int; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( int op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_int, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, int op2) { ap_int_base<_AP_SIZE_int + 1, true> val(op2); val[_AP_SIZE_int] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_int, false> operator,( int op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_int + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); ret <<= _AP_SIZE_int; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( unsigned int op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_int; ret >>= _AP_SIZE_int; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); ret <<= _AP_SIZE_int; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( unsigned int op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_int + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op2); val[_AP_SIZE_int] = op1; return val; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_int + 1, false> operator,( unsigned int op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_int, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_int; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_int, false> operator,( unsigned int op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_int; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( unsigned int op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_int, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op2); val[_AP_SIZE_int] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_int, false> operator,( unsigned int op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); ret <<= _AP_SIZE_long; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( long op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_long; ret >>= _AP_SIZE_long; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); ret <<= _AP_SIZE_long; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( long op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_long + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, long op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op2); val[_AP_SIZE_long] = op1; return val; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_long + 1, false> operator,( long op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_long, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, long op2) { ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, true> val(op2); ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_long; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_long, false> operator,( long op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, true> val(op1); ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_long; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( long op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_long, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, long op2) { ap_int_base<_AP_SIZE_long + 1, true> val(op2); val[_AP_SIZE_long] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_long, false> operator,( long op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_long + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); ret <<= _AP_SIZE_long; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( unsigned long op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_long; ret >>= _AP_SIZE_long; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); ret <<= _AP_SIZE_long; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( unsigned long op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_long + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op2); val[_AP_SIZE_long] = op1; return val; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_long + 1, false> operator,( unsigned long op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_long, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_long; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_long, false> operator,( unsigned long op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_long; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( unsigned long op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_long, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op2); val[_AP_SIZE_long] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_long, false> operator,( unsigned long op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); ret <<= _AP_SIZE_ap_slong; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_ap_slong; ret >>= _AP_SIZE_ap_slong; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); ret <<= _AP_SIZE_ap_slong; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_ap_slong + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op2); val[_AP_SIZE_ap_slong] = op1; return val; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_ap_slong + 1, false> operator,( ap_slong op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_ap_slong, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, true> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_ap_slong; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, true> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_ap_slong; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_ap_slong, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + 1, true> val(op2); val[_AP_SIZE_ap_slong] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_ap_slong + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); ret <<= _AP_SIZE_ap_slong; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_ap_slong; ret >>= _AP_SIZE_ap_slong; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); ret <<= _AP_SIZE_ap_slong; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_ap_slong + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op2); val[_AP_SIZE_ap_slong] = op1; return val; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_ap_slong + 1, false> operator,( ap_ulong op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_ap_slong, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_ap_slong; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_ap_slong; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_ap_slong, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op2); val[_AP_SIZE_ap_slong] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
#1359 "C:/Xilinx/Vivado/2018.3/include/ap_int_ref.h"
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, int rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned int rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, long rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned long rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_slong rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_ulong rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }

template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, int rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned int rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, long rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned long rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_slong rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_ulong rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
#57 "C:/Xilinx/Vivado/2018.3/include/ap_int.h" 2




template <int _AP_W>
struct ap_int : ap_int_base<_AP_W, true> {
  typedef ap_int_base<_AP_W, true> Base;

  inline ap_int() : Base() {}
  template <int _AP_W2>
  inline ap_int(const ap_int<_AP_W2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2>
  inline ap_int(const volatile ap_int<_AP_W2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2>
  inline ap_int(const ap_uint<_AP_W2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2>
  inline ap_int(const volatile ap_uint<_AP_W2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_int(const ap_range_ref<_AP_W2, _AP_S2>& ref) : Base(ref) {}

  template <int _AP_W2, bool _AP_S2>
  inline ap_int(const ap_bit_ref<_AP_W2, _AP_S2>& ref) : Base(ref) {}

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_int(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref)
      : Base(ref) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline ap_int(const ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline ap_int(const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {
  }

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline ap_int(
      const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline ap_int(
      const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_int(const ap_int_base<_AP_W2, _AP_S2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_int(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_int(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_int(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}



  inline ap_int(bool val) { Base::V = val; }
  inline ap_int(char val) { Base::V = val; }
  inline ap_int(signed char val) { Base::V = val; }
  inline ap_int(unsigned char val) { Base::V = val; }
  inline ap_int(short val) { Base::V = val; }
  inline ap_int(unsigned short val) { Base::V = val; }
  inline ap_int(int val) { Base::V = val; }
  inline ap_int(unsigned int val) { Base::V = val; }
  inline ap_int(long val) { Base::V = val; }
  inline ap_int(unsigned long val) { Base::V = val; }
  inline ap_int(ap_slong val) { Base::V = val; }
  inline ap_int(ap_ulong val) { Base::V = val; }

  ap_int(double val) : Base(val) {}
  ap_int(float val) : Base(val) {}
  ap_int(half val) : Base(val) {}


  inline ap_int(const char* s) : Base(s) {}

  inline ap_int(const char* s, signed char rd) : Base(s, rd) {}




  inline ap_int& operator=(const ap_int<_AP_W>& op2) {
    Base::V = op2.V;
    return *this;
  }


  inline ap_int& operator=(const volatile ap_int<_AP_W>& op2) {
    Base::V = op2.V;
    return *this;
  }


  inline void operator=(const ap_int<_AP_W>& op2) volatile { Base::V = op2.V; }

  inline void operator=(const volatile ap_int<_AP_W>& op2) volatile {
    Base::V = op2.V;
  }

};




template <int _AP_W>
struct ap_uint : ap_int_base<_AP_W, false> {
  typedef ap_int_base<_AP_W, false> Base;

  inline ap_uint() : Base() {}
  template <int _AP_W2>
  inline ap_uint(const ap_uint<_AP_W2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2>
  inline ap_uint(const ap_int<_AP_W2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2>
  inline ap_uint(const volatile ap_uint<_AP_W2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2>
  inline ap_uint(const volatile ap_int<_AP_W2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_uint(const ap_range_ref<_AP_W2, _AP_S2>& ref) : Base(ref) {}

  template <int _AP_W2, bool _AP_S2>
  inline ap_uint(const ap_bit_ref<_AP_W2, _AP_S2>& ref) : Base(ref) {}

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_uint(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref)
      : Base(ref) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline ap_uint(const ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline ap_uint(const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {
  }

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline ap_uint(
      const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline ap_uint(
      const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_uint(const ap_int_base<_AP_W2, _AP_S2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_uint(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_uint(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_uint(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}



  inline ap_uint(bool val) { Base::V = val; }
  inline ap_uint(char val) { Base::V = val; }
  inline ap_uint(signed char val) { Base::V = val; }
  inline ap_uint(unsigned char val) { Base::V = val; }
  inline ap_uint(short val) { Base::V = val; }
  inline ap_uint(unsigned short val) { Base::V = val; }
  inline ap_uint(int val) { Base::V = val; }
  inline ap_uint(unsigned int val) { Base::V = val; }
  inline ap_uint(long val) { Base::V = val; }
  inline ap_uint(unsigned long val) { Base::V = val; }
  inline ap_uint(ap_slong val) { Base::V = val; }
  inline ap_uint(ap_ulong val) { Base::V = val; }

  ap_uint(double val) : Base(val) {}
  ap_uint(float val) : Base(val) {}
  ap_uint(half val) : Base(val) {}


  inline ap_uint(const char* s) : Base(s) {}

  inline ap_uint(const char* s, signed char rd) : Base(s, rd) {}




  inline ap_uint& operator=(const ap_uint<_AP_W>& op2) {
    Base::V = op2.V;
    return *this;
  }


  inline ap_uint& operator=(const volatile ap_uint<_AP_W>& op2) {
    Base::V = op2.V;
    return *this;
  }


  inline void operator=(const ap_uint<_AP_W>& op2) volatile { Base::V = op2.V; }

  inline void operator=(const volatile ap_uint<_AP_W>& op2) volatile {
    Base::V = op2.V;
  }

};
#341 "C:/Xilinx/Vivado/2018.3/include/ap_int.h"
#1 "C:/Xilinx/Vivado/2018.3/include/ap_int_special.h" 1
#54 "C:/Xilinx/Vivado/2018.3/include/ap_int_special.h"
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdio" 1 3
#39 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdio" 3

#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdio" 3
#55 "C:/Xilinx/Vivado/2018.3/include/ap_int_special.h" 2
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdlib" 1 3
#39 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdlib" 3

#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
#56 "C:/Xilinx/Vivado/2018.3/include/ap_int_special.h" 2




namespace std {
template<typename _Tp> class complex;
}







namespace std {
#88 "C:/Xilinx/Vivado/2018.3/include/ap_int_special.h"
template <int _AP_W>
struct complex<ap_int<_AP_W> > {
  typedef ap_int<_AP_W> _Tp;
  typedef _Tp value_type;




  complex() : _M_real(_Tp()), _M_imag(_Tp()) {}


  complex(const _Tp &__r, const _Tp &__i = _Tp(0))
      : _M_real(__r), _M_imag(__i) {}


  template <typename _Up>
  complex(const complex<_Up> &__z) : _M_real(__z.real()), _M_imag(__z.imag()) {}


  const _Tp& real() const { return _M_real; }
  const _Tp& imag() const { return _M_imag; }







  void real(_Tp __val) { _M_real = __val; }

  void imag(_Tp __val) { _M_imag = __val; }



  complex<_Tp> &operator=(const _Tp __t) {
    _M_real = __t;
    _M_imag = _Tp(0);
    return *this;
  }



  complex<_Tp> &operator+=(const _Tp &__t) {
    _M_real += __t;
    return *this;
  }



  complex<_Tp> &operator-=(const _Tp &__t) {
    _M_real -= __t;
    return *this;
  }



  complex<_Tp> &operator*=(const _Tp &__t) {
    _M_real *= __t;
    _M_imag *= __t;
    return *this;
  }



  complex<_Tp> &operator/=(const _Tp &__t) {
    _M_real /= __t;
    _M_imag /= __t;
    return *this;
  }


  template <typename _Up>
  complex<_Tp> &operator=(const complex<_Up> &__z) {
    _M_real = __z.real();
    _M_imag = __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator+=(const complex<_Up> &__z) {
    _M_real += __z.real();
    _M_imag += __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator-=(const complex<_Up> &__z) {
    _M_real -= __z.real();
    _M_imag -= __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator*=(const complex<_Up> &__z) {
    const _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();
    _M_imag = _M_real * __z.imag() + _M_imag * __z.real();
    _M_real = __r;
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator/=(const complex<_Up> &__z) {
    complex<_Tp> cj (__z.real(), -__z.imag());
    complex<_Tp> a = (*this) * cj;
    complex<_Tp> b = cj * __z;
    _M_real = a.real() / b.real();
    _M_imag = a.imag() / b.real();
    return *this;
  }

 private:
  _Tp _M_real;
  _Tp _M_imag;

};
#220 "C:/Xilinx/Vivado/2018.3/include/ap_int_special.h"
template <int _AP_W>
inline bool operator==(const complex<ap_int<_AP_W> > &__x, const ap_int<_AP_W> &__y) {
  return __x.real() == __y &&
         __x.imag() == 0;
}


template <int _AP_W>
inline bool operator==(const ap_int<_AP_W> &__x, const complex<ap_int<_AP_W> > &__y) {
  return __x == __y.real() &&
         0 == __y.imag();
}


template <int _AP_W>
inline bool operator!=(const complex<ap_int<_AP_W> > &__x, const ap_int<_AP_W> &__y) {
  return __x.real() != __y ||
         __x.imag() != 0;
}


template <int _AP_W>
inline bool operator!=(const ap_int<_AP_W> &__x, const complex<ap_int<_AP_W> > &__y) {
  return __x != __y.real() ||
         0 != __y.imag();
}

}
#342 "C:/Xilinx/Vivado/2018.3/include/ap_int.h" 2
#62 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 2
#77 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cfenv" 1 3
#32 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cfenv" 3

#33 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cfenv" 3
#41 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cfenv" 3
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/fenv.h" 1 3
#32 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/fenv.h" 3

#33 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/fenv.h" 3



#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/fenv.h" 1 3
#84 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/fenv.h" 3

#84 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/fenv.h" 3
typedef unsigned short fexcept_t;





typedef struct
{
  unsigned short __control_word;
  unsigned short __unused0;
  unsigned short __status_word;
  unsigned short __unused1;
  unsigned short __tag_word;
  unsigned short __unused2;
  unsigned int __ip_offset;
  unsigned short __ip_selector;
  unsigned short __opcode;
  unsigned int __data_offset;
  unsigned short __data_selector;
  unsigned short __unused3;
  unsigned int __mxcsr;
} fenv_t;
#124 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/fenv.h" 3
extern "C" {





extern int __attribute__((__cdecl__)) feclearexcept (int);
extern int __attribute__((__cdecl__)) fegetexceptflag (fexcept_t * flagp, int excepts);
extern int __attribute__((__cdecl__)) feraiseexcept (int excepts );
extern int __attribute__((__cdecl__)) fesetexceptflag (const fexcept_t *, int);
extern int __attribute__((__cdecl__)) fetestexcept (int excepts);



extern int __attribute__((__cdecl__)) fegetround (void);
extern int __attribute__((__cdecl__)) fesetround (int mode);



extern int __attribute__((__cdecl__)) fegetenv(fenv_t * envp);
extern int __attribute__((__cdecl__)) fesetenv(const fenv_t * );
extern int __attribute__((__cdecl__)) feupdateenv(const fenv_t *);
extern int __attribute__((__cdecl__)) feholdexcept(fenv_t *);


}
#37 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/fenv.h" 2 3
#55 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/fenv.h" 3
namespace std
{

  using ::fenv_t;
  using ::fexcept_t;


  using ::feclearexcept;
  using ::fegetexceptflag;
  using ::feraiseexcept;
  using ::fesetexceptflag;
  using ::fetestexcept;

  using ::fegetround;
  using ::fesetround;

  using ::fegetenv;
  using ::feholdexcept;
  using ::fesetenv;
  using ::feupdateenv;
}
#42 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cfenv" 2 3
#58 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cfenv" 3
namespace std
{

  using ::fenv_t;
  using ::fexcept_t;


  using ::feclearexcept;
  using ::fegetexceptflag;
  using ::feraiseexcept;
  using ::fesetexceptflag;
  using ::fetestexcept;

  using ::fegetround;
  using ::fesetround;

  using ::fegetenv;
  using ::feholdexcept;
  using ::fesetenv;
  using ::feupdateenv;
}
#78 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 2
#98 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"

#98 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
template <typename _Tp1, typename _Tp2>
inline bool _AP_ctype_op_get_bit(_Tp1& var, const _Tp2& index) {
  return !!(var & (1ull << (index)));
}
template <typename _Tp1, typename _Tp2, typename _Tp3>
inline _Tp1 _AP_ctype_op_set_bit(_Tp1& var, const _Tp2& index, const _Tp3& x) {
  var |= (((x) ? 1ull : 0ull) << (index));
  return var;
}
template <typename _Tp1, typename _Tp2, typename _Tp3>
inline _Tp1 _AP_ctype_op_get_range(_Tp1& var, const _Tp2& low,
                                   const _Tp3& high) {
  _Tp1 r = var;
  ap_ulong mask = -1ll;
  mask >>= (sizeof(_Tp1) * 8 - ((high) - (low) + 1));
  r >>= (low);
  r &= mask;
  return r;
}
template <typename _Tp1, typename _Tp2, typename _Tp3, typename _Tp4>
inline _Tp1 _AP_ctype_op_set_range(_Tp1& var, const _Tp2& low, const _Tp3& high,
                                   const _Tp4& x) {
  ap_ulong mask = -1ll;
  mask >>= (_AP_SIZE_ap_slong - ((high) - (low) + 1));
  var &= ~(mask << (low));
  var |= ((mask & x) << (low));
  return var;
}






template <int _AP_W2, int _AP_I2, bool _AP_S2>
struct _ap_fixed_factory;
template <int _AP_W2, int _AP_I2>
struct _ap_fixed_factory<_AP_W2, _AP_I2, true> {
  typedef ap_fixed<_AP_W2, _AP_I2> type;
};
template <int _AP_W2, int _AP_I2>
struct _ap_fixed_factory<_AP_W2, _AP_I2, false> {
  typedef ap_ufixed<_AP_W2, _AP_I2> type;
};
#153 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct ap_fixed_base : ssdm_int_sim<_AP_W, _AP_S> {
 public:
  typedef ssdm_int_sim<_AP_W, _AP_S> Base;
  static const int width = _AP_W;
  static const int iwidth = _AP_I;
  static const ap_q_mode qmode = _AP_Q;
  static const ap_o_mode omode = _AP_O;


  template <int _AP_W2, int _AP_I2, bool _AP_S2>
  struct RType {
    enum {
      _AP_F = _AP_W - _AP_I,
      F2 = _AP_W2 - _AP_I2,
      mult_w = _AP_W + _AP_W2,
      mult_i = _AP_I + _AP_I2,
      mult_s = _AP_S || _AP_S2,
      plus_w = ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) +
               1 + ((_AP_F) > (F2) ? (_AP_F) : (F2)),
      plus_i =
          ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) + 1,
      plus_s = _AP_S || _AP_S2,
      minus_w =
          ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) + 1 +
          ((_AP_F) > (F2) ? (_AP_F) : (F2)),
      minus_i =
          ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) + 1,
      minus_s = true,

      div_w = _AP_S2 + _AP_W + ((F2) > (0) ? (F2) : (0)),



      div_i = _AP_S2 + _AP_I + F2,
      div_s = _AP_S || _AP_S2,
      logic_w =
          ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) +
          ((_AP_F) > (F2) ? (_AP_F) : (F2)),
      logic_i = ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))),
      logic_s = _AP_S || _AP_S2
    };

    typedef ap_fixed_base<_AP_W, _AP_I, _AP_S> lhs;
    typedef ap_fixed_base<_AP_W2, _AP_I2, _AP_S2> rhs;

    typedef ap_fixed_base<mult_w, mult_i, mult_s> mult_base;
    typedef ap_fixed_base<plus_w, plus_i, plus_s> plus_base;
    typedef ap_fixed_base<minus_w, minus_i, minus_s> minus_base;
    typedef ap_fixed_base<logic_w, logic_i, logic_s> logic_base;
    typedef ap_fixed_base<div_w, div_i, div_s> div_base;
    typedef ap_fixed_base<_AP_W, _AP_I, _AP_S> arg1_base;

    typedef typename _ap_fixed_factory<mult_w, mult_i, mult_s>::type mult;
    typedef typename _ap_fixed_factory<plus_w, plus_i, plus_s>::type plus;
    typedef typename _ap_fixed_factory<minus_w, minus_i, minus_s>::type minus;
    typedef typename _ap_fixed_factory<logic_w, logic_i, logic_s>::type logic;
    typedef typename _ap_fixed_factory<div_w, div_i, div_s>::type div;
    typedef typename _ap_fixed_factory<_AP_W, _AP_I, _AP_S>::type arg1;
  };

 private:


  void fromString(const std::string& val, unsigned char radix) {
    do { if ((!(radix == 2 || radix == 8 || radix == 10 || radix == 16))) { fprintf(
#219 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#219 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "ERROR: " "ap_fixed_base::fromString(%s, %d)", val.c_str(), radix); fprintf(
#219 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#219 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "\n"); abort(); } } while (0)
                                                                      ;

    Base::V = 0;
    int startPos = 0;
    int endPos = val.length();
    int decPos = val.find(".");
    if (decPos == -1) decPos = endPos;


    bool isNegative = false;
    if (val[0] == '-') {
      isNegative = true;
      ++startPos;
    } else if (val[0] == '+')
      ++startPos;
#243 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
    ap_fixed_base<((_AP_I) > (4) ? (_AP_I) : (4)) + 4, ((_AP_I) > (4) ? (_AP_I) : (4)) + 4, false>
        integer_bits = 0;


    unsigned shift = (radix == 16 ? 4 : radix == 8 ? 3 : radix == 2 ? 1 : 0);




    bool sticky_int = false;


    for (int i = startPos; i < decPos; i++) {

      char cdigit = val[i];
      if (cdigit == '\0') continue;
      unsigned digit = ap_private_ops::decode_digit(cdigit, radix);

      sticky_int |= integer_bits[((_AP_I) > (4) ? (_AP_I) : (4)) + 4 - 1] |
                    integer_bits[((_AP_I) > (4) ? (_AP_I) : (4)) + 4 - 2] |
                    integer_bits[((_AP_I) > (4) ? (_AP_I) : (4)) + 4 - 3] |
                    integer_bits[((_AP_I) > (4) ? (_AP_I) : (4)) + 4 - 4];

      if (shift)
        integer_bits <<= shift;
      else
        integer_bits *= radix;


      integer_bits += digit;


    }
    integer_bits[((_AP_I) > (4) ? (_AP_I) : (4)) + 4 - 3] =
        integer_bits[((_AP_I) > (4) ? (_AP_I) : (4)) + 4 - 3] | sticky_int;

    ap_fixed_base<((_AP_W - _AP_I) > (0) ? (_AP_W - _AP_I) : (0)) + 4 + 4, 4, false> fractional_bits = 0;
    bool sticky = false;


    for (int i = endPos - 1; i >= decPos + 1; i--) {

      char cdigit = val[i];
      if (cdigit == '\0') continue;
      unsigned digit = ap_private_ops::decode_digit(cdigit, radix);

      fractional_bits += digit;

      sticky |= fractional_bits[0] | fractional_bits[1] | fractional_bits[2] |
                fractional_bits[3];

      if (shift)
        fractional_bits >>= shift;
      else
        fractional_bits /= radix;



    }




    fractional_bits[0] = fractional_bits[0] | sticky;

    if (isNegative)
      *this = -(integer_bits + fractional_bits);
    else
      *this = integer_bits + fractional_bits;


  }


  inline void report() {
    if (!_AP_S && _AP_O == AP_WRAP_SM) {
      fprintf(
#319 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
             (&__iob_func()[2])
#319 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
                   , "ap_ufxied<...> cannot support AP_WRAP_SM.\n");
      exit(1);
    }
    if (_AP_W > ((1024 + 1023) / 1024) * 1024) {
      fprintf(
#323 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
             (&__iob_func()[2])
#323 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
                   ,
              "[E] ap_%sfixed<%d, ...>: Bitwidth exceeds the "
              "default max value %d. Please use macro "
              "AP_INT_MAX_W to set a larger max value.\n",
              _AP_S ? "" : "u", _AP_W, ((1024 + 1023) / 1024) * 1024);
      exit(1);
    }
  }






  inline void overflow_adjust(bool underflow, bool overflow, bool lD,
                              bool sign) {
    if (!underflow && !overflow) return;
    if (_AP_O == AP_WRAP) {
      if (_AP_N == 0) return;
      if (_AP_S) {


        Base::V = _AP_ROOT_op_set_bit(Base::V, _AP_W - 1, sign);
        if (_AP_N > 1) {

          ap_int_base<_AP_W, false> mask(-1);
          if (sign) mask.V = 0;
          Base::V =
              _AP_ROOT_op_set_range(Base::V, _AP_W - _AP_N, _AP_W - 2, mask.V);
        }
      } else {

        ap_int_base<_AP_W, false> mask(-1);
        Base::V =
            _AP_ROOT_op_set_range(Base::V, _AP_W - _AP_N, _AP_W - 1, mask.V);
      }
    } else if (_AP_O == AP_SAT_ZERO) {
      Base::V = 0;
    } else if (_AP_O == AP_WRAP_SM && _AP_S) {
      bool Ro = (Base::V).get_bit((_AP_W - 1));
      if (_AP_N == 0) {
        if (lD != Ro) {
          Base::V = ~Base::V;
          Base::V = _AP_ROOT_op_set_bit(Base::V, _AP_W - 1, lD);
        }
      } else {
        if (_AP_N == 1 && sign != Ro) {
          Base::V = ~Base::V;
        } else if (_AP_N > 1) {
          bool lNo = (Base::V).get_bit((_AP_W - _AP_N));
          if (lNo == sign) Base::V = ~Base::V;
          ap_int_base<_AP_W, false> mask(-1);
          if (sign) mask.V = 0;
          Base::V =
              _AP_ROOT_op_set_range(Base::V, _AP_W - _AP_N, _AP_W - 2, mask.V);
        }
        Base::V = _AP_ROOT_op_set_bit(Base::V, _AP_W - 1, sign);
      }
    } else {
      if (_AP_S) {
        if (overflow) {
          Base::V = 1;
          Base::V <<= _AP_W - 1;
          Base::V = ~Base::V;
        } else if (underflow) {
          Base::V = 1;
          Base::V <<= _AP_W - 1;
          if (_AP_O == AP_SAT_SYM) Base::V |= 1;
        }
      } else {
        if (overflow)
          Base::V = ~(ap_int_base<_AP_W, false>(0).V);
        else if (underflow)
          Base::V = 0;
      }
    }
  }

  inline bool quantization_adjust(bool qb, bool r, bool s) {
    bool carry = (bool)(Base::V).get_bit((_AP_W - 1));
    if (_AP_Q == AP_TRN) return false;
    if (_AP_Q == AP_RND_ZERO)
      qb &= s || r;
    else if (_AP_Q == AP_RND_MIN_INF)
      qb &= r;
    else if (_AP_Q == AP_RND_INF)
      qb &= !s || r;
    else if (_AP_Q == AP_RND_CONV)
      qb &= (Base::V).get_bit((0)) || r;
    else if (_AP_Q == AP_TRN_ZERO)
      qb = s && (qb || r);
    Base::V += qb;
    return carry && (!(bool)(Base::V).get_bit((_AP_W - 1)));
  }


 public:



  inline ap_fixed_base() {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed_base(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    operator=(op);
    report();
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed_base(
      const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    operator=(op);
    report();
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_fixed_base(const ap_int_base<_AP_W2, _AP_S2>& op) {
    ap_fixed_base<_AP_W2, _AP_W2, _AP_S2> tmp;
    tmp.V = op.V;
    operator=(tmp);
    report();
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_fixed_base(const volatile ap_int_base<_AP_W2, _AP_S2>& op) {
    ap_fixed_base<_AP_W2, _AP_W2, _AP_S2> tmp;
    tmp.V = op.V;
    operator=(tmp);
    report();
  }



  inline ap_fixed_base(const char* s, signed char rd = 0) {
    unsigned char radix = rd;
    std::string str = ap_private_ops::parseString(s, radix);
    do { if ((radix == 0)) { fprintf(
#463 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#463 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "ERROR: " "ap_fixed_base(const char* \"%s\", %d), str=%s, radix = %d", s, rd, str.c_str(), radix); fprintf(
#463 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#463 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "\n"); abort(); } } while (0)
                                        ;
    fromString(str, radix);
  }
#490 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
  template <int _AP_W2, bool _AP_S2>
  inline ap_fixed_base(const ap_bit_ref<_AP_W2, _AP_S2>& op) {
    *this = ((bool)op);
    report();
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_fixed_base(const ap_range_ref<_AP_W2, _AP_S2>& op) {
    *this = (ap_int_base<_AP_W2, false>(op));
    report();
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_fixed_base(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op) {
    *this = (ap_int_base<_AP_W2 + _AP_W3, false>(op));
    report();
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed_base(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    *this = (bool(op));
    report();
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed_base(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    *this = (ap_int_base<_AP_W2, false>(op));
    report();
  }
#534 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
  inline ap_fixed_base(const bool x) { ap_fixed_base<(1), (1), (false)> tmp; tmp.V = x; *this = tmp; }
  inline ap_fixed_base(const char x) { ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)> tmp; tmp.V = x; *this = tmp; }
  inline ap_fixed_base(const signed char x) { ap_fixed_base<(8), (8), (true)> tmp; tmp.V = x; *this = tmp; }
  inline ap_fixed_base(const unsigned char x) { ap_fixed_base<(8), (8), (false)> tmp; tmp.V = x; *this = tmp; }
  inline ap_fixed_base(const short x) { ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)> tmp; tmp.V = x; *this = tmp; }
  inline ap_fixed_base(const unsigned short x) { ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)> tmp; tmp.V = x; *this = tmp; }
  inline ap_fixed_base(const int x) { ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)> tmp; tmp.V = x; *this = tmp; }
  inline ap_fixed_base(const unsigned int x) { ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)> tmp; tmp.V = x; *this = tmp; }
  inline ap_fixed_base(const long x) { ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)> tmp; tmp.V = x; *this = tmp; }
  inline ap_fixed_base(const unsigned long x) { ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)> tmp; tmp.V = x; *this = tmp; }
  inline ap_fixed_base(const ap_slong x) { ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)> tmp; tmp.V = x; *this = tmp; }
  inline ap_fixed_base(const ap_ulong x) { ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)> tmp; tmp.V = x; *this = tmp; }







  ap_fixed_base(double d) {
    ap_int_base<64, false> ireg;
    ireg.V = doubleToRawBits(d);
    bool isneg = (ireg.V).get_bit((63));

    ap_int_base<11 + 1, true> exp;
    ap_int_base<11, false> exp_tmp;
    exp_tmp.V =
        (ireg.V).range((52 + 11 - 1), (52));
    exp = exp_tmp - ((1L << (11 - 1L)) - 1L);
    ap_int_base<52 + 2, true> man;
    man.V = (ireg.V).range((52 - 1), (0));

    do { if ((exp == ((1L << (11 - 1L)) - 1L) + 1 && man.V != 0)) { fprintf(
#566 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#566 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "WARNING: " "assign NaN to fixed point value"); fprintf(
#566 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#566 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "\n"); } } while (0)
                                                  ;
    man.V = _AP_ROOT_op_set_bit(man.V, 52, 1);
    if (isneg) man = -man;
    if ((ireg.V & 0x7fffffffffffffffLL) == 0) {
      Base::V = 0;
    } else {
      int _AP_W2 = 52 + 2, _AP_I2 = exp.V + 2, _AP_F = _AP_W - _AP_I,
          F2 = _AP_W2 - _AP_I2;
      bool _AP_S2 = true,
           QUAN_INC = F2 > _AP_F &&
                      !(_AP_Q == AP_TRN || (_AP_Q == AP_TRN_ZERO && !_AP_S2));
      bool carry = false;

      unsigned sh_amt = (F2 > _AP_F) ? F2 - _AP_F : _AP_F - F2;
      if (F2 == _AP_F)
        Base::V = man.V;
      else if (F2 > _AP_F) {
        if (sh_amt < 52 + 2)
          Base::V = man.V >> sh_amt;
        else {
          Base::V = isneg ? -1 : 0;
        }
        if ((_AP_Q != AP_TRN) && !((_AP_Q == AP_TRN_ZERO) && !_AP_S2)) {
          bool qb = (F2 - _AP_F > _AP_W2) ? isneg : (bool)(man.V).get_bit((F2 - _AP_F - 1))
                                                                              ;
          bool r =
              (F2 > _AP_F + 1)
                  ? (man.V).range(((F2 - _AP_F - 2 < _AP_W2) ? (F2 - _AP_F - 2) : (_AP_W2 - 1)), (0))

                                                                        != 0
                  : false;
          carry = quantization_adjust(qb, r, isneg);
        }
      } else {
        Base::V = man.V;
        if (sh_amt < _AP_W)
          Base::V = Base::V << sh_amt;
        else
          Base::V = 0;
      }

      if ((_AP_O != AP_WRAP || _AP_N != 0) &&
          ((!_AP_S && _AP_S2) ||
           _AP_I - _AP_S <
               _AP_I2 - _AP_S2 +
                   (QUAN_INC ||
                    (_AP_S2 && (_AP_O == AP_SAT_SYM))))) {
        bool deleted_zeros = _AP_S2 ? true : !carry, deleted_ones = true;
        bool neg_src = isneg;
        bool lD = false;
        int pos1 = F2 - _AP_F + _AP_W;
        int pos2 = F2 - _AP_F + _AP_W + 1;
        bool newsignbit = (Base::V).get_bit((_AP_W - 1));
        if (pos1 < _AP_W2 && pos1 >= 0)

          lD = (man.V >> pos1) & 1;
        if (pos1 < _AP_W2) {
          bool Range1_all_ones = true;
          bool Range1_all_zeros = true;
          bool Range2_all_ones = true;
          ap_int_base<52 + 2, false> Range2;
          ap_int_base<52 + 2, false> all_ones(-1);

          if (pos2 >= 0 && pos2 < _AP_W2) {


            Range2.V = man.V;
            Range2.V >>= pos2;
            Range2_all_ones = Range2 == (all_ones >> pos2);
          } else if (pos2 < 0)
            Range2_all_ones = false;
          if (pos1 >= 0 && pos2 < _AP_W2) {
            Range1_all_ones = Range2_all_ones && lD;
            Range1_all_zeros = !Range2.V && !lD;
          } else if (pos2 == _AP_W2) {
            Range1_all_ones = lD;
            Range1_all_zeros = !lD;
          } else if (pos1 < 0) {
            Range1_all_zeros = !man.V;
            Range1_all_ones = false;
          }

          deleted_zeros =
              deleted_zeros && (carry ? Range1_all_ones : Range1_all_zeros);
          deleted_ones =
              carry ? Range2_all_ones && (pos1 < 0 || !lD) : Range1_all_ones;
          neg_src = isneg && !(carry && Range1_all_ones);
        } else
          neg_src = isneg && newsignbit;
        bool neg_trg = _AP_S && newsignbit;
        bool overflow = (neg_trg || !deleted_zeros) && !isneg;
        bool underflow = (!neg_trg || !deleted_ones) && neg_src;
        if ((_AP_O == AP_SAT_SYM) && _AP_S2 && _AP_S)
          underflow |=
              neg_src &&
              (_AP_W > 1 ? (Base::V).range((_AP_W - 2), (0)) == 0
                         : true);
        overflow_adjust(underflow, overflow, lD, neg_src);
      }
    }
    report();
  }


  inline ap_fixed_base(float d) { *this = ap_fixed_base(double(d)); }


  inline ap_fixed_base(half d) { *this = ap_fixed_base(double(d)); }
#687 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed_base& operator=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {

    const int _AP_F = _AP_W - _AP_I;
    const int F2 = _AP_W2 - _AP_I2;
    const int QUAN_INC =
          F2 > _AP_F && !(_AP_Q == AP_TRN || (_AP_Q == AP_TRN_ZERO && !_AP_S2));

    if (!op) Base::V = 0;
    bool carry = false;
    bool signbit = (op.V).get_bit((_AP_W2 - 1));
    bool isneg = signbit && _AP_S2;
    if (F2 == _AP_F)
      Base::V = op.V;
    else if (F2 > _AP_F) {
      unsigned int sh_amt = F2 - _AP_F;

      if (sh_amt < _AP_W2) {
        Base::V = op.V >> sh_amt;
      } else {
        Base::V = isneg ? -1 : 0;
      }
      if (_AP_Q != AP_TRN && !(_AP_Q == AP_TRN_ZERO && !_AP_S2)) {
        bool qbit = (op.V).get_bit((F2 - _AP_F - 1));

        bool qb = (F2 - _AP_F > _AP_W2) ? _AP_S2 && signbit : qbit;
        enum { hi = ((F2 - _AP_F - 2) < _AP_W2) ? (F2 - _AP_F - 2) : (_AP_W2 - 1) };

        bool r = (F2 > _AP_F + 1) ? ((op.V).range((hi), (0)) != 0) : false;
        carry = quantization_adjust(qb, r, isneg);
      }
    } else {
      unsigned sh_amt = _AP_F - F2;

      if (sh_amt < _AP_W) {
        if (_AP_W > _AP_W2) {

          Base::V = op.V;
          Base::V <<= sh_amt;
        } else {

          Base::V = op.V << sh_amt;
        }
      } else {
        Base::V = 0;
      }
    }

    if ((_AP_O != AP_WRAP || _AP_N != 0) &&
        ((!_AP_S && _AP_S2) ||
         _AP_I - _AP_S <
             _AP_I2 - _AP_S2 +
                 (QUAN_INC || (_AP_S2 && _AP_O == AP_SAT_SYM)))) {
      bool deleted_zeros = _AP_S2 ? true : !carry;
      bool deleted_ones = true;
      bool neg_src = isneg;
      bool newsignbit = (Base::V).get_bit((_AP_W - 1));
      enum { pos1 = F2 - _AP_F + _AP_W, pos2 = F2 - _AP_F + _AP_W + 1 };
      bool lD = (pos1 < _AP_W2 && pos1 >= 0) ? (op.V).get_bit((pos1))
                                             : false;
      if (pos1 < _AP_W2) {
        bool Range1_all_ones = true;
        bool Range1_all_zeros = true;
        bool Range2_all_ones = true;
        ap_int_base<_AP_W2, false> all_ones(-1);

        if (pos2 < _AP_W2 && pos2 >= 0) {
          ap_int_base<_AP_W2, false> Range2;
          Range2.V = (op.V).range((_AP_W2 - 1), (pos2));
          Range2_all_ones = Range2 == (all_ones >> pos2);
        } else if (pos2 < 0) {
          Range2_all_ones = false;
        }

        if (pos1 >= 0 && pos2 < _AP_W2) {
          ap_int_base<_AP_W2, false> Range1;
          Range1.V = (op.V).range((_AP_W2 - 1), (pos1));
          Range1_all_ones = Range1 == (all_ones >> pos1);
          Range1_all_zeros = !Range1.V;
        } else if (pos2 == _AP_W2) {
          Range1_all_ones = lD;
          Range1_all_zeros = !lD;
        } else if (pos1 < 0) {
          Range1_all_zeros = !op.V;
          Range1_all_ones = false;
        }

        deleted_zeros =
            deleted_zeros && (carry ? Range1_all_ones : Range1_all_zeros);
        deleted_ones =
            carry ? Range2_all_ones && (pos1 < 0 || !lD) : Range1_all_ones;
        neg_src = isneg && !(carry && Range1_all_ones);
      } else
        neg_src = isneg && newsignbit;
      bool neg_trg = _AP_S && newsignbit;
      bool overflow = (neg_trg || !deleted_zeros) && !isneg;
      bool underflow = (!neg_trg || !deleted_ones) && neg_src;
      if ((_AP_O == AP_SAT_SYM) && _AP_S2 && _AP_S)
        underflow |=
            neg_src &&
            (_AP_W > 1 ? (Base::V).range((_AP_W - 2), (0)) == 0
                       : true);

      overflow_adjust(underflow, overflow, lD, neg_src);
    }
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed_base& operator=(
      const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    operator=(const_cast<const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(op));
    return *this;
  }


  inline ap_fixed_base& setBits(ap_ulong bv) {

    Base::V = bv;
    return *this;
  }


  static inline ap_fixed_base bitsToFixed(ap_ulong bv) {

    ap_fixed_base t;



    t.V.set_bits(bv);

    return t;
  }





  inline ap_int_base<((_AP_I) > (1) ? (_AP_I) : (1)), _AP_S> to_ap_int_base(
      bool Cnative = true) const {
    ap_int_base<((_AP_I) > (1) ? (_AP_I) : (1)), _AP_S> ret;
    if (_AP_I == 0) {
      ret.V = 0;
    } else if (_AP_I > 0 && _AP_I <= _AP_W) {
      ret.V = (Base::V).range((_AP_W - 1), (_AP_W - _AP_I));
    } else if (_AP_I > _AP_W) {
      ret.V = (Base::V).range((_AP_W - 1), (0));
      ret.V <<= (_AP_I - _AP_W);
    }
#847 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
    if (Cnative && _AP_I < _AP_W) {

      if (_AP_S && (Base::V).get_bit((_AP_W - 1)) && (_AP_I < _AP_W) &&
          ((Base::V).range((_AP_I < 0 ? _AP_W - 1 : _AP_W - _AP_I - 1), (0))
                                                                      != 0))
        ++ret;
    } else {

    }
    return ret;
  };

 public:
  template <int _AP_W2, bool _AP_S2>
  inline operator ap_int_base<_AP_W2, _AP_S2>() const {
    return ap_int_base<_AP_W2, _AP_S2>(to_ap_int_base());
  }


  inline char to_char() const { return to_ap_int_base().to_char(); }

  inline int to_int() const { return to_ap_int_base().to_int(); }

  inline unsigned to_uint() const { return to_ap_int_base().to_uint(); }

  inline ap_slong to_int64() const { return to_ap_int_base().to_int64(); }

  inline ap_ulong to_uint64() const { return to_ap_int_base().to_uint64(); }



  inline double to_double() const {

    do { if ((std::fegetround() != 
#880 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   0x0000
#880 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   )) { fprintf(
#880 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#880 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "WARNING: " "Only FE_TONEAREST is supported"); fprintf(
#880 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#880 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "\n"); } } while (0)
                                                 ;

    enum { BITS = 52 + 11 + 1 };
    if (!Base::V) return 0.0f;
    bool s = _AP_S && (Base::V).get_bit((_AP_W - 1));
    ap_int_base<_AP_W, false> tmp;
    if (s)
      tmp.V = -Base::V;
    else
      tmp.V = Base::V;
    int l = tmp.countLeadingZeros();
    int e = _AP_I - l - 1 + ((1L << (11 - 1L)) - 1L);
    int lsb_index = _AP_W - l - 1 - 52;

    bool a = (lsb_index >=2) ?
        ((tmp.V).range((lsb_index - 2), (0)) != 0) : 0;

    a |= (lsb_index >=0) ? (tmp.V).get_bit((lsb_index)) : 0;

    ap_ulong m;

    if (_AP_W > BITS) {
      m = (lsb_index >= 1) ? (ap_ulong)(tmp.V >> (lsb_index - 1))
                           : (ap_ulong)(tmp.V << (1 - lsb_index));
    } else {
      m = (ap_ulong)tmp.V;
      m = (lsb_index >= 1) ? (m >> (lsb_index - 1))
                           : (m << (1 - lsb_index));
    }
    m += a;
    m >>= 1;


    if (_AP_ctype_op_get_bit(m, 52 + 1)) {
      e += 1;
    }

    m = _AP_ctype_op_set_bit(m, BITS - 1, s);

    m = _AP_ctype_op_set_range(m, 52, 52 + 11 - 1, e);


    return rawBitsToDouble(m);
  }



  inline float to_float() const {

    do { if ((std::fegetround() != 
#930 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   0x0000
#930 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   )) { fprintf(
#930 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#930 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "WARNING: " "Only FE_TONEAREST is supported"); fprintf(
#930 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#930 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "\n"); } } while (0)
                                                 ;

    enum { BITS = 23 + 8 + 1 };
    if (!Base::V) return 0.0f;
    bool s = _AP_S && (Base::V).get_bit((_AP_W - 1));
    ap_int_base<_AP_W, false> tmp;
    if (s)
      tmp.V = -Base::V;
    else
      tmp.V = Base::V;
    int l = tmp.countLeadingZeros();
    int e = _AP_I - l - 1 + ((1L << (8 - 1L)) - 1L);
    int lsb_index = _AP_W - l - 1 - 23;

    bool a = (lsb_index >=2) ?
        ((tmp.V).range((lsb_index - 2), (0)) != 0) : 0;

    a |= (lsb_index >=0) ? (tmp.V).get_bit((lsb_index)) : 0;

    unsigned long m;

    if (_AP_W > BITS) {
      m = (lsb_index >= 1) ? (unsigned long)(tmp.V >> (lsb_index - 1))
                           : (unsigned long)(tmp.V << (1 - lsb_index));
    } else {
      m = (unsigned long)tmp.V;
      m = (lsb_index >= 1) ? (m >> (lsb_index - 1))
                           : (m << (1 - lsb_index));
    }
    m += a;
    m >>= 1;

    if (_AP_ctype_op_get_bit(m, 23 + 1)) {
      e += 1;
    }

    m = _AP_ctype_op_set_bit(m, BITS - 1, s);
    m = _AP_ctype_op_set_range(m, 23, 23 + 8 - 1, e);

    return rawBitsToFloat(m);
  }



  inline half to_half() const {

    do { if ((std::fegetround() != 
#977 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   0x0000
#977 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   )) { fprintf(
#977 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#977 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "WARNING: " "Only FE_TONEAREST is supported"); fprintf(
#977 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#977 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "\n"); } } while (0)
                                                 ;

    enum { BITS = 10 + 5 + 1 };
    if (!Base::V) return 0.0f;
    bool s = _AP_S && (Base::V).get_bit((_AP_W - 1));
    ap_int_base<_AP_W, false> tmp;
    if (s)
      tmp.V = -Base::V;
    else
      tmp.V = Base::V;
    int l = tmp.countLeadingZeros();
    int e = _AP_I - l - 1 + ((1L << (5 - 1L)) - 1L);
    int lsb_index = _AP_W - l - 1 - 10;

    bool a = (lsb_index >=2) ?
        ((tmp.V).range((lsb_index - 2), (0)) != 0) : 0;

    a |= (lsb_index >=0) ? (tmp.V).get_bit((lsb_index)) : 0;

    unsigned short m;

    if (_AP_W > BITS) {
      m = (lsb_index >= 1) ? (unsigned short)(tmp.V >> (lsb_index - 1))
                           : (unsigned short)(tmp.V << (1 - lsb_index));
    } else {
      m = (unsigned short)tmp.V;
      m = (lsb_index >= 1) ? (m >> (lsb_index - 1))
                           : (m << (1 - lsb_index));
    }
    m += a;
    m >>= 1;

    if (_AP_ctype_op_get_bit(m, 10 + 1)) {
      e += 1;
    }

    m = _AP_ctype_op_set_bit(m, BITS - 1, s);
    m = _AP_ctype_op_set_range(m, 10, 10 + 5 - 1, e);

    return rawBitsToHalf(m);
  }


  inline operator long double() const { return (long double)to_double(); }

  inline operator double() const { return to_double(); }

  inline operator float() const { return to_float(); }

  inline operator half() const { return to_half(); }

  inline operator bool() const { return (bool)Base::V != 0; }

  inline operator char() const { return (char)to_int(); }

  inline operator signed char() const { return (signed char)to_int(); }

  inline operator unsigned char() const { return (unsigned char)to_uint(); }

  inline operator short() const { return (short)to_int(); }

  inline operator unsigned short() const { return (unsigned short)to_uint(); }

  inline operator int() const { return to_int(); }

  inline operator unsigned int() const { return to_uint(); }



  inline operator long() const { return (long)to_int64(); }

  inline operator unsigned long() const { return (unsigned long)to_uint64(); }






  inline operator ap_ulong() const { return to_uint64(); }

  inline operator ap_slong() const { return to_int64(); }

  inline int length() const { return _AP_W; };




  inline ap_ulong bits_to_uint64() const {
    return (Base::V).to_uint64();
  }





  inline int countLeadingZeros() {
#1103 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
    return Base::V.countLeadingZeros();

  }



  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline typename RType<_AP_W2, _AP_I2, _AP_S2>::mult operator*(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2)
      const {
    typename RType<_AP_W2, _AP_I2, _AP_S2>::mult_base r, t;
    r.V = Base::V;
    t.V = op2.V;
    r.V *= op2.V;
    return r;
  }



  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline typename RType<_AP_W2, _AP_I2, _AP_S2>::div operator/(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2)
      const {
    typename RType<_AP_W2, _AP_I2, _AP_S2>::div_base r;

    enum {F2 = _AP_W2-_AP_I2,
              _W1=((_AP_W + ((F2) > (0) ? (F2) : (0)) + ((_AP_S2 && !_AP_S) ? 1 : 0)) > (_AP_W2 + ((_AP_S && !_AP_S2) ? 1 : 0)) ? (_AP_W + ((F2) > (0) ? (F2) : (0)) + ((_AP_S2 && !_AP_S) ? 1 : 0)) : (_AP_W2 + ((_AP_S && !_AP_S2) ? 1 : 0)))};
    ap_int_base<_W1,_AP_S||_AP_S2> dividend,divisior;
    ap_int_base<_W1,_AP_S> tmp1;
    ap_int_base<_W1,_AP_S2> tmp2;
    tmp1.V = Base::V;
    tmp1.V <<= ((F2) > (0) ? (F2) : (0));
    tmp2.V = op2.V;
    dividend = tmp1;
    divisior = tmp2;
    r.V = ((_AP_S||_AP_S2) ? dividend.V.sdiv(divisior.V): dividend.V.udiv(divisior.V));
#1176 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
    return r;
  }
#1191 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline typename RType<_AP_W2, _AP_I2, _AP_S2>::plus operator +( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>::plus_base ret, lhs(*this), rhs(op2); ret.V = lhs.V + rhs.V; return ret; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline typename RType<_AP_W2, _AP_I2, _AP_S2>::minus operator -( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>::minus_base ret, lhs(*this), rhs(op2); ret.V = lhs.V - rhs.V; return ret; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline typename RType<_AP_W2, _AP_I2, _AP_S2>::logic operator &( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>::logic_base ret, lhs(*this), rhs(op2); ret.V = lhs.V & rhs.V; return ret; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline typename RType<_AP_W2, _AP_I2, _AP_S2>::logic operator |( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>::logic_base ret, lhs(*this), rhs(op2); ret.V = lhs.V | rhs.V; return ret; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline typename RType<_AP_W2, _AP_I2, _AP_S2>::logic operator ^( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>::logic_base ret, lhs(*this), rhs(op2); ret.V = lhs.V ^ rhs.V; return ret; }
#1209 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator *=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator *(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator /=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator /(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator +=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator +(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator -=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator -(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator &=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator &(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator |=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator |(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator ^=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator ^(op2); return *this; }





  inline ap_fixed_base& operator++() {
    operator+=(ap_fixed_base<_AP_W - _AP_I + 1, 1, false>(1));
    return *this;
  }


  inline ap_fixed_base& operator--() {
    operator-=(ap_fixed_base<_AP_W - _AP_I + 1, 1, false>(1));
    return *this;
  }


  inline const ap_fixed_base operator++(int) {
    ap_fixed_base r(*this);
    operator++();
    return r;
  }


  inline const ap_fixed_base operator--(int) {
    ap_fixed_base r(*this);
    operator--();
    return r;
  }



  inline ap_fixed_base operator+() { return *this; }

  inline ap_fixed_base<_AP_W + 1, _AP_I + 1, true> operator-() const {
    ap_fixed_base<_AP_W + 1, _AP_I + 1, true> r(*this);
    r.V = -r.V;
    return r;
  }

  inline ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> getNeg() {
    ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> r(*this);
    r.V = -r.V;
    return r;
  }



  inline bool operator!() const { return Base::V == 0; }




  inline ap_fixed_base<_AP_W, _AP_I, _AP_S> operator~() const {
    ap_fixed_base<_AP_W, _AP_I, _AP_S> r;
    r.V = ~Base::V;
    return r;
  }




  template <int _AP_SHIFT>
  inline ap_fixed_base<_AP_W, _AP_I + _AP_SHIFT, _AP_S> lshift() const {
    ap_fixed_base<_AP_W, _AP_I + _AP_SHIFT, _AP_S> r;
    r.V = Base::V;
    return r;
  }

  template <int _AP_SHIFT>
  inline ap_fixed_base<_AP_W, _AP_I - _AP_SHIFT, _AP_S> rshift() const {
    ap_fixed_base<_AP_W, _AP_I - _AP_SHIFT, _AP_S> r;
    r.V = Base::V;
    return r;
  }





  inline ap_fixed_base operator<<(unsigned int sh) const {
    ap_fixed_base r;
    r.V = Base::V << sh;
#1327 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
    return r;
  }

  inline ap_fixed_base operator>>(unsigned int sh) const {
    ap_fixed_base r;
    r.V = Base::V >> sh;
#1349 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
    return r;
  }


  inline ap_fixed_base operator<<(int sh) const {
    ap_fixed_base r;
    bool isNeg = sh < 0;
    unsigned int ush = isNeg ? -sh : sh;
    if (isNeg) {
      return operator>>(ush);
    } else {
      return operator<<(ush);
    }
  }

  inline ap_fixed_base operator>>(int sh) const {
    bool isNeg = sh < 0;
    unsigned int ush = isNeg ? -sh : sh;
    if (isNeg) {
      return operator<<(ush);
    } else {
      return operator>>(ush);
    }
  }


  template <int _AP_W2>
  inline ap_fixed_base operator<<(const ap_int_base<_AP_W2, true>& op2) const {


    int sh = op2.to_int();
    return operator<<(sh);
  }

  template <int _AP_W2>
  inline ap_fixed_base operator>>(const ap_int_base<_AP_W2, true>& op2) const {
    int sh = op2.to_int();
    return operator>>(sh);
  }


  template <int _AP_W2>
  inline ap_fixed_base operator<<(const ap_int_base<_AP_W2, false>& op2) const {
    unsigned int sh = op2.to_uint();
    return operator<<(sh);
  }

  template <int _AP_W2>
  inline ap_fixed_base operator>>(const ap_int_base<_AP_W2, false>& op2) const {
    unsigned int sh = op2.to_uint();
    return operator>>(sh);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed_base operator<<(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          op2) {
    return operator<<(op2.to_ap_int_base());
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed_base operator>>(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          op2) {
    return operator>>(op2.to_ap_int_base());
  }





  inline ap_fixed_base& operator<<=(const int sh) {
    *this = operator<<(sh);
    return *this;
  }

  inline ap_fixed_base& operator<<=(const unsigned int sh) {
    *this = operator<<(sh);
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_fixed_base& operator<<=(const ap_int_base<_AP_W2, _AP_S2>& sh) {
    *this = operator<<(sh.to_int());
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed_base& operator<<=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          sh) {
    *this = operator<<(sh.to_int());
    return *this;
  }


  inline ap_fixed_base& operator>>=(const int sh) {
    *this = operator>>(sh);
    return *this;
  }

  inline ap_fixed_base& operator>>=(const unsigned int sh) {
    *this = operator>>(sh);
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_fixed_base& operator>>=(const ap_int_base<_AP_W2, _AP_S2>& sh) {
    *this = operator>>(sh.to_int());
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed_base& operator>>=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          sh) {
    *this = operator>>(sh.to_int());
    return *this;
  }
#1493 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline bool operator >(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V > op2.V; else if (_AP_F > F2) return Base::V > ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V > op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline bool operator <(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V < op2.V; else if (_AP_F > F2) return Base::V < ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V < op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline bool operator >=(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V >= op2.V; else if (_AP_F > F2) return Base::V >= ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V >= op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline bool operator <=(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V <= op2.V; else if (_AP_F > F2) return Base::V <= ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V <= op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline bool operator ==(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V == op2.V; else if (_AP_F > F2) return Base::V == ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V == op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline bool operator !=(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V != op2.V; else if (_AP_F > F2) return Base::V != ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V != op2.V; return false; }





  inline bool operator >(double d) const { return to_double() > d; }
  inline bool operator <(double d) const { return to_double() < d; }
  inline bool operator >=(double d) const { return to_double() >= d; }
  inline bool operator <=(double d) const { return to_double() <= d; }
  inline bool operator ==(double d) const { return to_double() == d; }
  inline bool operator !=(double d) const { return to_double() != d; }


  inline af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator[](
      unsigned index) {
    do { if ((index >= _AP_W)) { fprintf(
#1514 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#1514 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit beyond MSB"); fprintf(
#1514 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#1514 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, index);
  }

  template <int _AP_W2, bool _AP_S2>
  inline af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator[](
      const ap_int_base<_AP_W2, _AP_S2>& index) {
    do { if ((index < 0)) { fprintf(
#1521 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#1521 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit with negative index"); fprintf(
#1521 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#1521 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    do { if ((index >= _AP_W)) { fprintf(
#1522 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#1522 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit beyond MSB"); fprintf(
#1522 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#1522 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this,
                                                                index.to_int());
  }

  inline bool operator[](unsigned index) const {
    do { if ((index >= _AP_W)) { fprintf(
#1528 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#1528 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit beyond MSB"); fprintf(
#1528 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#1528 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    return (const_cast<ap_fixed_base*>(this)->V).get_bit((index));
  }

  inline af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> bit(
      unsigned index) {
    do { if ((index >= _AP_W)) { fprintf(
#1534 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#1534 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit beyond MSB"); fprintf(
#1534 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#1534 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, index);
  }

  template <int _AP_W2, bool _AP_S2>
  inline af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> bit(
      const ap_int_base<_AP_W2, _AP_S2>& index) {
    do { if ((index < 0)) { fprintf(
#1541 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#1541 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit with negative index"); fprintf(
#1541 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#1541 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    do { if ((index >= _AP_W)) { fprintf(
#1542 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#1542 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit beyond MSB"); fprintf(
#1542 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#1542 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this,
                                                                index.to_int());
  }

  inline bool bit(unsigned index) const {
    do { if ((index >= _AP_W)) { fprintf(
#1548 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#1548 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit beyond MSB"); fprintf(
#1548 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#1548 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    return (const_cast<ap_fixed_base*>(this)->V).get_bit((index));
  }

  template <int _AP_W2>
  inline af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> get_bit(
      const ap_int_base<_AP_W2, true>& index) {
    do { if ((index < _AP_I - _AP_W)) { fprintf(
#1555 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#1555 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit with negative index"); fprintf(
#1555 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#1555 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "\n"); } } while (0)
                                                             ;
    do { if ((index >= _AP_I)) { fprintf(
#1557 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#1557 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit beyond MSB"); fprintf(
#1557 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#1557 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(
        this, index.to_int() + _AP_W - _AP_I);
  }

  inline bool get_bit(int index) const {
    do { if ((index >= _AP_I)) { fprintf(
#1563 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#1563 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit beyond MSB"); fprintf(
#1563 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#1563 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    do { if ((index < _AP_I - _AP_W)) { fprintf(
#1564 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#1564 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit beyond MSB"); fprintf(
#1564 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#1564 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    return (const_cast<ap_fixed_base*>(this)->V).get_bit((index + _AP_W - _AP_I))
                                                     ;
  }
#1579 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
  template <int _AP_W2>
  inline bool get_bit(const ap_int_base<_AP_W2, true>& index) const {
    do { if ((index >= _AP_I)) { fprintf(
#1581 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#1581 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit beyond MSB"); fprintf(
#1581 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#1581 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    do { if ((index < _AP_I - _AP_W)) { fprintf(
#1582 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#1582 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit beyond MSB"); fprintf(
#1582 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#1582 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    return (const_cast<ap_fixed_base*>(this)->V).get_bit((index.to_int() + _AP_W - _AP_I))
                                                              ;
  }

  inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range(int Hi,
                                                                      int Lo) {
    do { if (((Hi >= _AP_W) || (Lo >= _AP_W))) { fprintf(
#1589 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#1589 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "WARNING: " "Out of bounds in range()"); fprintf(
#1589 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#1589 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, Hi, Lo);
  }


  inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range(
      int Hi, int Lo) const {
    do { if (((Hi >= _AP_W) || (Lo >= _AP_W))) { fprintf(
#1596 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#1596 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "WARNING: " "Out of bounds in range()"); fprintf(
#1596 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
#1596 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(
        const_cast<ap_fixed_base*>(this), Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range() {
    return this->range(_AP_W - 1, 0);
  }

  inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range() const {
    return this->range(_AP_W - 1, 0);
  }

  inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator()(
      int Hi, int Lo) {
    return this->range(Hi, Lo);
  }

  inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator()(
      int Hi, int Lo) const {
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator()(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator()(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  inline bool is_zero() const { return Base::V == 0; }

  inline bool is_neg() const {
    if (_AP_S && (Base::V).get_bit((_AP_W - 1))) return true;
    return false;
  }

  inline int wl() const { return _AP_W; }

  inline int iwl() const { return _AP_I; }

  inline ap_q_mode q_mode() const { return _AP_Q; }

  inline ap_o_mode o_mode() const { return _AP_O; }

  inline int n_bits() const { return _AP_N; }
#1679 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
  std::string to_string(unsigned char radix = 2, bool sign = _AP_S) const {


    if (radix == 2) sign = false;

    std::string str;
    str.clear();
    char step = 0;
    bool isNeg = sign && (Base::V < 0);


    ap_fixed_base<_AP_W + 1, _AP_I + 1> tmp(*this);
    if (isNeg) {
      tmp = -tmp;
      str += '-';
    }
    std::string prefix;
    switch (radix) {
      case 2:
        prefix = "0b";
        step = 1;
        break;
      case 8:
        prefix = "0o";
        step = 3;
        break;
      case 16:
        prefix = "0x";
        step = 4;
        break;
      default:
        break;
    }

    if (_AP_I > 0) {




      ap_int_base<((_AP_I + 1) > (1) ? (_AP_I + 1) : (1)), false> int_part;




      int_part.V = (tmp.V).range((_AP_W), (_AP_W - _AP_I))
                                      ;
      str += int_part.to_string(radix, false);
    } else {
      str += prefix;
      str += '0';
    }

    ap_fixed_base<((_AP_W - _AP_I) > (1) ? (_AP_W - _AP_I) : (1)), 0, false> frac_part = tmp;

    if (radix == 10) {
      if (frac_part != 0) {
        str += ".";
        while (frac_part != 0) {
          char digit = (frac_part * radix).to_char();
          str += static_cast<char>(digit + '0');
          frac_part *= radix;
        }
      }
    } else {
      if (frac_part != 0) {
        str += ".";
        for (signed i = _AP_W - _AP_I - 1; i >= 0; i -= step) {
          char digit = frac_part.range(i, ((0) > (i - step + 1) ? (0) : (i - step + 1))).to_char();


          int offset = ((0) < (i - step + 1) ? (0) : (i - step + 1));
          digit <<= -offset;
          str += digit < 10 ? static_cast<char>(digit + '0')
                            : static_cast<char>(digit - 10 + 'a');
        }
        if (radix == 16)
          str += "p0";
      }
    }
    return str;
  }






};

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline void b_not(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) {
  ret.V = ~op.V;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline void b_and(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  ret.V = op1.V & op2.V;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline void b_or(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  ret.V = op1.V | op2.V;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline void b_xor(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  ret.V = op1.V ^ op2.V;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
          ap_o_mode _AP_O2, int _AP_N2>
inline void neg(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
  ap_fixed_base<_AP_W2 + !_AP_S2, _AP_I2 + !_AP_S2, true, _AP_Q2, _AP_O2,
                _AP_N2>
      t;
  t.V = -op.V;
  ret = t;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
          ap_o_mode _AP_O2, int _AP_N2>
inline void lshift(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op,
    int i) {
  enum {
    F2 = _AP_W2 - _AP_I2,
    _AP_I3 = ((_AP_I) > (_AP_I2) ? (_AP_I) : (_AP_I2)),
    _AP_W3 = _AP_I3 + F2,
  };

  ap_fixed_base<_AP_W3, _AP_I3, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> t;
  t.V = op.V;
  t.V <<= i;

  ret = t;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
          ap_o_mode _AP_O2, int _AP_N2>
inline void rshift(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op,
    int i) {
  enum {
    F = _AP_W - _AP_I,
    F2 = _AP_W2 - _AP_I2,
    F3 = ((F) > (F2) ? (F) : (F2)),
    _AP_W3 = _AP_I2 + F3,
    sh = F - F2,
  };

  ap_fixed_base<_AP_W3, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> t;
  t.V = op.V;
  if (sh >= 0)
    t.V <<= (int) sh;
  t.V >>= i;

  ret = t;
}
#1868 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
inline std::string scientificFormat(std::string& input) {
  if (input.length() == 0) return input;

  size_t decPosition = input.find('.');
  if (decPosition == std::string::npos) decPosition = input.length();

  size_t firstNonZeroPos = 0;
  for (; input[firstNonZeroPos] > '9' || input[firstNonZeroPos] < '1';
       firstNonZeroPos++)
    ;

  int exp;
  if (firstNonZeroPos > decPosition)
    exp = decPosition - firstNonZeroPos;
  else
    exp = decPosition - firstNonZeroPos - 1;
  std::string expString = "";
  if (exp == 0)
    ;
  else if (exp < 0) {
    expString += "e-";
    exp = -exp;
  } else
    expString += "e+";

  if (exp < 10 && exp > 0) {
    expString += '0';
    expString += (char)('0' + exp);
  } else if (exp != 0) {
    std::string tmp;

    std::ostringstream oss;
    oss << exp;

    tmp = oss.str();
    expString += tmp;
  }

  int lastNonZeroPos = (int)(input.length() - 1);
  for (; lastNonZeroPos >= 0; --lastNonZeroPos)
    if (input[lastNonZeroPos] <= '9' && input[lastNonZeroPos] > '0') break;

  std::string ans = "";
  ans += input[firstNonZeroPos];
  if (firstNonZeroPos != (size_t)lastNonZeroPos) {
    ans += '.';
    for (int i = firstNonZeroPos + 1; i <= lastNonZeroPos; i++)
      if (input[i] != '.') ans += input[i];
  }

  ans += expString;
  return ans;
}

inline std::string reduceToPrecision(std::string& input, int precision) {
  bool isZero = true;
  size_t inputLen = input.length();
  for (size_t i = 0; i < inputLen && isZero; i++)
    if (input[i] != '.' && input[i] != '0') isZero = false;
  if (isZero) return "0";


  int FirstNonZeroPos = 0;
  int LastNonZeroPos = (int)inputLen - 1;
  int truncBitPosition = 0;
  size_t decPosition = input.find('.');
  for (; input[FirstNonZeroPos] < '1' || input[FirstNonZeroPos] > '9';
       FirstNonZeroPos++)
    ;

  for (; input[LastNonZeroPos] < '1' || input[LastNonZeroPos] > '9';
       LastNonZeroPos--)
    ;

  if (decPosition == std::string::npos) decPosition = inputLen;

  if ((int)decPosition > LastNonZeroPos) {
    if (LastNonZeroPos - FirstNonZeroPos + 1 <= precision) return input;
    truncBitPosition = FirstNonZeroPos + precision;
  } else if ((int)decPosition < FirstNonZeroPos) {
    if (LastNonZeroPos - FirstNonZeroPos + 1 <= precision) {
      if (FirstNonZeroPos - decPosition - 1 < 4) {
        return input;
      } else {
        if (input[0] == '-') {
          std::string tmp = input.substr(1, inputLen - 1);
          return std::string("-") + scientificFormat(tmp);
        } else
          return scientificFormat(input);
      }
    }
    truncBitPosition = FirstNonZeroPos + precision;
  } else {
    if (LastNonZeroPos - FirstNonZeroPos <= precision) return input;
    truncBitPosition = FirstNonZeroPos + precision + 1;
  }



  std::string ans = "";
  std::string dupInput = "0";
  if (input[0] == '-') {
    ans += '-';
    dupInput += input.substr(1, inputLen - 1);
  } else {
    dupInput += input.substr(0, inputLen);
    ++truncBitPosition;
  }


  bool carry = dupInput[truncBitPosition] > '4';
  for (int i = truncBitPosition - 1; i >= 0 && carry; i--) {
    if (dupInput[i] == '.') continue;
    if (dupInput[i] == '9')
      dupInput[i] = '0';
    else {
      ++dupInput[i];
      carry = false;
    }
  }


  if (dupInput[0] == '1')
    FirstNonZeroPos = 0;
  else {
    FirstNonZeroPos = 0;
    while (dupInput[FirstNonZeroPos] < '1' || dupInput[FirstNonZeroPos] > '9')
      ++FirstNonZeroPos;
  }

  unsigned it = FirstNonZeroPos;
  int NValidNumber = 0;
  while (it < dupInput.length()) {
    if (dupInput[it] == '.') {
      ++it;
      continue;
    }
    ++NValidNumber;
    if (NValidNumber > precision) dupInput[it] = '0';
    ++it;
  }


  decPosition = dupInput.find('.');
  if (decPosition == std::string::npos)
    truncBitPosition = (int)dupInput.length();
  else
    for (truncBitPosition = (int)(dupInput.length() - 1); truncBitPosition >= 0;
         --truncBitPosition) {
      if (dupInput[truncBitPosition] == '.') break;
      if (dupInput[truncBitPosition] != '0') {
        truncBitPosition++;
        break;
      }
    }

  if (dupInput[0] == '1')
    dupInput = dupInput.substr(0, truncBitPosition);
  else
    dupInput = dupInput.substr(1, truncBitPosition - 1);

  decPosition = dupInput.find('.');
  if (decPosition != std::string::npos) {
    size_t it = 0;
    for (it = decPosition + 1; dupInput[it] == '0'; it++)
      ;
    if (it - decPosition - 1 < 4) {
      ans += dupInput;
      return ans;
    } else {
      ans += scientificFormat(dupInput);
      return ans;
    }
  } else if ((int)(dupInput.length()) <= precision) {
    ans += dupInput;
    return ans;
  }

  ans += scientificFormat(dupInput);
  return ans;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline void print(
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& x) {
  if (_AP_I > 0) {
    ap_int_base<_AP_I, _AP_S> p1;
    p1.V = x.V >> (_AP_W - _AP_I);
    print(p1.V);
  } else {
    printf("0");
  }
  printf(".");
  if (_AP_I < _AP_W) {
    ap_int_base<_AP_W - _AP_I, false> p2;
    p2.V = (x.V).range((_AP_W - _AP_I), (0));
    print(p2.V, false);
  }
}
#2079 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline std::ostream& operator<<(
    std::ostream& out,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& x) {

  unsigned width = out.width();
  unsigned precision = out.precision();
  char fill = out.fill();
  std::string str = x.to_string(10, _AP_S);
  str = reduceToPrecision(str, precision);
  if (width > str.length()) {
    for (unsigned i = 0; i < width - str.length(); ++i)
      out << fill;
  }
  out << str;
  return out;
}





template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline std::istream& operator>>(
    std::istream& in,
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& x) {
  double d;
  in >> d;
  x = ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(d);
  return in;
}
#2212 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator +(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::plus operator +( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator -(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::minus operator -( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator *(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::mult operator *( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator /(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::div operator /( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator &(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator &( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator |(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator |( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator ^(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator ^( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator >>(ap_int_base<(1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator <<(ap_int_base<(1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator +=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator -=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator *=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator /=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator &=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator |=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator ^=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator >>=(ap_int_base<(1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator <<=(ap_int_base<(1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator >(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator <(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator >=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator <=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator ==(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator !=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator +(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::plus operator +( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator -(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::minus operator -( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator *(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::mult operator *( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator /(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::div operator /( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator &(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator &( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator |(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator |( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator ^(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator ^( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator >>(ap_int_base<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator <<(ap_int_base<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator +=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator -=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator *=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator /=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator &=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator |=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator ^=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator >>=(ap_int_base<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator <<=(ap_int_base<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator >(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator <(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator >=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator <=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator ==(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator !=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator +(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::plus operator +( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator -(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::minus operator -( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator *(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::mult operator *( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator /(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::div operator /( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator &(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator &( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator |(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator |( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator ^(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator ^( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator >>(ap_int_base<(8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator <<(ap_int_base<(8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator +=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator -=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator *=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator /=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator &=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator |=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator ^=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator >>=(ap_int_base<(8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator <<=(ap_int_base<(8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator >(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator <(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator >=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator <=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator ==(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator !=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator +(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::plus operator +( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator -(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::minus operator -( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator *(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::mult operator *( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator /(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::div operator /( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator &(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator &( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator |(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator |( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator ^(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator ^( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >>(ap_int_base<(8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <<(ap_int_base<(8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator +=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator -=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator *=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator /=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator &=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator |=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator ^=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >>=(ap_int_base<(8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <<=(ap_int_base<(8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator ==(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator !=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::plus operator +( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::minus operator -( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::mult operator *( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::div operator /( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator &( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator |( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator ^( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::plus operator +( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::minus operator -( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::mult operator *( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::div operator /( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator &( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator |( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator ^( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::plus operator +( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::minus operator -( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::mult operator *( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::div operator /( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator &( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator |( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator ^( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::plus operator +( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::minus operator -( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::mult operator *( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::div operator /( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator &( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator |( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator ^( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::plus operator +( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::minus operator -( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::mult operator *( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::div operator /( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator &( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator |( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator ^( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::plus operator +( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::minus operator -( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::mult operator *( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::div operator /( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator &( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator |( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator ^( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::plus operator +( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::minus operator -( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::mult operator *( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::div operator /( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator &( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator |( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator ^( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::plus operator +( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::minus operator -( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::mult operator *( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::div operator /( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator &( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator |( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator ^( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator !=(op); }
#2300 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_base.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::plus operator +( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator +(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::minus operator -( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator -(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::mult operator *( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator *(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::div operator /( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator /(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::logic operator &( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator &(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::logic operator |( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator |(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::logic operator ^( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator ^(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }



template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator +=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W2, _AP_S2>& operator +=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator +=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator -=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W2, _AP_S2>& operator -=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator -=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator *=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W2, _AP_S2>& operator *=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator *=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator /=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W2, _AP_S2>& operator /=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator /=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator &=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W2, _AP_S2>& operator &=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator &=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator |=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W2, _AP_S2>& operator |=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator |=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator ^=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W2, _AP_S2>& operator ^=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator ^=(op.to_ap_int_base()); }



template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator ==(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator ==( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator ==(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator !=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator !=( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator >(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator >(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator >=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >=( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator >=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator <(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator <(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator <=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <=( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator <=(op); }




template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline bool operator==(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator==(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline bool operator!=(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator!=(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline bool operator>(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator<(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline bool operator>=(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator<=(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline bool operator<(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator>(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline bool operator<=(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator>=(op1);
}
#56 "C:/Xilinx/Vivado/2018.3/include/ap_fixed.h" 2
#1 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_ref.h" 1
#69 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_ref.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct af_bit_ref {



  typedef ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> ref_type;
  ref_type& d_bv;
  int d_index;

 public:
  inline af_bit_ref(
      const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ref)
      : d_bv(ref.d_bv), d_index(ref.d_index) {

    do { if ((d_index < 0)) { fprintf(
#84 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
#84 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_ref.h"
   , "WARNING: " "Index of bit vector  (%d) cannot be negative.", d_index); fprintf(
#84 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
#84 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_ref.h"
   , "\n"); } } while (0)
                        ;
    do { if ((d_index >= _AP_W)) { fprintf(
#86 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
#86 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_ref.h"
   , "WARNING: " "Index of bit vector (%d) out of range (%d).", d_index, _AP_W); fprintf(
#86 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
#86 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_ref.h"
   , "\n"); } } while (0)
                               ;

  }

  inline af_bit_ref(ref_type* bv, int index = 0) : d_bv(*bv), d_index(index) {}

  inline af_bit_ref(const ref_type* bv, int index = 0)
      : d_bv(*const_cast<ref_type*>(bv)), d_index(index) {}


  inline operator bool() const { return (d_bv.V).get_bit((d_index)); }



  inline af_bit_ref& operator=(bool val) {
    d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val);
    return *this;
  }



  inline af_bit_ref& operator=(const af_bit_ref& val) {
    return operator=(bool(val));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline af_bit_ref& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=(bool(val));
  }

  template <int _AP_W2, bool _AP_S2>
  inline af_bit_ref& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& val) {
    return operator=(bool(val));
  }

  template <int _AP_W2, bool _AP_S2>
  inline af_bit_ref& operator=(const ap_int_base<_AP_W2, _AP_S2>& val) {
    return operator=(val != 0);
  }

  template <int _AP_W2, bool _AP_S2>
  inline af_bit_ref& operator=(const ap_range_ref<_AP_W2, _AP_S2>& val) {
    return operator=(ap_int_base<_AP_W2, false>(val));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline af_bit_ref& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=(ap_int_base<_AP_W2, false>(val));
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline af_bit_ref& operator=(
      const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
    return operator=(ap_int_base<_AP_W2 + _AP_W3, false>(val));
  }




  template <int _AP_W2, int _AP_S2>
  inline ap_concat_ref<1, af_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(ap_int_base<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<1, af_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, op);
  }

  template <int _AP_W2, int _AP_S2>
  inline ap_concat_ref<1, af_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> > operator,(
      const ap_bit_ref<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<1, af_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >(*this,
                                                                        op);
  }

  template <int _AP_W2, int _AP_S2>
  inline ap_concat_ref<1, af_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
  operator,(const ap_range_ref<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<1, af_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >(
        *this, op);
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_concat_ref<1, af_bit_ref, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &op) {
    return ap_concat_ref<1, af_bit_ref, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this,
                                                                         op);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_concat_ref<
      1, af_bit_ref, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &op) {
    return ap_concat_ref<
        1, af_bit_ref, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
                                                                       op);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_concat_ref<1, af_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                                    _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &op) {
    return ap_concat_ref<1, af_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                                      _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            op));
  }




  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline bool operator==(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    return get() == op.get();
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline bool operator!=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    return get() != op.get();
  }


  inline bool operator~() const {
    bool bit = (d_bv.V).get_bit((d_index));
    return bit ? false : true;
  }

  inline bool get() const { return (d_bv.V).get_bit((d_index)); }

  inline int length() const { return 1; }


  std::string to_string() const { return get() ? "1" : "0"; }




};




template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline std::ostream& operator<<(
    std::ostream& os,
    const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& x) {
  os << x.to_string();
  return os;
}




template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct af_range_ref {



  typedef ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> ref_type;
  ref_type& d_bv;
  int l_index;
  int h_index;

 public:

  inline af_range_ref(
      const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ref)
      : d_bv(ref.d_bv), l_index(ref.l_index), h_index(ref.h_index) {}




  inline af_range_ref(ref_type* bv, int h, int l)
      : d_bv(*bv), l_index(l), h_index(h) {

    do { if ((h < 0 || l < 0)) { fprintf(
#279 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
#279 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_ref.h"
   , "WARNING: " "Higher bound(%d) and lower(%d) bound cannot be negative.", h, l); fprintf(
#279 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
#279 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_ref.h"
   , "\n"); } } while (0)

                  ;
    do { if ((h >= _AP_W || l >= _AP_W)) { fprintf(
#282 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
#282 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_ref.h"
   , "WARNING: " "Higher bound(%d) or lower(%d) bound out of range.", h, l); fprintf(
#282 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
#282 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_ref.h"
   , "\n"); } } while (0)
                                                                          ;
    do { if ((h < l)) { fprintf(
#284 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
#284 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_ref.h"
   , "WARNING: " "The bits selected will be returned in reverse order."); fprintf(
#284 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
#284 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_ref.h"
   , "\n"); } } while (0);

  }

  inline af_range_ref(const ref_type* bv, int h, int l)
      : d_bv(*const_cast<ref_type*>(bv)), l_index(l), h_index(h) {

    do { if ((h < 0 || l < 0)) { fprintf(
#291 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
#291 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_ref.h"
   , "WARNING: " "Higher bound(%d) and lower(%d) bound cannot be negative.", h, l); fprintf(
#291 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
#291 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_ref.h"
   , "\n"); } } while (0)

                  ;
    do { if ((h >= _AP_W || l >= _AP_W)) { fprintf(
#294 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
#294 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_ref.h"
   , "WARNING: " "Higher bound(%d) or lower(%d) bound out of range.", h, l); fprintf(
#294 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
#294 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_ref.h"
   , "\n"); } } while (0)
                                                                          ;
    do { if ((h < l)) { fprintf(
#296 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
#296 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_ref.h"
   , "WARNING: " "The bits selected will be returned in reverse order."); fprintf(
#296 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
#296 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_ref.h"
   , "\n"); } } while (0);

  }
#310 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_ref.h"
  inline af_range_ref& operator=(const bool val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const char val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const signed char val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const unsigned char val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const short val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const unsigned short val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const int val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const unsigned int val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const long val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const unsigned long val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const ap_slong val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const ap_ulong val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const half val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const float val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const double val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }



  inline af_range_ref& operator=(const char* val) {
    const ap_int_base<_AP_W, false> tmp(val);
    d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V);
    return *this;
  }



  template <int _AP_W3, bool _AP_S3>
  inline af_range_ref& operator=(const ap_int_base<_AP_W3, _AP_S3>& val) {
    d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, val.V);
    return *this;
  }


  template <int _AP_W2, bool _AP_S2>
  inline af_range_ref& operator=(const ap_range_ref<_AP_W2, _AP_S2>& val) {
    const ap_int_base<_AP_W2, false> tmp(val);
    return operator=(tmp);
  }


  template <int _AP_W2, bool _AP_S2>
  inline af_range_ref& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& val) {
    const ap_int_base<1, false> tmp((bool)val);
    return operator=(tmp);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline af_range_ref& operator=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          val) {
    d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, val.V);
    return *this;
  }




  inline af_range_ref& operator=(const af_range_ref& val) {
    ap_int_base<_AP_W, false> tmp(val);
    return operator=(tmp);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline af_range_ref& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    ap_int_base<_AP_W2, false> tmp(val);
    return operator=(tmp);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline af_range_ref& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    ap_int_base<1, false> tmp((bool)val);
    return operator=(tmp);
  }


  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline af_range_ref& operator=(
      const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
    const ap_int_base<_AP_W2 + _AP_W3, false> tmp(val);
    return operator=(tmp);
  }




  template <int _AP_W2, bool _AP_S2>
  inline bool operator==(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop == rop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator!=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator==(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator<(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop < rop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator>(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop > rop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator<=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator>(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator>=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator<(op2));
  }




  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline bool operator==(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop == rop;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline bool operator!=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    return !(operator==(op2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline bool operator<(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop < rop;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline bool operator>(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop > rop;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline bool operator<=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    return !(operator>(op2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline bool operator>=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    return !(operator<(op2));
  }





  template <int _AP_W2, int _AP_S2>
  inline
      ap_concat_ref<_AP_W, af_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(ap_int_base<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(*this, op);
  }


  template <int _AP_W2, int _AP_S2>
  inline ap_concat_ref<_AP_W, af_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >
  operator,(const ap_bit_ref<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<_AP_W, af_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_bit_ref<_AP_W2, _AP_S2>&>(op));
  }


  template <int _AP_W2, int _AP_S2>
  inline ap_concat_ref<_AP_W, af_range_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
  operator,(const ap_range_ref<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
                         ap_range_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_range_ref<_AP_W2, _AP_S2>&>(op));
  }


  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_concat_ref<_AP_W, af_range_ref, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &op) {
    return ap_concat_ref<_AP_W, af_range_ref, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(
        *this, const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(op));
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline
      ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
                    af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>
                    &op) {
    return ap_concat_ref<
        _AP_W, af_range_ref, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            op));
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline
      ap_concat_ref<_AP_W, af_range_ref, 1,
                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(
          const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &op) {
    return ap_concat_ref<
        _AP_W, af_range_ref, 1,
        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            op));
  }


  inline operator ap_ulong() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = (d_bv.V).range((h_index), (l_index));
    return ret.to_uint64();
  }

  inline operator ap_int_base<_AP_W, false>() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = (d_bv.V).range((h_index), (l_index));
    return ret;
  }

  inline ap_int_base<_AP_W, false> to_ap_int_base() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = (d_bv.V).range((h_index), (l_index));
    return ret;
  }


  inline char to_char() const {
    return (char)((d_bv.V).range((h_index), (l_index)));
  }

  inline int to_int() const {
    return (int)((d_bv.V).range((h_index), (l_index)));
  }

  inline unsigned to_uint() const {
    return (unsigned)((d_bv.V).range((h_index), (l_index)));
  }

  inline long to_long() const {
    return (long)((d_bv.V).range((h_index), (l_index)));
  }

  inline unsigned long to_ulong() const {
    return (unsigned long)((d_bv.V).range((h_index), (l_index)));
  }

  inline ap_slong to_int64() const {
    return (ap_slong)((d_bv.V).range((h_index), (l_index)));
  }

  inline ap_ulong to_uint64() const {
    return (ap_ulong)((d_bv.V).range((h_index), (l_index)));
  }

  inline ap_int_base<_AP_W, false> get() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = (d_bv.V).range((h_index), (l_index));
    return ret;
  }

  template <int _AP_W2>
  inline void set(const ap_int_base<_AP_W2, false>& val) {
    d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, val.V);
  }

  inline int length() const {
    return h_index >= l_index ? h_index - l_index + 1 : l_index - h_index + 1;
  }


  std::string to_string(signed char rd = 2) const {
    ap_int_base<_AP_W, false> ret;
    ret.V = (d_bv.V).range((h_index), (l_index));
    return ret.to_string(rd);
  }






};




template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline std::ostream& operator<<(
    std::ostream& os,
    const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& x) {
  os << x.to_string();
  return os;
}
#695 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_ref.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
#741 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_ref.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator ==( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator ==( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator !=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator !=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != ap_int_base<1, false>(op); }
#57 "C:/Xilinx/Vivado/2018.3/include/ap_fixed.h" 2





template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
struct ap_fixed : ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> {
  typedef ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> Base;


  inline ap_fixed() : Base() {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                                      _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed(const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                                               _AP_O2, _AP_N2>& op)
      : Base(op) {}
#111 "C:/Xilinx/Vivado/2018.3/include/ap_fixed.h"
  template <int _AP_W2, bool _AP_S2>
  inline ap_fixed(const ap_int_base<_AP_W2, _AP_S2>& op) : Base(op) {}

  template <int _AP_W2, bool _AP_S2>
  inline ap_fixed(const volatile ap_int_base<_AP_W2, _AP_S2>& op) : Base(op) {}
#136 "C:/Xilinx/Vivado/2018.3/include/ap_fixed.h"
  template <int _AP_W2, bool _AP_S2>
  inline ap_fixed(const ap_bit_ref<_AP_W2, _AP_S2>& op) : Base(op) {}


  template <int _AP_W2, bool _AP_S2>
  inline ap_fixed(const ap_range_ref<_AP_W2, _AP_S2>& op) : Base(op) {}


  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_fixed(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op)
      : Base(op) {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}





  inline ap_fixed(bool v) : Base(v) {}
  inline ap_fixed(char v) : Base(v) {}
  inline ap_fixed(signed char v) : Base(v) {}
  inline ap_fixed(unsigned char v) : Base(v) {}
  inline ap_fixed(short v) : Base(v) {}
  inline ap_fixed(unsigned short v) : Base(v) {}
  inline ap_fixed(int v) : Base(v) {}
  inline ap_fixed(unsigned int v) : Base(v) {}
  inline ap_fixed(long v) : Base(v) {}
  inline ap_fixed(unsigned long v) : Base(v) {}
  inline ap_fixed(ap_slong v) : Base(v) {}
  inline ap_fixed(ap_ulong v) : Base(v) {}
  inline ap_fixed(half v) : Base(v) {}
  inline ap_fixed(float v) : Base(v) {}
  inline ap_fixed(double v) : Base(v) {}


  inline ap_fixed(const char* s) : Base(s) {}

  inline ap_fixed(const char* s, signed char rd) : Base(s, rd) {}






  inline ap_fixed& operator=(
      const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) {
    Base::V = op.V;
    return *this;
  }

  inline void operator=(
      const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) volatile {
    Base::V = op.V;
  }

  inline ap_fixed& operator=(
      const volatile ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) {
    Base::V = op.V;
    return *this;
  }

  inline void operator=(
      const volatile ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) volatile {
    Base::V = op.V;
  }
};





template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
struct ap_ufixed : ap_fixed_base<_AP_W, _AP_I, false, _AP_Q, _AP_O, _AP_N> {
  typedef ap_fixed_base<_AP_W, _AP_I, false, _AP_Q, _AP_O, _AP_N> Base;


  inline ap_ufixed() : Base() {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_ufixed(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                                       _AP_O2, _AP_N2>& op)
      : Base(op) {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_ufixed(const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                                                _AP_O2, _AP_N2>& op)
      : Base(op) {}
#267 "C:/Xilinx/Vivado/2018.3/include/ap_fixed.h"
  template <int _AP_W2, bool _AP_S2>
  inline ap_ufixed(const ap_int_base<_AP_W2, _AP_S2>& op) : Base(op) {}

  template <int _AP_W2, bool _AP_S2>
  inline ap_ufixed(const volatile ap_int_base<_AP_W2, _AP_S2>& op) : Base(op) {}
#289 "C:/Xilinx/Vivado/2018.3/include/ap_fixed.h"
  template <int _AP_W2, bool _AP_S2>
  inline ap_ufixed(const ap_bit_ref<_AP_W2, _AP_S2>& op) : Base(op) {}

  template <int _AP_W2, bool _AP_S2>
  inline ap_ufixed(const ap_range_ref<_AP_W2, _AP_S2>& op) : Base(op) {}

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_ufixed(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_ufixed(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_ufixed(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}




  inline ap_ufixed(bool v) : Base(v) {}
  inline ap_ufixed(char v) : Base(v) {}
  inline ap_ufixed(signed char v) : Base(v) {}
  inline ap_ufixed(unsigned char v) : Base(v) {}
  inline ap_ufixed(short v) : Base(v) {}
  inline ap_ufixed(unsigned short v) : Base(v) {}
  inline ap_ufixed(int v) : Base(v) {}
  inline ap_ufixed(unsigned int v) : Base(v) {}
  inline ap_ufixed(long v) : Base(v) {}
  inline ap_ufixed(unsigned long v) : Base(v) {}
  inline ap_ufixed(ap_slong v) : Base(v) {}
  inline ap_ufixed(ap_ulong v) : Base(v) {}
  inline ap_ufixed(half v) : Base(v) {}
  inline ap_ufixed(float v) : Base(v) {}
  inline ap_ufixed(double v) : Base(v) {}


  inline ap_ufixed(const char* s) : Base(s) {}

  inline ap_ufixed(const char* s, signed char rd) : Base(s, rd) {}


  inline ap_ufixed& operator=(
      const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) {
    Base::V = op.V;
    return *this;
  }

  inline void operator=(
      const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) volatile {
    Base::V = op.V;
  }

  inline ap_ufixed& operator=(
      const volatile ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) {
    Base::V = op.V;
    return *this;
  }

  inline void operator=(const volatile ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O,
                                                 _AP_N>& op) volatile {
    Base::V = op.V;
  }
};
#380 "C:/Xilinx/Vivado/2018.3/include/ap_fixed.h"
#1 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_special.h" 1
#54 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_special.h"
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdio" 1 3
#39 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdio" 3

#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdio" 3
#55 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_special.h" 2
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdlib" 1 3
#39 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdlib" 3

#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
#56 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_special.h" 2




namespace std {
template<typename _Tp> class complex;
}







namespace std {
#88 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_special.h"
template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
struct complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > {
  typedef ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> _Tp;
  typedef _Tp value_type;




  complex() : _M_real(_Tp()), _M_imag(_Tp()) {}


  complex(const _Tp &__r, const _Tp &__i = _Tp(0))
      : _M_real(__r), _M_imag(__i) {}


  template <typename _Up>
  complex(const complex<_Up> &__z) : _M_real(__z.real()), _M_imag(__z.imag()) {}


  const _Tp& real() const { return _M_real; }
  const _Tp& imag() const { return _M_imag; }







  void real(_Tp __val) { _M_real = __val; }

  void imag(_Tp __val) { _M_imag = __val; }



  complex<_Tp> &operator=(const _Tp __t) {
    _M_real = __t;
    _M_imag = _Tp(0);
    return *this;
  }



  complex<_Tp> &operator+=(const _Tp &__t) {
    _M_real += __t;
    return *this;
  }



  complex<_Tp> &operator-=(const _Tp &__t) {
    _M_real -= __t;
    return *this;
  }



  complex<_Tp> &operator*=(const _Tp &__t) {
    _M_real *= __t;
    _M_imag *= __t;
    return *this;
  }



  complex<_Tp> &operator/=(const _Tp &__t) {
    _M_real /= __t;
    _M_imag /= __t;
    return *this;
  }


  template <typename _Up>
  complex<_Tp> &operator=(const complex<_Up> &__z) {
    _M_real = __z.real();
    _M_imag = __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator+=(const complex<_Up> &__z) {
    _M_real += __z.real();
    _M_imag += __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator-=(const complex<_Up> &__z) {
    _M_real -= __z.real();
    _M_imag -= __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator*=(const complex<_Up> &__z) {
    const _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();
    _M_imag = _M_real * __z.imag() + _M_imag * __z.real();
    _M_real = __r;
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator/=(const complex<_Up> &__z) {
    complex<_Tp> cj (__z.real(), -__z.imag());
    complex<_Tp> a = (*this) * cj;
    complex<_Tp> b = cj * __z;
    _M_real = a.real() / b.real();
    _M_imag = a.imag() / b.real();
    return *this;
  }

 private:
  _Tp _M_real;
  _Tp _M_imag;

};
#219 "C:/Xilinx/Vivado/2018.3/include/ap_fixed_special.h"
template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator==(
    const complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__x,
    const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__y) {
  return __x.real() == __y &&
         __x.imag() == 0;
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator==(
    const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__x,
    const complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__y) {
  return __x == __y.real() &&
         0 == __y.imag();
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator!=(
    const complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__x,
    const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__y) {
  return __x.real() != __y ||
         __x.imag() != 0;
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator!=(
    const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__x,
    const complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__y) {
  return __x != __y.real() ||
         0 != __y.imag();
}

}
#381 "C:/Xilinx/Vivado/2018.3/include/ap_fixed.h" 2
#42 "C:/Xilinx/Vivado/2018.3/include/hls_hotbm_apfixed.h" 2
#1 "C:/Xilinx/Vivado/2018.3/include/ap_int.h" 1
#43 "C:/Xilinx/Vivado/2018.3/include/hls_hotbm_apfixed.h" 2
#1 "C:/Xilinx/Vivado/2018.3/include/utils/x_hls_defines.h" 1
#39 "C:/Xilinx/Vivado/2018.3/include/utils/x_hls_defines.h"
#1 "C:/Xilinx/Vivado/2018.3/include/ap_int.h" 1
#40 "C:/Xilinx/Vivado/2018.3/include/utils/x_hls_defines.h" 2
#107 "C:/Xilinx/Vivado/2018.3/include/utils/x_hls_defines.h"
template<int M, int E>
struct float_struct {
    ap_uint<M> mant;
    ap_uint<E> exp;
    ap_uint<1> sign;
};




template<int M, int E>
struct float_struct2 {
    ap_int<M> mant;
    ap_uint<E> exp;
};
#44 "C:/Xilinx/Vivado/2018.3/include/hls_hotbm_apfixed.h" 2
#1 "C:/Xilinx/Vivado/2018.3/include/utils/x_hls_utils.h" 1
#35 "C:/Xilinx/Vivado/2018.3/include/utils/x_hls_utils.h"
#1 "C:/Xilinx/Vivado/2018.3/include/ap_fixed.h" 1
#36 "C:/Xilinx/Vivado/2018.3/include/utils/x_hls_utils.h" 2




#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cmath" 1 3
#39 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cmath" 3

#40 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/cmath" 3
#41 "C:/Xilinx/Vivado/2018.3/include/utils/x_hls_utils.h" 2
#68 "C:/Xilinx/Vivado/2018.3/include/utils/x_hls_utils.h"
namespace hls {

    template<typename T>
    class numeric_limits {
    public:
        static T max() { return std::numeric_limits<T>::max(); }
        static T min() { return std::numeric_limits<T>::min(); }
        static T epsilon() { return std::numeric_limits<T>::epsilon(); }
    };

    template <int W, int I, ap_q_mode Q, ap_o_mode O>
    class numeric_limits<ap_fixed<W,I,Q,O> > {
    public:
        static ap_fixed<W,I,Q,O> max() {
            ap_int<W> m = ::hls::numeric_limits<ap_int<W> >::max();
            ap_fixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_fixed<W,I,Q,O> min() {
            ap_int<W> m = ::hls::numeric_limits<ap_int<W> >::min();
            ap_fixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_fixed<W,I,Q,O> epsilon() {
          ap_fixed<W,I,Q,O> x = 0;
          x[0] = 1;

          return x;
        }
    };

    template <int W, int I, ap_q_mode Q, ap_o_mode O>
    class numeric_limits<ap_ufixed<W,I,Q,O> > {
    public:
        static ap_ufixed<W,I,Q,O> max() {
            ap_uint<W> m = ::hls::numeric_limits<ap_uint<W> >::max();
            ap_ufixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_ufixed<W,I,Q,O> min() { return 0; }
        static ap_ufixed<W,I,Q,O> epsilon() {
          ap_ufixed<W,I,Q,O> x = 0;
          x[0] = 1;
          return x;
        }
    };

    template <int W>
    class numeric_limits<ap_int<W> > {
    public:
        static ap_int<W> max() { ap_int<W> m = min(); return ~m; }
        static ap_int<W> min() { ap_int<W> m = 0; m[W-1] = 1; return m; }
        static ap_int<W> epsilon() {
          ap_int<W> x = 0;
          x[0] = 1;
          return x;
        }
    };

    template <int W>
    class numeric_limits<ap_uint<W> > {
    public:
        static ap_uint<W> max() { ap_uint<W> zero = 0; return ~zero; }
        static ap_uint<W> min() { return 0; }
        static ap_uint<W> epsilon() {
          ap_uint<W> x = 0;
          x[0] = 1;
          return x;
        }
    };
}


namespace hlstmp {

    template<typename T>
    class numeric_limits {
    public:
        static T max() { return std::numeric_limits<T>::max(); }
        static T min() { return std::numeric_limits<T>::min(); }
        static T epsilon() { return std::numeric_limits<T>::epsilon(); }
    };

    template <int W, int I, ap_q_mode Q, ap_o_mode O>
    class numeric_limits<ap_fixed<W,I,Q,O> > {
    public:
        static ap_fixed<W,I,Q,O> max() {
            ap_int<W> m = ::hlstmp::numeric_limits<ap_int<W> >::max();
            ap_fixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_fixed<W,I,Q,O> min() {
            ap_int<W> m = ::hlstmp::numeric_limits<ap_int<W> >::min();
            ap_fixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_fixed<W,I,Q,O> epsilon() {
          ap_fixed<W,I,Q,O> x = 0;
          x[0] = 1;

          return x;
        }
    };

    template <int W, int I, ap_q_mode Q, ap_o_mode O>
    class numeric_limits<ap_ufixed<W,I,Q,O> > {
    public:
        static ap_ufixed<W,I,Q,O> max() {
            ap_uint<W> m = ::hlstmp::numeric_limits<ap_uint<W> >::max();
            ap_ufixed<W,I,Q,O> x;
            x(W-1,0) = m(W-1,0);
            return x;
        }
        static ap_ufixed<W,I,Q,O> min() { return 0; }
        static ap_ufixed<W,I,Q,O> epsilon() {
          ap_ufixed<W,I,Q,O> x = 0;
          x[0] = 1;
          return x;
        }
    };

    template <int W>
    class numeric_limits<ap_int<W> > {
    public:
        static ap_int<W> max() { ap_int<W> m = min(); return ~m; }
        static ap_int<W> min() { ap_int<W> m = 0; m[W-1] = 1; return m; }
        static ap_int<W> epsilon() {
          ap_int<W> x = 0;
          x[0] = 1;
          return x;
        }
    };

    template <int W>
    class numeric_limits<ap_uint<W> > {
    public:
        static ap_uint<W> max() { ap_uint<W> zero = 0; return ~zero; }
        static ap_uint<W> min() { return 0; }
        static ap_uint<W> epsilon() {
          ap_uint<W> x = 0;
          x[0] = 1;
          return x;
        }
    };
}


static inline
const
uint32_t pow2(uint32_t e)
{
    switch(e) {
        case 0: return 1; break;
        case 1: return 2; break;
        case 2: return 4; break;
        case 3: return 8; break;
        case 4: return 16; break;
        case 5: return 32; break;
        case 6: return 64; break;
        case 7: return 128; break;
        case 8: return 256; break;
        case 9: return 512; break;
        case 10: return 1024; break;
        case 11: return 2048; break;
        default: return 0;
    }
}

template<class T>
T reg(T in)
{

#pragma HLS INLINE self off
#pragma HLS INTERFACE ap_none port=return register

    return in;
}
#264 "C:/Xilinx/Vivado/2018.3/include/utils/x_hls_utils.h"
static inline
float to_float(float v)
{
    return v;
}

template<int _W, int _I>
float to_float(ap_fixed<_W, _I> v)
{
    return v.to_float();
}
#283 "C:/Xilinx/Vivado/2018.3/include/utils/x_hls_utils.h"
template <typename T>
class fp_struct
{
};

union single_cast {
    float f;
    uint32_t i;
};

template <>
class fp_struct<float>
{
public:
    const static int EXP_INFNAN = 255;
    const static int EXP_BIAS = 127;
    const static int EXP_BITS = 8;
    const static int SIG_BITS = 23;
    const static int BITS = 32;

    fp_struct() {
    }
    fp_struct(float f) {


        union single_cast dc;
        dc.f = f;
        ap_uint<32> data = dc.i;





        sign[0] = data[31];
        exp(7,0)= data(30,23);
        sig(22,0)= data(22,0);
    }
    fp_struct(ap_uint<32> data) {
        sign[0] = data[31];
        exp(7,0)= data(30,23);
        sig(22,0)= data(22,0);
    }
    fp_struct(uint32_t i) {
        ap_uint<32> data = i;
        sign[0] = data[31];
        exp(7,0)= data(30,23);
        sig(22,0)= data(22,0);
    }
    inline ap_uint<32> data() const {
        ap_uint<32> t;
        t[31] = sign[0];
        t(30,23) = exp(7,0);
        t(22,0) = sig(22,0);
        return t;
    }
    inline int expv() const {
        return exp-127;
    }
    inline int32_t to_int() const {
        return data().to_int();
    }
    inline float to_float() const {


        union single_cast ret;
        ret.i = data().to_uint();
        return ret.f;







    }
    inline void set_mantissa(ap_ufixed<1+SIG_BITS,1> mantissa) {
        ap_ufixed<SIG_BITS,0> significand = mantissa;
        sig = significand(SIG_BITS-1,0);
    }
    inline ap_ufixed<1+SIG_BITS,1> mantissa() const {
        ap_ufixed<1+SIG_BITS,1> y = 0;
        y(y.wl()-1,0) = sig(SIG_BITS-1,0);
        y[y.wl()-1] = 1;
        return y;
    }
    inline float to_ieee() const {
        return to_float();
    }
    inline int __signbit() const {
        return sign.to_int();
    }

    static float infinity() {
        fp_struct<float> x;
        x.sign = 0;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    static float minus_infinity() {
        fp_struct<float> x;
        x.sign = 1;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    typedef uint32_t inttype;
    typedef ap_uint<32> data_type;
    ap_uint<1> sign;
    ap_uint<EXP_BITS> exp;
    ap_uint<SIG_BITS> sig;
};


static inline
std::ostream &operator << (std::ostream &os, const fp_struct<float> &s)
{

    os << s.to_float();
    os << " (sign: " << s.sign << ", exp: " << s.exp << ", sig: ";
    os << s.sig.to_string(8);
    os << " " << s.sig.to_string(2);
    os << ")";

    return os;
}


static inline
void
castSingle(
    float din,
    fp_struct<float> &dout)
{
    fp_struct<float> t(din);
    dout = t;
}

static inline
float
castSingle(
    fp_struct<float> din)
{
    return din.to_float();
}

static inline
void
dumpSingle(
    float da,
    fp_struct<float> ds)
{
#447 "C:/Xilinx/Vivado/2018.3/include/utils/x_hls_utils.h"
}







union double_cast {
    double d;
    uint64_t i;
};

template <>
class fp_struct<double>
{
public:
    const static int EXP_INFNAN = 2047;
    const static int EXP_BIAS = 1023;
    const static int EXP_BITS = 11;
    const static int SIG_BITS = 52;
    const static int BITS = 64;

    fp_struct() {
    }
    fp_struct(double f) {
        union double_cast dc;
        dc.d = f;
        ap_uint<64> data = dc.i;
        sign[0] = data[63];
        exp(10,0) = data(62,52);
        sig(51,0) = data(51,0);
    }
    fp_struct(ap_uint<64> data) {
        sign[0] = data[63];
        exp(10,0) = data(62,52);
        sig(51,0) = data(51,0);
    }
    fp_struct(uint64_t i) {
        ap_uint<64> data = i;
        sign[0] = data[EXP_BITS+SIG_BITS+1-1];
        exp(EXP_BITS-1,0) = data(EXP_BITS-1+SIG_BITS,SIG_BITS);
        sig(SIG_BITS-1,0) = data(SIG_BITS-1,0);
    }
    inline ap_uint<64> data() const {
        ap_uint<64> t;
        t[EXP_BITS+SIG_BITS+1-1] = sign[0];
        t(EXP_BITS-1+SIG_BITS,SIG_BITS) = exp(EXP_BITS-1,0);
        t(SIG_BITS-1,0) = sig(SIG_BITS-1,0);
        return t;
    }
    inline int64_t to_int() const {
        return data().to_int64();
    }
    inline int expv() const {
        return exp-1023;
    }
    inline ap_uint<20> sig_msb() const {
        return sig(51,32);
    }
    inline ap_uint<32> sig_lsb() const {
        return sig(31,0);
    }
    inline double to_double() const {
        union double_cast ret;
        ret.i = data().to_uint64();
        return ret.d;
    }
    inline void set_mantissa(ap_ufixed<1+SIG_BITS,1> mantissa) {
        ap_ufixed<SIG_BITS,0> significand = mantissa;
        sig = significand(SIG_BITS-1,0);
    }
    inline ap_ufixed<1+SIG_BITS,1> mantissa() const {
        ap_ufixed<1+SIG_BITS,1> y = 0;
        y(y.wl()-1,0) = sig(SIG_BITS-1,0);
        y[y.wl()-1] = 1;
        return y;
    }
    inline double to_ieee() const {
        return to_double();
    }
    inline int __signbit() const {
        return sign.to_int();
    }

    static double infinity() {
        fp_struct<double> x;
        x.sign = 0;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    static double minus_infinity() {
        fp_struct<double> x;
        x.sign = 1;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    typedef uint64_t inttype;
    typedef ap_uint<64> data_type;
    ap_uint<1> sign;
    ap_uint<EXP_BITS> exp;
    ap_uint<SIG_BITS> sig;
};


static inline
std::ostream &operator << (std::ostream &os, const fp_struct<double> &s)
{

    os << s.to_double() << " (sign: " << s.sign << ", exp: " << s.exp << ", sig: " << s.sig << " " << s.sig.to_string(2,true) << ")";

    return os;
}


static inline
void
castDouble(
    double din,
    fp_struct<double> &dout)
{
    fp_struct<double> t(din);
    dout = t;
}

static inline
double
castDouble(
    fp_struct<double> din)
{
    return din.to_double();
}

static inline
void
dumpDouble(
    double da,
    fp_struct<double> ds)
{
#600 "C:/Xilinx/Vivado/2018.3/include/utils/x_hls_utils.h"
}
#616 "C:/Xilinx/Vivado/2018.3/include/utils/x_hls_utils.h"
template <>
class fp_struct<half>
{
public:
    const static int EXP_INFNAN = 31;
    const static int EXP_BIAS = 15;
    const static int EXP_BITS = 5;
    const static int SIG_BITS = 10;
    const static int BITS = 16;

    fp_struct() {
    }
    fp_struct(half f) {





        ap_uint<16> data = (uint16_t)f.get_bits();

        sign[0] = data[EXP_BITS+SIG_BITS+1-1];
        exp(EXP_BITS-1,0) = data(EXP_BITS-1+SIG_BITS,SIG_BITS);
        sig(SIG_BITS-1,0) = data(SIG_BITS-1,0);
    }
    fp_struct(ap_uint<16> data) {
        sign[0] = data[EXP_BITS+SIG_BITS+1-1];
        exp(EXP_BITS-1,0) = data(EXP_BITS-1+SIG_BITS,SIG_BITS);
        sig(SIG_BITS-1,0) = data(SIG_BITS-1,0);
    }
    fp_struct(uint16_t i) {
        ap_uint<16> data = i;
        sign[0] = data[EXP_BITS+SIG_BITS+1-1];
        exp(EXP_BITS-1,0) = data(EXP_BITS-1+SIG_BITS,SIG_BITS);
        sig(SIG_BITS-1,0) = data(SIG_BITS-1,0);
    }
    inline ap_uint<16> data() const {
        ap_uint<16> t;
        t[EXP_BITS+SIG_BITS+1-1] = sign[0];
        t(EXP_BITS-1+SIG_BITS,SIG_BITS) = exp(EXP_BITS-1,0);
        t(SIG_BITS-1,0) = sig(SIG_BITS-1,0);
        return t;
    }
    inline int expv() const {
        return exp-EXP_BIAS;
    }
    inline int16_t to_int() const {
        return uint16_t(data().to_int());
    }
    inline half to_half() const {





        half h;
        h.set_bits(detail::uint16(data().to_uint()));
        return h;

    }
    inline void set_mantissa(ap_ufixed<1+SIG_BITS,1> mantissa) {
        ap_ufixed<SIG_BITS,0> significand = mantissa;
        sig = significand(SIG_BITS-1,0);
    }
    inline ap_ufixed<1+SIG_BITS,1> mantissa() const {
        ap_ufixed<1+SIG_BITS,1> y = 0;
        y(y.wl()-1,0) = sig(SIG_BITS-1,0);
        y[y.wl()-1] = 1;
        return y;
    }
    inline half to_ieee() const {
        return to_half();
    }
    inline int __signbit() const {
        return sign.to_int();
    }

    static half infinity() {
        fp_struct<half> x;
        x.sign = 0;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    static half minus_infinity() {
        fp_struct<half> x;
        x.sign = 1;
        x.exp = -1;
        x.sig = 0;
        return x.to_ieee();
    }

    typedef uint16_t inttype;
    typedef ap_uint<16> data_type;
    ap_uint<1> sign;
    ap_uint<EXP_BITS> exp;
    ap_uint<SIG_BITS> sig;
};


static inline
std::ostream &operator << (std::ostream &os, const fp_struct<half> &s)
{

    os << s.to_half() << " (sign: " << s.sign << ", exp: " << s.exp << ", sig: " << s.sig << " " << s.sig.to_string(2,true) << ")";

    return os;
}


static inline
void
castHalf(
    half din,
    fp_struct<half> &dout)
{
    fp_struct<half> t(din);
    dout = t;
}

static inline
half
castHalf(
    fp_struct<half> din)
{
    return din.to_half();
}

static inline
void
dumpHalf(
    half da,
    fp_struct<half> ds)
{
#760 "C:/Xilinx/Vivado/2018.3/include/utils/x_hls_utils.h"
}
#775 "C:/Xilinx/Vivado/2018.3/include/utils/x_hls_utils.h"
template < unsigned int _Base, unsigned int _Num >
class Power
{
public:
    static const unsigned int Value = _Base * Power< _Base, _Num - 1 >::Value;
};

template < unsigned int _Base >
class Power< _Base, 0 >
{
public:
    static const unsigned int Value = 1;
};
#797 "C:/Xilinx/Vivado/2018.3/include/utils/x_hls_utils.h"
template < unsigned int _Num, unsigned int _I=_Num/2>
class BitWidth
{
public:
    static const unsigned int Value = 1 + BitWidth<_Num,_I/2>::Value;
};

template <unsigned int _Num>
class BitWidth<_Num, 0>
{
public:
    static const unsigned int Value = 1;
};
#819 "C:/Xilinx/Vivado/2018.3/include/utils/x_hls_utils.h"
template < unsigned int _Num, unsigned int _I=_Num/2>
class UnsignedBitWidth
{
public:
    static const unsigned int Value = 1 + UnsignedBitWidth<_Num,_I/2>::Value;
};

template <unsigned int _Num>
class UnsignedBitWidth<_Num, 0>
{
public:
    static const unsigned int Value = 0;
};
#840 "C:/Xilinx/Vivado/2018.3/include/utils/x_hls_utils.h"
template < typename T >
class Type_BitWidth
{
public:
    static const unsigned int Value = 8*sizeof(T);
};

template <int W >
class Type_BitWidth< ap_uint<W> >
{
public:
    static const unsigned int Value = W;
};

template < int W >
class Type_BitWidth< ap_int<W> >
{
public:
    static const unsigned int Value = W;
};

template < int W, int I >
class Type_BitWidth< ap_ufixed<W, I> >
{
public:
    static const unsigned int Value = W;
};

template < int W, int I >
class Type_BitWidth< ap_fixed<W, I> >
{
public:
    static const unsigned int Value = W;
};
#888 "C:/Xilinx/Vivado/2018.3/include/utils/x_hls_utils.h"
template <typename _T, int _Num, int _I=_Num-1>
class Table : public Table<_T, _Num, _I-1>
{
public:
    typedef typename _T::TableType TableType;
    static const typename _T::TableType dummy;
    static const int size = _Num;

};

template <typename _T, int _Num>
class Table<_T, _Num, 0>
{
public:
    static const typename _T::TableType dummy;
    static typename _T::TableType array[_Num];
};
#915 "C:/Xilinx/Vivado/2018.3/include/utils/x_hls_utils.h"
template <typename _T, int _Num, int _I>
const typename _T::TableType Table<_T, _Num, _I>::dummy
    = Table<_T, _Num, 0>::array[_I] = _T::apply(_I,_Num) + 0*Table<_T, _Num, _I-1>::dummy;

template <typename _T, int _Num>
const typename _T::TableType Table<_T, _Num, 0>::dummy
    = Table<_T, _Num, 0>::array[0] = _T::apply(0,_Num);




template <typename _T, int _Num>
typename _T::TableType Table<_T, _Num, 0>::array[_Num];



template <class T>
struct is_fptype { static const bool value = false; };
template <> struct is_fptype<float> { static const bool value = true; };
template <> struct is_fptype<double> { static const bool value = true; };
template <> struct is_fptype<half> { static const bool value = true; };

template <class T>
struct is_integraltype { static const bool value = false; };
template <> struct is_integraltype<int> { static const bool value = true; };
template <> struct is_integraltype<unsigned int> { static const bool value = true; };
template <> struct is_integraltype<char> { static const bool value = true; };
template <> struct is_integraltype<signed char> { static const bool value = true; };
template <> struct is_integraltype<unsigned char> { static const bool value = true; };
template <> struct is_integraltype<short> { static const bool value = true; };
template <> struct is_integraltype<unsigned short> { static const bool value = true; };
template <> struct is_integraltype<long> { static const bool value = true; };
template <> struct is_integraltype<unsigned long> { static const bool value = true; };
template <> struct is_integraltype<long long> { static const bool value = true; };
template <> struct is_integraltype<unsigned long long> { static const bool value = true; };
template <int W> struct is_integraltype<ap_int<W> > { static const bool value = true; };
template <int W> struct is_integraltype<ap_uint<W> > { static const bool value = true; };

template <class T>
struct is_fixedtype { static const bool value = false; };
template <int W, int I, ap_q_mode Q, ap_o_mode O> struct is_fixedtype<ap_fixed<W,I,Q,O> > { static const bool value = true; };
template <int W, int I, ap_q_mode Q, ap_o_mode O> struct is_fixedtype<ap_ufixed<W,I,Q,O> > { static const bool value = true; };

namespace hls {
    template<bool B, class T = void>
    struct enable_if {};

    template<class T>
    struct enable_if<true, T> { typedef T type; };
    template<typename T, T _v>
    struct integral_constant
    {
        static const T value = _v;
        typedef T value_type;
        typedef integral_constant<T,_v> type;
        operator value_type() { return value; }
    };

    typedef integral_constant<bool, true> true_type;
    typedef integral_constant<bool, false> false_type;

    template<typename T1, typename T2>
    struct is_same;

    template<typename T1, typename T2>
    struct is_same : public false_type { };

    template<typename T1>
    struct is_same<T1,T1> : public true_type { };

    template<typename T>
    struct is_arithmetic : public integral_constant<bool, (is_integraltype<T>::value || is_fptype<T>::value)> { };
}

template<typename T1, typename T2>
struct enable_or { static const bool value = T1::value || T2::value; };

template<typename T1, typename T2>
struct enable_and { static const bool value = T1::value && T2::value; };



template<typename T, bool = is_integraltype<T>::value>
struct __promote { typedef double type; };

template<typename T>
struct __promote<T, false> { };

template<>
struct __promote<double> { typedef double type; };

template<>
struct __promote<float> { typedef float type; };

template<>
struct __promote<half> { typedef half type; };
#45 "C:/Xilinx/Vivado/2018.3/include/hls_hotbm_apfixed.h" 2






namespace hotbm_apfixed
{

  namespace first_order_fixed_16{
 extern const ap_fixed<19,2> sin_cos_K0[256];
 extern const ap_fixed<11,2> sin_cos_K1[256];
  };

  namespace second_order_float{
 extern const ap_fixed<29,0> cos_K0[128];
 extern const ap_fixed<23,1> cos_K1[128];
 extern const ap_fixed<15,0> cos_K2[128];
 extern const ap_fixed<30,1> sin_K0[128];
 extern const ap_fixed<21,-1> sin_K1[128];
 extern const ap_fixed<13,-2> sin_K2[128];
 extern const ap_ufixed<30,1> sin_cos_K0[256];
 extern const ap_fixed<23,1> sin_cos_K1[256];
 extern const ap_fixed<15,0> sin_cos_K2[256];
  };

  namespace fourth_order_double{
 extern const ap_fixed<59,0> cos_K0[128];
 extern const ap_fixed<53,1> cos_K1[128];
 extern const ap_fixed<45,0> cos_K2[128];
 extern const ap_fixed<35,-3> cos_K3[128];
 extern const ap_fixed<27,-4> cos_K4[128];
 extern const ap_fixed<60,1> sin_K0[128];
 extern const ap_fixed<51,-1> sin_K1[128];
 extern const ap_fixed<43,-2> sin_K2[128];
 extern const ap_fixed<33,-5> sin_K3[128];
 extern const ap_fixed<24,-7> sin_K4[128];
 extern const ap_fixed<59,1> sin_cos_K0[256];
 extern const ap_fixed<52,1> sin_cos_K1[256];
 extern const ap_fixed<44,0> sin_cos_K2[256];
 extern const ap_fixed<34,-3> sin_cos_K3[256];
 extern const ap_fixed<26,-4> sin_cos_K4[256];
  };

  template<class T>
  struct value_list{
  };

  template<>
  struct value_list<double>{
    typedef double T;
 static const int g = 10;
 static const int p1 = 61;
 static const int alpha = 7;

 static const int beta1 = 0;

 static const int beta2 = alpha;

    static const int W_dout = fp_struct<T>::SIG_BITS+1+g;
    static const int W_Mx = fp_struct<T>::SIG_BITS+1+g;

    template <int Wx, int Wr>
    static ap_ufixed<Wx, 1> sin_or_cos_approximation(bool do_cos,
              ap_uint<3> &k,
              ap_ufixed<Wx, 0> &x,
              ap_ufixed<Wr, 0> &Mx,
              ap_int<fp_struct<double>::EXP_BITS> &Ex){

   const bool swap_table[8] = {0,1,1,0,0,1,1,0};
#pragma HLS array_partition variable=swap_table complete
#pragma HLS RESOURCE variable=fourth_order_double::sin_cos_K0 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=fourth_order_double::sin_cos_K1 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=fourth_order_double::sin_cos_K2 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=fourth_order_double::sin_cos_K3 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=fourth_order_double::sin_cos_K4 core=ROM_1P_LUTRAM

   ap_uint<alpha+1> A = x(x.wl()-x.iwl()-1,x.wl()-x.iwl()-alpha);
   ap_ufixed<Wx-alpha-beta1, -alpha> B = x;
   ap_ufixed<Wx-alpha-beta2, -alpha> B_trunc = B;
   ap_ufixed<Wx-2*alpha, -2*alpha> B_squared = B_trunc*B_trunc;
   ap_ufixed<Wx-3*alpha, -3*alpha> B_third_power = B_trunc*B_squared;
   ap_ufixed<Wx-4*alpha, -4*alpha> B_fourth_power = B_squared*B_squared;

   bool sin_basis = do_cos? swap_table[k]:!swap_table[k];
   A[alpha] = sin_basis;

   ap_fixed<Wx, 1> t1 = fourth_order_double::sin_cos_K0[A];
   ap_fixed<Wx, 1> t2 = B*fourth_order_double::sin_cos_K1[A];
   ap_fixed<Wx, 1> t3 = B_squared*fourth_order_double::sin_cos_K2[A];
   ap_fixed<Wx, 1> t4 = B_third_power*fourth_order_double::sin_cos_K3[A];
   ap_fixed<Wx, 1> t5 = B_fourth_power*fourth_order_double::sin_cos_K4[A];
   ap_ufixed<Wx, 1> result = Mx*(t1+t2+t3+t4+t5);
   return result;
    }

    template <int Wx, int Wr>
    static void sincos_approximation(ap_uint<3> &k,
          ap_ufixed<Wx, 0> &x,
          ap_ufixed<Wr, 0> Mx,
          ap_int<fp_struct<double>::EXP_BITS> Ex,
          ap_ufixed<Wr, 1> &sin_result,
          ap_ufixed<Wr, 1> &cos_result
          ) {
#pragma HLS RESOURCE variable=fourth_order_double::cos_K0 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=fourth_order_double::cos_K1 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=fourth_order_double::cos_K2 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=fourth_order_double::cos_K3 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=fourth_order_double::cos_K4 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=fourth_order_double::sin_K0 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=fourth_order_double::sin_K1 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=fourth_order_double::sin_K2 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=fourth_order_double::sin_K3 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=fourth_order_double::sin_K4 core=ROM_1P_LUTRAM

   ap_uint<alpha> A = x(x.wl()-x.iwl()-1,
         x.wl()-x.iwl()-alpha);
   ap_ufixed<Wx-alpha-beta1, -alpha> B = x;
   ap_ufixed<Wx-alpha-beta2, -alpha> B_trunc = B;
   ap_ufixed<Wx-2*alpha, -2*alpha> B_squared = B_trunc*B_trunc;
   ap_ufixed<Wx-3*alpha, -3*alpha> B_third_power = B_trunc*B_squared;
   ap_ufixed<Wx-4*alpha, -4*alpha> B_fourth_power = B_squared*B_squared;

   ap_fixed<Wx, 1> cos_t1 = fourth_order_double::cos_K0[A];
   ap_fixed<Wx, 1> cos_t2 = B*fourth_order_double::cos_K1[A];
   ap_fixed<Wx, 1> cos_t3 = B_squared*fourth_order_double::cos_K2[A];
   ap_fixed<Wx, 1> cos_t4 = B_third_power*fourth_order_double::cos_K3[A];
   ap_fixed<Wx, 1> cos_t5 = B_fourth_power*fourth_order_double::cos_K4[A];
   cos_result = 1 - (cos_t1 + cos_t2 + cos_t3 + cos_t4 + cos_t5);

   ap_fixed<Wx, 1> sin_t1 = fourth_order_double::sin_K0[A];
   ap_fixed<Wx, 1> sin_t2 = B*fourth_order_double::sin_K1[A];
   ap_fixed<Wx, 1> sin_t3 = B_squared*fourth_order_double::sin_K2[A];
   ap_fixed<Wx, 1> sin_t4 = B_third_power*fourth_order_double::sin_K3[A];
   ap_fixed<Wx, 1> sin_t5 = B_fourth_power*fourth_order_double::sin_K4[A];
   sin_result = Mx * (sin_t1 + sin_t2 + sin_t3 + sin_t4 + sin_t5);
    }
  };

  template<>
  struct value_list<float> {
 typedef float T;
 static const int g = 5;
 static const int p1 = 29;
 static const int alpha = 7;
 static const int beta1 = 0;
 static const int beta2 = 7;

 static const int W_dout = fp_struct<T>::SIG_BITS+1+g;
 static const int W_Mx = fp_struct<T>::SIG_BITS+1+g;

 template <int Wx, int Wr>
 static ap_ufixed<Wx, 1> sin_or_cos_approximation(bool do_cos,
              ap_uint<3> &k,
              ap_ufixed<Wx, 0> &x,
              ap_ufixed<Wr, 0> &Mx,
              ap_int<fp_struct<float>::EXP_BITS> &Ex){

   const bool swap_table[8] = {0,1,1,0,0,1,1,0};

#pragma HLS array_partition variable=swap_table complete
#pragma HLS RESOURCE variable=second_order_float::sin_cos_K0 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=second_order_float::sin_cos_K1 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=second_order_float::sin_cos_K2 core=ROM_1P_LUTRAM

   ap_uint<alpha+1> A = x(x.wl()-x.iwl()-1,x.wl()-x.iwl()-alpha);
   ap_ufixed<Wx-alpha-beta1, -alpha> B = x;
   ap_ufixed<Wx-alpha-beta2, -alpha> B_trunc = B;
   ap_ufixed<Wx-2*alpha, -2*alpha> B_squared = B_trunc*B_trunc;

   bool sin_basis = do_cos? swap_table[k]:!swap_table[k];
   A[alpha] = sin_basis;

   ap_fixed<Wx, 1> t1 = second_order_float::sin_cos_K0[A];
   ap_fixed<Wx, 1> t2 = B*second_order_float::sin_cos_K1[A];
   ap_fixed<Wx, 1> t3 = B_squared*second_order_float::sin_cos_K2[A];
   ap_ufixed<Wx, 1> result = (t1+t2+t3) * Mx;

   return result;
 }

 template <int Wx, int Wr>
 static void sincos_approximation(ap_uint<3> &k,
          ap_ufixed<Wx, 0> &x,
          ap_ufixed<Wr, 0> &Mx,
          ap_int<fp_struct<float>::EXP_BITS> &Ex,
          ap_ufixed<Wr, 1> &sin_result,
          ap_ufixed<Wr, 1> &cos_result
          ) {
#pragma HLS RESOURCE variable=second_order_float::cos_K0 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=second_order_float::cos_K1 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=second_order_float::cos_K2 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=second_order_float::sin_K0 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=second_order_float::sin_K1 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=second_order_float::sin_K2 core=ROM_1P_LUTRAM

   ap_uint<alpha> A = x(x.wl()-x.iwl()-1,
         x.wl()-x.iwl()-alpha);
   ap_ufixed<Wx-alpha-beta1, -alpha> B = x;
   ap_ufixed<Wx-alpha-beta2, -alpha> B_trunc = B;
   ap_ufixed<Wx-2*alpha, -2*alpha> B_squared = B_trunc*B_trunc;


   ap_ufixed<Wx, 1> cos_t1 = second_order_float::cos_K0[A];
   ap_ufixed<Wx, 1> cos_t2 = B*second_order_float::cos_K1[A];
   ap_ufixed<Wx, 1> cos_t3 = B_squared*second_order_float::cos_K2[A];
   cos_result = 1 - (cos_t1 + cos_t2 + cos_t3);

   ap_fixed<Wx, 1> sin_t1 = second_order_float::sin_K0[A];
   ap_fixed<Wx, 1> sin_t2 = B*second_order_float::sin_K1[A];
   ap_fixed<Wx, 1> sin_t3 = B_squared*second_order_float::sin_K2[A];
   sin_result = Mx * (sin_t1 + sin_t2 + sin_t3);
 }
  };

  struct sin_cos_fixed_16 {

 typedef half T;
 static const int g = 3;
 static const int p1 = 12;
 static const int alpha = 8;
 static const int beta1 = 4;

 template <int W_dout>
 static ap_ufixed<W_dout, 1> sin_or_cos_approximation(bool do_cos,
               ap_uint<2> &k,
               ap_ufixed<W_dout, 0> &x){

#pragma HLS RESOURCE variable=first_order_fixed_16::sin_cos_K0 core=ROM_1P_LUTRAM
#pragma HLS RESOURCE variable=first_order_fixed_16::sin_cos_K1 core=ROM_1P_LUTRAM

   ap_uint<alpha> A = x(x.wl()-x.iwl()-1,x.wl()-x.iwl()-alpha);

   const int BW = (W_dout-alpha-beta1)>1 ? W_dout-alpha-beta1 : 2;
   ap_ufixed<BW, -alpha> B = x;

   ap_fixed<W_dout, 1> t1 = first_order_fixed_16::sin_cos_K0[A];
   ap_fixed<W_dout, 1> t2 = B*first_order_fixed_16::sin_cos_K1[A];
   ap_ufixed<W_dout, 1> result = (t1+t2);

   return result;
 };
  };

  template<int W, int I>
  ap_fixed<W,2>
  sinf_or_cosf(ap_fixed<W,I> t_in, bool do_cos, bool do_pi,
      typename hls::enable_if<(W > 16) && (W <= 32), bool>::type dummy = true)
  {
 const int WO = W;
 const int g = 3;

 const bool swap_table[8] = {0,1,1,0,0,1,1,0};
 const bool neg_sin_table[16] = {0,0,1,0,1,1,0,1, 1,0,1,1,0,1,0,0};
 const bool neg_cos_table[16] = {0,0,0,1,1,1,1,0, 0,1,1,1,1,0,0,0};

#pragma HLS array_partition variable=swap_table complete
#pragma HLS array_partition variable=neg_sin_table complete
#pragma HLS array_partition variable=neg_cos_table complete

 ap_uint<3> k;
 ap_ufixed<WO+1+g, 0> x;
 ap_ufixed<WO+1+g, 0> Mx;
 ap_int<fp_struct<float>::EXP_BITS> Ex = 0;

 int exactly_pi_over_4 = 0;
 bool is_negative = t_in[t_in.wl()-1];
 ap_ufixed<W, I> din = is_negative ? ap_fixed<W, I>(-t_in) : t_in;

 if(do_pi) {
   k = din*4;
   x = din*4;
   ap_ufixed<W, 1> Mx_bits_extended = din*4;



   exactly_pi_over_4 = (Mx_bits_extended == 1);
 } else {
   ap_ufixed<WO+1+g+3, 3> Wx = din * ap_ufixed<W+1+g,2>(4/
#323 "C:/Xilinx/Vivado/2018.3/include/hls_hotbm_apfixed.h" 3
                                                         3.14159265358979323846
#323 "C:/Xilinx/Vivado/2018.3/include/hls_hotbm_apfixed.h"
                                                             );
   k = Wx;
   x = Wx;
 }




 if(k[0] == 1) {
   x = 1-x;
 }
 Mx = x;

 bool cos_basis = do_cos?!swap_table[k]: swap_table[k];
 if(cos_basis) {


   Mx = ap_ufixed<value_list<float>::W_dout, 0, AP_RND, AP_SAT>(1);
   Ex = 0;
 }

 ap_ufixed<WO+1+g, 1> result = value_list<float>::sin_or_cos_approximation(do_cos,k,x,Mx,Ex);

 if(exactly_pi_over_4) {
   result = 0.7071067811865475244008443;
 }

 ap_uint<4> index = k;
 index[3] = is_negative;

 if(cos_basis ? neg_cos_table[index] : neg_sin_table[index]) {
   return -result;
 } else {
   return result;
 }
  }


  template<int W, int I>
  ap_fixed<W,2>
  sinf_or_cosf(ap_fixed<W,I> t_in, bool do_cos, bool do_pi,
      typename hls::enable_if<(W > 32) && (W <= 64), bool>::type dummy = true)
  {
 const int WO = W;
 const int g = 3;

 const bool swap_table[8] = {0,1,1,0,0,1,1,0};
 const bool neg_sin_table[16] = {0,0,1,0,1,1,0,1, 1,0,1,1,0,1,0,0};
 const bool neg_cos_table[16] = {0,0,0,1,1,1,1,0, 0,1,1,1,1,0,0,0};
#pragma HLS array_partition variable=swap_table complete
#pragma HLS array_partition variable=neg_sin_table complete
#pragma HLS array_partition variable=neg_cos_table complete

 ap_uint<3> k;
 ap_ufixed<WO+1+g, 0> x;
 ap_ufixed<WO+1+g, 0> Mx;
 ap_int<fp_struct<double>::EXP_BITS> Ex = 0;

 int exactly_pi_over_4 = 0;
 bool is_negative = t_in[t_in.wl()-1];
 ap_ufixed<W, I> din = is_negative ? ap_fixed<W, I>(-t_in) : t_in;

 if(do_pi) {
   k = din*4;
   x = din*4;
   ap_ufixed<W, 1> Mx_bits_extended = din*4;



   exactly_pi_over_4 = (Mx_bits_extended == 1);
 } else {
   ap_ufixed<WO+1+g+3, 3> Wx = din * ap_ufixed<W+1+g,2>(4/
#394 "C:/Xilinx/Vivado/2018.3/include/hls_hotbm_apfixed.h" 3
                                                         3.14159265358979323846
#394 "C:/Xilinx/Vivado/2018.3/include/hls_hotbm_apfixed.h"
                                                             );
   k = Wx;
   x = Wx;
 }




 if(k[0] == 1) {
   x = 1-x;
 }
 Mx = x;

 bool cos_basis = do_cos?!swap_table[k]: swap_table[k];
 if(cos_basis) {


   Mx = ap_ufixed<value_list<double>::W_dout, 0, AP_RND, AP_SAT>(1);
   Ex = 0;
 }

 ap_ufixed<WO+1+g, 1> result = value_list<double>::sin_or_cos_approximation(do_cos,k,x,Mx,Ex);

 if(exactly_pi_over_4) {
   result = 0.7071067811865475244008443;
 }

 ap_uint<4> index = k;
 index[3] = is_negative;

 if(cos_basis ? neg_cos_table[index] : neg_sin_table[index]) {
   return -result;
 } else {
   return result;
 }
  };


  template<int W, int I>
  ap_fixed<W,2>
  sinf_or_cosf(ap_fixed<W,I> t_in, bool do_cos, bool do_pi,
      typename hls::enable_if<W <= 16, bool>::type dummy = true)
  {
 const int WO = W;
 const int g = 4;

 const bool neg_sin_table[8] = {0,0,1,1, 1,1,0,0};
 const bool neg_cos_table[8] = {0,1,1,0, 0,1,1,0};
#pragma HLS array_partition variable=neg_sin_table complete
#pragma HLS array_partition variable=neg_cos_table complete

 ap_uint<2> k;
 ap_ufixed<WO+1+g, 0> x;

 bool is_negative = t_in[t_in.wl()-1];
 ap_ufixed<W, I> din = is_negative ? ap_fixed<W, I>(-t_in) : t_in;

 if(do_pi) {
   k = din*2;
   x = din*2;
   ap_ufixed<W, 1> Mx_bits_extended = din*2;
 }
 else {
   ap_ufixed<WO+1+g+2, 2> Wx = din * ap_ufixed<W+1+g,2>(2/
#457 "C:/Xilinx/Vivado/2018.3/include/hls_hotbm_apfixed.h" 3
                                                         3.14159265358979323846
#457 "C:/Xilinx/Vivado/2018.3/include/hls_hotbm_apfixed.h"
                                                             );
   k = Wx;
   x = Wx;
 }

 bool is_special_case = false;

 if((k[0] == 1) ^ !do_cos) {
   ap_ufixed<WO+1+g+1, 1> Wx = 1-x;
   x = Wx;
   is_special_case = (Wx[Wx.wl()-1] == 1);
 }

 ap_ufixed<WO+1+g, 1> result = sin_cos_fixed_16::sin_or_cos_approximation(do_cos,k,x);

 if(is_special_case) {
   ap_uint<3> index = k;
   index[2] = do_cos;
   const bool special_case_table[8] = {0,1,0,1,1,0,1,0};
   result(result.wl()-2,0) = 0;
   result[result.wl()-1] = special_case_table[index];
 }

 {
   ap_uint<3> index = k;
   index[2] = is_negative;

   if(do_cos ? neg_cos_table[index] : neg_sin_table[index]) {
  return -result;
   } else {
  return result;
   }
 }
  };

};
#1024 "C:/Xilinx/Vivado/2018.3/include/hls_math.h" 2
#1 "C:/Xilinx/Vivado/2018.3/include/hls_cordic_apfixed.h" 1
#40 "C:/Xilinx/Vivado/2018.3/include/hls_cordic_apfixed.h"
#1 "C:/Xilinx/Vivado/2018.3/include/ap_int.h" 1
#41 "C:/Xilinx/Vivado/2018.3/include/hls_cordic_apfixed.h" 2




namespace cordic_apfixed {

  extern const ap_ufixed<128,2> circ_table_arctan_128[128];
  extern const int hyperb_table_tau_128[128];
  extern const ap_ufixed<128,4> hyperb_table_arctanh_128[128];





  template<int W, int I, int Wo>
  void circ_range_redux( ap_ufixed<W,I> x,
       ap_uint<2> &k,
       ap_ufixed<Wo,1> &r) {

 ap_ufixed<(Wo+I),0> inv_pi2("0x0.A2F9836E4E43FC715BBF");
 ap_ufixed<Wo+1,1> pi2("1.5707963267948966192313216916397514420985846996876");
 ap_ufixed<Wo+I,I> prod = x * inv_pi2;
 ap_uint<I> kint = prod;

    k = kint;
 r = x - kint * pi2;
  };






  template<int W, int I, int MODE>
  void cordic_circ_apfixed( ap_fixed<W,I> &x,
       ap_fixed<W,I> &y,
       ap_fixed<W,I> &z) {

 const int Nmax = W;

 ap_fixed<W,I> tx, ty, tz;
 ap_fixed<W,I> x_s, y_s, z_s;
 ap_uint<1> d;

 for (int n=0; n<Nmax; n++){
#pragma HLS pipeline

   if(MODE == 1) {
  d = ~y[W-1];
   }
   else {
  d = z[W-1];
   }

   x_s = x >> n;
   y_s = y >> n;
   z_s = circ_table_arctan_128[n];

   if(d){
  tx = x + y_s;
  ty = y - x_s;
  tz = z + z_s;
   }
   else{
  tx = x - y_s;
  ty = y + x_s;
  tz = z - z_s;
   }

   x = tx;
   y = ty;
   z = tz;
#124 "C:/Xilinx/Vivado/2018.3/include/hls_cordic_apfixed.h"
    }
  };







  template<int W, int I, int MODE, int INTYPE>
  void doublecordic_apfixed( ap_fixed<W,I> &x,
                             ap_fixed<W,I> &y,
                             ap_fixed<W,I> &z,
                             ap_fixed<W,I> &t) {

    const int Nmax = W - I + 1;

    for (int n=0; n<Nmax; n++){

      if(INTYPE==64){
#pragma HLS pipeline II=5
      }
      else if(INTYPE==32){
#pragma HLS pipeline II=3
      }
      else if(INTYPE==16){
#pragma HLS pipeline II=1
      }
      else{
#pragma HLS pipeline II=4
      }

      ap_uint<1> d;
      if(MODE == 0) {
        if(y<=t){
          d = x[W-1];
        }
        else{
          d = ~x[W-1];
        }
      }
      else {
        if(x>=t){
          d = y[W-1];
        }
        else{
          d = ~y[W-1];
        }
      }

      ap_fixed<W,I> x_s = x >> (n-1);
      ap_fixed<W,I> y_s = y >> (n-1);
      ap_fixed<W,I> x_s2 = x_s >> (n+1);
      ap_fixed<W,I> y_s2 = y_s >> (n+1);

   x = x - x_s2;
   y = y - y_s2;
      if(d){
        x = x + y_s;
        y = y - x_s;
      }
      else{
        x = x - y_s;
        y = y + x_s;
      }


   ap_fixed<W,I> t_s;
   int n2 = (n << 1);
      if(n2<W){
        t_s = (t >> n2);
  t = t + t_s;
      }


      ap_fixed<W,I> ca = circ_table_arctan_128[n];
      ap_fixed<W,I> z_s = (ca << 1);
   ap_fixed<W,I> tz;
      if(d){
        tz = z - z_s;
      }
      else{
        tz = z + z_s;
      }
      z = tz;
#219 "C:/Xilinx/Vivado/2018.3/include/hls_cordic_apfixed.h"
    }
  };



  template<int W, int I>
  void generic_sincos(ap_fixed<W,I> in,
       ap_fixed<W-I+2,2> & outsin, ap_fixed<W-I+2,2> & outcos){

 ap_uint<1> sign0 = (in > 0) ? 1: 0;


 ap_ufixed<W,I> inabs;
 if(sign0)
   inabs = in;
 else
   inabs = -in;


 const int Fr = (W - I) + I + 1;
 ap_uint<2> k;
 ap_ufixed<Fr,1> r;
 circ_range_redux(inabs, k, r);

 ap_fixed<W+2,3> x, y, z;

 const ap_fixed<W+2,3> K1("0x0.9B74EDA8435E47F277F7");
 x = K1;
 y = 0;

 if(k==1 or k==3){
   ap_ufixed<Fr,1> pi2("0x1.921FB54442D1846");

   z = pi2 - r;
 }
 else{
   z = r;
 }







 cordic_circ_apfixed<W+2,3,0>(x,y,z);







 if(k==0){
   outsin = y;
   outcos = x;
 }
 else if(k==1){
   outsin = y;
   outcos = -x;
 }
 else if(k==2){
   outsin = -y;
   outcos = -x;
 }
 else{
   outsin = -y;
   outcos = x;
 }

 if(sign0==0)
   outsin = -outsin;
  };


  template<int W, int I>
  ap_fixed<W,I> generic_tan(ap_fixed<W,I> x){

 const int Ix = I;
 const int Fx = (((W-I)>(I-1)) ? (W-I): (I-1)) + I;
 const int Wx = I + Fx;

 ap_fixed<Wx,Ix> xs = x;

 ap_fixed<Wx-Ix+2,2> outsin;
 ap_fixed<Wx-Ix+2,2> outcos;
 generic_sincos(xs, outsin, outcos);

 ap_fixed<W,I> out = outsin / outcos;


 if(I==1){
   if(out[W-1]==1){
  out[W-1] = 0;
  for(int i=0;i<W-1;i++){
#pragma HLS UNROLL
    out[i] = 1;
  }
   }
 }

 return out;
  };


  template<int W, int I>
  ap_ufixed<W,I> generic_tan(ap_ufixed<W,I> in) {
 ap_fixed<W+1,I+1> fin = in;
 ap_fixed<W+1,I+1> fout = generic_tan(fin);
 ap_ufixed<W,I> out = 0;
 if(fout[W]==0){
  out = fout;
 }
 return out;
  };


  template<int I>
  ap_int<I> generic_tan(ap_int<I> in) {
 ap_fixed<I,I> fin = in;
 ap_fixed<I,I> fout = generic_tan(fin);
 ap_int<I> out = fout;
 return out;
  };


  template<int I>
  ap_uint<I> generic_tan(ap_uint<I> in) {
 ap_fixed<I+1,I+1> fin = in;
 ap_fixed<I+1,I+1> fout = generic_tan(fin);
 ap_uint<I> out = 0;
 if(fout[I]==0){
  out = fout;
 }
 return out;
  };


  template<int W, int I>
  ap_fixed<W,2> generic_atan(ap_fixed<W,I> in){

 ap_uint<1> sign0 = (in > 0) ? 1: 0;


 ap_fixed<W+1,I+1> inabs;
 if(sign0)
   inabs = in;
 else
   inabs = -in;


 ap_uint<1> sign1 = (inabs > 1) ? 1: 0;

 ap_fixed<W+2,3> x, y, z;
 if(sign1){
   x = 1;

   y = 1.0 / inabs.to_double();
   z = 0;
 }
 else{
   x = 1;
   y = inabs;
   z = 0;
 }
 cordic_circ_apfixed<W+2,3,1>(x,y,z);

 ap_fixed<W,2> out;
 if(sign1){
   const ap_fixed<W,2> pi2("0x1.921FB54442D1846");
   out = pi2 - z;
 }
 else{
   out = z;
 }


 if(sign0){
   return out;
 }
 else{
   return -out;
 }
  };


  template<int W, int I>
  ap_ufixed<W,2> generic_atan(ap_ufixed<W,I> in){
 ap_fixed<W+1,I+1> fin = in;
 ap_fixed<W+1,2> fout = generic_atan(fin);
 ap_ufixed<W,2> out = 0;
 if(fout[W]==0){
  out = fout;
 }
 return out;
  };


  template<int I>
  ap_int<2> generic_atan(ap_int<I> in){
 if(in<-1)
   return ap_int<2>(-1);
 else if(in>1)
   return ap_int<2>(1);
 else
   return ap_int<2>(0);
  };


  template<int I>
  ap_uint<1> generic_atan(ap_uint<I> in){
 if(in>1)
   return ap_uint<1>(1);
 else
   return ap_uint<1>(0);
  };


  template<int W, int I>
  ap_fixed<W,3> generic_atan2(ap_fixed<W,I> in1,
         ap_fixed<W,I> in2){

 const ap_fixed<W+1,3> pi("0x3.243F6A8885A308D3");
 const ap_fixed<W+2,3> pi2("0x1.921FB54442D1846");
 const ap_fixed<W+1,3> pi4("0x0.C90FDAA22168C23");
 const ap_fixed<W+1,3> pi3_("-0x2.5B2F8FE6643A469");

 ap_uint<2> signin1 = (in1 > 0) ? 2: (in1==0) ? 1: 0;
 ap_uint<2> signin2 = (in2 > 0) ? 2: (in2==0) ? 1: 0;

 ap_fixed<W,3> out;



 if(signin1==1 and signin2==2){
   out = 0;
   return out;
 }
 else if(signin1==1 and signin2==0){
   out = pi;
   return out;
 }
 else if(signin1==2 and signin2==1){
   out = pi2;
   return out;
 }
 else if(signin1==0 and signin2==1){
   out = -pi2;
   return out;
 }
 else if(in1==in2){
   if(signin1==2){
  out = pi4;
  return out;
   }
   else if(signin1==1){
  out = 0;
  return out;
   }
   else{
  out = pi3_;
  return out;
   }
 }



 ap_fixed<W+1,I+1> in1abs;
 if(signin1==0)
   in1abs = -in1;
 else
   in1abs = in1;

 ap_fixed<W+1,I+1> in2abs;
 if(signin2==0)
   in2abs = -in2;
 else
   in2abs = in2;

 ap_fixed<W+1,2> in1abs_sft;
 ap_fixed<W+1,2> in2abs_sft;
 for(int i=0;i<W+1;i++){
#pragma HLS UNROLL
   in1abs_sft[i] = in1abs[i];
 }
 for(int i=0;i<W+1;i++){
#pragma HLS UNROLL
   in2abs_sft[i] = in2abs[i];
 }

 ap_fixed<W+7,3> x, y, z;
 if(in1abs > in2abs){
   x = in1abs_sft;
   y = in2abs_sft;
   z = 0;
 }
 else{
   x = in2abs_sft;
   y = in1abs_sft;
   z = 0;
 }
  cordic_circ_apfixed<W+7,3,1>(x,y,z);

 if(in1abs > in2abs){
   z = pi2 - z;
 }

 if(signin2==0 and signin1==2){
   out = pi - z;
 }
 else if(signin2==0 and signin1==0){
   out = z - pi;
 }
 else if(signin2==2 and signin1==0){
   out = -z;
 }
 else{
   out = z;
 }

 return out;
  };


  template<int W, int I>
  ap_ufixed<W,3> generic_atan2(ap_ufixed<W,I> in1,
          ap_ufixed<W,I> in2){
 ap_fixed<W+1,I+1> fin1 = in1;
 ap_fixed<W+1,I+1> fin2 = in2;
 ap_fixed<W+1,3> fout = generic_atan2(fin1, fin2);
 ap_ufixed<W,3> out = 0;
 if(fout[W]==0){
  out = fout;
 }
 return out;
  }


  template<int I>
  ap_int<3> generic_atan2(ap_int<I> in1,
          ap_int<I> in2){
   ap_fixed<I+1,I+1> fin1 = in1;
   ap_fixed<I+1,I+1> fin2 = in2;
   ap_fixed<I+1,3> fout = generic_atan2(fin1, fin2);
   ap_int<3> out = fout;
   return out;
  }


  template<int I>
  ap_uint<2> generic_atan2(ap_uint<I> in1,
           ap_uint<I> in2){
   ap_fixed<I+1,I+1> fin1 = in1;
   ap_fixed<I+1,I+1> fin2 = in2;
   ap_fixed<I+1,3> fout = generic_atan2(fin1, fin2);
   ap_uint<2> out = 0;
 if(fout[I]==0){
  out = fout;
 }
   return out;
  }





  template<int W, int I, int Wo>
  void hyperb_range_redux( ap_ufixed<W,I> x,
         ap_uint<I+1> &k,
         ap_ufixed<Wo,0> &r) {

 ap_ufixed<(Wo+I)+1,1> inv_ln2("0x1.71547652b82fe1777d0ffda0d23a7d11d6aef551cp0");
 ap_ufixed<Wo,0> ln2("0xb.17217f7d1cf79abc9e3b39803f2f6af40f343267p-4");
 ap_ufixed<Wo+(I+1),I+1> prod = x * inv_ln2;
 ap_ufixed<Wo,0> prod_dec = prod;

    k = prod;
 r = prod_dec * ln2;
  };






  template<int W, int I, int MODE>
  void cordic_hyperb_apfixed( ap_fixed<W,I> &x,
         ap_fixed<W,I> &y,
         ap_fixed<W,I> &z) {

 const int Nmax = W + 1;

 ap_fixed<W,I> tx, ty, tz;
 ap_fixed<W,I> x_s, y_s, z_s;
 ap_uint<1> d;

 for (int n=0; n<Nmax; n++){

   int k = hyperb_table_tau_128[n];

   if(MODE == 1) {
  d = ~y[W-1];
   }
   else {
  d = z[W-1];
   }

   x_s = x >> k;
   y_s = y >> k;
   z_s = hyperb_table_arctanh_128[k-1];

   if(d){
  tx = x - y_s;
  ty = y - x_s;
  tz = z + z_s;
   }
   else{
  tx = x + y_s;
  ty = y + x_s;
  tz = z - z_s;
   }

   x = tx;
   y = ty;
   z = tz;
#652 "C:/Xilinx/Vivado/2018.3/include/hls_cordic_apfixed.h"
    }
  }


  template <int W, int I>
  void sinh_cosh_range_redux_cordic( ap_fixed<W,I> in,
          ap_fixed<W,I> &s_out,
          ap_fixed<W,I> &c_out){

 ap_uint<1> sign0 = in[W-1];

 ap_ufixed<W,I> inabs;
 if(sign0 == 0)
   inabs = in;
 else
   inabs = -in;

 const int Fr = (W - I) + I;

 if(in==0){
   s_out = 0;
   c_out = 1;
   return;
 }


 ap_uint<I+1> k;
 ap_ufixed<Fr,0> r;
 hyperb_range_redux(inabs, k, r);

 ap_fixed<Fr+2,2> x("1.20749706776307212887772");
 ap_fixed<Fr+2,2> y(0);
 ap_fixed<Fr+2,2> z(r);




 cordic_hyperb_apfixed<Fr+2,2,0>(x,y,z);



 ap_fixed<Fr+(I+2),I+2> er, e_r;
 er = x + y;
 e_r = x - y;



 er <<= (k-1);
 e_r >>= (k+1);



 ap_fixed<W+1,I+1> s_out_tmp = er - e_r;
 ap_fixed<W+1,I+1> c_out_tmp = er + e_r;




 if(s_out_tmp[W-1]==1){
   s_out_tmp[W-1] = 0;
   for(int i=0;i<W-1;i++){
#pragma HLS UNROLL
  s_out_tmp[i] = 1;
   }
 }


 if(sign0 == 0){
   s_out = s_out_tmp;
 }
 else{
   s_out = -s_out_tmp;
 }




 if(c_out_tmp[W-1]==1){
   c_out[W-1] = 0;
   for(int i=0;i<W-1;i++){
#pragma HLS UNROLL
  c_out[i] = 1;
   }
 }
 else{
   c_out = c_out_tmp;
 }
  };

    template<int W, int I>
    void tanh_range_redux_cordic(ap_fixed<W,I> in, ap_fixed<W,I> &tan_out) {

        ap_uint<1> sign0 = in[W-1];

        ap_ufixed<W,I> inabs;
        if(sign0 == 0)
            inabs = in;
        else
            inabs = -in;

        const int Fr = (W - I) + I;

        if(in==0){
            tan_out = 0;
            return;
        }

        ap_uint<I+1> k;
        ap_ufixed<Fr,0> r;
        hyperb_range_redux(inabs, k, r);

        ap_fixed<Fr+2,2> x("1.20749706776307212887772");
        ap_fixed<Fr+2,2> y(0);
        ap_fixed<Fr+2,2> z(r);

        cordic_hyperb_apfixed<Fr+2,2,0>(x,y,z);
        ap_fixed<Fr+(I+2),I+2> er, e_r;
        er = x + y;
        e_r = x - y;
        er <<= k;
        e_r >>= k;
        tan_out = (er/(er+e_r))*2 - 1;
    }

    template<int W, int I>
    ap_fixed<W,I> generic_tanh(ap_fixed<W,I> in) {
        ap_fixed<W,I> tan_out;
        tanh_range_redux_cordic(in, tan_out);
        return tan_out;
    }

    template<int W, int I>
    ap_ufixed<W,I> generic_tanh(ap_ufixed<W,I> in) {
        ap_fixed<W+1,I+1> fin = in;
        ap_fixed<W+1,I+1> fout = generic_tanh(fin);
        ap_ufixed<W,I> tan_out = fout;
        return tan_out;
    }

    template<int I>
    ap_int<I> generic_tanh(ap_int<I> in) {
        ap_fixed<I,I> fin = in;
        ap_fixed<I,I> fout = generic_tanh(fin);
        ap_int<I> tan_out = fout;
        return tan_out;
    }

    template<int I>
    ap_uint<I> generic_tanh(ap_uint<I> in) {
        ap_fixed<I+1,I+1> fin = in;
        ap_fixed<I+1,I+1> fout = generic_tanh(fin);
        ap_uint<I> tan_out = fout;
        return tan_out;
    }

  template<int W, int I>
  ap_fixed<W,I> generic_sinh(ap_fixed<W,I> in) {
 ap_fixed<W,I> s_out, c_out;
 sinh_cosh_range_redux_cordic(in,s_out,c_out);
 return s_out;
  }


  template<int W, int I>
  ap_ufixed<W,I> generic_sinh(ap_ufixed<W,I> in) {
 ap_fixed<W+1,I+1> fin = in;
 ap_fixed<W+1,I+1> fout = generic_sinh(fin);
 ap_ufixed<W,I> out = 0;
 if(fout[W]==0){
  out = fout;
 }
 return out;
  };


  template<int I>
  ap_int<I> generic_sinh(ap_int<I> in) {
 ap_fixed<I,I> fin = in;
 ap_fixed<I,I> fout = generic_sinh(fin);
 ap_int<I> out = fout;
 return out;
  };


  template<int I>
  ap_uint<I> generic_sinh(ap_uint<I> in) {
 ap_fixed<I+1,I+1> fin = in;
 ap_fixed<I+1,I+1> fout = generic_sinh(fin);
 ap_uint<I> out = 0;
 if(fout[I]==0){
  out = fout;
 }
 return out;
  };


  template<int W, int I>
  ap_fixed<W, I> generic_cosh(ap_fixed<W,I> in) {
 ap_fixed<W,I> s_out, c_out;
 sinh_cosh_range_redux_cordic(in,s_out,c_out);
 return c_out;
  }


  template<int W, int I>
  ap_ufixed<W,I> generic_cosh(ap_ufixed<W,I> in) {
 ap_fixed<W+1,I+1> fin = in;
 ap_fixed<W+1,I+1> fout = generic_cosh(fin);
 ap_ufixed<W,I> out = 0;
 if(fout[W]==0){
  out = fout;
 }
 return out;
  };


  template<int I>
  ap_int<I> generic_cosh(ap_int<I> in) {
 ap_fixed<I,I> fin = in;
 ap_fixed<I,I> fout = generic_cosh(fin);
 ap_int<I> out = fout;
 return out;
  };


  template<int I>
  ap_uint<I> generic_cosh(ap_uint<I> in) {
 ap_fixed<I+1,I+1> fin = in;
 ap_fixed<I+1,I+1> fout = generic_cosh(fin);
 ap_uint<I> out = 0;
 if(fout[I]==0){
  out = fout;
 }
 return out;
  };



  template<int W, int I>
  ap_fixed<W-I+3,3> generic_asin(ap_fixed<W,I> in){

    const int I0 = 3;
    const int W0 = W - I + I0 + 6;

    const ap_fixed<W,I> cst1("0x1");
    const ap_fixed<W,I> cst0("0x0");
    const ap_fixed<W,I> cst_1("-0x1");



    if(I>=2){
      if((in>cst1) or (in<cst_1)){
        printf("Error: input value %f (for asin) is not between -1 and 1.\n", in.to_double());

#905 "C:/Xilinx/Vivado/2018.3/include/hls_cordic_apfixed.h" 3
       (void) ((!!(
#905 "C:/Xilinx/Vivado/2018.3/include/hls_cordic_apfixed.h"
       0
#905 "C:/Xilinx/Vivado/2018.3/include/hls_cordic_apfixed.h" 3
       )) || (_assert(
#905 "C:/Xilinx/Vivado/2018.3/include/hls_cordic_apfixed.h"
       "0"
#905 "C:/Xilinx/Vivado/2018.3/include/hls_cordic_apfixed.h" 3
       ,"C:/Xilinx/Vivado/2018.3/include/hls_cordic_apfixed.h",905),0))
#905 "C:/Xilinx/Vivado/2018.3/include/hls_cordic_apfixed.h"
                ;
      }
    }


    ap_fixed<W-I+3,3> out;


    if(in==cst1){
      out = ap_fixed<W-I+3,3>("0x1.921FB54442D1846");
      return out;
    }
    else if(in==cst_1){
      out = ap_fixed<W-I+3,3>("-0x1.921FB54442D1846");
      return out;
    }
    else if(in==cst0){
      out = ap_fixed<W-I+3,3>("0x0");
      return out;
    }


    ap_uint<1> sign0 = (in >= 0) ? 1: 0;


    ap_fixed<W,I> inabs;
    if(sign0)
      inabs = in;
    else
      inabs = -in;

    ap_fixed<W0,I0> x("0x1");
    ap_fixed<W0,I0> y("0x0");
    ap_fixed<W0,I0> z("0x0");
    ap_fixed<W0,I0> t = inabs;


    doublecordic_apfixed<W0,I0,0,0>(x,y,z,t);


    if(sign0)
      out = z;
    else
      out = -z;

    return out;
  }



  template<int W, int I>
  ap_fixed<W-I+3,3> generic_acos(ap_fixed<W,I> in){

    const int I0 = 3;
    const int W0 = W - I + I0;



    if(I>=2){
      const ap_fixed<W,I> cst1("0x1");
      const ap_fixed<W,I> cst_1("-0x1");

      if((in>cst1) or (in<cst_1)){
        printf("Error: input value %f (for acos) is not between -1 and 1.\n", in.to_double());

#969 "C:/Xilinx/Vivado/2018.3/include/hls_cordic_apfixed.h" 3
       (void) ((!!(
#969 "C:/Xilinx/Vivado/2018.3/include/hls_cordic_apfixed.h"
       0
#969 "C:/Xilinx/Vivado/2018.3/include/hls_cordic_apfixed.h" 3
       )) || (_assert(
#969 "C:/Xilinx/Vivado/2018.3/include/hls_cordic_apfixed.h"
       "0"
#969 "C:/Xilinx/Vivado/2018.3/include/hls_cordic_apfixed.h" 3
       ,"C:/Xilinx/Vivado/2018.3/include/hls_cordic_apfixed.h",969),0))
#969 "C:/Xilinx/Vivado/2018.3/include/hls_cordic_apfixed.h"
                ;
      }
    }



    const ap_fixed<W0,I0> pi2("0x1.921FB54442D1846");
    ap_fixed<W0,I0> out = generic_asin(in);

    return pi2 - out;
#991 "C:/Xilinx/Vivado/2018.3/include/hls_cordic_apfixed.h"
  }

  template<int W, int I>
  void cordic_semi_recovery_asinh(ap_fixed<W,I> in_top, ap_fixed<W,I>& out) {

    if(in_top == 0) {
      out = 0;
      return;
    }

    ap_fixed<W,I> in;
    if(in_top >= 0) {
      in = in_top;
    }
    else {
      in = -in_top;
    }

    int m = in.countLeadingZeros();
    int k = I-m;

    if(W-I-2 >= k) {

      ap_fixed<W,I> boundk = 1.0;
      ap_fixed<W,I> bound_k_2 = 1.0;
      boundk <<= k;
      bound_k_2 >>= k;
      bound_k_2 >>= 2;

      if(in >= (boundk - bound_k_2)) {
        k+=1;
      }

    }

    if(k < 0) {
      k = 0;
    }

    const int Nmax = W - I + 1;
    int tau;
    ap_fixed<W,I> x_r(1);
    ap_fixed<W,I> y_r(0);
    ap_fixed<W,I> z_r(0);
    ap_fixed<W,I> x1_tau, x_2tau, y1_tau, y_2tau, z_s;
    ap_fixed<W,I> xk, x_k, yk, y_k;
    ap_fixed<W,I> y_semi_recovery;
    ap_fixed<W,I> in_s;

    for(int i=0; i<Nmax; i++) {

      xk = x_r << k;
      x_k = x_r >> k;
      yk = y_r << k;
      y_k = y_r >> k;

      y_semi_recovery = (xk - x_k + yk + y_k) >> 1;

      tau = hyperb_table_tau_128[i+1];
      z_s = hyperb_table_arctanh_128[tau-1] << 1;

      x1_tau = ((x_r >> tau) << 1);
      x_2tau = (x_r >> (tau << 1));
      y1_tau = ((y_r >> tau) << 1);
      y_2tau = (y_r >> (tau << 1));

      if(y_semi_recovery <= in) {
        x_r += x_2tau + y1_tau;
        y_r += y_2tau + x1_tau;
        z_r += z_s;
      }
      else {
        x_r += x_2tau - y1_tau;
        y_r += y_2tau - x1_tau;
        z_r -= z_s;
      }

      in_s = in >> (tau << 1);
      in -= in_s;
    }

    ap_ufixed<W,0> ln2("0xb.17217f7d1cf79abc9e3b39803f2f6af40f343267p-4");
    if(in_top >= 0) {
      out = z_r + k*ln2;
    }
    else {
      out = -z_r - k*ln2;
    }
  }

  template<int W, int I>
  void cordic_semi_recovery_acosh(ap_fixed<W,I> in, ap_fixed<W,I>& out) {


    if(in < 1) {
      std::cout<<"Input should be equal or greater than 1.0."<<std::endl;
    }

    if(in == 1) {
      out = 0;
      return;
    }

    int m = in.countLeadingZeros();
    int k = I-m;


    ap_fixed<W,I> boundk = 1.0;
    ap_fixed<W,I> bound_k_1 = 1.0;
    boundk <<= k;
    boundk >>= 1;
    bound_k_1 >>= k;
    bound_k_1 >>= 1;

      if(in < (boundk - bound_k_1)) {
        k-=1;
      }

    if(k < 0) {
      k = 0;
    }

    const int Nmax = W - I + 1;
    int tau;
    ap_fixed<W,I> x_r(1);
    ap_fixed<W,I> y_r(0);
    ap_fixed<W,I> z_r(0);
    ap_fixed<W,I> x1_tau, x_2tau, y1_tau, y_2tau, z_s;
    ap_fixed<W,I> xk, x_k, yk, y_k;
    ap_fixed<W,I> x_semi_recovery;
    ap_fixed<W,I> in_s;

    for(int i=0; i<Nmax; i++) {

      xk = x_r << k;
      x_k = x_r >> k;
      yk = y_r << k;
      y_k = y_r >> k;

      x_semi_recovery = (xk + x_k + yk - y_k) >> 1;

      tau = hyperb_table_tau_128[i+1];
      z_s = hyperb_table_arctanh_128[tau-1] << 1;

      x1_tau = ((x_r >> tau) << 1);
      x_2tau = (x_r >> (tau << 1));
      y1_tau = ((y_r >> tau) << 1);
      y_2tau = (y_r >> (tau << 1));

      if(x_semi_recovery <= in) {
        x_r += x_2tau + y1_tau;
        y_r += y_2tau + x1_tau;
        z_r += z_s;
      }
      else {
        x_r += x_2tau - y1_tau;
        y_r += y_2tau - x1_tau;
        z_r -= z_s;
      }

      in_s = in >> (tau << 1);
      in -= in_s;
    }

    ap_ufixed<W,0> ln2("0xb.17217f7d1cf79abc9e3b39803f2f6af40f343267p-4");
    out = z_r + k*ln2;
  }


  template<int W, int I>
  ap_fixed<W,I> generic_asinh(ap_fixed<W,I> in) {
    ap_fixed<W+1,I+1> input, output; input = in;
    cordic_semi_recovery_asinh(input, output);
    return output;
  }


  template<int W, int I>
  ap_ufixed<W,I> generic_asinh(ap_ufixed<W,I> in) {
    ap_fixed<W+1,I+1> input, output;
    input = in;
    cordic_semi_recovery_asinh(input, output);
    return output;
  };


  template<int I>
  ap_int<I> generic_asinh(ap_int<I> in) {
    ap_fixed<I+1,I+1> input, output;
    input = in;
    cordic_semi_recovery_asinh(input, output);
    return output;
  };


  template<int I>
  ap_uint<I> generic_asinh(ap_uint<I> in) {
    ap_fixed<I+1,I+1> input, output;
    input = in;
    cordic_semi_recovery_asinh(input, output);
    return output;
  };


  template<int W, int I>
  ap_fixed<W,I> generic_acosh(ap_fixed<W,I> in) {
    ap_fixed<W+1,I+1> input, output;
    input = in;
    cordic_semi_recovery_acosh(input, output);
    return output;
  }


  template<int W, int I>
  ap_ufixed<W,I> generic_acosh(ap_ufixed<W,I> in) {
    ap_fixed<W+1,I+1> input, output;
    input = in;
    cordic_semi_recovery_acosh(input, output);
    return output;
  };


  template<int I>
  ap_int<I> generic_acosh(ap_int<I> in) {
    ap_fixed<I,I> input, output;
    input = in;
    cordic_semi_recovery_acosh(input, output);
    return output;
  };


  template<int I>
  ap_uint<I> generic_acosh(ap_uint<I> in) {
    ap_fixed<I+1,I+1> input, output;
    input = in;
    cordic_semi_recovery_acosh(input, output);
    return output;
  };

}
#1025 "C:/Xilinx/Vivado/2018.3/include/hls_math.h" 2
#1 "C:/Xilinx/Vivado/2018.3/include/hls_exp_apfixed.h" 1
#35 "C:/Xilinx/Vivado/2018.3/include/hls_exp_apfixed.h"
namespace exp_reduce {

template<int W_, int I_>
ap_fixed<W_,I_> exp(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline

    int F_ = W_ - I_;
    if (I_>33) return 0;
    else if (F_>32) return 0;




    int I_s_;
    int M_ = (I_-1>F_) ? (I_-1) : F_;
    if (M_==1) I_s_ = 1;
    else if (M_==2) I_s_ = 2;
    else if (M_<6) I_s_ = 3;
    else if (M_<12) I_s_ = 4;
    else if (M_<24) I_s_ = 5;
    else I_s_ = 6;

    ap_fixed<W_,I_> r;
    if (I_s_==1) {
        ap_fixed<3,2> x_l = x;
        ap_ufixed<2,1> y = 0;
        if (x_l[2]!=x_l[1]) {
            if (!x_l[2]) y = "0x1.8p0";
        } else {
            if (!x_l[2]) y[1] = 1;
            if (x_l[2]|x_l[0]) y[0] = 1;
        }
        if (I_<2) {
            if (y[1]) {
                y[1] = 0;
                y[0] = 1;
            }
        }
        r = y;
    } else if (I_s_==2) {
        ap_fixed<5,3> x_l = x;
        ap_ufixed<4,2> y = 0;
        ap_fixed<2,2> x_l_int;
        x_l_int(1,0) = x_l(3,2);
        ap_ufixed<2,0> x_l_fract;
        x_l_fract(1,0) = x_l(1,0);

        if ((x_l[4]!=x_l[3])||((x_l_int==1)&&(x_l_fract>=ap_ufixed<2,0>("0x0.8p0")))) {
            if (!x_l[4]) y = "0x3.cp0";
        } else {
            if (!x_l[4]&((x_l[1]&x_l[0])|x_l[2])) y[3] = 1;
            if (!x_l[4]&((!x_l[2]&!x_l[0])|(!x_l[1]&x_l[0]))) y[2] = 1;
            if ((!x_l[4]&x_l[1]&!x_l[0])|(!x_l[4]&x_l[2])|(x_l[2]&x_l[0])|(x_l[2]&x_l[1])) y[1] = 1;
            if ((!x_l[2]&!x_l[1]&x_l[0])|(!x_l[2]&x_l[1]&!x_l[0])|(x_l[2]&!x_l[1]&!x_l[0])|(x_l[2]&x_l[1]&x_l[0])|(x_l[4]&!x_l[3])) y[0] = 1;
        }
        if (I_<3) {
            bool overf = 0;
#pragma unroll
            for (int j = 3; j >= I_+1; j--) {
                if (y[j])
                    overf = 1;
            }
            if (overf) {
#pragma unroll
                for (int j = 3; j >= I_+1; j--)
                    y[j] = 0;
#pragma unroll
                for (int j = I_; j >= 0; j--)
                    y[j] = 1;
            }
        }
        r = y;
    } else if (I_s_==3) {
        ap_fixed<11,6> x_l = x;
        ap_ufixed<10,5> y = 0;
        ap_fixed<3,3> x_l_int;
        x_l_int(2,0) = x_l(7,5);
        ap_ufixed<5,0> x_l_fract;
        x_l_fract(4,0) = x_l(4,0);

        if ((x_l[10]!=x_l[9])||(x_l[10]!=x_l[8])||(x_l[10]!=x_l[7])||((x_l_int==3)&&(x_l_fract>ap_fixed<5,0>("0x0.7p0")))) {
            if (!x_l[10]) y = "0x1f.f8p0";
        } else {





            ap_uint<4> x_msb_ind;
            x_msb_ind[3] = x_l[10];
            x_msb_ind(2,0) = x_l(6,4);
            ap_uint<4> x_lsb_ind;
            x_lsb_ind(3,0) = x_l(3,0);
            ap_ufixed<4,-1> x_lsb = x_l;
#150 "C:/Xilinx/Vivado/2018.3/include/hls_exp_apfixed.h"
            const static ap_ufixed<12,0> exp_x_lsb_m_1_table[16] = {
                "0x0.0p0", "0x0.082p0", "0x0.108p0", "0x0.193p0", "0x0.221p0", "0x0.2b5p0", "0x0.34dp0", "0x0.3eap0",
                "0x0.48bp0", "0x0.532p0", "0x0.5dfp0", "0x0.69p0", "0x0.748p0", "0x0.805p0", "0x0.8c8p0", "0x0.991p0",
            };
            ap_ufixed<12, 0> exp_x_lsb_m_1 = exp_x_lsb_m_1_table[x_lsb_ind];

            const static ap_ufixed<12,5> exp_x_msb_table[16] = {
                "0x1.0p0", "0x1.a6p0", "0x2.b8p0", "0x4.7cp0", "0x7.64p0", "0xc.2ep0", "0x14.16p0", "0x21.1ep0",
                "0x0.04p0", "0x0.08p0", "0x0.0cp0", "0x0.16p0", "0x0.22p0", "0x0.3ap0", "0x0.5ep0", "0x0.9cp0",
            };
            ap_ufixed<12,5> exp_x_msb = exp_x_msb_table[x_msb_ind];
            ap_ufixed<24,5> y_lo = exp_x_msb * exp_x_lsb_m_1;
            ap_ufixed<12,5> y_lo_s = y_lo;
            ap_ufixed<12,5> y_l = y_lo_s + exp_x_msb;
            y = y_l;
        }
        if (I_<6) {
            bool overf = 0;
#pragma unroll
            for (int j = 9; j >= I_+4; j--) {
                if (y[j])
                    overf = 1;
            }
            if (overf) {
#pragma unroll
                for (int j = 9; j >= I_+4; j--)
                    y[j] = 0;
#pragma unroll
                for (int j = I_+3; j >= 0; j--)
                    y[j] = 1;
            }
        }
        r = y;
    } else if (I_s_==4) {
        ap_fixed<23,12> x_l = x;
        ap_ufixed<22,11> y = 0;
        ap_fixed<4,4> x_l_int;
        x_l_int(3,0) = x_l(14,11);
        ap_ufixed<11,0> x_l_fract;
        x_l_fract(10,0) = x_l(10,0);
        bool overf = 0;
#pragma unroll
        for (int j = 14; j < 22; j++)
            if (x_l[22]!=x_l[j])
                overf = 1;

        if (overf||((x_l_int==7)&&(x_l_fract>ap_ufixed<11,0>("0x0.ap0")))) {
            if (!x_l[22]) {
#pragma unroll
                for (int j = 0; j < 22; j++) y[j] = 1;
            }
        } else {
            ap_uint<5> x_msb_ind_1;
            x_msb_ind_1[4] = x_l[22];
            x_msb_ind_1(3,0) = x_l(13,10);
            ap_uint<5> x_msb_ind_2;
            x_msb_ind_2(4,0) = x_l(9,5);
            ap_ufixed<5,-1> x_msb_2 = x_l;
            ap_uint<5> x_lsb_ind;
            x_lsb_ind(4,0) = x_l(4,0);


            const static ap_ufixed<11,-13> f_x_lsb_table[32] = {
                "0x0.0p0", "0x0.000002p0", "0x0.000008p0", "0x0.000012p0",
                "0x0.00002p0", "0x0.000032p0", "0x0.000048p0", "0x0.000062p0",
                "0x0.00008p0", "0x0.0000a2p0", "0x0.0000c9p0", "0x0.0000f3p0",
                "0x0.000121p0", "0x0.000153p0", "0x0.000189p0", "0x0.0001c3p0",
                "0x0.000202p0", "0x0.000244p0", "0x0.00028ap0", "0x0.0002d4p0",
                "0x0.000323p0", "0x0.000375p0", "0x0.0003ccp0", "0x0.000426p0",
                "0x0.000485p0", "0x0.0004e7p0", "0x0.00054ep0", "0x0.0005b9p0",
                "0x0.000627p0", "0x0.00069ap0", "0x0.000711p0", "0x0.00078cp0",
            };
            ap_ufixed<11,-13> f_x_lsb = f_x_lsb_table[x_lsb_ind];
            ap_ufixed<18, -6> exp_x_lsb_m_1 = 0;
            exp_x_lsb_m_1(17,13) = x_lsb_ind(4,0);
            exp_x_lsb_m_1(10,0) = f_x_lsb(10,0);

            const static ap_ufixed<25,0> exp_x_msb_2_m_1_table[32] = {
                "0x0.0000000p0", "0x0.04080a8p0", "0x0.0820560p0", "0x0.0c49238p0",
                "0x0.1082b58p0", "0x0.14cd500p0", "0x0.1929370p0", "0x0.1d96b10p0",
                "0x0.2216048p0", "0x0.26a7790p0", "0x0.2b4b588p0", "0x0.3001ed0p0",
                "0x0.34cb818p0", "0x0.39a8628p0", "0x0.3e98de8p0", "0x0.439d440p0",
                "0x0.48b5e40p0", "0x0.4de30f0p0", "0x0.5325180p0", "0x0.587c540p0",
                "0x0.5de9178p0", "0x0.636bb98p0", "0x0.6904930p0", "0x0.6eb3fc8p0",
                "0x0.747a510p0", "0x0.7a57ee0p0", "0x0.804d300p0", "0x0.865a778p0",
                "0x0.8c80248p0", "0x0.92be998p0", "0x0.99163b0p0", "0x0.9f876e8p0",
            };
            ap_ufixed<25, 0> exp_x_msb_2_m_1 = exp_x_msb_2_m_1_table[x_msb_ind_2];

            ap_ufixed<43,-6> f_x_msb_2_lsb = exp_x_msb_2_m_1 * exp_x_lsb_m_1;
            ap_ufixed<19,-6> f_x_msb_2_lsb_s = f_x_msb_2_lsb;
            ap_ufixed<25, 0> exp_x_msb_2_lsb_m_1 = f_x_msb_2_lsb_s + exp_x_lsb_m_1 + exp_x_msb_2_m_1;

            const static ap_ufixed<25,11> exp_x_msb_1_table[32] = {
                "0x1.0000p0", "0x1.a614p0", "0x2.b7e0p0", "0x4.7b50p0",
                "0x7.6398p0", "0xc.2eb8p0", "0x14.15e4p0", "0x21.1d90p0",
                "0x36.9920p0", "0x5a.0464p0", "0x94.69c4p0", "0xf4.b124p0",
                "0x193.6dc4p0", "0x299.2444p0", "0x448.a218p0", "0x710.0adcp0",
                "0x0.0014p0", "0x0.0024p0", "0x0.003cp0", "0x0.0064p0",
                "0x0.00a4p0", "0x0.010cp0", "0x0.01b8p0", "0x0.02d8p0",
                "0x0.04b0p0", "0x0.07bcp0", "0x0.0cc0p0", "0x0.1504p0",
                "0x0.22a4p0", "0x0.3920p0", "0x0.5e2cp0", "0x0.9b44p0",
            };
            ap_ufixed<25,11> exp_x_msb_1 = exp_x_msb_1_table[x_msb_ind_1];
            ap_ufixed<50,11> y_lo = exp_x_msb_1 * exp_x_msb_2_lsb_m_1;
            ap_ufixed<25,11> y_lo_s = y_lo;
            ap_ufixed<25,11> y_l = y_lo_s + exp_x_msb_1;
            y = y_l;
        }
        if (I_<12) {
            bool overf = 0;
#pragma unroll
            for (int j = 21; j >= I_+10; j--) {
                if (y[j])
                    overf = 1;
            }
            if (overf) {
#pragma unroll
                for (int j = 21; j >= I_+10; j--)
                    y[j] = 0;
#pragma unroll
                for (int j = I_+9; j >= 0; j--)
                    y[j] = 1;
            }
        }
        r = y;
    } else if (I_s_==5) {
        ap_fixed<47,24> x_l = x;
        ap_ufixed<46,23> y = 0;
        ap_fixed<5,5> x_l_int;
        x_l_int(4,0) = x_l(27,23);
        ap_ufixed<23,0> x_l_fract;
        x_l_fract(22,0) = x_l(22,0);
        bool overf = 0;
#pragma unroll
        for (int j = 27; j < 46; j++)
            if (x_l[46]!=x_l[j])
                overf = 1;

        if (overf||((x_l_int==15)&&(x_l_fract>=ap_ufixed<23,0>("0x0.f14028p0")))) {
            if (!x_l[46]) {
#pragma unroll
                for (int j = 0; j < 46; j++) y[j] = 1;
            }
        } else {
            ap_uint<8> x_msb_ind_1;
            x_msb_ind_1[7] = x_l[46];
            x_msb_ind_1(6,0) = x_l(26,20);
            ap_uint<8> x_msb_ind_2;
            x_msb_ind_2(7,0) = x_l(19,12);
            ap_uint<5> x_msb_ind_3;
            x_msb_ind_3(4,0) = x_l(11,7);
            ap_uint<3> x_msb_ind_4;
            x_msb_ind_4(2,0) = x_l(6,4);
            ap_uint<4> x_lsb_ind;
            x_lsb_ind(3,0) = x_l(3,0);

            ap_ufixed<8, -3> x_msb_2 = x_l;
            ap_ufixed<5,-11> x_msb_3 = x_l;
            ap_ufixed<3,-16> x_msb_4 = x_l;
            ap_ufixed<4,-19> x_lsb = x_l;

            const static ap_ufixed< 6,-33> f_x_msb_4_h_table[8] = {
"0x0.0000000000p0", "0x0.0000000002p0", "0x0.0000000008p0", "0x0.0000000012p0",
"0x0.0000000020p0", "0x0.0000000032p0", "0x0.0000000048p0", "0x0.0000000062p0",
            };
            const static ap_ufixed< 7,-51> f_x_msb_4_l_table[8] = {
"0x0.000000000000000p0", "0x0.000000000000000p0", "0x0.00000000000000cp0", "0x0.000000000000024p0",
"0x0.000000000000054p0", "0x0.0000000000000a8p0", "0x0.000000000000120p0", "0x0.0000000000001c8p0",
            };
            ap_ufixed< 6,-33> f_x_msb_4_h = f_x_msb_4_h_table[x_msb_ind_4];
            ap_ufixed< 7,-51> f_x_msb_4_l = f_x_msb_4_l_table[x_msb_ind_4];

            const static ap_ufixed< 8,-39> f_x_lsb_table[16] = {
"0x0.000000000000p0", "0x0.000000000002p0", "0x0.000000000008p0", "0x0.000000000012p0",
"0x0.000000000020p0", "0x0.000000000032p0", "0x0.000000000048p0", "0x0.000000000062p0",
"0x0.000000000080p0", "0x0.0000000000a2p0", "0x0.0000000000c8p0", "0x0.0000000000f2p0",
"0x0.000000000120p0", "0x0.000000000152p0", "0x0.000000000188p0", "0x0.0000000001c2p0",
            };
            ap_ufixed< 8,-39> f_x_lsb = f_x_lsb_table[x_lsb_ind];

            ap_ufixed< 7,-35> f_x_msb_4_lsb = x_msb_4 * x_lsb;

            ap_ufixed<10,-32> exp_x_msb_4_lsb_m_1_m = 0;
            exp_x_msb_4_lsb_m_1_m(8,3) = f_x_msb_4_h(5,0);
            exp_x_msb_4_lsb_m_1_m(2,0) = f_x_lsb(7,5);
            exp_x_msb_4_lsb_m_1_m = exp_x_msb_4_lsb_m_1_m + f_x_msb_4_lsb;

            ap_ufixed<42,-16> exp_x_msb_4_lsb_m_1 = 0;
            exp_x_msb_4_lsb_m_1(41,35) = x_l(6,0);
            exp_x_msb_4_lsb_m_1(25,16) = exp_x_msb_4_lsb_m_1_m(9,0);
            exp_x_msb_4_lsb_m_1(15,11) = f_x_lsb(4,0);
            exp_x_msb_4_lsb_m_1( 6, 0) = f_x_msb_4_l(6,0);


            const static ap_ufixed<32,-23> f_x_msb_3_table[32] = {
"0x0.00000000000000p0", "0x0.0000000080002ap0", "0x0.00000002000156p0", "0x0.00000004800480p0",
"0x0.00000008000aaap0", "0x0.0000000c8014d6p0", "0x0.00000012002400p0", "0x0.0000001880392cp0",
"0x0.00000020005556p0", "0x0.00000028807982p0", "0x0.0000003200a6acp0", "0x0.0000003c80ddd8p0",
"0x0.00000048012004p0", "0x0.00000054816e30p0", "0x0.0000006201c95cp0", "0x0.00000070823288p0",
"0x0.0000008002aab6p0", "0x0.000000908332e2p0", "0x0.000000a203cc12p0", "0x0.000000b4847740p0",
"0x0.000000c8053570p0", "0x0.000000dc8607a0p0", "0x0.000000f206eed0p0", "0x0.0000010887ec02p0",
"0x0.00000120090036p0", "0x0.000001388a2c6ap0", "0x0.000001520b71a0p0", "0x0.0000016c8cd0d6p0",
"0x0.000001880e4b0ep0", "0x0.000001a48fe148p0", "0x0.000001c2119484p0", "0x0.000001e09365c0p0",
            };

            ap_ufixed<32,-23> f_x_msb_3 = f_x_msb_3_table[x_msb_ind_3];
            ap_ufixed<44,-11> exp_x_msb_3_m_1 = 0;
            exp_x_msb_3_m_1(43,39) = x_msb_3(4,0);
            exp_x_msb_3_m_1(31, 0) = f_x_msb_3(31,0);

            ap_ufixed<86,-27> f_x_msb_3_4_lsb = exp_x_msb_3_m_1 * exp_x_msb_4_lsb_m_1;
            ap_ufixed<31,-27> f_x_msb_3_4_lsb_s = f_x_msb_3_4_lsb;
            ap_ufixed<48,-10> exp_x_msb_3_4_lsb_m_1 = f_x_msb_3_4_lsb_s + exp_x_msb_3_m_1 + exp_x_msb_4_lsb_m_1;


            const static ap_ufixed<46,-6> f_x_msb_2_table[256] = {
"0x0", "0x0.0000020015560p0", "0x0.00000800AAB55p0", "0x0.0000120240360p0",
"0x0.0000200556001p0", "0x0.0000320A6C4B8p0", "0x0.0000481203608p0", "0x0.0000621C9B971p0",
"0x0.0000802AB5577p0", "0x0.0000A23CD119Dp0", "0x0.0000C8536F668p0", "0x0.0000F26F10D5Dp0",
"0x0.0001209036103p0", "0x0.000152B75FCE3p0", "0x0.000188E50ED86p0", "0x0.0001C319C4077p0",
"0x0.0002015600445p0", "0x0.0002439A4487Ep0", "0x0.000289E711DB3p0", "0x0.0002D43CE9577p0",
"0x0.0003229C4C260p0", "0x0.00037505BB805p0", "0x0.0003CB79B8B01p0", "0x0.000425F8C50F2p0",
"0x0.0004848362076p0", "0x0.0004E71A11131p0", "0x0.00054DBD53BC8p0", "0x0.0005B86DAB9E3p0",
"0x0.0006272B9A630p0", "0x0.000699F7A1C5Dp0", "0x0.000710D24391Ep0", "0x0.00078BBC01A29p0",
"0x0.00080AB55DE39p0", "0x0.00088DBEDA50Bp0", "0x0.000914D8F8F63p0", "0x0.0009A0043BF07p0",
"0x0.000A2F41256C2p0", "0x0.000AC29037A63p0", "0x0.000B59F1F4EBDp0", "0x0.000BF566DF9AAp0",
"0x0.000C94EF7A206p0", "0x0.000D388C46FB4p0", "0x0.000DE03DC8B9Bp0", "0x0.000E8C0481FA7p0",
"0x0.000F3BE0F56CAp0", "0x0.000FEFD3A5CFAp0", "0x0.0010A7DD15F36p0", "0x0.001163FDC8B7Fp0",
"0x0.00122436410DDp0", "0x0.0012E88701F5Ep0", "0x0.0013B0F08E817p0", "0x0.00147D7369D22p0",
"0x0.00154E101719Fp0", "0x0.001622C7199B7p0", "0x0.0016FB98F4A96p0", "0x0.0017D8862BA72p0",
"0x0.0018B98F42084p0", "0x0.00199EB4BB511p0", "0x0.001A87F71B161p0", "0x0.001B7556E4FC4p0",
"0x0.001C66D49CB93p0", "0x0.001D5C70C612Dp0", "0x0.001E562BE4DFAp0", "0x0.001F54067D067p0",
"0x0.00205601127ECp0", "0x0.00215C1C29507p0", "0x0.0022665845940p0", "0x0.002374B5EB724p0",
"0x0.002487359F24Cp0", "0x0.00259DD7E4F57p0", "0x0.0026B89D413EFp0", "0x0.0027D786386C4p0",
"0x0.0028FA934EF90p0", "0x0.002A21C509717p0", "0x0.002B4D1BEC726p0", "0x0.002C7C987CA92p0",
"0x0.002DB03B3ED3Ap0", "0x0.002EE804B7C07p0", "0x0.003023F56C4ECp0", "0x0.0031640DE16E3p0",
"0x0.0032A84E9C1F5p0", "0x0.0033F0B821730p0", "0x0.00353D4AF68B0p0", "0x0.00368E07A0999p0",
"0x0.0037E2EEA4E19p0", "0x0.00393C0088B6Cp0", "0x0.003A993DD17D5p0", "0x0.003BFAA704AA3p0",
"0x0.003D603CA7C32p0", "0x0.003EC9FF405E6p0", "0x0.004037EF54230p0", "0x0.0041AA0D68C8Cp0",
"0x0.0043205A04182p0", "0x0.00449AD5ABEA5p0", "0x0.00461980E6294p0", "0x0.00479C5C38CF9p0",
"0x0.0049236829E8Bp0", "0x0.004AAEA53F90Ep0", "0x0.004C3E13FFF51p0", "0x0.004DD1B4F152Fp0",
"0x0.004F698899F90p0", "0x0.0051058F8046Ap0", "0x0.0052A5CA2AABFp0", "0x0.00544A391FA9Cp0",
"0x0.0055F2DCE5D1Ep0", "0x0.00579FB603C6Ep0", "0x0.005950C5003C2p0", "0x0.005B060A61F5Dp0",
"0x0.005CBF86AFC91p0", "0x0.005E7D3A709BEp0", "0x0.00603F262B650p0", "0x0.0062054A672C2p0",
"0x0.0063CFA7AB09Dp0", "0x0.00659E3E7E278p0", "0x0.0067710F67BFAp0", "0x0.0069481AEF1D5p0",
"0x0.006B23619B9CFp0", "0x0.006D02E3F4AB7p0", "0x0.006EE6A281C6Fp0", "0x0.0070CE9DCA7E6p0",
"0x0.0072BAD65671Bp0", "0x0.0074AB4CAD51Cp0", "0x0.0076A00156E07p0", "0x0.007898F4DAF09p0",
"0x0.007A9627C165Fp0", "0x0.007C979A92356p0", "0x0.007E9D4DD564Ap0", "0x0.0080A742130A8p0",
"0x0.0082B577D34EDp0", "0x0.0084C7EF9E6A7p0", "0x0.0086DEA9FCA73p0", "0x0.0088F9A776601p0",
"0x0.008B18E894010p0", "0x0.008D3C6DDE06Fp0", "0x0.008F6437DD000p0", "0x0.00919047198B6p0",
"0x0.0093C09C1C595p0", "0x0.0095F5376E2B2p0", "0x0.00982E1997D33p0", "0x0.009A6B4322352p0",
"0x0.009CACB496458p0", "0x0.009EF26E7D0A2p0", "0x0.00A13C715F99Ep0", "0x0.00A38ABDC71CEp0",
"0x0.00A5DD543CCC4p0", "0x0.00A8343549F26p0", "0x0.00AA8F6177EADp0", "0x0.00ACEED950222p0",
"0x0.00AF529D5C165p0", "0x0.00B1BAAE25566p0", "0x0.00B4270C3582Ap0", "0x0.00B697B8164C7p0",
"0x0.00B90CB25176Ap0", "0x0.00BB85FB70D50p0", "0x0.00BE0393FE4CCp0", "0x0.00C0857C83D44p0",
"0x0.00C30BB58B732p0", "0x0.00C5963F9F424p0", "0x0.00C8251B496BEp0", "0x0.00CAB849142B5p0",
"0x0.00CD4FC989CD6p0", "0x0.00CFEB9D34B00p0", "0x0.00D28BC49F428p0", "0x0.00D5304054059p0",
"0x0.00D7D910DD8B1p0", "0x0.00DA8636C6764p0", "0x0.00DD37B2997BCp0", "0x0.00DFED84E1618p0",
"0x0.00E2A7AE28FECp0", "0x0.00E5662EFB3C3p0", "0x0.00E82907E313Dp0", "0x0.00EAF0396B910p0",
"0x0.00EDBBC41FD08p0", "0x0.00F08BA88B009p0", "0x0.00F35FE73860Bp0", "0x0.00F63880B341Ep0",
"0x0.00F9157587069p0", "0x0.00FBF6C63F228p0", "0x0.00FEDC73671B0p0", "0x0.0101C67D8A86Cp0",
"0x0.0104B4E5350DFp0", "0x0.0107A7AAF26A2p0", "0x0.010A9ECF4E667p0", "0x0.010D9A52D4DF8p0",
"0x0.01109A3611C34p0", "0x0.01139E7991116p0", "0x0.0116A71DDEDADp0", "0x0.0119B42387423p0",
"0x0.011CC58B167B9p0", "0x0.011FDB5518CCAp0", "0x0.0122F5821A8C7p0", "0x0.01261412A823Cp0",
"0x0.012937074E0CDp0", "0x0.012C5E6098D37p0", "0x0.012F8A1F15151p0", "0x0.0132BA434F80Ap0",
"0x0.0135EECDD4D6Cp0", "0x0.013927BF31E98p0", "0x0.013C6517F39CCp0", "0x0.013FA6D8A6E5Dp0",
"0x0.0142ED01D8CBCp0", "0x0.0146379416673p0", "0x0.0149868FECE26p0", "0x0.014CD9F5E9795p0",
"0x0.015031C699799p0", "0x0.01538E028A426p0", "0x0.0156EEAA4944Bp0", "0x0.015A53BE64033p0",
"0x0.015DBD3F68122p0", "0x0.01612B2DE3178p0", "0x0.01649D8A62CB1p0", "0x0.0168145574F65p0",
"0x0.016B8F8FA7745p0", "0x0.016F0F3988321p0", "0x0.01729353A52E4p0", "0x0.01761BDE8C792p0",
"0x0.0179A8DACC350p0", "0x0.017D3A48F295Dp0", "0x0.0180D0298DE13p0", "0x0.01846A7D2C6ECp0",
"0x0.018809445CA7Bp0", "0x0.018BAC7FAD074p0", "0x0.018F542FAC1A4p0", "0x0.01930054E87F8p0",
"0x0.0196B0EFF0E79p0", "0x0.019A66015414Dp0", "0x0.019E1F89A0DBAp0", "0x0.01A1DD8966221p0",
"0x0.01A5A00132E02p0", "0x0.01A966F1961FCp0", "0x0.01AD325B1EFC9p0", "0x0.01B1023E5CA45p0",
"0x0.01B4D69BDE569p0", "0x0.01B8AF743364Cp0", "0x0.01BC8CC7EB323p0", "0x0.01C06E9795345p0",
"0x0.01C454E3C0F24p0", "0x0.01C83FACFE054p0", "0x0.01CC2EF3DC187p0", "0x0.01D022B8EAE8Fp0",
"0x0.01D41AFCBA45Ep0", "0x0.01D817BFDA104p0", "0x0.01DC1902DA3B1p0", "0x0.01E01EC64ACB7p0",
"0x0.01E4290ABBD87p0", "0x0.01E837D0BD8B2p0", "0x0.01EC4B18E01E9p0", "0x0.01F062E3B3DFEp0",
"0x0.01F47F31C92E4p0", "0x0.01F8A003B07AFp0", "0x0.01FCC559FA492p0", "0x0.0200EF35372E4p0",
"0x0.02051D95F7D1Cp0", "0x0.0209507CCCED1p0", "0x0.020D87EA474BEp0", "0x0.0211C3DEF7CBDp0",
            };
            ap_ufixed<46,-6> f_x_msb_2 = f_x_msb_2_table[x_msb_ind_2];
            ap_ufixed< 5,-6> f_x_msb_2_h;
            f_x_msb_2_h(4,0) = f_x_msb_2(45,41);
            ap_ufixed< 9,-2> exp_x_msb_2_m_1_h = f_x_msb_2_h + x_msb_2;
            ap_ufixed<50,-2> exp_x_msb_2_m_1;
            exp_x_msb_2_m_1(49,41) = exp_x_msb_2_m_1_h(8,0);
            exp_x_msb_2_m_1(40, 0) = f_x_msb_2(40,0);

            ap_ufixed<98,-12> f_x_msb_2_3_4_lsb = exp_x_msb_2_m_1 * exp_x_msb_3_4_lsb_m_1;
            ap_ufixed<46,-12> f_x_msb_2_3_4_lsb_s = f_x_msb_2_3_4_lsb;
            ap_ufixed<50,-2> exp_x_msb_2_3_4_lsb_m_1 = f_x_msb_2_3_4_lsb_s + exp_x_msb_2_m_1 + exp_x_msb_3_4_lsb_m_1;

            const static ap_ufixed<50,23> exp_x_msb_1_table[256] = {
"0x1.0000000p0", "0x1.2216045p0", "0x1.48B5E3Cp0", "0x1.747A513p0",
"0x1.A61298Ep0", "0x1.DE455DFp0", "0x2.1DF3B68p0", "0x2.661CB0Fp0",
"0x2.B7E1516p0", "0x3.1489176p0", "0x3.7D871DBp0", "0x3.F47FE87p0",
"0x4.7B4FF99p0", "0x5.1413452p0", "0x5.C12DA41p0", "0x6.855466Ep0",
"0x7.63992E3p0", "0x8.5F7635Bp0", "0x9.7CDC417p0", "0xA.C042667p0",
"0xC.2EB7EC9p0", "0xD.CDF892Ep0", "0xF.A48385Ep0", "0x11.B9B5652p0",
"0x14.15E5BF6p0", "0x16.C2887C1p0", "0x19.CA53B78p0", "0x1D.396AA97p0",
"0x21.1D8E427p0", "0x25.865441Cp0", "0x2A.8565A14p0", "0x30.2EC550Bp0",
"0x36.99205C4p0", "0x3D.DE28BF3p0", "0x46.1AFC4DBp0", "0x4F.7099532p0",
"0x5A.0462B78p0", "0x66.00B5BC9p0", "0x73.9593ABBp0", "0x82.F9621ADp0",
"0x94.69C4CB8p0", "0xA8.2C948C1p0", "0xBE.90F6F83p0", "0xD7.F09B78Cp0",
"0xF4.B122790p0", "0x115.45B4704p0", "0x13A.30CF1CCp0", "0x164.0650296p0",
"0x193.6DC5690p0", "0x1C9.250BEDCp0", "0x206.03487A3p0", "0x24A.FC4533Cp0",
"0x299.2442102p0", "0x2F1.B447462p0", "0x356.0F0B0F9p0", "0x3C7.C67E5BEp0",
"0x448.A216ABBp0", "0x4DA.A5EE46Ap0", "0x580.1AD754Fp0", "0x63B.9782341p0",
"0x710.0ADBAC7p0", "0x800.C7CC8E3p0", "0x911.9289C39p0", "0xA46.AFAA2ADp0",
"0xBA4.F53EA38p0", "0xD31.DE30C52p0", "0xEF3.A035D57p0", "0x10F1.44ADE60p0",
"0x1332.C4D2B7Cp0", "0x15C1.29A744Cp0", "0x18A6.B027DA0p0", "0x1BEE.F24BB12p0",
"0x1FA7.157C470p0", "0x23DD.FF3C8BAp0", "0x28A4.90D2CCEp0", "0x2E0D.EAE454Bp0",
"0x342F.BA11823p0", "0x3B22.8DC5359p0", "0x4302.3A933EEp0", "0x4BEE.49AFCDCp0",
"0x560A.773E541p0", "0x617F.4171BF9p0", "0x6E7A.8ABB4A8p0", "0x7D30.5191764p0",
"0x8DDB.80AF426p0", "0xA0BE.DB0DB10p0", "0xB626.0748BAEp0", "0xCE66.BE9EAADp0",
"0xE9E2.2447727p0", "0x10906.4A831F8p0", "0x12C4F.EB75B2Ap0", "0x1544C.5CB6133p0",
"0x1819B.C560F61p0", "0x1B4F3.9F8AF64p0", "0x1EF21.8F1B001p0", "0x2310E.996C40Fp0",
"0x27BC2.CA9A6F9p0", "0x2D069.571279Ap0", "0x33055.49F35D9p0", "0x39D06.D2FEF17p0",
"0x41831.49596E9p0", "0x4A3C1.FB2AC39p0", "0x541E7.E56949Dp0", "0x5F51C.72B7532p0",
"0x6C02D.645AB25p0", "0x7A648.0CFF534p0", "0x8AB06.0A3EE9Fp0", "0x9D27B.AFE4CF1p0",
"0xB2148.5EAE56Cp0", "0xC9CA9.07F86EFp0", "0xE4A8D.2881EDBp0", "0x1031AE.8E4996Cp0",
"0x1259AC.48BF05Dp0", "0x14CB29.2F2B31Fp0", "0x178FEE.7792E44p0", "0x1AB312.E89CD0Dp0",
"0x1E4127.437732Bp0", "0x224868.979FC2Ep0", "0x26D8F9.4A204BEp0", "0x2C0521.B4A8E0Bp0",
"0x31E199.5F5A550p0", "0x3885D9.FA89D00p0", "0x400C7D.64D3386p0", "0x4893A8.361032Dp0",
"0x523D82.79EDAEFp0", "0x5D30C0.7DAB686p0", "0x69993D.D4F2D95p0", "0x77A8AD.02A7C71p0",
"0x0.000001Ep0", "0x0.0000022p0", "0x0.0000026p0", "0x0.000002Bp0",
"0x0.0000031p0", "0x0.0000038p0", "0x0.000003Fp0", "0x0.0000048p0",
"0x0.0000052p0", "0x0.000005Dp0", "0x0.0000069p0", "0x0.0000077p0",
"0x0.0000087p0", "0x0.0000099p0", "0x0.00000ADp0", "0x0.00000C4p0",
"0x0.00000DFp0", "0x0.00000FCp0", "0x0.000011Ep0", "0x0.0000144p0",
"0x0.0000170p0", "0x0.00001A1p0", "0x0.00001D8p0", "0x0.0000217p0",
"0x0.000025Ep0", "0x0.00002AFp0", "0x0.000030Bp0", "0x0.0000372p0",
"0x0.00003E8p0", "0x0.000046Dp0", "0x0.0000504p0", "0x0.00005AFp0",
"0x0.0000671p0", "0x0.000074Cp0", "0x0.0000845p0", "0x0.000095Fp0",
"0x0.0000A9Fp0", "0x0.0000C09p0", "0x0.0000DA3p0", "0x0.0000F74p0",
"0x0.0001183p0", "0x0.00013D8p0", "0x0.000167Cp0", "0x0.000197Bp0",
"0x0.0001CDFp0", "0x0.00020B7p0", "0x0.0002513p0", "0x0.0002A02p0",
"0x0.0002F9Ap0", "0x0.00035F1p0", "0x0.0003D20p0", "0x0.0004543p0",
"0x0.0004E7Cp0", "0x0.00058F0p0", "0x0.00064C7p0", "0x0.0007232p0",
"0x0.0008167p0", "0x0.00092A2p0", "0x0.000A628p0", "0x0.000BC48p0",
"0x0.000D55Ap0", "0x0.000F1C2p0", "0x0.00111F3p0", "0x0.001366Cp0",
"0x0.0015FC2p0", "0x0.0018E98p0", "0x0.001C3AAp0", "0x0.001FFCEp0",
"0x0.00243F3p0", "0x0.002912Bp0", "0x0.002E8ABp0", "0x0.0034BD2p0",
"0x0.003BC2Dp0", "0x0.0043B7Dp0", "0x0.004CBC1p0", "0x0.0056F3Ap0",
"0x0.0062878p0", "0x0.006FA5Fp0", "0x0.007E83Ap0", "0x0.008F5C0p0",
"0x0.00A2728p0", "0x0.00B813Bp0", "0x0.00D0963p0", "0x0.00EC5C1p0",
"0x0.010BD4Ap0", "0x0.012F7DEp0", "0x0.0157E6Bp0", "0x0.0185B0Fp0",
"0x0.01B993Fp0", "0x0.01F45F9p0", "0x0.0236FF5p0", "0x0.02827E0p0",
"0x0.02D80A0p0", "0x0.0338F9Fp0", "0x0.03A6D22p0", "0x0.04234A7p0",
"0x0.04B0556p0", "0x0.0550280p0", "0x0.0605424p0", "0x0.06D279Ap0",
"0x0.07BB040p0", "0x0.08C284Cp0", "0x0.09ED1B4p0", "0x0.0B3F736p0",
"0x0.0CBED86p0", "0x0.0E7149Cp0", "0x0.105D938p0", "0x0.128B697p0",
"0x0.150385Cp0", "0x0.17CFCC2p0", "0x0.1AFB718p0", "0x0.1E9328Bp0",
"0x0.22A5554p0", "0x0.2742456p0", "0x0.2C7C72Fp0", "0x0.3268CDBp0",
"0x0.391F0EEp0", "0x0.40BA188p0", "0x0.495860Dp0", "0x0.531C6C9p0",
"0x0.5E2D58Dp0", "0x0.6AB7782p0", "0x0.78ED03Ap0", "0x0.8906E49p0",
"0x0.9B4597Ep0", "0x0.AFF230Ap0", "0x0.C75F7CFp0", "0x0.E1EB512p0",
            };
            ap_ufixed<50,23> exp_x_msb_1 = exp_x_msb_1_table[x_msb_ind_1];
            ap_ufixed<100,21> y_lo = exp_x_msb_1 * exp_x_msb_2_3_4_lsb_m_1;
            ap_ufixed<48,21> y_lo_s = y_lo;
            ap_ufixed<50,23> y_l = y_lo_s + exp_x_msb_1;
            y = y_l;
        }
        if (I_<24) {
            bool overf = 0;
#pragma unroll
            for (int j = 45; j >= I_+22; j--) {
                if (y[j])
                    overf = 1;
            }
            if (overf) {
#pragma unroll
                for (int j = 45; j >= I_+22; j--)
                    y[j] = 0;
#pragma unroll
                for (int j = I_+21; j >= 0; j--)
                    y[j] = 1;
            }
        }
        r = y;
    } else {

        ap_fixed<65,33> x_l = 0;
#pragma unroll
        for (int j = 32-F_; j < 32+I_; j++)
            x_l[j] = x[j-(32-F_)];
#pragma unroll
        for (int j = 32+I_; j <= 64; j++)
            x_l[j] = x[W_-1];
        ap_ufixed<64,32> y = 0;
        ap_fixed<6,6> x_l_int;
        x_l_int(5,0) = x_l(37,32);
        ap_ufixed<32,0> x_l_fract;
        x_l_fract(31,0) = x_l(31,0);
        bool overf = 0;
#pragma unroll
        for (int j = 37; j < 64; j++)
            if (x_l[64]!=x_l[j])
                overf = 1;

        if (overf||(x_l_int>22)||((x_l_int==22)&&(x_l_fract>=ap_ufixed<32,0>("0x0.2e42fefap0")))) {
            if (!x_l[64]) {
#pragma unroll
                for (int j = 0; j < 64; j++) y[j] = 1;
            }
        } else {
            ap_uint<8> x_msb_ind_1;
            x_msb_ind_1[7] = x_l[64];
            x_msb_ind_1(6,0) = x_l(36,30);
            ap_uint<8> x_msb_ind_2;
            x_msb_ind_2(7,0) = x_l(29,22);
            ap_uint<8> x_msb_ind_3;
            x_msb_ind_3(7,0) = x_l(21,14);
            ap_uint<8> x_msb_ind_4;
            x_msb_ind_4(7,0) = x_l(13,6);
            ap_uint<6> x_lsb_ind;
            x_lsb_ind(5,0) = x_l(5,0);

            ap_ufixed<8, -2> x_msb_2 = x_l;
            ap_ufixed<8,-10> x_msb_3 = x_l;
            ap_ufixed<8,-18> x_msb_4 = x_l;
            ap_ufixed<6,-26> x_lsb = x_l;

            const static ap_ufixed<31,-37> f_x_msb_4_table[256] = {
"0x0.000000000000000000p0", "0x0.000000000000080000p0", "0x0.000000000000200000p0", "0x0.000000000000480000p0",
"0x0.000000000000800000p0", "0x0.000000000000C80000p0", "0x0.000000000001200000p0", "0x0.000000000001880000p0",
"0x0.000000000002000001p0", "0x0.000000000002880001p0", "0x0.000000000003200002p0", "0x0.000000000003C80003p0",
"0x0.000000000004800004p0", "0x0.000000000005480005p0", "0x0.000000000006200007p0", "0x0.000000000007080008p0",
"0x0.00000000000800000Ap0", "0x0.00000000000908000Cp0", "0x0.00000000000A20000Fp0", "0x0.00000000000B480011p0",
"0x0.00000000000C800014p0", "0x0.00000000000DC80018p0", "0x0.00000000000F20001Bp0", "0x0.00000000001088001Fp0",
"0x0.000000000012000024p0", "0x0.000000000013880028p0", "0x0.00000000001520002Dp0", "0x0.000000000016C80033p0",
"0x0.000000000018800039p0", "0x0.00000000001A48003Fp0", "0x0.00000000001C200046p0", "0x0.00000000001E08004Dp0",
"0x0.000000000020000055p0", "0x0.00000000002208005Dp0", "0x0.000000000024200066p0", "0x0.00000000002648006Fp0",
"0x0.000000000028800079p0", "0x0.00000000002AC80083p0", "0x0.00000000002D20008Ep0", "0x0.00000000002F88009Ap0",
"0x0.0000000000320000A6p0", "0x0.0000000000348800B3p0", "0x0.0000000000372000C0p0", "0x0.000000000039C800CFp0",
"0x0.00000000003C8000DDp0", "0x0.00000000003F4800EDp0", "0x0.0000000000422000FDp0", "0x0.00000000004508010Ep0",
"0x0.000000000048000120p0", "0x0.00000000004B080132p0", "0x0.00000000004E200145p0", "0x0.000000000051480159p0",
"0x0.00000000005480016Ep0", "0x0.000000000057C80183p0", "0x0.00000000005B20019Ap0", "0x0.00000000005E8801B1p0",
"0x0.0000000000620001C9p0", "0x0.0000000000658801E2p0", "0x0.0000000000692001FCp0", "0x0.00000000006CC80216p0",
"0x0.000000000070800232p0", "0x0.00000000007448024Fp0", "0x0.00000000007820026Cp0", "0x0.00000000007C08028Bp0",
"0x0.0000000000800002AAp0", "0x0.0000000000840802CBp0", "0x0.0000000000882002ECp0", "0x0.00000000008C48030Fp0",
"0x0.000000000090800332p0", "0x0.000000000094C80357p0", "0x0.00000000009920037Dp0", "0x0.00000000009D8803A4p0",
"0x0.0000000000A20003CCp0", "0x0.0000000000A68803F5p0", "0x0.0000000000AB20041Fp0", "0x0.0000000000AFC8044Ap0",
"0x0.0000000000B4800477p0", "0x0.0000000000B94804A4p0", "0x0.0000000000BE2004D3p0", "0x0.0000000000C3080503p0",
"0x0.0000000000C8000535p0", "0x0.0000000000CD080567p0", "0x0.0000000000D220059Bp0", "0x0.0000000000D74805D1p0",
"0x0.0000000000DC800607p0", "0x0.0000000000E1C8063Fp0", "0x0.0000000000E7200678p0", "0x0.0000000000EC8806B2p0",
"0x0.0000000000F20006EEp0", "0x0.0000000000F788072Bp0", "0x0.0000000000FD20076Ap0", "0x0.000000000102C807AAp0",
"0x0.0000000001088007EBp0", "0x0.00000000010E48082Ep0", "0x0.000000000114200872p0", "0x0.00000000011A0808B8p0",
"0x0.000000000120000900p0", "0x0.000000000126080948p0", "0x0.00000000012C200993p0", "0x0.0000000001324809DEp0",
"0x0.000000000138800A2Cp0", "0x0.00000000013EC80A7Bp0", "0x0.000000000145200ACBp0", "0x0.00000000014B880B1Dp0",
"0x0.000000000152000B71p0", "0x0.000000000158880BC6p0", "0x0.00000000015F200C1Dp0", "0x0.000000000165C80C76p0",
"0x0.00000000016C800CD0p0", "0x0.000000000173480D2Cp0", "0x0.00000000017A200D8Ap0", "0x0.000000000181080DE9p0",
"0x0.000000000188000E4Ap0", "0x0.00000000018F080EADp0", "0x0.000000000196200F12p0", "0x0.00000000019D480F78p0",
"0x0.0000000001A4800FE0p0", "0x0.0000000001ABC8104Ap0", "0x0.0000000001B32010B6p0", "0x0.0000000001BA881124p0",
"0x0.0000000001C2001194p0", "0x0.0000000001C9881205p0", "0x0.0000000001D1201278p0", "0x0.0000000001D8C812EEp0",
"0x0.0000000001E0801365p0", "0x0.0000000001E84813DEp0", "0x0.0000000001F0201459p0", "0x0.0000000001F80814D6p0",
"0x0.000000000200001555p0", "0x0.0000000002080815D6p0", "0x0.000000000210201659p0", "0x0.0000000002184816DEp0",
"0x0.000000000220801765p0", "0x0.000000000228C817EEp0", "0x0.000000000231201879p0", "0x0.000000000239881907p0",
"0x0.000000000242001996p0", "0x0.00000000024A881A28p0", "0x0.000000000253201ABBp0", "0x0.00000000025BC81B51p0",
"0x0.000000000264801BE9p0", "0x0.00000000026D481C84p0", "0x0.000000000276201D20p0", "0x0.00000000027F081DBFp0",
"0x0.000000000288001E60p0", "0x0.000000000291081F03p0", "0x0.00000000029A201FA8p0", "0x0.0000000002A3482050p0",
"0x0.0000000002AC8020FAp0", "0x0.0000000002B5C821A6p0", "0x0.0000000002BF202255p0", "0x0.0000000002C8882306p0",
"0x0.0000000002D20023B9p0", "0x0.0000000002DB88246Fp0", "0x0.0000000002E5202527p0", "0x0.0000000002EEC825E1p0",
"0x0.0000000002F880269Ep0", "0x0.00000000030248275Dp0", "0x0.00000000030C20281Fp0", "0x0.0000000003160828E3p0",
"0x0.0000000003200029AAp0", "0x0.00000000032A082A73p0", "0x0.000000000334202B3Fp0", "0x0.00000000033E482C0Dp0",
"0x0.000000000348802CDEp0", "0x0.000000000352C82DB2p0", "0x0.00000000035D202E88p0", "0x0.000000000367882F60p0",
"0x0.00000000037200303Cp0", "0x0.00000000037C883119p0", "0x0.0000000003872031FAp0", "0x0.000000000391C832DDp0",
"0x0.00000000039C8033C3p0", "0x0.0000000003A74834ABp0", "0x0.0000000003B2203596p0", "0x0.0000000003BD083684p0",
"0x0.0000000003C8003775p0", "0x0.0000000003D3083868p0", "0x0.0000000003DE20395Ep0", "0x0.0000000003E9483A57p0",
"0x0.0000000003F4803B53p0", "0x0.0000000003FFC83C52p0", "0x0.00000000040B203D53p0", "0x0.000000000416883E57p0",
"0x0.000000000422003F5Ep0", "0x0.00000000042D884068p0", "0x0.000000000439204175p0", "0x0.000000000444C84285p0",
"0x0.000000000450804397p0", "0x0.00000000045C4844ADp0", "0x0.0000000004682045C5p0", "0x0.0000000004740846E1p0",
"0x0.000000000480004800p0", "0x0.00000000048C084921p0", "0x0.000000000498204A46p0", "0x0.0000000004A4484B6Dp0",
"0x0.0000000004B0804C98p0", "0x0.0000000004BCC84DC5p0", "0x0.0000000004C9204EF6p0", "0x0.0000000004D588502Ap0",
"0x0.0000000004E2005161p0", "0x0.0000000004EE88529Bp0", "0x0.0000000004FB2053D8p0", "0x0.000000000507C85518p0",
"0x0.00000000051480565Cp0", "0x0.0000000005214857A3p0", "0x0.00000000052E2058EDp0", "0x0.00000000053B085A3Ap0",
"0x0.000000000548005B8Ap0", "0x0.000000000555085CDEp0", "0x0.000000000562205E35p0", "0x0.00000000056F485F8Fp0",
"0x0.00000000057C8060ECp0", "0x0.000000000589C8624Dp0", "0x0.0000000005972063B1p0", "0x0.0000000005A4886519p0",
"0x0.0000000005B2006684p0", "0x0.0000000005BF8867F2p0", "0x0.0000000005CD206963p0", "0x0.0000000005DAC86AD8p0",
"0x0.0000000005E8806C51p0", "0x0.0000000005F6486DCDp0", "0x0.000000000604206F4Cp0", "0x0.0000000006120870CFp0",
"0x0.000000000620007255p0", "0x0.00000000062E0873DFp0", "0x0.00000000063C20756Cp0", "0x0.00000000064A4876FDp0",
"0x0.000000000658807891p0", "0x0.000000000666C87A29p0", "0x0.000000000675207BC4p0", "0x0.000000000683887D64p0",
"0x0.000000000692007F06p0", "0x0.0000000006A08880ADp0", "0x0.0000000006AF208256p0", "0x0.0000000006BDC88404p0",
"0x0.0000000006CC8085B5p0", "0x0.0000000006DB48876Ap0", "0x0.0000000006EA208923p0", "0x0.0000000006F9088ADFp0",
"0x0.000000000708008CA0p0", "0x0.000000000717088E63p0", "0x0.00000000072620902Bp0", "0x0.0000000007354891F6p0",
"0x0.0000000007448093C6p0", "0x0.000000000753C89599p0", "0x0.000000000763209770p0", "0x0.00000000077288994Ap0",
"0x0.000000000782009B29p0", "0x0.000000000791889D0Bp0", "0x0.0000000007A1209EF2p0", "0x0.0000000007B0C8A0DCp0",
"0x0.0000000007C080A2CAp0", "0x0.0000000007D048A4BCp0", "0x0.0000000007E020A6B2p0", "0x0.0000000007F008A8ACp0",
            };
            ap_ufixed<31,-37> f_x_msb_4 = f_x_msb_4_table[x_msb_ind_4];

            const static ap_ufixed<12,-53> f_x_lsb_table[64] = {
"0x0.00000000000000000p0", "0x0.00000000000000008p0", "0x0.00000000000000020p0", "0x0.00000000000000048p0",
"0x0.00000000000000080p0", "0x0.000000000000000c8p0", "0x0.00000000000000120p0", "0x0.00000000000000188p0",
"0x0.00000000000000200p0", "0x0.00000000000000288p0", "0x0.00000000000000320p0", "0x0.000000000000003c8p0",
"0x0.00000000000000480p0", "0x0.00000000000000548p0", "0x0.00000000000000620p0", "0x0.00000000000000708p0",
"0x0.00000000000000800p0", "0x0.00000000000000908p0", "0x0.00000000000000a20p0", "0x0.00000000000000b48p0",
"0x0.00000000000000c80p0", "0x0.00000000000000dc8p0", "0x0.00000000000000f20p0", "0x0.00000000000001088p0",
"0x0.00000000000001200p0", "0x0.00000000000001388p0", "0x0.00000000000001520p0", "0x0.000000000000016c8p0",
"0x0.00000000000001880p0", "0x0.00000000000001a48p0", "0x0.00000000000001c20p0", "0x0.00000000000001e08p0",
"0x0.00000000000002000p0", "0x0.00000000000002208p0", "0x0.00000000000002420p0", "0x0.00000000000002648p0",
"0x0.00000000000002880p0", "0x0.00000000000002ac8p0", "0x0.00000000000002d20p0", "0x0.00000000000002f88p0",
"0x0.00000000000003200p0", "0x0.00000000000003488p0", "0x0.00000000000003720p0", "0x0.000000000000039c8p0",
"0x0.00000000000003c80p0", "0x0.00000000000003f48p0", "0x0.00000000000004220p0", "0x0.00000000000004508p0",
"0x0.00000000000004800p0", "0x0.00000000000004b08p0", "0x0.00000000000004e20p0", "0x0.00000000000005148p0",
"0x0.00000000000005480p0", "0x0.000000000000057c8p0", "0x0.00000000000005b20p0", "0x0.00000000000005e88p0",
"0x0.00000000000006200p0", "0x0.00000000000006588p0", "0x0.00000000000006920p0", "0x0.00000000000006cc8p0",
"0x0.00000000000007080p0", "0x0.00000000000007448p0", "0x0.00000000000007820p0", "0x0.00000000000007c08p0",
            };
            ap_ufixed<12,-53> f_x_lsb = f_x_lsb_table[x_lsb_ind];

            ap_ufixed<14,-44> f_x_msb_4_lsb = x_msb_4 * x_lsb;

            ap_ufixed<15,-43> exp_x_msb_4_lsb_m_1_m1 = 0;
            exp_x_msb_4_lsb_m_1_m1(4,0) = f_x_lsb(11,7);
            exp_x_msb_4_lsb_m_1_m1 = exp_x_msb_4_lsb_m_1_m1 + f_x_msb_4_lsb;

            ap_ufixed<22,-43> exp_x_msb_4_lsb_m_1_m2 = exp_x_msb_4_lsb_m_1_m1;
            exp_x_msb_4_lsb_m_1_m2(6,0) = f_x_lsb(6,0);

            ap_ufixed<29,-36> exp_x_msb_4_lsb_m_1_m3 = 0;
            exp_x_msb_4_lsb_m_1_m3(27,0) = f_x_msb_4(30,3);
            exp_x_msb_4_lsb_m_1_m3 = exp_x_msb_4_lsb_m_1_m3 + exp_x_msb_4_lsb_m_1_m2;

            ap_ufixed<32,-36> exp_x_msb_4_lsb_m_1_m = exp_x_msb_4_lsb_m_1_m3;
            exp_x_msb_4_lsb_m_1_m(2,0) = f_x_msb_4(2,0);

            ap_ufixed<50,-18> exp_x_msb_4_lsb_m_1 = 0;
            exp_x_msb_4_lsb_m_1(49,36) = x_l(13,0);
            exp_x_msb_4_lsb_m_1(31, 0) = exp_x_msb_4_lsb_m_1_m(31,0);


            const static ap_ufixed<51,-21> f_x_msb_3_table[256] = {
"0x0", "0x0.00000000080000AAAAp0", "0x0.000000002000055556p0", "0x0.000000004800120003p0",
"0x0.0000000080002AAAB5p0", "0x0.00000000C80053556Fp0", "0x0.000000012000900036p0", "0x0.000000018800E4AB0Ep0",
"0x0.000000020001555600p0", "0x0.000000028801E60111p0", "0x0.0000000320029AAC4Bp0", "0x0.00000003C8037757B7p0",
"0x0.000000048004800360p0", "0x0.000000054805B8AF50p0", "0x0.000000062007255B96p0", "0x0.000000070808CA083Dp0",
"0x0.00000008000AAAB555p0", "0x0.00000009080CCB62EDp0", "0x0.0000000A200F301116p0", "0x0.0000000B4811DCBFE0p0",
"0x0.0000000C8014D56F60p0", "0x0.0000000DC8181E1FA7p0", "0x0.0000000F201BBAD0CBp0", "0x0.00000010881FAF82E1p0",
"0x0.000000120024003600p0", "0x0.000000138828B0EA3Fp0", "0x0.00000015202DC59FB6p0", "0x0.00000016C83342567Fp0",
"0x0.0000001880392B0EB5p0", "0x0.0000001A483F83C874p0", "0x0.0000001C20465083D6p0", "0x0.0000001E084D9540FBp0",
"0x0.000000200055560001p0", "0x0.00000022085D96C106p0", "0x0.0000002420665B842Cp0", "0x0.00000026486FA84995p0",
"0x0.000000288079811161p0", "0x0.0000002AC883E9DBB6p0", "0x0.0000002D208EE6A8B8p0", "0x0.0000002F889A7B788Cp0",
"0x0.0000003200A6AC4B58p0", "0x0.0000003488B37D2145p0", "0x0.0000003720C0F1FA7Ap0", "0x0.00000039C8CF0ED721p0",
"0x0.0000003C80DDD7B765p0", "0x0.0000003F48ED509B71p0", "0x0.0000004220FD7D8371p0", "0x0.00000045090E626F94p0",
"0x0.000000480120036008p0", "0x0.0000004B09326454FBp0", "0x0.0000004E2145894E9Fp0", "0x0.000000514959764D26p0",
"0x0.00000054816E2F50C1p0", "0x0.00000057C983B859A4p0", "0x0.0000005B219A156804p0", "0x0.0000005E89B14A7C16p0",
"0x0.0000006201C95B9611p0", "0x0.0000006589E24CB62Cp0", "0x0.0000006921FC21DCA0p0", "0x0.0000006CCA16DF09A6p0",
"0x0.000000708232883D78p0", "0x0.000000744A4F217853p0", "0x0.00000078226CAEBA73p0", "0x0.0000007C0A8B340414p0",
"0x0.0000008002AAB55577p0", "0x0.000000840ACB36AEDAp0", "0x0.0000008822ECBC107Dp0", "0x0.0000008C4B0F497AA3p0",
"0x0.000000908332E2ED8Ep0", "0x0.00000094CB578C6981p0", "0x0.00000099237D49EEC0p0", "0x0.0000009D8BA41F7D92p0",
"0x0.000000A203CC11163Dp0", "0x0.000000A68BF522B908p0", "0x0.000000AB241F58663Cp0", "0x0.000000AFCC4AB61E22p0",
"0x0.000000B484773FE105p0", "0x0.000000B94CA4F9AF31p0", "0x0.000000BE24D3E788F1p0", "0x0.000000C30D040D6E94p0",
"0x0.000000C805356F6068p0", "0x0.000000CD0D68115EBCp0", "0x0.000000D2259BF769E1p0", "0x0.000000D74DD1258228p0",
"0x0.000000DC86079FA7E4p0", "0x0.000000E1CE3F69DB69p0", "0x0.000000E72678881D0Bp0", "0x0.000000EC8EB2FE6D1Fp0",
"0x0.000000F206EED0CBFDp0", "0x0.000000F78F2C0339FAp0", "0x0.000000FD276A99B771p0", "0x0.00000102CFAA9844BBp0",
"0x0.0000010887EC02E231p0", "0x0.0000010E502EDD9030p0", "0x0.0000011428732C4F14p0", "0x0.0000011A10B8F31F3Bp0",
"0x0.000001200900360103p0", "0x0.000001261148F8F4CBp0", "0x0.0000012C29933FFAF5p0", "0x0.0000013251DF0F13E1p0",
"0x0.000001388A2C6A3FF3p0", "0x0.0000013ED27B557F8Dp0", "0x0.000001452ACBD4D315p0", "0x0.0000014B931DEC3AEFp0",
"0x0.000001520B719FB782p0", "0x0.0000015893C6F34937p0", "0x0.0000015F2C1DEAF074p0", "0x0.00000165D4768AADA5p0",
"0x0.0000016C8CD0D68133p0", "0x0.00000173552CD26B89p0", "0x0.0000017A2D8A826D16p0", "0x0.0000018115E9EA8645p0",
"0x0.000001880E4B0EB785p0", "0x0.0000018F16ADF30147p0", "0x0.000001962F129B63FAp0", "0x0.0000019D57790BE010p0",
"0x0.000001A48FE14875FBp0", "0x0.000001ABD84B552630p0", "0x0.000001B330B735F122p0", "0x0.000001BA9924EED748p0",
"0x0.000001C2119483D917p0", "0x0.000001C99A05F8F707p0", "0x0.000001D13279523191p0", "0x0.000001D8DAEE93892Ep0",
"0x0.000001E09365C0FE59p0", "0x0.000001E85BDEDE918Dp0", "0x0.000001F03459F04347p0", "0x0.000001F81CD6FA1405p0",
"0x0.000002001556000444p0", "0x0.000002081DD7061485p0", "0x0.00000210365A104547p0", "0x0.000002185EDF22970Dp0",
"0x0.000002209766410A5Ap0", "0x0.00000228DFEF6F9FAFp0", "0x0.00000231387AB25793p0", "0x0.00000239A1080D328Ap0",
"0x0.00000242199784311Cp0", "0x0.0000024AA2291B53CFp0", "0x0.000002533ABCD69B2Dp0", "0x0.0000025BE352BA07BEp0",
"0x0.000002649BEAC99A0Dp0", "0x0.0000026D64850952A7p0", "0x0.000002763D217D3216p0", "0x0.0000027F25C02938EAp0",
"0x0.000002881E611167B0p0", "0x0.00000291270439BEF8p0", "0x0.0000029A3FA9A63F53p0", "0x0.000002A368515AE951p0",
"0x0.000002ACA0FB5BBD86p0", "0x0.000002B5E9A7ACBC86p0", "0x0.000002BF425651E6E4p0", "0x0.000002C8AB074F3D36p0",
"0x0.000002D223BAA8C013p0", "0x0.000002DBAC70627012p0", "0x0.000002E54528804DCDp0", "0x0.000002EEEDE30659DBp0",
"0x0.000002F8A69FF894D9p0", "0x0.000003026F5F5AFF61p0", "0x0.0000030C4821319A10p0", "0x0.0000031630E5806584p0",
"0x0.0000032029AC4B625Bp0", "0x0.0000032A3275969134p0", "0x0.000003344B4165F2B1p0", "0x0.0000033E740FBD8772p0",
"0x0.00000348ACE0A1501Bp0", "0x0.00000352F5B4154D4Fp0", "0x0.0000035D4E8A1D7FB2p0", "0x0.00000367B762BDE7EAp0",
"0x0.00000372303DFA869Ep0", "0x0.0000037CB91BD75C75p0", "0x0.0000038751FC586A18p0", "0x0.00000391FADF81B02Fp0",
"0x0.0000039CB3C5572F67p0", "0x0.000003A77CADDCE86Ap0", "0x0.000003B2559916DBE4p0", "0x0.000003BD3E87090A84p0",
"0x0.000003C83777B774F8p0", "0x0.000003D3406B261BF0p0", "0x0.000003DE596159001Cp0", "0x0.000003E9825A54222Dp0",
"0x0.000003F4BB561B82D7p0", "0x0.000004000454B322CCp0", "0x0.0000040B5D561F02C2p0", "0x0.00000416C65A63236Ep0",
"0x0.000004223F61838586p0", "0x0.0000042DC86B8429C2p0", "0x0.0000043961786910DBp0", "0x0.000004450A88363B8Ap0",
"0x0.00000450C39AEFAA8Ap0", "0x0.0000045C8CB0995E96p0", "0x0.0000046865C937586Bp0", "0x0.000004744EE4CD98C6p0",
"0x0.000004804803602067p0", "0x0.0000048C5124F2F00Cp0", "0x0.000004986A498A0876p0", "0x0.000004A49371296A67p0",
"0x0.000004B0CC9BD516A1p0", "0x0.000004BD15C9910DE8p0", "0x0.000004C96EFA615101p0", "0x0.000004D5D82E49E0B0p0",
"0x0.000004E251654EBDBDp0", "0x0.000004EEDA9F73E8F0p0", "0x0.000004FB73DCBD6310p0", "0x0.000005081D1D2F2CE7p0",
"0x0.00000514D660CD4740p0", "0x0.000005219FA79BB2E7p0", "0x0.0000052E78F19E70A8p0", "0x0.0000053B623ED98150p0",
"0x0.000005485B8F50E5AFp0", "0x0.0000055564E3089E93p0", "0x0.000005627E3A04ACCEp0", "0x0.0000056FA794491131p0",
"0x0.0000057CE0F1D9CC8Ep0", "0x0.0000058A2A52BADFBAp0", "0x0.0000059783B6F04B88p0", "0x0.000005A4ED1E7E10CFp0",
"0x0.000005B26689683064p0", "0x0.000005BFEFF7B2AB20p0", "0x0.000005CD89696181DBp0", "0x0.000005DB32DE78B56Fp0",
"0x0.000005E8EC56FC46B6p0", "0x0.000005F6B5D2F0368Cp0", "0x0.000006048F525885CDp0", "0x0.0000061278D5393558p0",
"0x0.00000620725B96460Ap0", "0x0.0000062E7BE573B8C3p0", "0x0.0000063C9572D58E64p0", "0x0.0000064ABF03BFC7CEp0",
"0x0.00000658F8983665E5p0", "0x0.0000066742303D698Bp0", "0x0.000006759BCBD8D3A5p0", "0x0.00000684056B0CA519p0",
"0x0.000006927F0DDCDECEp0", "0x0.000006A108B44D81AAp0", "0x0.000006AFA25E628E98p0", "0x0.000006BE4C0C20067Fp0",
"0x0.000006CD05BD89EA4Bp0", "0x0.000006DBCF72A43AE8p0", "0x0.000006EAA92B72F942p0", "0x0.000006F992E7FA2646p0",
"0x0.000007088CA83DC2E4p0", "0x0.00000717966C41D00Ap0", "0x0.00000726B0340A4EAAp0", "0x0.00000735D9FF9B3FB6p0",
"0x0.0000074513CEF8A41Ep0", "0x0.000007545DA2267CD9p0", "0x0.00000763B77928CAD9p0", "0x0.000007732154038F14p0",
"0x0.000007829B32BACA82p0", "0x0.000007922515527E1Ap0", "0x0.000007A1BEFBCEAAD4p0", "0x0.000007B168E63351AAp0",
"0x0.000007C122D4847397p0", "0x0.000007D0ECC6C61195p0", "0x0.000007E0C6BCFC2CA3p0", "0x0.000007F0B0B72AC5BEp0",
            };
            ap_ufixed<51,-21> f_x_msb_3 = f_x_msb_3_table[x_msb_ind_3];
            ap_ufixed<62,-10> exp_x_msb_3_m_1 = 0;
            exp_x_msb_3_m_1(61,54) = x_msb_3(7,0);
            exp_x_msb_3_m_1(50, 0) = f_x_msb_3(50,0);

            ap_ufixed<50,-10> exp_x_msb_3_m_1_s = exp_x_msb_3_m_1;
            ap_ufixed<100,-28> f_x_msb_3_4_lsb = exp_x_msb_3_m_1_s * exp_x_msb_4_lsb_m_1;
            ap_ufixed<44,-28> f_x_msb_3_4_lsb_s = f_x_msb_3_4_lsb;
            ap_ufixed<63, -9> exp_x_msb_3_4_lsb_m_1 = f_x_msb_3_4_lsb_s + exp_x_msb_3_m_1 + exp_x_msb_4_lsb_m_1;


            const static ap_ufixed<64,-4> f_x_msb_2_table[256] = {
"0x0.0p0", "0x0.00000800AAB555DDEp0", "0x0.00002005560011127p0", "0x0.00004812036081A9Cp0",
"0x0.0000802AB55777D28p0", "0x0.0000C8536F6684062p0", "0x0.0001209036103740Dp0", "0x0.000188E50ED8634A0p0",
"0x0.0002015600445B0C3p0", "0x0.000289E711DB32FD7p0", "0x0.0003229C4C260197Ep0", "0x0.0003CB79B8B01FE26p0",
"0x0.0004848362076A08Dp0", "0x0.00054DBD53BC80058p0", "0x0.0006272B9A630659Dp0", "0x0.000710D24391E6D7Ap0",
"0x0.00080AB55DE3917ABp0", "0x0.000914D8F8F63D524p0", "0x0.000A2F41256C297AFp0", "0x0.000B59F1F4EBDE291p0",
"0x0.000C94EF7A206DC2Dp0", "0x0.000DE03DC8B9B60B1p0", "0x0.000F3BE0F56CA15C4p0", "0x0.0010A7DD15F367F40p0",
"0x0.00122436410DD14E5p0", "0x0.0013B0F08E817591Ep0", "0x0.00154E101719FF0C5p0", "0x0.0016FB98F4A96BBEFp0",
"0x0.0018B98F42084EFBDp0", "0x0.001A87F71B1613137p0", "0x0.001C66D49CB93B127p0", "0x0.001E562BE4DFA4904p0",
"0x0.00205601127EC98E0p0", "0x0.00226658459402659p0", "0x0.002487359F24C7C99p0", "0x0.0026B89D413EF4D5Ep0",
"0x0.0028FA934EF909304p0", "0x0.002B4D1BEC726B39Cp0", "0x0.002DB03B3ED3AA50Ep0", "0x0.003023F56C4EC123Fp0",
"0x0.0032A84E9C1F58145p0", "0x0.00353D4AF68B07AA1p0", "0x0.0037E2EEA4E19B185p0", "0x0.003A993DD17D52D25p0",
"0x0.003D603CA7C32730Fp0", "0x0.004037EF54230B293p0", "0x0.0043205A04182F12Fp0", "0x0.00461980E62943810p0",
"0x0.0049236829E8BC292p0", "0x0.004C3E13FFF512DD8p0", "0x0.004F698899F90A966p0", "0x0.0052A5CA2AABF28D0p0",
"0x0.0055F2DCE5D1E966Ep0", "0x0.005950C5003C20723p0", "0x0.005CBF86AFC91EF2Bp0", "0x0.00603F262B65057FCp0",
"0x0.0063CFA7AB09D1732p0", "0x0.0067710F67BFA0687p0", "0x0.006B23619B9CF3CDEp0", "0x0.006EE6A281C6F4857p0",
"0x0.0072BAD65671B6977p0", "0x0.0076A00156E07CF57p0", "0x0.007A9627C165FD4EDp0", "0x0.007E9D4DD564A3F5Ep0",
"0x0.0082B577D34ED7D5Bp0", "0x0.0086DEA9FCA73E799p0", "0x0.008B18E8940100253p0", "0x0.008F6437DD000BFDAp0",
"0x0.0093C09C1C595C43Ep0", "0x0.00982E1997D33A9FCp0", "0x0.009CACB49645847CCp0", "0x0.00A13C715F99EF773p0",
"0x0.00A5DD543CCC4DDAFp0", "0x0.00AA8F6177EAD3336p0", "0x0.00AF529D5C1658EBCp0", "0x0.00B4270C3582A301Dp0",
"0x0.00B90CB25176A4C8Bp0", "0x0.00BE0393FE4CC5BD7p0", "0x0.00C30BB58B73266CAp0", "0x0.00C8251B496BE5696p0",
"0x0.00CD4FC989CD64555p0", "0x0.00D28BC49F428CFA3p0", "0x0.00D7D910DD8B16743p0", "0x0.00DD37B2997BCA6E6p0",
"0x0.00E2A7AE28FECA6FBp0", "0x0.00E82907E313D5399p0", "0x0.00EDBBC41FD08C383p0", "0x0.00F35FE73860B9038p0",
"0x0.00F91575870692F24p0", "0x0.00FEDC73671B04BDFp0", "0x0.0104B4E5350DF2386p0", "0x0.010A9ECF4E667E12Dp0",
"0x0.01109A3611C34FB64p0", "0x0.0116A71DDEDAD92D8p0", "0x0.011CC58B167B9D206p0", "0x0.0122F5821A8C74E0Dp0",
"0x0.012937074E0CD6893p0", "0x0.012F8A1F15151B2C6p0", "0x0.0135EECDD4D6C5172p0", "0x0.013C6517F39CC6233p0",
"0x0.0142ED01D8CBC61C4p0", "0x0.0149868FECE26935Dp0", "0x0.015031C6997996937p0", "0x0.0156EEAA4944BEE23p0",
"0x0.015DBD3F68122303Ep0", "0x0.01649D8A62CB1ACBEp0", "0x0.016B8F8FA7745BCDBp0", "0x0.01729353A52E403D8p0",
"0x0.0179A8DACC350DE1Dp0", "0x0.0180D0298DE13D179p0", "0x0.018809445CA7BFE78p0", "0x0.018F542FAC1A492D6p0",
"0x0.0196B0EFF0E793D15p0", "0x0.019E1F89A0DBAA128p0", "0x0.01A5A00132E02CE42p0", "0x0.01AD325B1EFC9B5BCp0",
"0x0.01B4D69BDE569A322p0", "0x0.01BC8CC7EB323B553p0", "0x0.01C454E3C0F2458C8p0", "0x0.01CC2EF3DC187C2F6p0",
"0x0.01D41AFCBA45E6ED2p0", "0x0.01DC1902DA3B19A6Dp0", "0x0.01E4290ABBD87C5BCp0", "0x0.01EC4B18E01E9326Fp0",
"0x0.01F47F31C92E464FCp0", "0x0.01FCC559FA492A6B6p0", "0x0.02051D95F7D1C8917p0", "0x0.020D87EA474BE6A1Cp0",
"0x0.0216045B6F5CCF9CEp0", "0x0.021E92EDF7CB9C0E4p0", "0x0.022733A669817A88Ap0", "0x0.022FE6894E89F834Cp0",
"0x0.0238AB9B321349722p0", "0x0.024182E0A06E9289Bp0", "0x0.024A6C5E271030733p0", "0x0.02536818549001AC1p0",
"0x0.025C7613B8A9AF215p0", "0x0.02659654E43CF52B1p0", "0x0.026EC8E0694DEC9A9p0", "0x0.02780DBADB0553DA6p0",
"0x0.028164E8CDB0D8211p0", "0x0.028ACE6ED6C35EB5Fp0", "0x0.02944A518CD54E484p0", "0x0.029DD89587A4D858Dp0",
"0x0.02A7793F601642B5Dp0", "0x0.02B12C53B03431090p0", "0x0.02BAF1D7132FEE788p0", "0x0.02C4C9CE2561B759Fp0",
"0x0.02CEB43D844902F7Ap0", "0x0.02D8B129CE8CCD68Fp0", "0x0.02E2C097A3FBE17C9p0", "0x0.02ECE28BA58D22B56p0",
"0x0.02F7170A755FD759Ep0", "0x0.03015E18B6BBF2966p0", "0x0.030BB7BB0E125EB13p0", "0x0.031623F620FD4751Ep0",
"0x0.0320A2CE964063DACp0", "0x0.032B344915C941D54p0", "0x0.0335D86A48AF8F70Cp0", "0x0.03408F36D93566140p0",
"0x0.034B58B372C795013p0", "0x0.035634E4C1FDEC0D0p0", "0x0.036123CF749B8667Cp0", "0x0.036C2578398F157A0p0",
"0x0.037739E3C0F32BD30p0", "0x0.03826116BC0E882ACp0", "0x0.038D9B15DD5460763p0", "0x0.0398E7E5D864AD0E9p0",
"0x0.03A4478B620C73EB5p0", "0x0.03AFBA0B304613EEDp0", "0x0.03BB3F69FA3990464p0", "0x0.03C6D7AC783CDBDBFp0",
"0x0.03D282D763D424DCDp0", "0x0.03DE40EF77B220509p0", "0x0.03EA11F96FB855C4Fp0", "0x0.03F5F5FA08F76B0BBp0",
"0x0.0401ECF601AF700BDp0", "0x0.040DF6F219502AA55p0", "0x0.041A13F3107962A88p0", "0x0.042643FDA8FB2DDFBp0",
"0x0.04328716A5D63C2C4p0", "0x0.043EDD42CB3C23B6Dp0", "0x0.044B4686DE8FAD325p0", "0x0.0457C2E7A66520322p0",
"0x0.04645269EA828F932p0", "0x0.0470F51273E025F89p0", "0x0.047DAAE60CA8725B3p0", "0x0.048A73E98038B4ABFp0",
"0x0.049750219B212A8A0p0", "0x0.04A43F932B255C0B7p0", "0x0.04B14242FF3C689A0p0", "0x0.04BE5835E79153E1Dp0",
"0x0.04CB8170B58352D4Ep0", "0x0.04D8BDF83BA618C04p0", "0x0.04E60DD14DC22475Ep0", "0x0.04F37100C0D50D88Ep0",
"0x0.0500E78B6B11D19D6p0", "0x0.050E717623E121CBAp0", "0x0.051C0EC5C3E1B016Cp0", "0x0.0529BF7F24E87CF6Ap0",
"0x0.053783A7220124F51p0", "0x0.05455B42976E2E5EAp0", "0x0.0553465662A95706Bp0", "0x0.056144E76263E21F4p0",
"0x0.056F56FA7686E623Ep0", "0x0.057D7C9480339AD83p0", "0x0.058BB5BA61C3A75A3p0", "0x0.059A0270FEC97047Ap0",
"0x0.05A862BD3C1065F74p0", "0x0.05B6D6A3FF9D52C58p0", "0x0.05C55E2A30AEA974Ep0", "0x0.05D3F954B7BCD3A1Bp0",
"0x0.05E2A8287E7A8049Ep0", "0x0.05F16AAA6FD4F267Bp0", "0x0.060040DF77F44FA13p0", "0x0.060F2ACC843BEF0A0p0",
"0x0.061E2876834AA7FA4p0", "0x0.062D39E264FB20F7Ep0", "0x0.063C5F151A641EB4Cp0", "0x0.064B981395D8D31FEp0",
"0x0.065AE4E2CAE92C8AAp0", "0x0.066A4587AE6224E1Cp0", "0x0.0679BA07364E10FA3p0", "0x0.0689426659F4EFF1Bp0",
"0x0.0698DEAA11DCBAA37p0", "0x0.06A88ED757C9B3304p0", "0x0.06B852F326BEB49B0p0", "0x0.06C82B027AFD8278Ap0",
"0x0.06D8170A520718B46p0", "0x0.06E8170FAA9BFB67Ep0", "0x0.06F82B1784BC86C72p0", "0x0.07085326E1A93F207p0",
"0x0.07188F42C3E320F0Bp0", "0x0.0728DF702F2BF10B2p0", "0x0.073943B428868CD5Ap0", "0x0.0749BC13B6373A98Fp0",
"0x0.075A4893DFC3F9E4Cp0", "0x0.076AE939ADF4D4083p0", "0x0.077B9E0A2AD42C9E8p0", "0x0.078C670A61AF122F4p0",
"0x0.079D443F5F158EE3Ap0", "0x0.07AE35AE30DAF94F1p0", "0x0.07BF3B5BE616454CBp0", "0x0.07D0554D8F2254F0Cp0",
"0x0.07E183883D9E498E2p0", "0x0.07F2C611046DD4D06p0", "0x0.08041CECF7B989EA2p0", "0x0.081588212CEF2ED73p0",
"0x0.082707B2BAC20DB40p0", "0x0.08389BA6B92B46284p0", "0x0.084A4402416A1EE6Fp0", "0x0.085C00CA6E045741Fp0",
"0x0.086DD2045AC678D2Bp0", "0x0.087FB7B524C42936Cp0", "0x0.0891B1E1EA587BE12p0", "0x0.08A3C08FCB2643FFEp0",
            };
            ap_ufixed<64,-4> f_x_msb_2 = f_x_msb_2_table[x_msb_ind_2];
            ap_ufixed< 6,-4> f_x_msb_2_h;
            f_x_msb_2_h(5,0) = f_x_msb_2(63,58);
            ap_ufixed< 9,-1> exp_x_msb_2_m_1_h = f_x_msb_2_h + x_msb_2;
            ap_ufixed<67,-1> exp_x_msb_2_m_1;
            exp_x_msb_2_m_1(66,58) = exp_x_msb_2_m_1_h(8,0);
            exp_x_msb_2_m_1(57, 0) = f_x_msb_2(57,0);

            ap_ufixed<130,-10> f_x_msb_2_3_4_lsb = exp_x_msb_2_m_1 * exp_x_msb_3_4_lsb_m_1;
            ap_ufixed<62,-10> f_x_msb_2_3_4_lsb_s = f_x_msb_2_3_4_lsb;
            ap_ufixed<72,0> exp_x_msb_2_3_4_lsb_m_1 = f_x_msb_2_3_4_lsb_s + exp_x_msb_2_m_1 + exp_x_msb_3_4_lsb_m_1;

            const static ap_ufixed<68,32> exp_x_msb_1_table[256] = {
"0x1.000000000p0", "0x1.48B5E3C3Ep0", "0x1.A61298E1Ep0", "0x2.1DF3B68CFp0",
"0x2.B7E151628p0", "0x3.7D871DB61p0", "0x4.7B4FF993Fp0", "0x5.C12DA416Ep0",
"0x7.63992E353p0", "0x9.7CDC417A3p0", "0xC.2EB7EC98Fp0", "0xF.A48385EDFp0",
"0x14.15E5BF6FBp0", "0x19.CA53B7811p0", "0x21.1D8E4272Dp0", "0x2A.8565A144Cp0",
"0x36.99205C4E7p0", "0x46.1AFC4DB59p0", "0x5A.0462B7877p0", "0x73.9593ABB7Dp0",
"0x94.69C4CB819p0", "0xBE.90F6F83E9p0", "0xF4.B122790DDp0", "0x13A.30CF1CCBBp0",
"0x193.6DC5690C0p0", "0x206.03487A3B1p0", "0x299.2442102D9p0", "0x356.0F0B0F980p0",
"0x448.A216ABB76p0", "0x580.1AD754FA3p0", "0x710.0ADBAC7DAp0", "0x911.9289C3923p0",
"0xBA4.F53EA3863p0", "0xEF3.A035D5798p0", "0x1332.C4D2B7C4Ap0", "0x18A6.B027DA0A7p0",
"0x1FA7.157C470F8p0", "0x28A4.90D2CCEF1p0", "0x342F.BA11823B8p0", "0x4302.3A933EE5Cp0",
"0x560A.773E54157p0", "0x6E7A.8ABB4A83Cp0", "0x8DDB.80AF4269Dp0", "0xB626.0748BAEC7p0",
"0xE9E2.2447727BFp0", "0x12C4F.EB75B2AB0p0", "0x1819B.C560F6113p0", "0x1EF21.8F1B001A4p0",
"0x27BC2.CA9A6F934p0", "0x33055.49F35D91Fp0", "0x41831.49596E996p0", "0x541E7.E56949D58p0",
"0x6C02D.645AB2554p0", "0x8AB06.0A3EE9FB1p0", "0xB2148.5EAE56C5Bp0", "0xE4A8D.2881EDBE8p0",
"0x1259AC.48BF05D6Ep0", "0x178FEE.7792E44B3p0", "0x1E4127.437732B71p0", "0x26D8F9.4A204BEA5p0",
"0x31E199.5F5A550DDp0", "0x400C7D.64D3386CBp0", "0x523D82.79EDAEF9Cp0", "0x69993D.D4F2D9524p0",
"0x87975E.854001024p0", "0xAE1A47.C38A42CD0p0", "0xDF8D5F.6DCFE5CEAp0", "0x11F0BF8.1E99FDEB6p0",
"0x1709348.C0EA4F8CEp0", "0x1D94295.464477ACCp0", "0x25FAD90.65C78E342p0", "0x30C4623.616ED2BE2p0",
"0x3E9E441.232817A61p0", "0x506744D.3B342FC94p0", "0x673D70B.C00F1F76Dp0", "0x849012B.C127FC962p0",
"0xAA36C7C.F69370B94p0", "0xDA8F202.DD9ACE661p0", "0x118A2AAE.0AA05236Bp0", "0x16857CFA.1AA8A5555p0",
"0x1CEB088B.68E804021p0", "0x2521AEDA.32CD52BE5p0", "0x2FAD89E1.79BAB8EADp0", "0x3D3838C6.BE0F13F06p0",
"0x4E9B87F6.7BB3F5597p0", "0x64EF201B.01109A4A5p0", "0x819A1801.9394C0D96p0", "0xA6698403.CF5D9E663p0",
"0xD5AD6DCE.21AFFC0DDp0", "0x1125E066B.0B19418CCp0", "0x1604B68CF.05F65FAA9p0", "0x1C45AED0A.D0C934CDCp0",
"0x244D5E676.3FB814AF0p0", "0x2E9CEBF49.9C21839C7p0", "0x3BDA2CBD0.9F5AC2146p0", "0x4CDA0FD41.989F004E7p0",
"0x62ADFED51.D7EDCCDE6p0", "0x7EB50B520.76F91D6E8p0", "0xA2B1FD3D9.A57B6C33Cp0", "0xD0E7A50F4.EF0D7447Fp0",
"0x10C3D39209.62C88AAFBp0", "0x1586D0722B.3EEB27301p0", "0x1BA4068AAC.2B6E3EE34p0", "0x237DCBF1E5.709A9F9C1p0",
"0x2D9264D2D4.D6B94153Bp0", "0x3A83F23B18.FE5BD524Ap0", "0x4B22A1B5C3.27A2FD85Ap0", "0x6079C1866C.71A93951Dp0",
"0x7BE08BDFD9.CC72249ABp0", "0x9F0FB7309C.B446D3919p0", "0xCC3D265776.C3D25779Ep0", "0x1063F7612B0.C0831CA6Cp0",
"0x150BBA37963.79A4FB6ADp0", "0x1B05FA9B62E.737D935B8p0", "0x22B2DC5C41D.AD89559EBp0", "0x2C8DD1AB28B.404414BE7p0",
"0x39355C8C638.0AC5631B1p0", "0x49750434675.301B8D0E7p0", "0x5E521E7A16E.51F9CD3C2p0", "0x791C3B06F8B.EA2DEC48Cp0",
"0x9B823857614.764F43E20p0", "0xC7AD559D438.E7C270C30p0", "0x10063F4E687B.A1A43A35Bp0", "0x149363C905BA.3641D0164p0",
"0x1A6B765D8CDF.6CDBF1C63p0", "0x21EC75240E66.E2891CE63p0", "0x2B8F1073A6AF.BA219DB61p0", "0x37EE3FFC0063.E360F931Fp0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000001p0", "0x0.000000001p0", "0x0.000000002p0",
"0x0.000000002p0", "0x0.000000003p0", "0x0.000000004p0", "0x0.000000005p0",
"0x0.000000007p0", "0x0.000000009p0", "0x0.00000000Bp0", "0x0.00000000Ep0",
"0x0.000000013p0", "0x0.000000018p0", "0x0.00000001Fp0", "0x0.000000028p0",
"0x0.000000034p0", "0x0.000000042p0", "0x0.000000055p0", "0x0.00000006Ep0",
"0x0.00000008Dp0", "0x0.0000000B5p0", "0x0.0000000E9p0", "0x0.00000012Bp0",
"0x0.000000181p0", "0x0.0000001EEp0", "0x0.00000027Ap0", "0x0.00000032Fp0",
"0x0.000000416p0", "0x0.00000053Fp0", "0x0.0000006BDp0", "0x0.0000008A7p0",
"0x0.000000B1Cp0", "0x0.000000E44p0", "0x0.000001252p0", "0x0.000001786p0",
"0x0.000001E35p0", "0x0.0000026C9p0", "0x0.0000031CEp0", "0x0.000003FF3p0",
"0x0.00000521Dp0", "0x0.000006970p0", "0x0.000008762p0", "0x0.00000ADD6p0",
"0x0.00000DF36p0", "0x0.000011E9Cp0", "0x0.000017003p0", "0x0.00001D88Ap0",
"0x0.000025EC0p0", "0x0.000030B15p0", "0x0.00003E85Dp0", "0x0.00005047Ep0",
"0x0.000067153p0", "0x0.0000845C6p0", "0x0.0000A9F46p0", "0x0.0000DA39Ep0",
"0x0.000118354p0", "0x0.000167CB5p0", "0x0.0001CDFC2p0", "0x0.000251334p0",
"0x0.0002F9AF3p0", "0x0.0003D205Ap0", "0x0.0004E7CE2p0", "0x0.00064C7C6p0",
"0x0.000816791p0", "0x0.000A628A3p0", "0x0.000D55A1Fp0", "0x0.00111F30Fp0",
"0x0.0015FC210p0", "0x0.001C3AA91p0", "0x0.00243F374p0", "0x0.002E8ABFCp0",
"0x0.003BC2D73p0", "0x0.004CBC19Ap0", "0x0.006287862p0", "0x0.007E83A56p0",
"0x0.00A2728F8p0", "0x0.00D096336p0", "0x0.010BD4A5Ap0", "0x0.0157E6BFEp0",
"0x0.01B993FE0p0", "0x0.0236FF5BFp0", "0x0.02D80A08Dp0", "0x0.03A6D2222p0",
"0x0.04B0556E0p0", "0x0.0605424D5p0", "0x0.07BB04063p0", "0x0.09ED1B429p0",
"0x0.0CBED8666p0", "0x0.105D93892p0", "0x0.150385C09p0", "0x0.1AFB718E8p0",
"0x0.22A555477p0", "0x0.2C7C72FC0p0", "0x0.391F0EE49p0", "0x0.495860DCAp0",
"0x0.5E2D58D8Bp0", "0x0.78ED03AFBp0", "0x0.9B4597E37p0", "0x0.C75F7CF56p0",
            };
            ap_ufixed<68,32> exp_x_msb_1 = exp_x_msb_1_table[x_msb_ind_1];
            ap_ufixed<140,32> y_lo = exp_x_msb_1 * exp_x_msb_2_3_4_lsb_m_1;
            ap_ufixed<68,32> y_lo_s = y_lo;
            ap_ufixed<68,32> y_l = y_lo_s + exp_x_msb_1;
            y = y_l;
        }
        if (I_<33) {
            bool overf = 0;
#pragma unroll
            for (int j = 63; j >= I_+31; j--) {
                if (y[j])
                    overf = 1;
            }
            if (overf) {
#pragma unroll
                for (int j = 63; j >= I_+31; j--)
                    y[j] = 0;
#pragma unroll
                for (int j = I_+30; j >= 0; j--)
                    y[j] = 1;
            }
        }
        r = y;
    }
    return r;
}


template<int WO_, int I_, int WI_>
ap_fixed<WO_,I_> exp_core(ap_fixed<WI_,I_> x)
{
#pragma HLS pipeline

    const static int FO_ = WO_ - I_;
    const static int FI_ = WI_ - I_;


    if (I_>33) return 0;
    else if (FO_>32) return 0;
    else if (FI_>100) return 0;




    int I_s_;
    int M_ = (I_-1>FO_) ? (I_-1) : FO_;
    if (M_==1) I_s_ = 1;
    else if (M_==2) I_s_ = 2;
    else if (M_<6) I_s_ = 3;
    else if (M_<12) I_s_ = 4;
    else if (M_<24) I_s_ = 5;
    else I_s_ = 6;

    ap_fixed<WO_,I_> r = 0;

    ap_ufixed<1,-FO_> delta = 0;
    delta[0] = 1;

    if (I_s_==1) {






        const static int w = 7;
        const static int we = 2;
        const static int wf = 5;

        ap_fixed<w,we> x_l = x;
        ap_ufixed<3,2> y = 0;
        ap_ufixed<5,0> x_l_fract=0;
        x_l_fract(4,0) = x_l(4,0);


        if (x_l[6]!=x_l[5]) {
            if (!x_l[6]) y = "0x1.8p0";
        } else {
            if (!x_l[6]) y[1] = 1;

            if (!x_l[6]&(x_l[4]|(x_l[2]&x_l[3]))) y[0]=1;
            if (!x_l[6]&x_l[2]&x_l[3]) y[0]=1;
            if (x_l[6]&((x_l[4]&x_l[3])|x_l[5])) y[0] = 1;
            if (x_l[6]&x_l[5]&!x_l[4]&x_l[3]&!x_l[2]&x_l[1]) y[0] = 1;
        }
        y += delta;

            if (y[1]|y[2]) {
                y[2] = 0;
                y[1] = 0;
                y[0] = 1;
            }

        r = y;

    } else if (I_s_==2) {
        const static int w = 10;
        const static int we = 3;
        const static int wf = 7;


        ap_fixed<w,we> x_l = x;
        ap_ufixed<5,3> y = 0;
        ap_fixed<2,2> x_l_int;
        x_l_int(1,0) = x_l(wf+1,wf);
        ap_ufixed<7,0> x_l_fract;
        x_l_fract(6,0) = x_l(6,0);

        ap_uint<5> x_msb_ind;
        x_msb_ind[3] = x_l[w-1];
        x_msb_ind(2,0) = x_l(wf,wf-3);
        ap_ufixed<4,-3> x_lsb = x_l;


        if ((x_l[w-1]!=x_l[w-2])||((x_l_int==1)&&(x_l_fract>=ap_ufixed<wf,0>("0x0.54p0")))) {
            if (!x_l[w-1]) y = "0x3.cp0";
        } else {
            ap_ufixed<5,2> exp_x_msb_table[32] = {
               "0x1.00p0", "0x1.48p0", "0x1.A6p0", "0x2.1Dp0", "0x2.B7p0", "0x3.7Dp0", "0x4.7Bp0", "0x5.C1p0",
               "0x0.22p0", "0x0.2Cp0", "0x0.39p0", "0x0.49p0", "0x0.5Ep0", "0x0.78p0", "0x0.9Bp0", "0x0.C7p0",
            };
            ap_ufixed<5,2> exp_x_msb = exp_x_msb_table[x_msb_ind];


            ap_ufixed<5,0> y_lo = x_lsb * exp_x_msb;

            ap_ufixed<5,2> y_l = y_lo + exp_x_msb;

            y = y_l;
        }
        y += delta;
            bool overf = 0;
#pragma unroll
            for (int j = 4; j >= I_+1; j--) {
                if (y[j])
                    overf = 1;
            }
            if (overf) {
#pragma unroll
                for (int j = 4; j >= I_+1; j--)
                    y[j] = 0;
#pragma unroll
                for (int j = I_; j >= 0; j--)
                    y[j] = 1;
            }
        r = y;
    } else if (I_s_==3) {

        const static int w = 19;
        const static int we = 6;
        const static int wf = 13;

        ap_fixed<w,we> x_l = x;
        ap_ufixed<11,6> y = 0;
        ap_fixed<3,3> x_l_int;
        x_l_int(2,0) = x_l(wf+2,wf);
        ap_ufixed<wf,0> x_l_fract;
        x_l_fract(wf-1,0) = x_l(wf-1,0);




        if ((x_l[w-1]!=x_l[w-2])||(x_l[w-1]!=x_l[w-3])||(x_l[w-1]!=x_l[w-4])||((x_l_int==3)&&(x_l_fract>ap_ufixed<wf,0>("0x0.76FAp0")))) {
            if (!x_l[18]) y = "0x1f.f8p0";
        } else {
            const static int g = 2;
            const static int Maxprecision = FO_+we+g;
            ap_uint<4> x_msb_ind_1;
            x_msb_ind_1[3] = x_l[w-1];

            x_msb_ind_1(2,0) = x_l(wf+1,wf-1);

            ap_uint<6> x_msb_ind_2;
            x_msb_ind_2(5,0) = x_l(wf-2,wf-7);
            ap_ufixed<6,-1> x_msb_2 = x_l;

            ap_ufixed<wf-7,-7> x_lsb = x_l;

            const static ap_ufixed<Maxprecision,0> exp_x_msb_2_m_1_table[64] = {
                "0x0.0p0", "0x0.0202p0", "0x0.0408p0", "0x0.0612p0",
                "0x0.0820p0", "0x0.0A32p0", "0x0.0C49p0", "0x0.0E63p0",
                "0x0.1082p0", "0x0.12A5p0", "0x0.14CDp0", "0x0.16F9p0",
                "0x0.1929p0", "0x0.1B5Dp0", "0x0.1D96p0", "0x0.1FD4p0",
                "0x0.2216p0", "0x0.245Cp0", "0x0.26A7p0", "0x0.28F7p0",
                "0x0.2B4Bp0", "0x0.2DA4p0", "0x0.3001p0", "0x0.3264p0",
                "0x0.34CBp0", "0x0.3737p0", "0x0.39A8p0", "0x0.3C1Ep0",
                "0x0.3E98p0", "0x0.4118p0", "0x0.439Dp0", "0x0.4627p0",
                "0x0.48B5p0", "0x0.4B49p0", "0x0.4DE3p0", "0x0.5081p0",
                "0x0.5325p0", "0x0.55CEp0", "0x0.587Cp0", "0x0.5B2Fp0",
                "0x0.5DE9p0", "0x0.60A7p0", "0x0.636Bp0", "0x0.6635p0",
                "0x0.6904p0", "0x0.6BD9p0", "0x0.6EB3p0", "0x0.7194p0",
                "0x0.747Ap0", "0x0.7766p0", "0x0.7A57p0", "0x0.7D4Fp0",
                "0x0.804Dp0", "0x0.8350p0", "0x0.865Ap0", "0x0.896Ap0",
                "0x0.8C80p0", "0x0.8F9Cp0", "0x0.92BEp0", "0x0.95E7p0",
                "0x0.9916p0", "0x0.9C4Bp0", "0x0.9F87p0", "0x0.A2C9p0",
            };

            ap_ufixed<5,-8> f_x_msb_2_lsb = x_msb_2 * x_lsb;


            ap_ufixed<7,-6> f_x_msb_2_lsb_m_1_m=0;
            f_x_msb_2_lsb_m_1_m(5,0) = x_lsb(5,0);
            f_x_msb_2_lsb_m_1_m = f_x_msb_2_lsb_m_1_m + f_x_msb_2_lsb;


            ap_ufixed<Maxprecision+1,1> exp_x_msb_2_m_1 = exp_x_msb_2_m_1_table[x_msb_ind_2];
            ap_ufixed<Maxprecision,1> exp_x_msb_2_lsb_m_1 = f_x_msb_2_lsb_m_1_m + exp_x_msb_2_m_1;


            const static ap_ufixed<Maxprecision,5> exp_x_msb_1_table[16] = {
                "0x1.0000p0", "0x1.A612p0", "0x2.B7E1p0", "0x4.7B4Fp0",
                "0x7.6399p0", "0xC.2EB7p0", "0x14.15E5p0", "0x21.1D8Ep0",
                "0x0.04B0p0", "0x0.07BBp0", "0x0.0CBEp0", "0x0.1503p0",
                "0x0.22A5p0", "0x0.391Fp0", "0x0.5E2Dp0", "0x0.9B45p0",

            };
            ap_ufixed<Maxprecision,5> exp_x_msb = exp_x_msb_1_table[x_msb_ind_1];

            ap_ufixed<2*Maxprecision+1,6> y_lo = exp_x_msb * exp_x_msb_2_lsb_m_1;
            ap_ufixed<Maxprecision,5> y_lo_s = y_lo;
            ap_ufixed<Maxprecision,5> y_l = y_lo_s + exp_x_msb;
            y = y_l;

        }
        y += delta;

            bool overf = 0;
#pragma unroll
            for (int j = 10; j >= I_+4; j--) {
                if (y[j])
                    overf = 1;
            }
            if (overf) {
#pragma unroll
                for (int j = 10; j >= I_+4; j--)
                    y[j] = 0;
#pragma unroll
                for (int j = I_+3; j >= 0; j--)
                    y[j] = 1;
            }

        r = y;
    } else if (I_s_==4) {

        const static int wf = 25;
        const static int we = 12;
        const static int w = 37;
        ap_fixed<w,we> x_l = x;
        ap_ufixed<23,12> y = 0;
        ap_fixed<4,4> x_l_int;
        x_l_int(3,0) = x_l(wf+3,wf);
        ap_ufixed<wf,0> x_l_fract;
        x_l_fract(wf-1,0) = x_l(wf-1,0);
        bool overf = 0;
#pragma unroll
        for (int j = wf+3; j < w-1; j++)
            if (x_l[w-1]!=x_l[j])
                overf = 1;
        if (overf||((x_l_int==7)&&(x_l_fract>ap_ufixed<wf,0>("0x0.9fe7038p0")))) {
            if (!x_l[w-1]) {
#pragma unroll
                for (int j = 0; j < 22; j++) y[j] = 1;
            }
        } else {
            const static int g = 2;
            const static int Maxprecision = 25;
            ap_uint<5> x_msb_ind_1;
            x_msb_ind_1[4] = x_l[w-1];
            x_msb_ind_1(3,0) = x_l(wf+2,wf-1);

            ap_uint<5> x_msb_ind_2;
            x_msb_ind_2(4,0) = x_l(wf-2,wf-6);
            ap_ufixed<5,-1> x_msb_2 = x_l;

            ap_uint<7> x_msb_ind_3;
            x_msb_ind_3(6,0) = x_l(wf-7,wf-13);
            ap_ufixed<7,-6> x_msb_3 = x_l;

            ap_ufixed<7,-13> x_lsb = x_l;

            const static ap_ufixed<12,-13> f_x_msb_3_m_1_table[128] = {
"0x0.0p0", "0x0.0000002p0", "0x0.0000008p0", "0x0.0000012p0",
"0x0.0000020p0", "0x0.0000032p0", "0x0.0000048p0", "0x0.0000062p0",
"0x0.0000080p0", "0x0.00000A2p0", "0x0.00000C8p0", "0x0.00000F2p0",
"0x0.0000120p0", "0x0.0000152p0", "0x0.0000188p0", "0x0.00001C2p0",
"0x0.0000200p0", "0x0.0000242p0", "0x0.0000288p0", "0x0.00002D2p0",
"0x0.0000320p0", "0x0.0000372p0", "0x0.00003C8p0", "0x0.0000422p0",
"0x0.0000481p0", "0x0.00004E3p0", "0x0.0000549p0", "0x0.00005B3p0",
"0x0.0000621p0", "0x0.0000693p0", "0x0.000070Ap0", "0x0.0000784p0",
"0x0.0000802p0", "0x0.0000884p0", "0x0.000090Bp0", "0x0.0000995p0",
"0x0.0000A23p0", "0x0.0000AB6p0", "0x0.0000B4Cp0", "0x0.0000BE6p0",
"0x0.0000C85p0", "0x0.0000D27p0", "0x0.0000DCEp0", "0x0.0000E78p0",
"0x0.0000F26p0", "0x0.0000FD9p0", "0x0.000108Fp0", "0x0.000114Ap0",
"0x0.0001209p0", "0x0.00012CBp0", "0x0.0001392p0", "0x0.000145Cp0",
"0x0.000152Bp0", "0x0.00015FEp0", "0x0.00016D4p0", "0x0.00017AFp0",
"0x0.000188Ep0", "0x0.0001971p0", "0x0.0001A57p0", "0x0.0001B42p0",
"0x0.0001C31p0", "0x0.0001D24p0", "0x0.0001E1Bp0", "0x0.0001F16p0",
"0x0.0002015p0", "0x0.0002118p0", "0x0.000221Fp0", "0x0.000232Ap0",
"0x0.0002439p0", "0x0.000254Cp0", "0x0.0002663p0", "0x0.000277Fp0",
"0x0.000289Ep0", "0x0.00029C1p0", "0x0.0002AE9p0", "0x0.0002C14p0",
"0x0.0002D43p0", "0x0.0002E77p0", "0x0.0002FAEp0", "0x0.00030EAp0",
"0x0.0003229p0", "0x0.000336Dp0", "0x0.00034B4p0", "0x0.0003600p0",
"0x0.0003750p0", "0x0.00038A4p0", "0x0.00039FBp0", "0x0.0003B57p0",
"0x0.0003CB7p0", "0x0.0003E1Bp0", "0x0.0003F83p0", "0x0.00040EFp0",
"0x0.000425Fp0", "0x0.00043D3p0", "0x0.000454Bp0", "0x0.00046C7p0",
"0x0.0004848p0", "0x0.00049CCp0", "0x0.0004B54p0", "0x0.0004CE1p0",
"0x0.0004E71p0", "0x0.0005006p0", "0x0.000519Ep0", "0x0.000533Bp0",
"0x0.00054DBp0", "0x0.0005680p0", "0x0.0005829p0", "0x0.00059D6p0",
"0x0.0005B86p0", "0x0.0005D3Bp0", "0x0.0005EF4p0", "0x0.00060B1p0",
"0x0.0006272p0", "0x0.0006437p0", "0x0.0006600p0", "0x0.00067CEp0",
"0x0.000699Fp0", "0x0.0006B74p0", "0x0.0006D4Ep0", "0x0.0006F2Bp0",
"0x0.000710Dp0", "0x0.00072F2p0", "0x0.00074DCp0", "0x0.00076CAp0",
"0x0.00078BBp0", "0x0.0007AB1p0", "0x0.0007CABp0", "0x0.0007EA9p0",
            };

            ap_ufixed<6,-19> f_x_msb_3_lsb = x_msb_3 * x_lsb;


            ap_ufixed<12,-13> f_x_msb_3 = f_x_msb_3_m_1_table[x_msb_ind_3];

            ap_ufixed<13,-12> exp_x_msb_3_lsb_m_1_m = 0;
            exp_x_msb_3_lsb_m_1_m(11,0) = f_x_msb_3(11,0);
            exp_x_msb_3_lsb_m_1_m = exp_x_msb_3_lsb_m_1_m + f_x_msb_3_lsb;


            ap_ufixed<19,-6> x_msb_3_lsb = x_l;

            ap_ufixed<20,-5> exp_x_msb_3_lsb_m_1 = 0;
            exp_x_msb_3_lsb_m_1(18,0) = x_msb_3_lsb(18,0);
            exp_x_msb_3_lsb_m_1 = exp_x_msb_3_lsb_m_1+ exp_x_msb_3_lsb_m_1_m;


            const static ap_ufixed<25,0> exp_x_msb_2_m_1_table[32] = {
                "0x0.0000000p0", "0x0.04080a8p0", "0x0.0820560p0", "0x0.0c49238p0",
                "0x0.1082b58p0", "0x0.14cd500p0", "0x0.1929370p0", "0x0.1d96b10p0",
                "0x0.2216048p0", "0x0.26a7790p0", "0x0.2b4b588p0", "0x0.3001ed0p0",
                "0x0.34cb818p0", "0x0.39a8628p0", "0x0.3e98de8p0", "0x0.439d440p0",
                "0x0.48b5e40p0", "0x0.4de30f0p0", "0x0.5325180p0", "0x0.587c540p0",
                "0x0.5de9178p0", "0x0.636bb98p0", "0x0.6904930p0", "0x0.6eb3fc8p0",
                "0x0.747a510p0", "0x0.7a57ee0p0", "0x0.804d300p0", "0x0.865a778p0",
                "0x0.8c80248p0", "0x0.92be998p0", "0x0.99163b0p0", "0x0.9f876e8p0",
            };
            ap_ufixed<25, 0> exp_x_msb_2_m_1 = exp_x_msb_2_m_1_table[x_msb_ind_2];

            ap_ufixed<50,-5> f_x_msb_2_3_lsb = exp_x_msb_2_m_1 * exp_x_msb_3_lsb_m_1;
            ap_ufixed<20,-5> f_x_msb_2_3_lsb_s = f_x_msb_2_3_lsb;
            ap_ufixed<25, 0> exp_x_msb_2_3_lsb_m_1 = f_x_msb_2_3_lsb_s + exp_x_msb_3_lsb_m_1 + exp_x_msb_2_m_1;


            const static ap_ufixed<25,11> exp_x_msb_1_table[32] = {
                "0x1.0000p0", "0x1.a614p0", "0x2.b7e0p0", "0x4.7b50p0",
                "0x7.6398p0", "0xc.2eb8p0", "0x14.15e4p0", "0x21.1d90p0",
                "0x36.9920p0", "0x5a.0464p0", "0x94.69c4p0", "0xf4.b124p0",
                "0x193.6dc4p0", "0x299.2444p0", "0x448.a218p0", "0x710.0adcp0",
                "0x0.0014p0", "0x0.0024p0", "0x0.003cp0", "0x0.0064p0",
                "0x0.00a4p0", "0x0.010cp0", "0x0.01b8p0", "0x0.02d8p0",
                "0x0.04b0p0", "0x0.07bcp0", "0x0.0cc0p0", "0x0.1504p0",
                "0x0.22a4p0", "0x0.3920p0", "0x0.5e2cp0", "0x0.9b44p0",
            };
            ap_ufixed<25,11> exp_x_msb_1 = exp_x_msb_1_table[x_msb_ind_1];


            ap_ufixed<50,11> y_lo = exp_x_msb_1 * exp_x_msb_2_3_lsb_m_1;

            ap_ufixed<25,11> y_lo_s = y_lo;

            ap_ufixed<25,11> y_l = y_lo_s + exp_x_msb_1;

            y = y_l;

        }
        y += delta;

            overf = 0;
#pragma unroll
            for (int j = 22; j >= I_+10; j--) {
                if (y[j])
                    overf = 1;
            }
            if (overf) {
#pragma unroll
                for (int j = 22; j >= I_+10; j--)
                    y[j] = 0;
#pragma unroll
                for (int j = I_+9; j >= 0; j--)
                    y[j] = 1;
            }

        r = y;
    } else if (I_s_==5) {

        if(WI_>73) return 0;
        const static int we = 24;
        const static int wf = 49;
        const static int w = 73;
        ap_fixed<w,we> x_l = x;
        ap_ufixed<47,24> y = 0;
        ap_fixed<5,5> x_l_int;
        x_l_int(4,0) = x_l(wf+4,wf);
        ap_ufixed<wf,0> x_l_fract;
        x_l_fract(wf-1,0) = x_l(wf-1,0);
        bool overf = 0;
#pragma unroll
        for (int j = wf+4; j < w-1; j++)
            if (x_l[w-1]!=x_l[j])
                overf = 1;

        if (overf||((x_l_int==15)&&(x_l_fract>=ap_ufixed<wf,0>("0x0.F1402743D99F8p0")))) {
            if (!x_l[w-1]) {
#pragma unroll
                for (int j = 0; j < 46; j++) y[j] = 1;
            }
        } else {
            const static int g=4;
            const static int Maxprecision = 51;
            ap_uint<8> x_msb_ind_1;
            x_msb_ind_1[7] = x_l[w-1];
            x_msb_ind_1(6,0) = x_l(wf+3,wf-3);

            ap_uint<8> x_msb_ind_2;
            x_msb_ind_2(7,0) = x_l(wf-4,wf-11);
            ap_uint<5> x_msb_ind_3;
            x_msb_ind_3(4,0) = x_l(wf-12,wf-16);
            ap_uint<3> x_msb_ind_4;
            x_msb_ind_4(2,0) = x_l(wf-17,wf-19);

            ap_uint<6> x_msb_ind_5;
            x_msb_ind_5(5,0) = x_l(wf-20,wf-25);

            ap_ufixed<8, -3> x_msb_2 = x_l;
            ap_ufixed<5,-11> x_msb_3 = x_l;
            ap_ufixed<3,-16> x_msb_4 = x_l;
            ap_ufixed<6,-19> x_msb_5 = x_l;

            ap_ufixed<7,-25> x_lsb = x_l;

            const static ap_ufixed<12,-39> f_x_msb_5_table[64] = {
"0x0.0000000000000p0", "0x0.0000000000002p0", "0x0.0000000000008p0", "0x0.0000000000012p0",
"0x0.0000000000020p0", "0x0.0000000000032p0", "0x0.0000000000048p0", "0x0.0000000000062p0",
"0x0.0000000000080p0", "0x0.00000000000A2p0", "0x0.00000000000C8p0", "0x0.00000000000F2p0",
"0x0.0000000000120p0", "0x0.0000000000152p0", "0x0.0000000000188p0", "0x0.00000000001C2p0",
"0x0.0000000000200p0", "0x0.0000000000242p0", "0x0.0000000000288p0", "0x0.00000000002D2p0",
"0x0.0000000000320p0", "0x0.0000000000372p0", "0x0.00000000003C8p0", "0x0.0000000000422p0",
"0x0.0000000000480p0", "0x0.00000000004E2p0", "0x0.0000000000548p0", "0x0.00000000005B2p0",
"0x0.0000000000620p0", "0x0.0000000000692p0", "0x0.0000000000708p0", "0x0.0000000000782p0",
"0x0.0000000000800p0", "0x0.0000000000882p0", "0x0.0000000000908p0", "0x0.0000000000992p0",
"0x0.0000000000A20p0", "0x0.0000000000AB2p0", "0x0.0000000000B48p0", "0x0.0000000000BE2p0",
"0x0.0000000000C80p0", "0x0.0000000000D22p0", "0x0.0000000000DC8p0", "0x0.0000000000E72p0",
"0x0.0000000000F20p0", "0x0.0000000000FD2p0", "0x0.0000000001088p0", "0x0.0000000001142p0",
"0x0.0000000001200p0", "0x0.00000000012C2p0", "0x0.0000000001388p0", "0x0.0000000001452p0",
"0x0.0000000001520p0", "0x0.00000000015F2p0", "0x0.00000000016C8p0", "0x0.00000000017A2p0",
"0x0.0000000001880p0", "0x0.0000000001962p0", "0x0.0000000001A48p0", "0x0.0000000001B32p0",
"0x0.0000000001C20p0", "0x0.0000000001D12p0", "0x0.0000000001E08p0", "0x0.0000000001F02p0",

            };
            ap_ufixed<12,-39> f_x_msb_5 = f_x_msb_5_table[x_msb_ind_5];

            const static ap_ufixed<7,-33> f_x_msb_4_table[8] = {
"0x0.0000000000p0", "0x0.0000000002p0", "0x0.0000000008p0", "0x0.0000000012p0",
"0x0.0000000020p0", "0x0.0000000032p0", "0x0.0000000048p0", "0x0.0000000062p0",
            };
            ap_ufixed<7,-33> f_x_msb_4 = f_x_msb_4_table[x_msb_ind_4];

            ap_ufixed<7,-44> f_x_msb_5_lsb = x_msb_5 * x_lsb;

            ap_ufixed<16,-19> x_msb_5_lsb = x_l;

            ap_ufixed<19,-35> f_x_msb_4_5_lsb = x_msb_5_lsb * x_msb_4;
            ap_ufixed<16,-35> f_x_msb_4_5_lsb_s = f_x_msb_4_5_lsb;

            ap_ufixed<13,-38> exp_x_msb_4_5_lsb_m_1_m3 = 0;
            exp_x_msb_4_5_lsb_m_1_m3(11,0)=f_x_msb_5(11,0);
            exp_x_msb_4_5_lsb_m_1_m3 = exp_x_msb_4_5_lsb_m_1_m3+f_x_msb_5_lsb;

            ap_ufixed<17,-34> exp_x_msb_4_5_lsb_m_1_m4 = 0;
            exp_x_msb_4_5_lsb_m_1_m4(15,0)=f_x_msb_4_5_lsb_s(15,0);
            exp_x_msb_4_5_lsb_m_1_m4 = exp_x_msb_4_5_lsb_m_1_m4 + f_x_msb_4_5_lsb_s;

            ap_ufixed<8,-32> exp_x_msb_4_5_lsb_m_1_m5_s = 0;
            exp_x_msb_4_5_lsb_m_1_m5_s(5,0)=exp_x_msb_4_5_lsb_m_1_m4(16,11);
            exp_x_msb_4_5_lsb_m_1_m5_s = f_x_msb_4+exp_x_msb_4_5_lsb_m_1_m5_s;

            ap_ufixed<19,-32> exp_x_msb_4_5_lsb_m_1_m5 = exp_x_msb_4_5_lsb_m_1_m5_s;
            exp_x_msb_4_5_lsb_m_1_m5(10,0)=exp_x_msb_4_5_lsb_m_1_m4(10,0);

            ap_ufixed<32,-15> exp_x_msb_4_5_lsb_m_1_m6 = 0;
            ap_ufixed<wf-16,-16> x_msb_4_5_lsb = x_l;
            exp_x_msb_4_5_lsb_m_1_m6(14,0) = exp_x_msb_4_5_lsb_m_1_m5(18,4);
            exp_x_msb_4_5_lsb_m_1_m6 = exp_x_msb_4_5_lsb_m_1_m6 + x_msb_4_5_lsb;
            ap_ufixed<36,-15> exp_x_msb_4_5_lsb_m_1 = exp_x_msb_4_5_lsb_m_1_m6;
            exp_x_msb_4_5_lsb_m_1(3,0) = exp_x_msb_4_5_lsb_m_1_m5(3,0);


            const static ap_ufixed<32,-23> f_x_msb_3_table[32] = {
"0x0.00000000000000p0", "0x0.0000000080002ap0", "0x0.00000002000156p0", "0x0.00000004800480p0",
"0x0.00000008000aaap0", "0x0.0000000c8014d6p0", "0x0.00000012002400p0", "0x0.0000001880392cp0",
"0x0.00000020005556p0", "0x0.00000028807982p0", "0x0.0000003200a6acp0", "0x0.0000003c80ddd8p0",
"0x0.00000048012004p0", "0x0.00000054816e30p0", "0x0.0000006201c95cp0", "0x0.00000070823288p0",
"0x0.0000008002aab6p0", "0x0.000000908332e2p0", "0x0.000000a203cc12p0", "0x0.000000b4847740p0",
"0x0.000000c8053570p0", "0x0.000000dc8607a0p0", "0x0.000000f206eed0p0", "0x0.0000010887ec02p0",
"0x0.00000120090036p0", "0x0.000001388a2c6ap0", "0x0.000001520b71a0p0", "0x0.0000016c8cd0d6p0",
"0x0.000001880e4b0ep0", "0x0.000001a48fe148p0", "0x0.000001c2119484p0", "0x0.000001e09365c0p0",
            };

            ap_ufixed<32,-23> f_x_msb_3 = f_x_msb_3_table[x_msb_ind_3];
            ap_ufixed<44,-11> exp_x_msb_3_m_1 = 0;
            exp_x_msb_3_m_1(43,39) = x_msb_3(4,0);
            exp_x_msb_3_m_1(31, 0) = f_x_msb_3(31,0);


            ap_ufixed<80,-26> f_x_msb_3_4_lsb = exp_x_msb_3_m_1 * exp_x_msb_4_5_lsb_m_1;
            ap_ufixed<31,-26> f_x_msb_3_4_lsb_s = f_x_msb_3_4_lsb;
            ap_ufixed<48,-10> exp_x_msb_3_4_lsb_m_1 = f_x_msb_3_4_lsb_s + exp_x_msb_3_m_1 + exp_x_msb_4_5_lsb_m_1;


            const static ap_ufixed<46,-6> f_x_msb_2_table[256] = {
"0x0.0p0", "0x0.0000020015560p0", "0x0.00000800AAB55p0", "0x0.0000120240360p0",
"0x0.0000200556001p0", "0x0.0000320A6C4B8p0", "0x0.0000481203608p0", "0x0.0000621C9B971p0",
"0x0.0000802AB5577p0", "0x0.0000A23CD119Dp0", "0x0.0000C8536F668p0", "0x0.0000F26F10D5Dp0",
"0x0.0001209036103p0", "0x0.000152B75FCE3p0", "0x0.000188E50ED86p0", "0x0.0001C319C4077p0",
"0x0.0002015600445p0", "0x0.0002439A4487Ep0", "0x0.000289E711DB3p0", "0x0.0002D43CE9577p0",
"0x0.0003229C4C260p0", "0x0.00037505BB805p0", "0x0.0003CB79B8B01p0", "0x0.000425F8C50F2p0",
"0x0.0004848362076p0", "0x0.0004E71A11131p0", "0x0.00054DBD53BC8p0", "0x0.0005B86DAB9E3p0",
"0x0.0006272B9A630p0", "0x0.000699F7A1C5Dp0", "0x0.000710D24391Ep0", "0x0.00078BBC01A29p0",
"0x0.00080AB55DE39p0", "0x0.00088DBEDA50Bp0", "0x0.000914D8F8F63p0", "0x0.0009A0043BF07p0",
"0x0.000A2F41256C2p0", "0x0.000AC29037A63p0", "0x0.000B59F1F4EBDp0", "0x0.000BF566DF9AAp0",
"0x0.000C94EF7A206p0", "0x0.000D388C46FB4p0", "0x0.000DE03DC8B9Bp0", "0x0.000E8C0481FA7p0",
"0x0.000F3BE0F56CAp0", "0x0.000FEFD3A5CFAp0", "0x0.0010A7DD15F36p0", "0x0.001163FDC8B7Fp0",
"0x0.00122436410DDp0", "0x0.0012E88701F5Ep0", "0x0.0013B0F08E817p0", "0x0.00147D7369D22p0",
"0x0.00154E101719Fp0", "0x0.001622C7199B7p0", "0x0.0016FB98F4A96p0", "0x0.0017D8862BA72p0",
"0x0.0018B98F42084p0", "0x0.00199EB4BB511p0", "0x0.001A87F71B161p0", "0x0.001B7556E4FC4p0",
"0x0.001C66D49CB93p0", "0x0.001D5C70C612Dp0", "0x0.001E562BE4DFAp0", "0x0.001F54067D067p0",
"0x0.00205601127ECp0", "0x0.00215C1C29507p0", "0x0.0022665845940p0", "0x0.002374B5EB724p0",
"0x0.002487359F24Cp0", "0x0.00259DD7E4F57p0", "0x0.0026B89D413EFp0", "0x0.0027D786386C4p0",
"0x0.0028FA934EF90p0", "0x0.002A21C509717p0", "0x0.002B4D1BEC726p0", "0x0.002C7C987CA92p0",
"0x0.002DB03B3ED3Ap0", "0x0.002EE804B7C07p0", "0x0.003023F56C4ECp0", "0x0.0031640DE16E3p0",
"0x0.0032A84E9C1F5p0", "0x0.0033F0B821730p0", "0x0.00353D4AF68B0p0", "0x0.00368E07A0999p0",
"0x0.0037E2EEA4E19p0", "0x0.00393C0088B6Cp0", "0x0.003A993DD17D5p0", "0x0.003BFAA704AA3p0",
"0x0.003D603CA7C32p0", "0x0.003EC9FF405E6p0", "0x0.004037EF54230p0", "0x0.0041AA0D68C8Cp0",
"0x0.0043205A04182p0", "0x0.00449AD5ABEA5p0", "0x0.00461980E6294p0", "0x0.00479C5C38CF9p0",
"0x0.0049236829E8Bp0", "0x0.004AAEA53F90Ep0", "0x0.004C3E13FFF51p0", "0x0.004DD1B4F152Fp0",
"0x0.004F698899F90p0", "0x0.0051058F8046Ap0", "0x0.0052A5CA2AABFp0", "0x0.00544A391FA9Cp0",
"0x0.0055F2DCE5D1Ep0", "0x0.00579FB603C6Ep0", "0x0.005950C5003C2p0", "0x0.005B060A61F5Dp0",
"0x0.005CBF86AFC91p0", "0x0.005E7D3A709BEp0", "0x0.00603F262B650p0", "0x0.0062054A672C2p0",
"0x0.0063CFA7AB09Dp0", "0x0.00659E3E7E278p0", "0x0.0067710F67BFAp0", "0x0.0069481AEF1D5p0",
"0x0.006B23619B9CFp0", "0x0.006D02E3F4AB7p0", "0x0.006EE6A281C6Fp0", "0x0.0070CE9DCA7E6p0",
"0x0.0072BAD65671Bp0", "0x0.0074AB4CAD51Cp0", "0x0.0076A00156E07p0", "0x0.007898F4DAF09p0",
"0x0.007A9627C165Fp0", "0x0.007C979A92356p0", "0x0.007E9D4DD564Ap0", "0x0.0080A742130A8p0",
"0x0.0082B577D34EDp0", "0x0.0084C7EF9E6A7p0", "0x0.0086DEA9FCA73p0", "0x0.0088F9A776601p0",
"0x0.008B18E894010p0", "0x0.008D3C6DDE06Fp0", "0x0.008F6437DD000p0", "0x0.00919047198B6p0",
"0x0.0093C09C1C595p0", "0x0.0095F5376E2B2p0", "0x0.00982E1997D33p0", "0x0.009A6B4322352p0",
"0x0.009CACB496458p0", "0x0.009EF26E7D0A2p0", "0x0.00A13C715F99Ep0", "0x0.00A38ABDC71CEp0",
"0x0.00A5DD543CCC4p0", "0x0.00A8343549F26p0", "0x0.00AA8F6177EADp0", "0x0.00ACEED950222p0",
"0x0.00AF529D5C165p0", "0x0.00B1BAAE25566p0", "0x0.00B4270C3582Ap0", "0x0.00B697B8164C7p0",
"0x0.00B90CB25176Ap0", "0x0.00BB85FB70D50p0", "0x0.00BE0393FE4CCp0", "0x0.00C0857C83D44p0",
"0x0.00C30BB58B732p0", "0x0.00C5963F9F424p0", "0x0.00C8251B496BEp0", "0x0.00CAB849142B5p0",
"0x0.00CD4FC989CD6p0", "0x0.00CFEB9D34B00p0", "0x0.00D28BC49F428p0", "0x0.00D5304054059p0",
"0x0.00D7D910DD8B1p0", "0x0.00DA8636C6764p0", "0x0.00DD37B2997BCp0", "0x0.00DFED84E1618p0",
"0x0.00E2A7AE28FECp0", "0x0.00E5662EFB3C3p0", "0x0.00E82907E313Dp0", "0x0.00EAF0396B910p0",
"0x0.00EDBBC41FD08p0", "0x0.00F08BA88B009p0", "0x0.00F35FE73860Bp0", "0x0.00F63880B341Ep0",
"0x0.00F9157587069p0", "0x0.00FBF6C63F228p0", "0x0.00FEDC73671B0p0", "0x0.0101C67D8A86Cp0",
"0x0.0104B4E5350DFp0", "0x0.0107A7AAF26A2p0", "0x0.010A9ECF4E667p0", "0x0.010D9A52D4DF8p0",
"0x0.01109A3611C34p0", "0x0.01139E7991116p0", "0x0.0116A71DDEDADp0", "0x0.0119B42387423p0",
"0x0.011CC58B167B9p0", "0x0.011FDB5518CCAp0", "0x0.0122F5821A8C7p0", "0x0.01261412A823Cp0",
"0x0.012937074E0CDp0", "0x0.012C5E6098D37p0", "0x0.012F8A1F15151p0", "0x0.0132BA434F80Ap0",
"0x0.0135EECDD4D6Cp0", "0x0.013927BF31E98p0", "0x0.013C6517F39CCp0", "0x0.013FA6D8A6E5Dp0",
"0x0.0142ED01D8CBCp0", "0x0.0146379416673p0", "0x0.0149868FECE26p0", "0x0.014CD9F5E9795p0",
"0x0.015031C699799p0", "0x0.01538E028A426p0", "0x0.0156EEAA4944Bp0", "0x0.015A53BE64033p0",
"0x0.015DBD3F68122p0", "0x0.01612B2DE3178p0", "0x0.01649D8A62CB1p0", "0x0.0168145574F65p0",
"0x0.016B8F8FA7745p0", "0x0.016F0F3988321p0", "0x0.01729353A52E4p0", "0x0.01761BDE8C792p0",
"0x0.0179A8DACC350p0", "0x0.017D3A48F295Dp0", "0x0.0180D0298DE13p0", "0x0.01846A7D2C6ECp0",
"0x0.018809445CA7Bp0", "0x0.018BAC7FAD074p0", "0x0.018F542FAC1A4p0", "0x0.01930054E87F8p0",
"0x0.0196B0EFF0E79p0", "0x0.019A66015414Dp0", "0x0.019E1F89A0DBAp0", "0x0.01A1DD8966221p0",
"0x0.01A5A00132E02p0", "0x0.01A966F1961FCp0", "0x0.01AD325B1EFC9p0", "0x0.01B1023E5CA45p0",
"0x0.01B4D69BDE569p0", "0x0.01B8AF743364Cp0", "0x0.01BC8CC7EB323p0", "0x0.01C06E9795345p0",
"0x0.01C454E3C0F24p0", "0x0.01C83FACFE054p0", "0x0.01CC2EF3DC187p0", "0x0.01D022B8EAE8Fp0",
"0x0.01D41AFCBA45Ep0", "0x0.01D817BFDA104p0", "0x0.01DC1902DA3B1p0", "0x0.01E01EC64ACB7p0",
"0x0.01E4290ABBD87p0", "0x0.01E837D0BD8B2p0", "0x0.01EC4B18E01E9p0", "0x0.01F062E3B3DFEp0",
"0x0.01F47F31C92E4p0", "0x0.01F8A003B07AFp0", "0x0.01FCC559FA492p0", "0x0.0200EF35372E4p0",
"0x0.02051D95F7D1Cp0", "0x0.0209507CCCED1p0", "0x0.020D87EA474BEp0", "0x0.0211C3DEF7CBDp0",
            };
            ap_ufixed<46,-6> f_x_msb_2 = f_x_msb_2_table[x_msb_ind_2];
            ap_ufixed< 5,-6> f_x_msb_2_h;
            f_x_msb_2_h(4,0) = f_x_msb_2(45,41);
            ap_ufixed< 9,-2> exp_x_msb_2_m_1_h = f_x_msb_2_h + x_msb_2;
            ap_ufixed<50,-2> exp_x_msb_2_m_1;
            exp_x_msb_2_m_1(49,41) = exp_x_msb_2_m_1_h(8,0);
            exp_x_msb_2_m_1(40, 0) = f_x_msb_2(40,0);

            ap_ufixed<98,-12> f_x_msb_2_3_4_lsb = exp_x_msb_2_m_1 * exp_x_msb_3_4_lsb_m_1;
            ap_ufixed<46,-12> f_x_msb_2_3_4_lsb_s = f_x_msb_2_3_4_lsb;
            ap_ufixed<50,-2> exp_x_msb_2_3_4_lsb_m_1 = f_x_msb_2_3_4_lsb_s + exp_x_msb_2_m_1 + exp_x_msb_3_4_lsb_m_1;

            const static ap_ufixed<50,23> exp_x_msb_1_table[256] = {
"0x1.0000000p0", "0x1.2216045p0", "0x1.48B5E3Cp0", "0x1.747A513p0",
"0x1.A61298Ep0", "0x1.DE455DFp0", "0x2.1DF3B68p0", "0x2.661CB0Fp0",
"0x2.B7E1516p0", "0x3.1489176p0", "0x3.7D871DBp0", "0x3.F47FE87p0",
"0x4.7B4FF99p0", "0x5.1413452p0", "0x5.C12DA41p0", "0x6.855466Ep0",
"0x7.63992E3p0", "0x8.5F7635Bp0", "0x9.7CDC417p0", "0xA.C042667p0",
"0xC.2EB7EC9p0", "0xD.CDF892Ep0", "0xF.A48385Ep0", "0x11.B9B5652p0",
"0x14.15E5BF6p0", "0x16.C2887C1p0", "0x19.CA53B78p0", "0x1D.396AA97p0",
"0x21.1D8E427p0", "0x25.865441Cp0", "0x2A.8565A14p0", "0x30.2EC550Bp0",
"0x36.99205C4p0", "0x3D.DE28BF3p0", "0x46.1AFC4DBp0", "0x4F.7099532p0",
"0x5A.0462B78p0", "0x66.00B5BC9p0", "0x73.9593ABBp0", "0x82.F9621ADp0",
"0x94.69C4CB8p0", "0xA8.2C948C1p0", "0xBE.90F6F83p0", "0xD7.F09B78Cp0",
"0xF4.B122790p0", "0x115.45B4704p0", "0x13A.30CF1CCp0", "0x164.0650296p0",
"0x193.6DC5690p0", "0x1C9.250BEDCp0", "0x206.03487A3p0", "0x24A.FC4533Cp0",
"0x299.2442102p0", "0x2F1.B447462p0", "0x356.0F0B0F9p0", "0x3C7.C67E5BEp0",
"0x448.A216ABBp0", "0x4DA.A5EE46Ap0", "0x580.1AD754Fp0", "0x63B.9782341p0",
"0x710.0ADBAC7p0", "0x800.C7CC8E3p0", "0x911.9289C39p0", "0xA46.AFAA2ADp0",
"0xBA4.F53EA38p0", "0xD31.DE30C52p0", "0xEF3.A035D57p0", "0x10F1.44ADE60p0",
"0x1332.C4D2B7Cp0", "0x15C1.29A744Cp0", "0x18A6.B027DA0p0", "0x1BEE.F24BB12p0",
"0x1FA7.157C470p0", "0x23DD.FF3C8BAp0", "0x28A4.90D2CCEp0", "0x2E0D.EAE454Bp0",
"0x342F.BA11823p0", "0x3B22.8DC5359p0", "0x4302.3A933EEp0", "0x4BEE.49AFCDCp0",
"0x560A.773E541p0", "0x617F.4171BF9p0", "0x6E7A.8ABB4A8p0", "0x7D30.5191764p0",
"0x8DDB.80AF426p0", "0xA0BE.DB0DB10p0", "0xB626.0748BAEp0", "0xCE66.BE9EAADp0",
"0xE9E2.2447727p0", "0x10906.4A831F8p0", "0x12C4F.EB75B2Ap0", "0x1544C.5CB6133p0",
"0x1819B.C560F61p0", "0x1B4F3.9F8AF64p0", "0x1EF21.8F1B001p0", "0x2310E.996C40Fp0",
"0x27BC2.CA9A6F9p0", "0x2D069.571279Ap0", "0x33055.49F35D9p0", "0x39D06.D2FEF17p0",
"0x41831.49596E9p0", "0x4A3C1.FB2AC39p0", "0x541E7.E56949Dp0", "0x5F51C.72B7532p0",
"0x6C02D.645AB25p0", "0x7A648.0CFF534p0", "0x8AB06.0A3EE9Fp0", "0x9D27B.AFE4CF1p0",
"0xB2148.5EAE56Cp0", "0xC9CA9.07F86EFp0", "0xE4A8D.2881EDBp0", "0x1031AE.8E4996Cp0",
"0x1259AC.48BF05Dp0", "0x14CB29.2F2B31Fp0", "0x178FEE.7792E44p0", "0x1AB312.E89CD0Dp0",
"0x1E4127.437732Bp0", "0x224868.979FC2Ep0", "0x26D8F9.4A204BEp0", "0x2C0521.B4A8E0Bp0",
"0x31E199.5F5A550p0", "0x3885D9.FA89D00p0", "0x400C7D.64D3386p0", "0x4893A8.361032Dp0",
"0x523D82.79EDAEFp0", "0x5D30C0.7DAB686p0", "0x69993D.D4F2D95p0", "0x77A8AD.02A7C71p0",
"0x0.000001Ep0", "0x0.0000022p0", "0x0.0000026p0", "0x0.000002Bp0",
"0x0.0000031p0", "0x0.0000038p0", "0x0.000003Fp0", "0x0.0000048p0",
"0x0.0000052p0", "0x0.000005Dp0", "0x0.0000069p0", "0x0.0000077p0",
"0x0.0000087p0", "0x0.0000099p0", "0x0.00000ADp0", "0x0.00000C4p0",
"0x0.00000DFp0", "0x0.00000FCp0", "0x0.000011Ep0", "0x0.0000144p0",
"0x0.0000170p0", "0x0.00001A1p0", "0x0.00001D8p0", "0x0.0000217p0",
"0x0.000025Ep0", "0x0.00002AFp0", "0x0.000030Bp0", "0x0.0000372p0",
"0x0.00003E8p0", "0x0.000046Dp0", "0x0.0000504p0", "0x0.00005AFp0",
"0x0.0000671p0", "0x0.000074Cp0", "0x0.0000845p0", "0x0.000095Fp0",
"0x0.0000A9Fp0", "0x0.0000C09p0", "0x0.0000DA3p0", "0x0.0000F74p0",
"0x0.0001183p0", "0x0.00013D8p0", "0x0.000167Cp0", "0x0.000197Bp0",
"0x0.0001CDFp0", "0x0.00020B7p0", "0x0.0002513p0", "0x0.0002A02p0",
"0x0.0002F9Ap0", "0x0.00035F1p0", "0x0.0003D20p0", "0x0.0004543p0",
"0x0.0004E7Cp0", "0x0.00058F0p0", "0x0.00064C7p0", "0x0.0007232p0",
"0x0.0008167p0", "0x0.00092A2p0", "0x0.000A628p0", "0x0.000BC48p0",
"0x0.000D55Ap0", "0x0.000F1C2p0", "0x0.00111F3p0", "0x0.001366Cp0",
"0x0.0015FC2p0", "0x0.0018E98p0", "0x0.001C3AAp0", "0x0.001FFCEp0",
"0x0.00243F3p0", "0x0.002912Bp0", "0x0.002E8ABp0", "0x0.0034BD2p0",
"0x0.003BC2Dp0", "0x0.0043B7Dp0", "0x0.004CBC1p0", "0x0.0056F3Ap0",
"0x0.0062878p0", "0x0.006FA5Fp0", "0x0.007E83Ap0", "0x0.008F5C0p0",
"0x0.00A2728p0", "0x0.00B813Bp0", "0x0.00D0963p0", "0x0.00EC5C1p0",
"0x0.010BD4Ap0", "0x0.012F7DEp0", "0x0.0157E6Bp0", "0x0.0185B0Fp0",
"0x0.01B993Fp0", "0x0.01F45F9p0", "0x0.0236FF5p0", "0x0.02827E0p0",
"0x0.02D80A0p0", "0x0.0338F9Fp0", "0x0.03A6D22p0", "0x0.04234A7p0",
"0x0.04B0556p0", "0x0.0550280p0", "0x0.0605424p0", "0x0.06D279Ap0",
"0x0.07BB040p0", "0x0.08C284Cp0", "0x0.09ED1B4p0", "0x0.0B3F736p0",
"0x0.0CBED86p0", "0x0.0E7149Cp0", "0x0.105D938p0", "0x0.128B697p0",
"0x0.150385Cp0", "0x0.17CFCC2p0", "0x0.1AFB718p0", "0x0.1E9328Bp0",
"0x0.22A5554p0", "0x0.2742456p0", "0x0.2C7C72Fp0", "0x0.3268CDBp0",
"0x0.391F0EEp0", "0x0.40BA188p0", "0x0.495860Dp0", "0x0.531C6C9p0",
"0x0.5E2D58Dp0", "0x0.6AB7782p0", "0x0.78ED03Ap0", "0x0.8906E49p0",
"0x0.9B4597Ep0", "0x0.AFF230Ap0", "0x0.C75F7CFp0", "0x0.E1EB512p0",
            };
            ap_ufixed<50,23> exp_x_msb_1 = exp_x_msb_1_table[x_msb_ind_1];

            ap_ufixed<100,21> y_lo = exp_x_msb_1 * exp_x_msb_2_3_4_lsb_m_1;
            ap_ufixed<48,21> y_lo_s = y_lo;
            ap_ufixed<50,23> y_l = y_lo_s + exp_x_msb_1;
            y = y_l;
        }
        y += delta;

            overf = 0;
#pragma unroll
            for (int j = 46; j >= I_+22; j--) {
                if (y[j])
                    overf = 1;
            }
            if (overf) {
#pragma unroll
                for (int j = 46; j >= I_+22; j--)
                    y[j] = 0;
#pragma unroll
                for (int j = I_+21; j >= 0; j--)
                    y[j] = 1;
            }

        r = y;
    } else {
        const static int wf = 67;
        const static int we = 33;
        const static int w = 100;
        ap_fixed<w,we> x_l = x;


        ap_ufixed<65,33> y = 0;

        ap_fixed<6,6> x_l_int;
        x_l_int(5,0) = x_l(wf+5,wf);


        ap_ufixed<wf,0> x_l_fract;
        x_l_fract(wf-1,0) = x_l(wf-1,0);

        bool overf = 0;
#pragma unroll
        for (int j = wf+5; j < w-1; j++)
            if (x_l[w-1]!=x_l[j])
                overf = 1;
        if (overf||(x_l_int>22)||((x_l_int==22)&&(x_l_fract>=ap_ufixed<wf,0>("0x0.2E42FEFA39EF35783p0")))) {
            if (!x_l[w-1]) {
#pragma unroll
                for (int j = 0; j < 64; j++) y[j] = 1;
            }
        } else {
            const static int g=4;
            const static int Maxprecision=69;
            ap_uint<8> x_msb_ind_1;
            x_msb_ind_1[7] = x_l[w-1];

            x_msb_ind_1(6,0) = x_l(wf+4,wf-2);
            ap_uint<8> x_msb_ind_2;
            x_msb_ind_2(7,0) = x_l(wf-3,wf-10);
            ap_uint<8> x_msb_ind_3;
            x_msb_ind_3(7,0) = x_l(wf-11,wf-18);
            ap_uint<8> x_msb_ind_4;
            x_msb_ind_4(7,0) = x_l(wf-19,wf-26);

            ap_uint<8> x_msb_ind_5;
            x_msb_ind_5(7,0) = x_l(wf-27,wf-34);

            ap_ufixed<8, -2> x_msb_2 = x_l;
            ap_ufixed<8,-10> x_msb_3 = x_l;
            ap_ufixed<8,-18> x_msb_4 = x_l;
            ap_ufixed<8,-26> x_msb_5 = x_l;
            ap_ufixed<9,-34> x_lsb = x_l;

            const static ap_ufixed<32,-37> f_x_msb_4_table[256] = {
"0x0.000000000000000000p0", "0x0.000000000000080000p0", "0x0.000000000000200000p0", "0x0.000000000000480000p0",
"0x0.000000000000800000p0", "0x0.000000000000C80000p0", "0x0.000000000001200000p0", "0x0.000000000001880000p0",
"0x0.000000000002000001p0", "0x0.000000000002880001p0", "0x0.000000000003200002p0", "0x0.000000000003C80003p0",
"0x0.000000000004800004p0", "0x0.000000000005480005p0", "0x0.000000000006200007p0", "0x0.000000000007080008p0",
"0x0.00000000000800000Ap0", "0x0.00000000000908000Cp0", "0x0.00000000000A20000Fp0", "0x0.00000000000B480011p0",
"0x0.00000000000C800014p0", "0x0.00000000000DC80018p0", "0x0.00000000000F20001Bp0", "0x0.00000000001088001Fp0",
"0x0.000000000012000024p0", "0x0.000000000013880028p0", "0x0.00000000001520002Dp0", "0x0.000000000016C80033p0",
"0x0.000000000018800039p0", "0x0.00000000001A48003Fp0", "0x0.00000000001C200046p0", "0x0.00000000001E08004Dp0",
"0x0.000000000020000055p0", "0x0.00000000002208005Dp0", "0x0.000000000024200066p0", "0x0.00000000002648006Fp0",
"0x0.000000000028800079p0", "0x0.00000000002AC80083p0", "0x0.00000000002D20008Ep0", "0x0.00000000002F88009Ap0",
"0x0.0000000000320000A6p0", "0x0.0000000000348800B3p0", "0x0.0000000000372000C0p0", "0x0.000000000039C800CFp0",
"0x0.00000000003C8000DDp0", "0x0.00000000003F4800EDp0", "0x0.0000000000422000FDp0", "0x0.00000000004508010Ep0",
"0x0.000000000048000120p0", "0x0.00000000004B080132p0", "0x0.00000000004E200145p0", "0x0.000000000051480159p0",
"0x0.00000000005480016Ep0", "0x0.000000000057C80183p0", "0x0.00000000005B20019Ap0", "0x0.00000000005E8801B1p0",
"0x0.0000000000620001C9p0", "0x0.0000000000658801E2p0", "0x0.0000000000692001FCp0", "0x0.00000000006CC80216p0",
"0x0.000000000070800232p0", "0x0.00000000007448024Fp0", "0x0.00000000007820026Cp0", "0x0.00000000007C08028Bp0",
"0x0.0000000000800002AAp0", "0x0.0000000000840802CBp0", "0x0.0000000000882002ECp0", "0x0.00000000008C48030Fp0",
"0x0.000000000090800332p0", "0x0.000000000094C80357p0", "0x0.00000000009920037Dp0", "0x0.00000000009D8803A4p0",
"0x0.0000000000A20003CCp0", "0x0.0000000000A68803F5p0", "0x0.0000000000AB20041Fp0", "0x0.0000000000AFC8044Ap0",
"0x0.0000000000B4800477p0", "0x0.0000000000B94804A4p0", "0x0.0000000000BE2004D3p0", "0x0.0000000000C3080503p0",
"0x0.0000000000C8000535p0", "0x0.0000000000CD080567p0", "0x0.0000000000D220059Bp0", "0x0.0000000000D74805D1p0",
"0x0.0000000000DC800607p0", "0x0.0000000000E1C8063Fp0", "0x0.0000000000E7200678p0", "0x0.0000000000EC8806B2p0",
"0x0.0000000000F20006EEp0", "0x0.0000000000F788072Bp0", "0x0.0000000000FD20076Ap0", "0x0.000000000102C807AAp0",
"0x0.0000000001088007EBp0", "0x0.00000000010E48082Ep0", "0x0.000000000114200872p0", "0x0.00000000011A0808B8p0",
"0x0.000000000120000900p0", "0x0.000000000126080948p0", "0x0.00000000012C200993p0", "0x0.0000000001324809DEp0",
"0x0.000000000138800A2Cp0", "0x0.00000000013EC80A7Bp0", "0x0.000000000145200ACBp0", "0x0.00000000014B880B1Dp0",
"0x0.000000000152000B71p0", "0x0.000000000158880BC6p0", "0x0.00000000015F200C1Dp0", "0x0.000000000165C80C76p0",
"0x0.00000000016C800CD0p0", "0x0.000000000173480D2Cp0", "0x0.00000000017A200D8Ap0", "0x0.000000000181080DE9p0",
"0x0.000000000188000E4Ap0", "0x0.00000000018F080EADp0", "0x0.000000000196200F12p0", "0x0.00000000019D480F78p0",
"0x0.0000000001A4800FE0p0", "0x0.0000000001ABC8104Ap0", "0x0.0000000001B32010B6p0", "0x0.0000000001BA881124p0",
"0x0.0000000001C2001194p0", "0x0.0000000001C9881205p0", "0x0.0000000001D1201278p0", "0x0.0000000001D8C812EEp0",
"0x0.0000000001E0801365p0", "0x0.0000000001E84813DEp0", "0x0.0000000001F0201459p0", "0x0.0000000001F80814D6p0",
"0x0.000000000200001555p0", "0x0.0000000002080815D6p0", "0x0.000000000210201659p0", "0x0.0000000002184816DEp0",
"0x0.000000000220801765p0", "0x0.000000000228C817EEp0", "0x0.000000000231201879p0", "0x0.000000000239881907p0",
"0x0.000000000242001996p0", "0x0.00000000024A881A28p0", "0x0.000000000253201ABBp0", "0x0.00000000025BC81B51p0",
"0x0.000000000264801BE9p0", "0x0.00000000026D481C84p0", "0x0.000000000276201D20p0", "0x0.00000000027F081DBFp0",
"0x0.000000000288001E60p0", "0x0.000000000291081F03p0", "0x0.00000000029A201FA8p0", "0x0.0000000002A3482050p0",
"0x0.0000000002AC8020FAp0", "0x0.0000000002B5C821A6p0", "0x0.0000000002BF202255p0", "0x0.0000000002C8882306p0",
"0x0.0000000002D20023B9p0", "0x0.0000000002DB88246Fp0", "0x0.0000000002E5202527p0", "0x0.0000000002EEC825E1p0",
"0x0.0000000002F880269Ep0", "0x0.00000000030248275Dp0", "0x0.00000000030C20281Fp0", "0x0.0000000003160828E3p0",
"0x0.0000000003200029AAp0", "0x0.00000000032A082A73p0", "0x0.000000000334202B3Fp0", "0x0.00000000033E482C0Dp0",
"0x0.000000000348802CDEp0", "0x0.000000000352C82DB2p0", "0x0.00000000035D202E88p0", "0x0.000000000367882F60p0",
"0x0.00000000037200303Cp0", "0x0.00000000037C883119p0", "0x0.0000000003872031FAp0", "0x0.000000000391C832DDp0",
"0x0.00000000039C8033C3p0", "0x0.0000000003A74834ABp0", "0x0.0000000003B2203596p0", "0x0.0000000003BD083684p0",
"0x0.0000000003C8003775p0", "0x0.0000000003D3083868p0", "0x0.0000000003DE20395Ep0", "0x0.0000000003E9483A57p0",
"0x0.0000000003F4803B53p0", "0x0.0000000003FFC83C52p0", "0x0.00000000040B203D53p0", "0x0.000000000416883E57p0",
"0x0.000000000422003F5Ep0", "0x0.00000000042D884068p0", "0x0.000000000439204175p0", "0x0.000000000444C84285p0",
"0x0.000000000450804397p0", "0x0.00000000045C4844ADp0", "0x0.0000000004682045C5p0", "0x0.0000000004740846E1p0",
"0x0.000000000480004800p0", "0x0.00000000048C084921p0", "0x0.000000000498204A46p0", "0x0.0000000004A4484B6Dp0",
"0x0.0000000004B0804C98p0", "0x0.0000000004BCC84DC5p0", "0x0.0000000004C9204EF6p0", "0x0.0000000004D588502Ap0",
"0x0.0000000004E2005161p0", "0x0.0000000004EE88529Bp0", "0x0.0000000004FB2053D8p0", "0x0.000000000507C85518p0",
"0x0.00000000051480565Cp0", "0x0.0000000005214857A3p0", "0x0.00000000052E2058EDp0", "0x0.00000000053B085A3Ap0",
"0x0.000000000548005B8Ap0", "0x0.000000000555085CDEp0", "0x0.000000000562205E35p0", "0x0.00000000056F485F8Fp0",
"0x0.00000000057C8060ECp0", "0x0.000000000589C8624Dp0", "0x0.0000000005972063B1p0", "0x0.0000000005A4886519p0",
"0x0.0000000005B2006684p0", "0x0.0000000005BF8867F2p0", "0x0.0000000005CD206963p0", "0x0.0000000005DAC86AD8p0",
"0x0.0000000005E8806C51p0", "0x0.0000000005F6486DCDp0", "0x0.000000000604206F4Cp0", "0x0.0000000006120870CFp0",
"0x0.000000000620007255p0", "0x0.00000000062E0873DFp0", "0x0.00000000063C20756Cp0", "0x0.00000000064A4876FDp0",
"0x0.000000000658807891p0", "0x0.000000000666C87A29p0", "0x0.000000000675207BC4p0", "0x0.000000000683887D64p0",
"0x0.000000000692007F06p0", "0x0.0000000006A08880ADp0", "0x0.0000000006AF208256p0", "0x0.0000000006BDC88404p0",
"0x0.0000000006CC8085B5p0", "0x0.0000000006DB48876Ap0", "0x0.0000000006EA208923p0", "0x0.0000000006F9088ADFp0",
"0x0.000000000708008CA0p0", "0x0.000000000717088E63p0", "0x0.00000000072620902Bp0", "0x0.0000000007354891F6p0",
"0x0.0000000007448093C6p0", "0x0.000000000753C89599p0", "0x0.000000000763209770p0", "0x0.00000000077288994Ap0",
"0x0.000000000782009B29p0", "0x0.000000000791889D0Bp0", "0x0.0000000007A1209EF2p0", "0x0.0000000007B0C8A0DCp0",
"0x0.0000000007C080A2CAp0", "0x0.0000000007D048A4BCp0", "0x0.0000000007E020A6B2p0", "0x0.0000000007F008A8ACp0",
            };
            ap_ufixed<32,-37> f_x_msb_4 = f_x_msb_4_table[x_msb_ind_4];

            const static ap_ufixed<16,-53> f_x_msb_5_table[256] = {
"0x0.000000000000000000p0", "0x0.000000000000000008p0", "0x0.000000000000000020p0", "0x0.000000000000000048p0",
"0x0.000000000000000080p0", "0x0.0000000000000000C8p0", "0x0.000000000000000120p0", "0x0.000000000000000188p0",
"0x0.000000000000000200p0", "0x0.000000000000000288p0", "0x0.000000000000000320p0", "0x0.0000000000000003C8p0",
"0x0.000000000000000480p0", "0x0.000000000000000548p0", "0x0.000000000000000620p0", "0x0.000000000000000708p0",
"0x0.000000000000000800p0", "0x0.000000000000000908p0", "0x0.000000000000000A20p0", "0x0.000000000000000B48p0",
"0x0.000000000000000C80p0", "0x0.000000000000000DC8p0", "0x0.000000000000000F20p0", "0x0.000000000000001088p0",
"0x0.000000000000001200p0", "0x0.000000000000001388p0", "0x0.000000000000001520p0", "0x0.0000000000000016C8p0",
"0x0.000000000000001880p0", "0x0.000000000000001A48p0", "0x0.000000000000001C20p0", "0x0.000000000000001E08p0",
"0x0.000000000000002000p0", "0x0.000000000000002208p0", "0x0.000000000000002420p0", "0x0.000000000000002648p0",
"0x0.000000000000002880p0", "0x0.000000000000002AC8p0", "0x0.000000000000002D20p0", "0x0.000000000000002F88p0",
"0x0.000000000000003200p0", "0x0.000000000000003488p0", "0x0.000000000000003720p0", "0x0.0000000000000039C8p0",
"0x0.000000000000003C80p0", "0x0.000000000000003F48p0", "0x0.000000000000004220p0", "0x0.000000000000004508p0",
"0x0.000000000000004800p0", "0x0.000000000000004B08p0", "0x0.000000000000004E20p0", "0x0.000000000000005148p0",
"0x0.000000000000005480p0", "0x0.0000000000000057C8p0", "0x0.000000000000005B20p0", "0x0.000000000000005E88p0",
"0x0.000000000000006200p0", "0x0.000000000000006588p0", "0x0.000000000000006920p0", "0x0.000000000000006CC8p0",
"0x0.000000000000007080p0", "0x0.000000000000007448p0", "0x0.000000000000007820p0", "0x0.000000000000007C08p0",
"0x0.000000000000008000p0", "0x0.000000000000008408p0", "0x0.000000000000008820p0", "0x0.000000000000008C48p0",
"0x0.000000000000009080p0", "0x0.0000000000000094C8p0", "0x0.000000000000009920p0", "0x0.000000000000009D88p0",
"0x0.00000000000000A200p0", "0x0.00000000000000A688p0", "0x0.00000000000000AB20p0", "0x0.00000000000000AFC8p0",
"0x0.00000000000000B480p0", "0x0.00000000000000B948p0", "0x0.00000000000000BE20p0", "0x0.00000000000000C308p0",
"0x0.00000000000000C800p0", "0x0.00000000000000CD08p0", "0x0.00000000000000D220p0", "0x0.00000000000000D748p0",
"0x0.00000000000000DC80p0", "0x0.00000000000000E1C8p0", "0x0.00000000000000E720p0", "0x0.00000000000000EC88p0",
"0x0.00000000000000F200p0", "0x0.00000000000000F788p0", "0x0.00000000000000FD20p0", "0x0.0000000000000102C8p0",
"0x0.000000000000010880p0", "0x0.000000000000010E48p0", "0x0.000000000000011420p0", "0x0.000000000000011A08p0",
"0x0.000000000000012000p0", "0x0.000000000000012608p0", "0x0.000000000000012C20p0", "0x0.000000000000013248p0",
"0x0.000000000000013880p0", "0x0.000000000000013EC8p0", "0x0.000000000000014520p0", "0x0.000000000000014B88p0",
"0x0.000000000000015200p0", "0x0.000000000000015888p0", "0x0.000000000000015F20p0", "0x0.0000000000000165C8p0",
"0x0.000000000000016C80p0", "0x0.000000000000017348p0", "0x0.000000000000017A20p0", "0x0.000000000000018108p0",
"0x0.000000000000018800p0", "0x0.000000000000018F08p0", "0x0.000000000000019620p0", "0x0.000000000000019D48p0",
"0x0.00000000000001A480p0", "0x0.00000000000001ABC8p0", "0x0.00000000000001B320p0", "0x0.00000000000001BA88p0",
"0x0.00000000000001C200p0", "0x0.00000000000001C988p0", "0x0.00000000000001D120p0", "0x0.00000000000001D8C8p0",
"0x0.00000000000001E080p0", "0x0.00000000000001E848p0", "0x0.00000000000001F020p0", "0x0.00000000000001F808p0",
"0x0.000000000000020000p0", "0x0.000000000000020808p0", "0x0.000000000000021020p0", "0x0.000000000000021848p0",
"0x0.000000000000022080p0", "0x0.0000000000000228C8p0", "0x0.000000000000023120p0", "0x0.000000000000023988p0",
"0x0.000000000000024200p0", "0x0.000000000000024A88p0", "0x0.000000000000025320p0", "0x0.000000000000025BC8p0",
"0x0.000000000000026480p0", "0x0.000000000000026D48p0", "0x0.000000000000027620p0", "0x0.000000000000027F08p0",
"0x0.000000000000028800p0", "0x0.000000000000029108p0", "0x0.000000000000029A20p0", "0x0.00000000000002A348p0",
"0x0.00000000000002AC80p0", "0x0.00000000000002B5C8p0", "0x0.00000000000002BF20p0", "0x0.00000000000002C888p0",
"0x0.00000000000002D200p0", "0x0.00000000000002DB88p0", "0x0.00000000000002E520p0", "0x0.00000000000002EEC8p0",
"0x0.00000000000002F880p0", "0x0.000000000000030248p0", "0x0.000000000000030C20p0", "0x0.000000000000031608p0",
"0x0.000000000000032000p0", "0x0.000000000000032A08p0", "0x0.000000000000033420p0", "0x0.000000000000033E48p0",
"0x0.000000000000034880p0", "0x0.0000000000000352C8p0", "0x0.000000000000035D20p0", "0x0.000000000000036788p0",
"0x0.000000000000037200p0", "0x0.000000000000037C88p0", "0x0.000000000000038720p0", "0x0.0000000000000391C8p0",
"0x0.000000000000039C80p0", "0x0.00000000000003A748p0", "0x0.00000000000003B220p0", "0x0.00000000000003BD08p0",
"0x0.00000000000003C800p0", "0x0.00000000000003D308p0", "0x0.00000000000003DE20p0", "0x0.00000000000003E948p0",
"0x0.00000000000003F480p0", "0x0.00000000000003FFC8p0", "0x0.000000000000040B20p0", "0x0.000000000000041688p0",
"0x0.000000000000042200p0", "0x0.000000000000042D88p0", "0x0.000000000000043920p0", "0x0.0000000000000444C8p0",
"0x0.000000000000045080p0", "0x0.000000000000045C48p0", "0x0.000000000000046820p0", "0x0.000000000000047408p0",
"0x0.000000000000048000p0", "0x0.000000000000048C08p0", "0x0.000000000000049820p0", "0x0.00000000000004A448p0",
"0x0.00000000000004B080p0", "0x0.00000000000004BCC8p0", "0x0.00000000000004C920p0", "0x0.00000000000004D588p0",
"0x0.00000000000004E200p0", "0x0.00000000000004EE88p0", "0x0.00000000000004FB20p0", "0x0.0000000000000507C8p0",
"0x0.000000000000051480p0", "0x0.000000000000052148p0", "0x0.000000000000052E20p0", "0x0.000000000000053B08p0",
"0x0.000000000000054800p0", "0x0.000000000000055508p0", "0x0.000000000000056220p0", "0x0.000000000000056F48p0",
"0x0.000000000000057C80p0", "0x0.0000000000000589C8p0", "0x0.000000000000059720p0", "0x0.00000000000005A488p0",
"0x0.00000000000005B200p0", "0x0.00000000000005BF88p0", "0x0.00000000000005CD20p0", "0x0.00000000000005DAC8p0",
"0x0.00000000000005E880p0", "0x0.00000000000005F648p0", "0x0.000000000000060420p0", "0x0.000000000000061208p0",
"0x0.000000000000062000p0", "0x0.000000000000062E08p0", "0x0.000000000000063C20p0", "0x0.000000000000064A48p0",
"0x0.000000000000065880p0", "0x0.0000000000000666C8p0", "0x0.000000000000067520p0", "0x0.000000000000068388p0",
"0x0.000000000000069200p0", "0x0.00000000000006A088p0", "0x0.00000000000006AF20p0", "0x0.00000000000006BDC8p0",
"0x0.00000000000006CC80p0", "0x0.00000000000006DB48p0", "0x0.00000000000006EA20p0", "0x0.00000000000006F908p0",
"0x0.000000000000070800p0", "0x0.000000000000071708p0", "0x0.000000000000072620p0", "0x0.000000000000073548p0",
"0x0.000000000000074480p0", "0x0.0000000000000753C8p0", "0x0.000000000000076320p0", "0x0.000000000000077288p0",
"0x0.000000000000078200p0", "0x0.000000000000079188p0", "0x0.00000000000007A120p0", "0x0.00000000000007B0C8p0",
"0x0.00000000000007C080p0", "0x0.00000000000007D048p0", "0x0.00000000000007E020p0", "0x0.00000000000007F008p0",
            };

            ap_ufixed<16,-53> f_x_msb_5 = f_x_msb_5_table[x_msb_ind_5];

            ap_ufixed<9,-60> f_x_msb_5_lsb = x_msb_5 * x_lsb;

            ap_ufixed<25,-26> x_msb_5_lsb = x_l;

            ap_ufixed<25,-44> f_x_msb_4_5_lsb = x_msb_5_lsb * x_msb_4;

            ap_ufixed<6,-37> f_x_msb_4_s = f_x_msb_4;
            ap_ufixed<6,-63> exp_x_msb_4_5_lsb_m_1_m1 = x_msb_5 * f_x_msb_4;

            ap_ufixed<10,-59> exp_x_msb_4_5_lsb_m_1_m2 = 0;
            exp_x_msb_4_5_lsb_m_1_m2(8,0) = f_x_msb_5_lsb(8,0);
            exp_x_msb_4_5_lsb_m_1_m2 = exp_x_msb_4_5_lsb_m_1_m1 + exp_x_msb_4_5_lsb_m_1_m2;

            ap_ufixed<17,-52> exp_x_msb_4_5_lsb_m_1_m3 = 0;
            exp_x_msb_4_5_lsb_m_1_m3(15,0) = f_x_msb_5(15,0);
            exp_x_msb_4_5_lsb_m_1_m3 = exp_x_msb_4_5_lsb_m_1_m2+exp_x_msb_4_5_lsb_m_1_m3;

            ap_ufixed<26,-43> exp_x_msb_4_5_lsb_m_1_m4 =0;
            exp_x_msb_4_5_lsb_m_1_m4(24,0) = f_x_msb_4_5_lsb(24,0);
            exp_x_msb_4_5_lsb_m_1_m4 = exp_x_msb_4_5_lsb_m_1_m4 + exp_x_msb_4_5_lsb_m_1_m3;

            ap_ufixed<33,-36> exp_x_msb_4_5_lsb_m_1_m5 = 0;
            exp_x_msb_4_5_lsb_m_1_m5(31,0) = f_x_msb_4(31,0);
            exp_x_msb_4_5_lsb_m_1_m5 = exp_x_msb_4_5_lsb_m_1_m5 + exp_x_msb_4_5_lsb_m_1_m4;

            ap_ufixed<wf-18,-18> x_msb_4_5_lsb = x_l;
            ap_ufixed<wf-17,-17> exp_x_msb_4_5_lsb_m_1_s = 0;
            exp_x_msb_4_5_lsb_m_1_s(30,0) = exp_x_msb_4_5_lsb_m_1_m5(32,2);
            exp_x_msb_4_5_lsb_m_1_s = exp_x_msb_4_5_lsb_m_1_s + x_msb_4_5_lsb;

            ap_ufixed<52,-17> exp_x_msb_4_5_lsb_m_1 = exp_x_msb_4_5_lsb_m_1_s;
            exp_x_msb_4_5_lsb_m_1(1,0) = exp_x_msb_4_5_lsb_m_1_m5(1,0);


            const static ap_ufixed<51,-21> f_x_msb_3_table[256] = {
"0x0", "0x0.00000000080000AAAAp0", "0x0.000000002000055556p0", "0x0.000000004800120003p0",
"0x0.0000000080002AAAB5p0", "0x0.00000000C80053556Fp0", "0x0.000000012000900036p0", "0x0.000000018800E4AB0Ep0",
"0x0.000000020001555600p0", "0x0.000000028801E60111p0", "0x0.0000000320029AAC4Bp0", "0x0.00000003C8037757B7p0",
"0x0.000000048004800360p0", "0x0.000000054805B8AF50p0", "0x0.000000062007255B96p0", "0x0.000000070808CA083Dp0",
"0x0.00000008000AAAB555p0", "0x0.00000009080CCB62EDp0", "0x0.0000000A200F301116p0", "0x0.0000000B4811DCBFE0p0",
"0x0.0000000C8014D56F60p0", "0x0.0000000DC8181E1FA7p0", "0x0.0000000F201BBAD0CBp0", "0x0.00000010881FAF82E1p0",
"0x0.000000120024003600p0", "0x0.000000138828B0EA3Fp0", "0x0.00000015202DC59FB6p0", "0x0.00000016C83342567Fp0",
"0x0.0000001880392B0EB5p0", "0x0.0000001A483F83C874p0", "0x0.0000001C20465083D6p0", "0x0.0000001E084D9540FBp0",
"0x0.000000200055560001p0", "0x0.00000022085D96C106p0", "0x0.0000002420665B842Cp0", "0x0.00000026486FA84995p0",
"0x0.000000288079811161p0", "0x0.0000002AC883E9DBB6p0", "0x0.0000002D208EE6A8B8p0", "0x0.0000002F889A7B788Cp0",
"0x0.0000003200A6AC4B58p0", "0x0.0000003488B37D2145p0", "0x0.0000003720C0F1FA7Ap0", "0x0.00000039C8CF0ED721p0",
"0x0.0000003C80DDD7B765p0", "0x0.0000003F48ED509B71p0", "0x0.0000004220FD7D8371p0", "0x0.00000045090E626F94p0",
"0x0.000000480120036008p0", "0x0.0000004B09326454FBp0", "0x0.0000004E2145894E9Fp0", "0x0.000000514959764D26p0",
"0x0.00000054816E2F50C1p0", "0x0.00000057C983B859A4p0", "0x0.0000005B219A156804p0", "0x0.0000005E89B14A7C16p0",
"0x0.0000006201C95B9611p0", "0x0.0000006589E24CB62Cp0", "0x0.0000006921FC21DCA0p0", "0x0.0000006CCA16DF09A6p0",
"0x0.000000708232883D78p0", "0x0.000000744A4F217853p0", "0x0.00000078226CAEBA73p0", "0x0.0000007C0A8B340414p0",
"0x0.0000008002AAB55577p0", "0x0.000000840ACB36AEDAp0", "0x0.0000008822ECBC107Dp0", "0x0.0000008C4B0F497AA3p0",
"0x0.000000908332E2ED8Ep0", "0x0.00000094CB578C6981p0", "0x0.00000099237D49EEC0p0", "0x0.0000009D8BA41F7D92p0",
"0x0.000000A203CC11163Dp0", "0x0.000000A68BF522B908p0", "0x0.000000AB241F58663Cp0", "0x0.000000AFCC4AB61E22p0",
"0x0.000000B484773FE105p0", "0x0.000000B94CA4F9AF31p0", "0x0.000000BE24D3E788F1p0", "0x0.000000C30D040D6E94p0",
"0x0.000000C805356F6068p0", "0x0.000000CD0D68115EBCp0", "0x0.000000D2259BF769E1p0", "0x0.000000D74DD1258228p0",
"0x0.000000DC86079FA7E4p0", "0x0.000000E1CE3F69DB69p0", "0x0.000000E72678881D0Bp0", "0x0.000000EC8EB2FE6D1Fp0",
"0x0.000000F206EED0CBFDp0", "0x0.000000F78F2C0339FAp0", "0x0.000000FD276A99B771p0", "0x0.00000102CFAA9844BBp0",
"0x0.0000010887EC02E231p0", "0x0.0000010E502EDD9030p0", "0x0.0000011428732C4F14p0", "0x0.0000011A10B8F31F3Bp0",
"0x0.000001200900360103p0", "0x0.000001261148F8F4CBp0", "0x0.0000012C29933FFAF5p0", "0x0.0000013251DF0F13E1p0",
"0x0.000001388A2C6A3FF3p0", "0x0.0000013ED27B557F8Dp0", "0x0.000001452ACBD4D315p0", "0x0.0000014B931DEC3AEFp0",
"0x0.000001520B719FB782p0", "0x0.0000015893C6F34937p0", "0x0.0000015F2C1DEAF074p0", "0x0.00000165D4768AADA5p0",
"0x0.0000016C8CD0D68133p0", "0x0.00000173552CD26B89p0", "0x0.0000017A2D8A826D16p0", "0x0.0000018115E9EA8645p0",
"0x0.000001880E4B0EB785p0", "0x0.0000018F16ADF30147p0", "0x0.000001962F129B63FAp0", "0x0.0000019D57790BE010p0",
"0x0.000001A48FE14875FBp0", "0x0.000001ABD84B552630p0", "0x0.000001B330B735F122p0", "0x0.000001BA9924EED748p0",
"0x0.000001C2119483D917p0", "0x0.000001C99A05F8F707p0", "0x0.000001D13279523191p0", "0x0.000001D8DAEE93892Ep0",
"0x0.000001E09365C0FE59p0", "0x0.000001E85BDEDE918Dp0", "0x0.000001F03459F04347p0", "0x0.000001F81CD6FA1405p0",
"0x0.000002001556000444p0", "0x0.000002081DD7061485p0", "0x0.00000210365A104547p0", "0x0.000002185EDF22970Dp0",
"0x0.000002209766410A5Ap0", "0x0.00000228DFEF6F9FAFp0", "0x0.00000231387AB25793p0", "0x0.00000239A1080D328Ap0",
"0x0.00000242199784311Cp0", "0x0.0000024AA2291B53CFp0", "0x0.000002533ABCD69B2Dp0", "0x0.0000025BE352BA07BEp0",
"0x0.000002649BEAC99A0Dp0", "0x0.0000026D64850952A7p0", "0x0.000002763D217D3216p0", "0x0.0000027F25C02938EAp0",
"0x0.000002881E611167B0p0", "0x0.00000291270439BEF8p0", "0x0.0000029A3FA9A63F53p0", "0x0.000002A368515AE951p0",
"0x0.000002ACA0FB5BBD86p0", "0x0.000002B5E9A7ACBC86p0", "0x0.000002BF425651E6E4p0", "0x0.000002C8AB074F3D36p0",
"0x0.000002D223BAA8C013p0", "0x0.000002DBAC70627012p0", "0x0.000002E54528804DCDp0", "0x0.000002EEEDE30659DBp0",
"0x0.000002F8A69FF894D9p0", "0x0.000003026F5F5AFF61p0", "0x0.0000030C4821319A10p0", "0x0.0000031630E5806584p0",
"0x0.0000032029AC4B625Bp0", "0x0.0000032A3275969134p0", "0x0.000003344B4165F2B1p0", "0x0.0000033E740FBD8772p0",
"0x0.00000348ACE0A1501Bp0", "0x0.00000352F5B4154D4Fp0", "0x0.0000035D4E8A1D7FB2p0", "0x0.00000367B762BDE7EAp0",
"0x0.00000372303DFA869Ep0", "0x0.0000037CB91BD75C75p0", "0x0.0000038751FC586A18p0", "0x0.00000391FADF81B02Fp0",
"0x0.0000039CB3C5572F67p0", "0x0.000003A77CADDCE86Ap0", "0x0.000003B2559916DBE4p0", "0x0.000003BD3E87090A84p0",
"0x0.000003C83777B774F8p0", "0x0.000003D3406B261BF0p0", "0x0.000003DE596159001Cp0", "0x0.000003E9825A54222Dp0",
"0x0.000003F4BB561B82D7p0", "0x0.000004000454B322CCp0", "0x0.0000040B5D561F02C2p0", "0x0.00000416C65A63236Ep0",
"0x0.000004223F61838586p0", "0x0.0000042DC86B8429C2p0", "0x0.0000043961786910DBp0", "0x0.000004450A88363B8Ap0",
"0x0.00000450C39AEFAA8Ap0", "0x0.0000045C8CB0995E96p0", "0x0.0000046865C937586Bp0", "0x0.000004744EE4CD98C6p0",
"0x0.000004804803602067p0", "0x0.0000048C5124F2F00Cp0", "0x0.000004986A498A0876p0", "0x0.000004A49371296A67p0",
"0x0.000004B0CC9BD516A1p0", "0x0.000004BD15C9910DE8p0", "0x0.000004C96EFA615101p0", "0x0.000004D5D82E49E0B0p0",
"0x0.000004E251654EBDBDp0", "0x0.000004EEDA9F73E8F0p0", "0x0.000004FB73DCBD6310p0", "0x0.000005081D1D2F2CE7p0",
"0x0.00000514D660CD4740p0", "0x0.000005219FA79BB2E7p0", "0x0.0000052E78F19E70A8p0", "0x0.0000053B623ED98150p0",
"0x0.000005485B8F50E5AFp0", "0x0.0000055564E3089E93p0", "0x0.000005627E3A04ACCEp0", "0x0.0000056FA794491131p0",
"0x0.0000057CE0F1D9CC8Ep0", "0x0.0000058A2A52BADFBAp0", "0x0.0000059783B6F04B88p0", "0x0.000005A4ED1E7E10CFp0",
"0x0.000005B26689683064p0", "0x0.000005BFEFF7B2AB20p0", "0x0.000005CD89696181DBp0", "0x0.000005DB32DE78B56Fp0",
"0x0.000005E8EC56FC46B6p0", "0x0.000005F6B5D2F0368Cp0", "0x0.000006048F525885CDp0", "0x0.0000061278D5393558p0",
"0x0.00000620725B96460Ap0", "0x0.0000062E7BE573B8C3p0", "0x0.0000063C9572D58E64p0", "0x0.0000064ABF03BFC7CEp0",
"0x0.00000658F8983665E5p0", "0x0.0000066742303D698Bp0", "0x0.000006759BCBD8D3A5p0", "0x0.00000684056B0CA519p0",
"0x0.000006927F0DDCDECEp0", "0x0.000006A108B44D81AAp0", "0x0.000006AFA25E628E98p0", "0x0.000006BE4C0C20067Fp0",
"0x0.000006CD05BD89EA4Bp0", "0x0.000006DBCF72A43AE8p0", "0x0.000006EAA92B72F942p0", "0x0.000006F992E7FA2646p0",
"0x0.000007088CA83DC2E4p0", "0x0.00000717966C41D00Ap0", "0x0.00000726B0340A4EAAp0", "0x0.00000735D9FF9B3FB6p0",
"0x0.0000074513CEF8A41Ep0", "0x0.000007545DA2267CD9p0", "0x0.00000763B77928CAD9p0", "0x0.000007732154038F14p0",
"0x0.000007829B32BACA82p0", "0x0.000007922515527E1Ap0", "0x0.000007A1BEFBCEAAD4p0", "0x0.000007B168E63351AAp0",
"0x0.000007C122D4847397p0", "0x0.000007D0ECC6C61195p0", "0x0.000007E0C6BCFC2CA3p0", "0x0.000007F0B0B72AC5BEp0",
            };
            ap_ufixed<51,-21> f_x_msb_3 = f_x_msb_3_table[x_msb_ind_3];
            ap_ufixed<62,-10> exp_x_msb_3_m_1 = 0;
            exp_x_msb_3_m_1(61,54) = x_msb_3(7,0);
            exp_x_msb_3_m_1(50, 0) = f_x_msb_3(50,0);

            ap_ufixed<50,-10> exp_x_msb_3_m_1_s = exp_x_msb_3_m_1;

            ap_ufixed<101,-27> f_x_msb_3_4_5_lsb = exp_x_msb_3_m_1_s * exp_x_msb_4_5_lsb_m_1;
            ap_ufixed<45,-27> f_x_msb_3_4_5_lsb_s = f_x_msb_3_4_5_lsb;
            ap_ufixed<63, -9> exp_x_msb_3_4_5_lsb_m_1 = f_x_msb_3_4_5_lsb_s + exp_x_msb_3_m_1 + exp_x_msb_4_5_lsb_m_1;


            const static ap_ufixed<64,-4> f_x_msb_2_table[256] = {
"0x0.0p0", "0x0.00000800AAB555DDEp0", "0x0.00002005560011127p0", "0x0.00004812036081A9Cp0",
"0x0.0000802AB55777D28p0", "0x0.0000C8536F6684062p0", "0x0.0001209036103740Dp0", "0x0.000188E50ED8634A0p0",
"0x0.0002015600445B0C3p0", "0x0.000289E711DB32FD7p0", "0x0.0003229C4C260197Ep0", "0x0.0003CB79B8B01FE26p0",
"0x0.0004848362076A08Dp0", "0x0.00054DBD53BC80058p0", "0x0.0006272B9A630659Dp0", "0x0.000710D24391E6D7Ap0",
"0x0.00080AB55DE3917ABp0", "0x0.000914D8F8F63D524p0", "0x0.000A2F41256C297AFp0", "0x0.000B59F1F4EBDE291p0",
"0x0.000C94EF7A206DC2Dp0", "0x0.000DE03DC8B9B60B1p0", "0x0.000F3BE0F56CA15C4p0", "0x0.0010A7DD15F367F40p0",
"0x0.00122436410DD14E5p0", "0x0.0013B0F08E817591Ep0", "0x0.00154E101719FF0C5p0", "0x0.0016FB98F4A96BBEFp0",
"0x0.0018B98F42084EFBDp0", "0x0.001A87F71B1613137p0", "0x0.001C66D49CB93B127p0", "0x0.001E562BE4DFA4904p0",
"0x0.00205601127EC98E0p0", "0x0.00226658459402659p0", "0x0.002487359F24C7C99p0", "0x0.0026B89D413EF4D5Ep0",
"0x0.0028FA934EF909304p0", "0x0.002B4D1BEC726B39Cp0", "0x0.002DB03B3ED3AA50Ep0", "0x0.003023F56C4EC123Fp0",
"0x0.0032A84E9C1F58145p0", "0x0.00353D4AF68B07AA1p0", "0x0.0037E2EEA4E19B185p0", "0x0.003A993DD17D52D25p0",
"0x0.003D603CA7C32730Fp0", "0x0.004037EF54230B293p0", "0x0.0043205A04182F12Fp0", "0x0.00461980E62943810p0",
"0x0.0049236829E8BC292p0", "0x0.004C3E13FFF512DD8p0", "0x0.004F698899F90A966p0", "0x0.0052A5CA2AABF28D0p0",
"0x0.0055F2DCE5D1E966Ep0", "0x0.005950C5003C20723p0", "0x0.005CBF86AFC91EF2Bp0", "0x0.00603F262B65057FCp0",
"0x0.0063CFA7AB09D1732p0", "0x0.0067710F67BFA0687p0", "0x0.006B23619B9CF3CDEp0", "0x0.006EE6A281C6F4857p0",
"0x0.0072BAD65671B6977p0", "0x0.0076A00156E07CF57p0", "0x0.007A9627C165FD4EDp0", "0x0.007E9D4DD564A3F5Ep0",
"0x0.0082B577D34ED7D5Bp0", "0x0.0086DEA9FCA73E799p0", "0x0.008B18E8940100253p0", "0x0.008F6437DD000BFDAp0",
"0x0.0093C09C1C595C43Ep0", "0x0.00982E1997D33A9FCp0", "0x0.009CACB49645847CCp0", "0x0.00A13C715F99EF773p0",
"0x0.00A5DD543CCC4DDAFp0", "0x0.00AA8F6177EAD3336p0", "0x0.00AF529D5C1658EBCp0", "0x0.00B4270C3582A301Dp0",
"0x0.00B90CB25176A4C8Bp0", "0x0.00BE0393FE4CC5BD7p0", "0x0.00C30BB58B73266CAp0", "0x0.00C8251B496BE5696p0",
"0x0.00CD4FC989CD64555p0", "0x0.00D28BC49F428CFA3p0", "0x0.00D7D910DD8B16743p0", "0x0.00DD37B2997BCA6E6p0",
"0x0.00E2A7AE28FECA6FBp0", "0x0.00E82907E313D5399p0", "0x0.00EDBBC41FD08C383p0", "0x0.00F35FE73860B9038p0",
"0x0.00F91575870692F24p0", "0x0.00FEDC73671B04BDFp0", "0x0.0104B4E5350DF2386p0", "0x0.010A9ECF4E667E12Dp0",
"0x0.01109A3611C34FB64p0", "0x0.0116A71DDEDAD92D8p0", "0x0.011CC58B167B9D206p0", "0x0.0122F5821A8C74E0Dp0",
"0x0.012937074E0CD6893p0", "0x0.012F8A1F15151B2C6p0", "0x0.0135EECDD4D6C5172p0", "0x0.013C6517F39CC6233p0",
"0x0.0142ED01D8CBC61C4p0", "0x0.0149868FECE26935Dp0", "0x0.015031C6997996937p0", "0x0.0156EEAA4944BEE23p0",
"0x0.015DBD3F68122303Ep0", "0x0.01649D8A62CB1ACBEp0", "0x0.016B8F8FA7745BCDBp0", "0x0.01729353A52E403D8p0",
"0x0.0179A8DACC350DE1Dp0", "0x0.0180D0298DE13D179p0", "0x0.018809445CA7BFE78p0", "0x0.018F542FAC1A492D6p0",
"0x0.0196B0EFF0E793D15p0", "0x0.019E1F89A0DBAA128p0", "0x0.01A5A00132E02CE42p0", "0x0.01AD325B1EFC9B5BCp0",
"0x0.01B4D69BDE569A322p0", "0x0.01BC8CC7EB323B553p0", "0x0.01C454E3C0F2458C8p0", "0x0.01CC2EF3DC187C2F6p0",
"0x0.01D41AFCBA45E6ED2p0", "0x0.01DC1902DA3B19A6Dp0", "0x0.01E4290ABBD87C5BCp0", "0x0.01EC4B18E01E9326Fp0",
"0x0.01F47F31C92E464FCp0", "0x0.01FCC559FA492A6B6p0", "0x0.02051D95F7D1C8917p0", "0x0.020D87EA474BE6A1Cp0",
"0x0.0216045B6F5CCF9CEp0", "0x0.021E92EDF7CB9C0E4p0", "0x0.022733A669817A88Ap0", "0x0.022FE6894E89F834Cp0",
"0x0.0238AB9B321349722p0", "0x0.024182E0A06E9289Bp0", "0x0.024A6C5E271030733p0", "0x0.02536818549001AC1p0",
"0x0.025C7613B8A9AF215p0", "0x0.02659654E43CF52B1p0", "0x0.026EC8E0694DEC9A9p0", "0x0.02780DBADB0553DA6p0",
"0x0.028164E8CDB0D8211p0", "0x0.028ACE6ED6C35EB5Fp0", "0x0.02944A518CD54E484p0", "0x0.029DD89587A4D858Dp0",
"0x0.02A7793F601642B5Dp0", "0x0.02B12C53B03431090p0", "0x0.02BAF1D7132FEE788p0", "0x0.02C4C9CE2561B759Fp0",
"0x0.02CEB43D844902F7Ap0", "0x0.02D8B129CE8CCD68Fp0", "0x0.02E2C097A3FBE17C9p0", "0x0.02ECE28BA58D22B56p0",
"0x0.02F7170A755FD759Ep0", "0x0.03015E18B6BBF2966p0", "0x0.030BB7BB0E125EB13p0", "0x0.031623F620FD4751Ep0",
"0x0.0320A2CE964063DACp0", "0x0.032B344915C941D54p0", "0x0.0335D86A48AF8F70Cp0", "0x0.03408F36D93566140p0",
"0x0.034B58B372C795013p0", "0x0.035634E4C1FDEC0D0p0", "0x0.036123CF749B8667Cp0", "0x0.036C2578398F157A0p0",
"0x0.037739E3C0F32BD30p0", "0x0.03826116BC0E882ACp0", "0x0.038D9B15DD5460763p0", "0x0.0398E7E5D864AD0E9p0",
"0x0.03A4478B620C73EB5p0", "0x0.03AFBA0B304613EEDp0", "0x0.03BB3F69FA3990464p0", "0x0.03C6D7AC783CDBDBFp0",
"0x0.03D282D763D424DCDp0", "0x0.03DE40EF77B220509p0", "0x0.03EA11F96FB855C4Fp0", "0x0.03F5F5FA08F76B0BBp0",
"0x0.0401ECF601AF700BDp0", "0x0.040DF6F219502AA55p0", "0x0.041A13F3107962A88p0", "0x0.042643FDA8FB2DDFBp0",
"0x0.04328716A5D63C2C4p0", "0x0.043EDD42CB3C23B6Dp0", "0x0.044B4686DE8FAD325p0", "0x0.0457C2E7A66520322p0",
"0x0.04645269EA828F932p0", "0x0.0470F51273E025F89p0", "0x0.047DAAE60CA8725B3p0", "0x0.048A73E98038B4ABFp0",
"0x0.049750219B212A8A0p0", "0x0.04A43F932B255C0B7p0", "0x0.04B14242FF3C689A0p0", "0x0.04BE5835E79153E1Dp0",
"0x0.04CB8170B58352D4Ep0", "0x0.04D8BDF83BA618C04p0", "0x0.04E60DD14DC22475Ep0", "0x0.04F37100C0D50D88Ep0",
"0x0.0500E78B6B11D19D6p0", "0x0.050E717623E121CBAp0", "0x0.051C0EC5C3E1B016Cp0", "0x0.0529BF7F24E87CF6Ap0",
"0x0.053783A7220124F51p0", "0x0.05455B42976E2E5EAp0", "0x0.0553465662A95706Bp0", "0x0.056144E76263E21F4p0",
"0x0.056F56FA7686E623Ep0", "0x0.057D7C9480339AD83p0", "0x0.058BB5BA61C3A75A3p0", "0x0.059A0270FEC97047Ap0",
"0x0.05A862BD3C1065F74p0", "0x0.05B6D6A3FF9D52C58p0", "0x0.05C55E2A30AEA974Ep0", "0x0.05D3F954B7BCD3A1Bp0",
"0x0.05E2A8287E7A8049Ep0", "0x0.05F16AAA6FD4F267Bp0", "0x0.060040DF77F44FA13p0", "0x0.060F2ACC843BEF0A0p0",
"0x0.061E2876834AA7FA4p0", "0x0.062D39E264FB20F7Ep0", "0x0.063C5F151A641EB4Cp0", "0x0.064B981395D8D31FEp0",
"0x0.065AE4E2CAE92C8AAp0", "0x0.066A4587AE6224E1Cp0", "0x0.0679BA07364E10FA3p0", "0x0.0689426659F4EFF1Bp0",
"0x0.0698DEAA11DCBAA37p0", "0x0.06A88ED757C9B3304p0", "0x0.06B852F326BEB49B0p0", "0x0.06C82B027AFD8278Ap0",
"0x0.06D8170A520718B46p0", "0x0.06E8170FAA9BFB67Ep0", "0x0.06F82B1784BC86C72p0", "0x0.07085326E1A93F207p0",
"0x0.07188F42C3E320F0Bp0", "0x0.0728DF702F2BF10B2p0", "0x0.073943B428868CD5Ap0", "0x0.0749BC13B6373A98Fp0",
"0x0.075A4893DFC3F9E4Cp0", "0x0.076AE939ADF4D4083p0", "0x0.077B9E0A2AD42C9E8p0", "0x0.078C670A61AF122F4p0",
"0x0.079D443F5F158EE3Ap0", "0x0.07AE35AE30DAF94F1p0", "0x0.07BF3B5BE616454CBp0", "0x0.07D0554D8F2254F0Cp0",
"0x0.07E183883D9E498E2p0", "0x0.07F2C611046DD4D06p0", "0x0.08041CECF7B989EA2p0", "0x0.081588212CEF2ED73p0",
"0x0.082707B2BAC20DB40p0", "0x0.08389BA6B92B46284p0", "0x0.084A4402416A1EE6Fp0", "0x0.085C00CA6E045741Fp0",
"0x0.086DD2045AC678D2Bp0", "0x0.087FB7B524C42936Cp0", "0x0.0891B1E1EA587BE12p0", "0x0.08A3C08FCB2643FFEp0",
            };
            ap_ufixed<64,-4> f_x_msb_2 = f_x_msb_2_table[x_msb_ind_2];
            ap_ufixed< 6,-4> f_x_msb_2_h;
            f_x_msb_2_h(5,0) = f_x_msb_2(63,58);
            ap_ufixed< 9,-1> exp_x_msb_2_m_1_h = f_x_msb_2_h + x_msb_2;
            ap_ufixed<67,-1> exp_x_msb_2_m_1;
            exp_x_msb_2_m_1(66,58) = exp_x_msb_2_m_1_h(8,0);
            exp_x_msb_2_m_1(57, 0) = f_x_msb_2(57,0);

            ap_ufixed<130,-10> f_x_msb_2_3_4_5_lsb = exp_x_msb_2_m_1 * exp_x_msb_3_4_5_lsb_m_1;
            ap_ufixed<62,-10> f_x_msb_2_3_4_5_lsb_s = f_x_msb_2_3_4_5_lsb;
            ap_ufixed<72,0> exp_x_msb_2_3_4_5_lsb_m_1 = f_x_msb_2_3_4_5_lsb_s + exp_x_msb_2_m_1 + exp_x_msb_3_4_5_lsb_m_1;

            const static ap_ufixed<68,32> exp_x_msb_1_table[256] = {
"0x1.000000000p0", "0x1.48B5E3C3Ep0", "0x1.A61298E1Ep0", "0x2.1DF3B68CFp0",
"0x2.B7E151628p0", "0x3.7D871DB61p0", "0x4.7B4FF993Fp0", "0x5.C12DA416Ep0",
"0x7.63992E353p0", "0x9.7CDC417A3p0", "0xC.2EB7EC98Fp0", "0xF.A48385EDFp0",
"0x14.15E5BF6FBp0", "0x19.CA53B7811p0", "0x21.1D8E4272Dp0", "0x2A.8565A144Cp0",
"0x36.99205C4E7p0", "0x46.1AFC4DB59p0", "0x5A.0462B7877p0", "0x73.9593ABB7Dp0",
"0x94.69C4CB819p0", "0xBE.90F6F83E9p0", "0xF4.B122790DDp0", "0x13A.30CF1CCBBp0",
"0x193.6DC5690C0p0", "0x206.03487A3B1p0", "0x299.2442102D9p0", "0x356.0F0B0F980p0",
"0x448.A216ABB76p0", "0x580.1AD754FA3p0", "0x710.0ADBAC7DAp0", "0x911.9289C3923p0",
"0xBA4.F53EA3863p0", "0xEF3.A035D5798p0", "0x1332.C4D2B7C4Ap0", "0x18A6.B027DA0A7p0",
"0x1FA7.157C470F8p0", "0x28A4.90D2CCEF1p0", "0x342F.BA11823B8p0", "0x4302.3A933EE5Cp0",
"0x560A.773E54157p0", "0x6E7A.8ABB4A83Cp0", "0x8DDB.80AF4269Dp0", "0xB626.0748BAEC7p0",
"0xE9E2.2447727BFp0", "0x12C4F.EB75B2AB0p0", "0x1819B.C560F6113p0", "0x1EF21.8F1B001A4p0",
"0x27BC2.CA9A6F934p0", "0x33055.49F35D91Fp0", "0x41831.49596E996p0", "0x541E7.E56949D58p0",
"0x6C02D.645AB2554p0", "0x8AB06.0A3EE9FB1p0", "0xB2148.5EAE56C5Bp0", "0xE4A8D.2881EDBE8p0",
"0x1259AC.48BF05D6Ep0", "0x178FEE.7792E44B3p0", "0x1E4127.437732B71p0", "0x26D8F9.4A204BEA5p0",
"0x31E199.5F5A550DDp0", "0x400C7D.64D3386CBp0", "0x523D82.79EDAEF9Cp0", "0x69993D.D4F2D9524p0",
"0x87975E.854001024p0", "0xAE1A47.C38A42CD0p0", "0xDF8D5F.6DCFE5CEAp0", "0x11F0BF8.1E99FDEB6p0",
"0x1709348.C0EA4F8CEp0", "0x1D94295.464477ACCp0", "0x25FAD90.65C78E342p0", "0x30C4623.616ED2BE2p0",
"0x3E9E441.232817A61p0", "0x506744D.3B342FC94p0", "0x673D70B.C00F1F76Dp0", "0x849012B.C127FC962p0",
"0xAA36C7C.F69370B94p0", "0xDA8F202.DD9ACE661p0", "0x118A2AAE.0AA05236Bp0", "0x16857CFA.1AA8A5555p0",
"0x1CEB088B.68E804021p0", "0x2521AEDA.32CD52BE5p0", "0x2FAD89E1.79BAB8EADp0", "0x3D3838C6.BE0F13F06p0",
"0x4E9B87F6.7BB3F5597p0", "0x64EF201B.01109A4A5p0", "0x819A1801.9394C0D96p0", "0xA6698403.CF5D9E663p0",
"0xD5AD6DCE.21AFFC0DDp0", "0x1125E066B.0B19418CCp0", "0x1604B68CF.05F65FAA9p0", "0x1C45AED0A.D0C934CDCp0",
"0x244D5E676.3FB814AF0p0", "0x2E9CEBF49.9C21839C7p0", "0x3BDA2CBD0.9F5AC2146p0", "0x4CDA0FD41.989F004E7p0",
"0x62ADFED51.D7EDCCDE6p0", "0x7EB50B520.76F91D6E8p0", "0xA2B1FD3D9.A57B6C33Cp0", "0xD0E7A50F4.EF0D7447Fp0",
"0x10C3D39209.62C88AAFBp0", "0x1586D0722B.3EEB27301p0", "0x1BA4068AAC.2B6E3EE34p0", "0x237DCBF1E5.709A9F9C1p0",
"0x2D9264D2D4.D6B94153Bp0", "0x3A83F23B18.FE5BD524Ap0", "0x4B22A1B5C3.27A2FD85Ap0", "0x6079C1866C.71A93951Dp0",
"0x7BE08BDFD9.CC72249ABp0", "0x9F0FB7309C.B446D3919p0", "0xCC3D265776.C3D25779Ep0", "0x1063F7612B0.C0831CA6Cp0",
"0x150BBA37963.79A4FB6ADp0", "0x1B05FA9B62E.737D935B8p0", "0x22B2DC5C41D.AD89559EBp0", "0x2C8DD1AB28B.404414BE7p0",
"0x39355C8C638.0AC5631B1p0", "0x49750434675.301B8D0E7p0", "0x5E521E7A16E.51F9CD3C2p0", "0x791C3B06F8B.EA2DEC48Cp0",
"0x9B823857614.764F43E20p0", "0xC7AD559D438.E7C270C30p0", "0x10063F4E687B.A1A43A35Bp0", "0x149363C905BA.3641D0164p0",
"0x1A6B765D8CDF.6CDBF1C63p0", "0x21EC75240E66.E2891CE63p0", "0x2B8F1073A6AF.BA219DB61p0", "0x37EE3FFC0063.E360F931Fp0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0", "0x0.000000000p0",
"0x0.000000000p0", "0x0.000000001p0", "0x0.000000001p0", "0x0.000000002p0",
"0x0.000000002p0", "0x0.000000003p0", "0x0.000000004p0", "0x0.000000005p0",
"0x0.000000007p0", "0x0.000000009p0", "0x0.00000000Bp0", "0x0.00000000Ep0",
"0x0.000000013p0", "0x0.000000018p0", "0x0.00000001Fp0", "0x0.000000028p0",
"0x0.000000034p0", "0x0.000000042p0", "0x0.000000055p0", "0x0.00000006Ep0",
"0x0.00000008Dp0", "0x0.0000000B5p0", "0x0.0000000E9p0", "0x0.00000012Bp0",
"0x0.000000181p0", "0x0.0000001EEp0", "0x0.00000027Ap0", "0x0.00000032Fp0",
"0x0.000000416p0", "0x0.00000053Fp0", "0x0.0000006BDp0", "0x0.0000008A7p0",
"0x0.000000B1Cp0", "0x0.000000E44p0", "0x0.000001252p0", "0x0.000001786p0",
"0x0.000001E35p0", "0x0.0000026C9p0", "0x0.0000031CEp0", "0x0.000003FF3p0",
"0x0.00000521Dp0", "0x0.000006970p0", "0x0.000008762p0", "0x0.00000ADD6p0",
"0x0.00000DF36p0", "0x0.000011E9Cp0", "0x0.000017003p0", "0x0.00001D88Ap0",
"0x0.000025EC0p0", "0x0.000030B15p0", "0x0.00003E85Dp0", "0x0.00005047Ep0",
"0x0.000067153p0", "0x0.0000845C6p0", "0x0.0000A9F46p0", "0x0.0000DA39Ep0",
"0x0.000118354p0", "0x0.000167CB5p0", "0x0.0001CDFC2p0", "0x0.000251334p0",
"0x0.0002F9AF3p0", "0x0.0003D205Ap0", "0x0.0004E7CE2p0", "0x0.00064C7C6p0",
"0x0.000816791p0", "0x0.000A628A3p0", "0x0.000D55A1Fp0", "0x0.00111F30Fp0",
"0x0.0015FC210p0", "0x0.001C3AA91p0", "0x0.00243F374p0", "0x0.002E8ABFCp0",
"0x0.003BC2D73p0", "0x0.004CBC19Ap0", "0x0.006287862p0", "0x0.007E83A56p0",
"0x0.00A2728F8p0", "0x0.00D096336p0", "0x0.010BD4A5Ap0", "0x0.0157E6BFEp0",
"0x0.01B993FE0p0", "0x0.0236FF5BFp0", "0x0.02D80A08Dp0", "0x0.03A6D2222p0",
"0x0.04B0556E0p0", "0x0.0605424D5p0", "0x0.07BB04063p0", "0x0.09ED1B429p0",
"0x0.0CBED8666p0", "0x0.105D93892p0", "0x0.150385C09p0", "0x0.1AFB718E8p0",
"0x0.22A555477p0", "0x0.2C7C72FC0p0", "0x0.391F0EE49p0", "0x0.495860DCAp0",
"0x0.5E2D58D8Bp0", "0x0.78ED03AFBp0", "0x0.9B4597E37p0", "0x0.C75F7CF56p0",
            };
            ap_ufixed<68,32> exp_x_msb_1 = exp_x_msb_1_table[x_msb_ind_1];
            ap_ufixed<140,32> y_lo = exp_x_msb_1 * exp_x_msb_2_3_4_5_lsb_m_1;
            ap_ufixed<68,32> y_lo_s = y_lo;
            ap_ufixed<68,32> y_l = y_lo_s + exp_x_msb_1;
            y = y_l;
        }
        y += delta;

            overf = 0;
#pragma unroll
            for (int j = 64; j >= I_+31; j--) {
                if (y[j])
                    overf = 1;
            }
            if (overf) {
#pragma unroll
                for (int j = 64; j >= I_+31; j--)
                    y[j] = 0;
#pragma unroll
                for (int j = I_+30; j >= 0; j--)
                    y[j] = 1;
            }

        r = y;
    }
    return r;
}

template<int W_, int I_>
ap_ufixed<W_,I_> exp(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xf = x;
    return exp(xf);
}

template<int I_>
ap_int<I_> exp(ap_int<I_> x) {
    ap_fixed<I_,I_> xf = x;
    return exp(xf);
}

template<int I_>
ap_uint<I_> exp(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xf = x;
    return exp(xf);
}

template<int W, int I>
ap_fixed<W,I> expm1(ap_fixed<W,I> x) {
    ap_fixed<W,I> result, tmp;
    ap_ufixed<1,1> one = 1;
    if(I < 1) {
        result = 0;
    } else {
        ap_fixed<W,I> tmp = exp(x);
        ap_ufixed<1,1> one = 1;
        result = tmp - one;
    }
    return result;
}

template<int W, int I>
ap_ufixed<W,I> expm1(ap_ufixed<W,I> x) {
    ap_fixed<W+1,I+1> xf = x;
    return expm1(xf);
}

template<int I>
ap_int<I> expm1(ap_int<I> x) {
    ap_fixed<I,I> xf = x;
    return expm1(xf);
}

template<int I>
ap_uint<I> expm1(ap_uint<I> x) {
    ap_fixed<I+1,I+1> xf = x;
    return expm1(xf);
}

template<int W, int I>
ap_fixed<W,I> exp2(ap_fixed<W,I> x) {

    int F = W - I;
    if(I > 33 || F > 32) {
        return 0;
    }

    int I_s;
    int M = ((I - 1) > F) ? (I - 1) : F;

    if(M == 1) {
        I_s = 1;
    } else if(M == 2) {
        I_s = 2;
    } else if(M <= 4) {
        I_s = 3;
    } else if(M <= 8) {
        I_s = 4;
    } else if(M <= 16) {
        I_s = 5;
    } else {
        I_s = 6;
    }

    ap_fixed<W,I> r;

    if(I_s == 1) {

        ap_fixed<3,2> x_l = x;
        ap_ufixed<2,1> y = 0;

        if(!x_l[2]) {
            y[1] = 1;
        }
        if(x_l[1]) {
            y[0] = 1;
        }

        if(I<2) {
            if(y[1]) {
                y[1]=0;
                y[0]=1;
            }
        }
        r = y;

    } else if(I_s == 2) {

        ap_fixed<5,3> x_l = x;
        ap_ufixed<4,2> y = 0;
        ap_fixed<2,2> x_l_int;
        x_l_int(1,0) = x_l(3,2);
        ap_ufixed<2,0> x_l_fract;
        x_l_fract(1,0) = x_l(1,0);

        if( (x_l[4]&&(!x_l[3])) || ((!x_l[4])&&x_l[3]) ) {
            if(!x_l[4]) {
                y = "0x3.cp0";
            }
        } else {
            if((!x_l[3])&(x_l[2])) y[3] = 1;
            if(((!x_l[3])&(!x_l[2])) | ((!x_l[3])&x_l[2]&x_l[1]&x_l[0])) y[2] = 1;
            if( (x_l[3]&x_l[2]) | ((!x_l[3])&( (x_l[2]&(x_l[1]^x_l[0])) | ((!x_l[2])&x_l[1]&x_l[0] )))) y[1] = 1;
            if((x_l[3]&(!x_l[2])) | (x_l[1]&((x_l[0]&x_l[2]) | ((!x_l[0])&(!x_l[3]))))) y[0] =1;
        }

        if(I<3) {
            bool overf = 0;
#pragma unroll
            for(int j=3; j>=I+1; j--) {
                if(y[j]) {
                    overf = 1;
                }
            }
            if (overf) {
#pragma unroll
                for(int j=3; j>=I+1; j--) {
                    y[j] = 0;
                }
#pragma unroll
                for(int j=I; j>=0; j--) {
                    y[j] = 1;
                }
            }
        }
        r = y;

    } else if(I_s == 3) {

        ap_fixed<9,5> x_l = x;
        ap_ufixed<8,4> y = 0;
        ap_fixed<3,3> x_l_int;
        x_l_int(2,0) = x_l(6,4);
        ap_ufixed<4,0> x_l_fract;
        x_l_fract(3,0) = x_l(3,0);

        if((x_l[8]!=x_l[7])||(x_l[8]!=x_l[6])) {
            if(!x_l[8]) {
                y = "0xf.fp0";
            }
        } else {
            ap_uint<4> x_msb_ind;
            ap_uint<3> x_lsb_ind;
            x_msb_ind[3] = x_l[8];
            x_msb_ind(2,0) = x_l(5,3);
            x_lsb_ind(2,0) = x_l(2,0);
            const static ap_ufixed<10,4> exp2_x_msb_table[16] = {
                "0x1.00p0", "0x1.6Cp0", "0x2.00p0", "0x2.D4p0",
                "0x4.00p0", "0x5.A8p0", "0x8.00p0", "0xB.50p0",
                "0x0.10p0", "0x0.18p0", "0x0.20p0", "0x0.2Cp0",
                "0x0.40p0", "0x0.5Cp0", "0x0.80p0", "0x0.B4p0"
            };
            const static ap_ufixed<10,0> exp2_x_lsb_m_1_table[8] = {
                "0x0.0p0", "0x0.0B4p0", "0x0.174p0", "0x0.238p0",
                "0x0.308p0", "0x0.3E0p0", "0x0.4C0p0", "0x0.5ACp0"
            };
            ap_ufixed<11,0> exp2_x_lsb_m_1 = exp2_x_lsb_m_1_table[x_lsb_ind];
            ap_ufixed<10,4> exp2_x_msb = exp2_x_msb_table[x_msb_ind];
            ap_ufixed<21,4> y_lo = exp2_x_msb * exp2_x_lsb_m_1;
            ap_ufixed<10,4> y_lo_s = y_lo;
            ap_ufixed<10,4> y_l = y_lo_s + exp2_x_msb;
            y = y_l;
        }

        if(I < 5) {
            bool overf = 0;
#pragma unroll
            for(int j=7; j>=3+I; j--) {
                if(y[j]) {
                    overf = 1;
                }
            }
            if(overf) {
#pragma unroll
                for(int j=7; j>=3+I; j--) {
                    y[j] = 0;
                }
#pragma unroll
                for(int j=I+2; j>=0; j--) {
                    y[j] = 1;
                }
            }
        }
        r = y;

    } else if(I_s == 4) {

        ap_fixed<17,9> x_l=x;
        ap_ufixed<16,8> y = 0;
        ap_fixed<4,4> x_l_int;
        x_l_int(3,0) = x_l(11,8);
        ap_ufixed<8,0> x_l_fract;
        x_l_fract(7,0) = x_l(7,0);

        bool overf_1 = 0;
#pragma unroll
        for(int j=11; j<16; j++) {
            if(x_l[16]!=x_l[j]) {
                overf_1 = 1;
            }
        }
        if(overf_1) {
            if(!x_l[16]) {
                y = "0xff.ffp0";
            }
        } else {

            ap_uint<5> x_msb_ind_1;
            x_msb_ind_1(4,0) = x_l(11,7);
            ap_uint<4> x_msb_ind_2;
            x_msb_ind_2(3,0) = x_l(6,3);
            ap_uint<3> x_lsb_ind;
            x_lsb_ind = x_l(2,0);

            const static ap_ufixed<14,-5> exp2_x_lsb_m_1_table[8] = {
                "0x0.0p0", "0x0.00B1Ap0", "0x0.0163Ep0", "0x0.02168p0",
                "0x0.02C9Ap0", "0x0.037D4p0", "0x0.04316p0", "0x0.04E60p0"
            };
            ap_ufixed<14,-5> exp2_x_lsb_m_1 = exp2_x_lsb_m_1_table[x_lsb_ind];

            const static ap_ufixed<19,0> exp2_x_msb_2_m_1_table[16] = {
                "0x0.0p0,0", "0x0.059B0p0", "0x0.0B558p0", "0x0.11302p0",
                "0x0.172B8p0", "0x0.1D488p0", "0x0.2387Ap0", "0x0.29E9Ep0",
                "0x0.306FEp0", "0x0.371A8p0", "0x0.3DEA6p0", "0x0.44E08p0",
                "0x0.4BFDAp0", "0x0.5342Cp0", "0x0.5AB08p0", "0x0.6247Ep0"
            };
            ap_ufixed<19,0> exp2_x_msb_2_m_1 = exp2_x_msb_2_m_1_table[x_msb_ind_2];
            ap_ufixed<33,-5> f_x_msb_2_lsb = exp2_x_msb_2_m_1 * exp2_x_lsb_m_1;
            ap_ufixed<19,0> f_x_msb_2_lsb_s = f_x_msb_2_lsb;
            ap_ufixed<19,0> exp2_x_msb_2_lsb_m_1 = f_x_msb_2_lsb_s + exp2_x_msb_2_m_1 + exp2_x_lsb_m_1;

            const static ap_ufixed<19,8> exp2_x_msb_1_table[32] = {
                "0x1.000p0", "0x1.6A0p0", "0x2.000p0", "0x2.D42p0",
                "0x4.000p0", "0x5.A82p0", "0x8.000p0", "0xB.504p0",
                "0x10.000p0", "0x16.A0Ap0", "0x20.000p0", "0x2D.414p0",
                "0x40.000p0", "0x5A.828p0", "0x80.000p0", "0xB5.050p0",
                "0x0.010p0", "0x0.016p0", "0x0.020p0", "0x0.02Ep0",
                "0x0.040p0", "0x0.05Ap0", "0x0.080p0", "0x0.0B6p0",
                "0x0.100p0", "0x0.16Ap0", "0x0.200p0", "0x0.2D4p0",
                "0x0.400p0", "0x0.5A8p0", "0x0.800p0", "0x0.B50p0"
            };
            ap_ufixed<19,8> exp2_x_msb_1 = exp2_x_msb_1_table[x_msb_ind_1];
            ap_ufixed<38,8> y_lo = exp2_x_msb_1 * exp2_x_msb_2_lsb_m_1;
            ap_ufixed<19,8> y_lo_s = y_lo;
            ap_ufixed<19,8> y_l = y_lo_s + exp2_x_msb_1;
            y = y_l;
        }

        if(I < 9) {
            bool overf_2 = 0;
#pragma unroll
            for(int j=15; j>=7+I; j--) {
                if(y[j]) {
                    overf_2 = 1;
                }
            }
            if(overf_2) {
#pragma unroll
                for(int j=15; j>=7+I; j--) {
                    y[j] = 0;
                }
#pragma unroll
                for(int j=6+I; j>=0; j--) {
                    y[j] = 1;
                }
            }
        }
        r = y;

    } else if(I_s == 5) {

        ap_fixed<33,17> x_l = x;
        ap_ufixed<32,16> y = 0;
        ap_fixed<5,5> x_l_int;
        x_l_int(4,0) = x_l(20,16);
        ap_ufixed<16,0> x_l_fract;
        x_l_fract(15,0) = x_l(15,0);

        bool overf_1 = 0;
#pragma unroll
        for(int j=20; j<32; j++) {
            if(x_l[32]!=x_l[j]) {
                overf_1 = 1;
            }
        }
        if(overf_1) {
            if(!x_l[32]) {
                y = "0xffff.ffffp0";
            }
        } else {
            ap_uint<6> x_msb_ind_1;
            x_msb_ind_1(5,0) = x_l(20,15);
            ap_uint<5> x_msb_ind_2;
            x_msb_ind_2(4,0) = x_l(14,10);
            ap_uint<5> x_msb_ind_3;
            x_msb_ind_3(4,0) = x_l(9,5);
            ap_uint<5> x_lsb_ind;
            x_lsb_ind = x_l(4,0);

            const static ap_ufixed<25,-11> exp2_x_lsb_m_1_table[32] = {
                "0x0.0p0", "0x0.0000B1725p0", "0x0.000162E52p0", "0x0.000214587p0",
                "0x0.0002C5CC3p0", "0x0.000377408p0", "0x0.000428B53p0", "0x0.0004DA2A7p0",
                "0x0.00058BA02p0", "0x0.00063D165p0", "0x0.0006EE8CFp0", "0x0.0007A0042p0",
                "0x0.0008517BBp0", "0x0.000902F3Dp0", "0x0.0009B46C6p0", "0x0.000A65E57p0",
                "0x0.000B175F0p0", "0x0.000BC8D90p0", "0x0.000C7A538p0", "0x0.000D2BCE8p0",
                "0x0.000DDD4A0p0", "0x0.000E8EC5Fp0", "0x0.000F40425p0", "0x0.000FF1BF4p0",
                "0x0.0010A33CAp0", "0x0.001154BA8p0", "0x0.00120638Dp0", "0x0.0012B7B7Bp0",
                "0x0.001369370p0", "0x0.00141AB6Cp0", "0x0.0014CC371p0", "0x0.00157DB7Dp0"
            };
            ap_ufixed<25,-11> exp2_x_lsb_m_1 = exp2_x_lsb_m_1_table[x_lsb_ind];

            const static ap_ufixed<30,-6> exp2_x_msb_3_m_1_table[32] = {
                "0x0.0p0", "0x0.00162F390p0", "0x0.002C605E3p0", "0x0.0042936FBp0",
                "0x0.0058C86DAp0", "0x0.006EFF584p0", "0x0.0085382FBp0", "0x0.009B72F42p0",
                "0x0.00B1AFA5Bp0", "0x0.00C7EE449p0", "0x0.00DE2ED0Fp0", "0x0.00F4714AFp0",
                "0x0.010AB5B2Dp0", "0x0.0120FC08Ap0", "0x0.0137444CAp0", "0x0.014D8E7EFp0",
                "0x0.0163DA9FBp0", "0x0.017A28AF2p0", "0x0.019078AD7p0", "0x0.01A6CA9ABp0",
                "0x0.01BD1E771p0", "0x0.01D37442Dp0", "0x0.01E9CBFE1p0", "0x0.020025A8Fp0",
                "0x0.02168143Bp0", "0x0.022CDECE7p0", "0x0.02433E495p0", "0x0.02599FB48p0",
                "0x0.027003104p0", "0x0.0286685CAp0", "0x0.029CCF99Dp0", "0x0.02B338C81p0"
            };
            ap_ufixed<30,-6> exp2_x_msb_3_m_1 = exp2_x_msb_3_m_1_table[x_msb_ind_3];
            ap_ufixed<55,-17> f_x_msb_3_lsb = exp2_x_msb_3_m_1 * exp2_x_lsb_m_1;
            ap_ufixed<19,-17> f_x_msb_3_lsb_s = f_x_msb_3_lsb;
            ap_ufixed<30,-6> exp2_x_msb_3_lsb_m_1 = f_x_msb_3_lsb_s + exp2_x_msb_3_m_1 + exp2_x_lsb_m_1;

            const static ap_ufixed<36,0> exp2_x_msb_2_m_1_table[32] = {
                "0x0.0p0", "0x0.02C9A3E78p0", "0x0.059B0D316p0", "0x0.087451876p0",
                "0x0.0B5586CFAp0", "0x0.0E3EC32D4p0", "0x0.11301D012p0", "0x0.1429AAEA9p0",
                "0x0.172B83C7Dp0", "0x0.1A35BEB70p0", "0x0.1D4873169p0", "0x0.2063B8863p0",
                "0x0.2387A6E75p0", "0x0.26B4565E2p0", "0x0.29E9DF520p0", "0x0.2D285A6E4p0",
                "0x0.306FE0A32p0", "0x0.33C08B264p0", "0x0.371A7373Bp0", "0x0.3A7DB34E6p0",
                "0x0.3DEA64C12p0", "0x0.4160A21F7p0", "0x0.44E086062p0", "0x0.486A2B5C1p0",
                "0x0.4BFDAD536p0", "0x0.4F9B2769Dp0", "0x0.5342B569Dp0", "0x0.56F4736B5p0",
                "0x0.5AB07DD48p0", "0x0.5E76F15ADp0", "0x0.6247EB03Ap0", "0x0.662388255p0"
            };
            ap_ufixed<36,0> exp2_x_msb_2_m_1 = exp2_x_msb_2_m_1_table[x_msb_ind_2];
            ap_ufixed<66,-6> f_x_msb_2_lsb = exp2_x_msb_2_m_1 * exp2_x_msb_3_lsb_m_1;
            ap_ufixed<30,-6> f_x_msb_2_lsb_s = f_x_msb_2_lsb;
            ap_ufixed<36,0> exp2_x_msb_2_3_lsb_m_1 = f_x_msb_2_lsb_s + exp2_x_msb_2_m_1 + exp2_x_msb_3_lsb_m_1;

            const static ap_ufixed<36,16> exp2_x_msb_1_table[64] = {
                "0x1.00000p0", "0x1.6A09Ep0", "0x2.00000p0", "0x2.D413Dp0",
                "0x4.00000p0", "0x5.A827Ap0", "0x8.00000p0", "0xB.504F3p0",
                "0x10.00000p0", "0x16.A09E6p0", "0x20.00000p0", "0x2D.413CDp0",
                "0x40.00000p0", "0x5A.8279Ap0", "0x80.00000p0", "0xB5.04F33p0",
                "0x100.00000p0", "0x16A.09E66p0", "0x200.00000p0", "0x2D4.13CCDp0",
                "0x400.00000p0", "0x5A8.2799Ap0", "0x800.00000p0", "0xB50.4F334p0",
                "0x1000.00000p0", "0x16A0.9E668p0", "0x2000.00000p0", "0x2D41.3CCD0p0",
                "0x4000.00000p0", "0x5A82.799A0p0", "0x8000.00000p0", "0xB504.F3340p0",
                "0x0.00010p0", "0x0.00017p0", "0x0.00020p0", "0x0.0002Dp0",
                "0x0.00040p0", "0x0.0005Bp0", "0x0.00080p0", "0x0.000B5p0",
                "0x0.00100p0", "0x0.0016Ap0", "0x0.00200p0", "0x0.002D4p0",
                "0x0.00400p0", "0x0.005A8p0", "0x0.00800p0", "0x0.00B50p0",
                "0x0.01000p0", "0x0.016A1p0", "0x0.02000p0", "0x0.02D41p0",
                "0x0.04000p0", "0x0.05A82p0", "0x0.08000p0", "0x0.0B505p0",
                "0x0.10000p0", "0x0.16A0Ap0", "0x0.20000p0", "0x0.2D414p0",
                "0x0.40000p0", "0x0.5A828p0", "0x0.80000p0", "0x0.B504Fp0"
            };
            ap_ufixed<36,16> exp2_x_msb_1 = exp2_x_msb_1_table[x_msb_ind_1];
            ap_ufixed<72,16> y_lo = exp2_x_msb_1 * exp2_x_msb_2_3_lsb_m_1;
            ap_ufixed<36,16> y_lo_s = y_lo;
            ap_ufixed<36,16> y_l = y_lo_s + exp2_x_msb_1;
            y = y_l;
        }

        if(I<17) {
            bool overf_2 = 0;
#pragma unroll
            for(int j=31; j>=I+15; j--) {
                if(y[j]) {
                    overf_2 = 1;
                }
            }
            if(overf_2) {
#pragma unroll
                for(int j=31; j>=I+15; j--) {
                    y[j] = 0;
                }
#pragma unroll
                for(int j=I+14; j>=0; j--) {
                    y[j] = 1;
                }
            }
        }
        r = y;

    } else {
        ap_fixed<65,33> x_l = 0;
#pragma unroll
        for(int j=32-F; j<32+I; j++) {
            x_l[j] = x[j-(32-F)];
        }
#pragma unroll
        for(int j=32+I; j<=64; j++) {
            x_l[j] = x[W-1];
        }
        ap_ufixed<64,32> y = 0;
        ap_fixed<6,6> x_l_int;
        x_l_int(5,0) = x_l(37,32);
        ap_ufixed<32,0> x_l_fract;
        x_l_fract(31,0) = x_l(31,0);

        bool overf_1 = 0;
#pragma unroll
        for(int j=37; j<64; j++) {
            if(x_l[j]!=x_l[64]) {
                overf_1 = 1;
            }
        }
        if(overf_1) {
            if(!x_l[64]) {
#pragma unroll
                for(int j=0; j<64; j++) {
                    y[j] = 1;
                }
            }
        } else {
            ap_uint<8> x_msb_ind_1;
            x_msb_ind_1(7,0) = x_l(37,30);
            ap_uint<8> x_msb_ind_2;
            x_msb_ind_2(7,0) = x_l(29,22);
            ap_uint<8> x_msb_ind_3;
            x_msb_ind_3(7,0) = x_l(21,14);
            ap_uint<8> x_msb_ind_4;
            x_msb_ind_4(7,0) = x_l(13,6);
            ap_uint<6> x_lsb_ind;
            x_lsb_ind(5,0) = x_l(5,0);

            const static ap_ufixed<42,-26> exp2_x_lsb_m_1_table[64] = {
                "0x0.0p0", "0x0.00000000B17217F81p0", "0x0.0000000162E42FF0Ap0", "0x0.00000002145647E9Ap0",
                "0x0.00000002C5C85FE32p0", "0x0.00000003773A77DD2p0", "0x0.0000000428AC8FD79p0", "0x0.00000004DA1EA7D28p0",
                "0x0.000000058B90BFCDFp0", "0x0.000000063D02D7C9Dp0", "0x0.00000006EE74EFC63p0", "0x0.000000079FE707C31p0",
                "0x0.0000000851591FC07p0", "0x0.0000000902CB37BE4p0", "0x0.00000009B43D4FBC9p0", "0x0.0000000A65AF67BB6p0",
                "0x0.0000000B17217FBAAp0", "0x0.0000000BC89397BA6p0", "0x0.0000000C7A05AFBA9p0", "0x0.0000000D2B77C7BB5p0",
                "0x0.0000000DDCE9DFBC8p0", "0x0.0000000E8E5BF7BE2p0", "0x0.0000000F3FCE0FC05p0", "0x0.0000000FF14027C2Fp0",
                "0x0.00000010A2B23FC61p0", "0x0.00000011542457C9Ap0", "0x0.0000001205966FCDBp0", "0x0.00000012B70887D24p0",
                "0x0.00000013687A9FD75p0", "0x0.0000001419ECB7DCDp0", "0x0.00000014CB5ECFE2Dp0", "0x0.000000157CD0E7E94p0",
                "0x0.000000162E42FFF03p0", "0x0.00000016DFB517F7Ap0", "0x0.0000001791272FFF9p0", "0x0.0000001842994807Fp0",
                "0x0.00000018F40B6010Dp0", "0x0.00000019A57D781A3p0", "0x0.0000001A56EF90240p0", "0x0.0000001B0861A82E6p0",
                "0x0.0000001BB9D3C0392p0", "0x0.0000001C6B45D8447p0", "0x0.0000001D1CB7F0503p0", "0x0.0000001DCE2A085C7p0",
                "0x0.0000001E7F9C20692p0", "0x0.0000001F310E38765p0", "0x0.0000001FE28050840p0", "0x0.0000002093F268923p0",
                "0x0.00000021456480A0Dp0", "0x0.00000021F6D698AFFp0", "0x0.00000022A848B0BF9p0", "0x0.0000002359BAC8CFAp0",
                "0x0.000000240B2CE0E03p0", "0x0.00000024BC9EF8F14p0", "0x0.000000256E111102Cp0", "0x0.000000261F832914Cp0",
                "0x0.00000026D0F541274p0", "0x0.000000278267593A3p0", "0x0.0000002833D9714DBp0", "0x0.00000028E54B89619p0",
                "0x0.0000002996BDA1760p0", "0x0.0000002A482FB98AEp0", "0x0.0000002AF9A1D1A04p0", "0x0.0000002BAB13E9B61p0"
            };
            ap_ufixed<42,-26> exp2_x_lsb_m_1 = exp2_x_lsb_m_1_table[x_lsb_ind];

            const static ap_ufixed<50,-18> exp2_x_msb_4_m_1_table[256] = {
                "0x0.0p0", "0x0.0000002C5C8601CC7p0", "0x0.00000058B90C0B48Cp0", "0x0.0000008515921C751p0",
                "0x0.000000B1721835515p0", "0x0.000000DDCE9E55DD7p0", "0x0.0000010A2B247E199p0", "0x0.0000013687AAAE059p0",
                "0x0.00000162E430E5A19p0", "0x0.0000018F40B724ED7p0", "0x0.000001BB9D3D6BE95p0", "0x0.000001E7F9C3BA951p0",
                "0x0.00000214564A10F0Dp0", "0x0.00000240B2D06EFC7p0", "0x0.0000026D0F56D4B80p0", "0x0.000002996BDD42239p0",
                "0x0.000002C5C863B73F0p0", "0x0.000002F224EA340A6p0", "0x0.0000031E8170B885Cp0", "0x0.0000034ADDF744B10p0",
                "0x0.000003773A7DD88C3p0", "0x0.000003A3970474175p0", "0x0.000003CFF38B17526p0", "0x0.000003FC5011C23D6p0",
                "0x0.00000428AC9874D86p0", "0x0.00000455091F2F234p0", "0x0.0000048165A5F11E1p0", "0x0.000004ADC22CBAC8Dp0",
                "0x0.000004DA1EB38C238p0", "0x0.000005067B3A652E2p0", "0x0.00000532D7C145E8Bp0", "0x0.0000055F34482E533p0",
                "0x0.0000058B90CF1E6D9p0", "0x0.000005B7ED561637Fp0", "0x0.000005E449DD15B24p0", "0x0.00000610A6641CDC8p0",
                "0x0.0000063D02EB2BB6Bp0", "0x0.000006695F724240Dp0", "0x0.00000695BBF9607AEp0", "0x0.000006C218808664Dp0",
                "0x0.000006EE7507B3FECp0", "0x0.0000071AD18EE948Ap0", "0x0.000007472E1626427p0", "0x0.000007738A9D6AEC2p0",
                "0x0.0000079FE724B745Dp0", "0x0.000007CC43AC0B4F7p0", "0x0.000007F8A0336708Fp0", "0x0.00000824FCBACA727p0",
                "0x0.000008515942358BEp0", "0x0.0000087DB5C9A8553p0", "0x0.000008AA125122CE8p0", "0x0.000008D66ED8A4F7Bp0",
                "0x0.00000902CB602ED0Ep0", "0x0.0000092F27E7C059Fp0", "0x0.0000095B846F59930p0", "0x0.00000987E0F6FA7C0p0",
                "0x0.000009B43D7EA314Ep0", "0x0.000009E09A06535DCp0", "0x0.00000A0CF68E0B568p0", "0x0.00000A395315CAFF3p0",
                "0x0.00000A65AF9D9257Ep0", "0x0.00000A920C2561607p0", "0x0.00000ABE68AD38190p0", "0x0.00000AEAC53516817p0",
                "0x0.00000B1721BCFC99Ep0", "0x0.00000B437E44EA623p0", "0x0.00000B6FDACCDFDA7p0", "0x0.00000B9C3754DD02Bp0",
                "0x0.00000BC893DCE1DADp0", "0x0.00000BF4F064EE62Fp0", "0x0.00000C214CED029AFp0", "0x0.00000C4DA9751E82Ep0",
                "0x0.00000C7A05FD421ADp0", "0x0.00000CA662856D62Ap0", "0x0.00000CD2BF0DA05A6p0", "0x0.00000CFF1B95DB022p0",
                "0x0.00000D2B781E1D59Cp0", "0x0.00000D57D4A667615p0", "0x0.00000D84312EB918Dp0", "0x0.00000DB08DB712805p0",
                "0x0.00000DDCEA3F7397Bp0", "0x0.00000E0946C7DC5F0p0", "0x0.00000E35A3504CD65p0", "0x0.00000E61FFD8C4FD8p0",
                "0x0.00000E8E5C6144D4Ap0", "0x0.00000EBAB8E9CC5BBp0", "0x0.00000EE715725B92Cp0", "0x0.00000F1371FAF279Bp0",
                "0x0.00000F3FCE8391109p0", "0x0.00000F6C2B0C37576p0", "0x0.00000F988794E54E3p0", "0x0.00000FC4E41D9AF4Ep0",
                "0x0.00000FF140A6584B8p0", "0x0.0000101D9D2F1D521p0", "0x0.00001049F9B7EA08Ap0", "0x0.000010765640BE6F1p0",
                "0x0.000010A2B2C99A857p0", "0x0.000010CF0F527E4BCp0", "0x0.000010FB6BDB69C21p0", "0x0.00001127C8645CE84p0",
                "0x0.0000115424ED57BE6p0", "0x0.0000118081765A447p0", "0x0.000011ACDDFF647A7p0", "0x0.000011D93A8876607p0",
                "0x0.0000120597118FF65p0", "0x0.00001231F39AB13C2p0", "0x0.0000125E5023DA31Ep0", "0x0.0000128AACAD0AD7Ap0",
                "0x0.000012B70936432D4p0", "0x0.000012E365BF8332Dp0", "0x0.0000130FC248CAE85p0", "0x0.0000133C1ED21A4DDp0",
                "0x0.000013687B5B71633p0", "0x0.00001394D7E4D0288p0", "0x0.000013C1346E369DDp0", "0x0.000013ED90F7A4C30p0",
                "0x0.00001419ED811A982p0", "0x0.000014464A0A981D4p0", "0x0.00001472A6941D524p0", "0x0.0000149F031DAA373p0",
                "0x0.000014CB5FA73ECC1p0", "0x0.000014F7BC30DB10Fp0", "0x0.0000152418BA7F05Bp0", "0x0.0000155075442AAA6p0",
                "0x0.0000157CD1CDDDFF1p0", "0x0.000015A92E579903Ap0", "0x0.000015D58AE15BB83p0", "0x0.00001601E76B261CAp0",
                "0x0.0000162E43F4F8310p0", "0x0.0000165AA07ED1F56p0", "0x0.00001686FD08B369Ap0", "0x0.000016B359929C8DEp0",
                "0x0.000016DFB61C8D620p0", "0x0.0000170C12A685E62p0", "0x0.000017386F30861A2p0", "0x0.00001764CBBA8DFE1p0",
                "0x0.0000179128449D920p0", "0x0.000017BD84CEB4D5Dp0", "0x0.000017E9E158D3C9Ap0", "0x0.000018163DE2FA6D6p0",
                "0x0.000018429A6D28C10p0", "0x0.0000186EF6F75EC4Ap0", "0x0.0000189B53819C782p0", "0x0.000018C7B00BE1DBAp0",
                "0x0.000018F40C962EEF0p0", "0x0.00001920692083B26p0", "0x0.0000194CC5AAE025Bp0", "0x0.0000197922354448Ep0",
                "0x0.000019A57EBFB01C1p0", "0x0.000019D1DB4A239F3p0", "0x0.000019FE37D49ED23p0", "0x0.00001A2A945F21B53p0",
                "0x0.00001A56F0E9AC482p0", "0x0.00001A834D743E8B0p0", "0x0.00001AAFA9FED87DCp0", "0x0.00001ADC06897A208p0",
                "0x0.00001B08631423733p0", "0x0.00001B34BF9ED475Dp0", "0x0.00001B611C298D286p0", "0x0.00001B8D78B44D8ADp0",
                "0x0.00001BB9D53F159D4p0", "0x0.00001BE631C9E55FAp0", "0x0.00001C128E54BCD1Fp0", "0x0.00001C3EEADF9BF43p0",
                "0x0.00001C6B476A82C66p0", "0x0.00001C97A3F571488p0", "0x0.00001CC40080677A9p0", "0x0.00001CF05D0B655C9p0",
                "0x0.00001D1CB9966AEE8p0", "0x0.00001D49162178306p0", "0x0.00001D7572AC8D223p0", "0x0.00001DA1CF37A9C40p0",
                "0x0.00001DCE2BC2CE15Bp0", "0x0.00001DFA884DFA175p0", "0x0.00001E26E4D92DC8Ep0", "0x0.00001E534164692A6p0",
                "0x0.00001E7F9DEFAC3BEp0", "0x0.00001EABFA7AF6FD4p0", "0x0.00001ED85706496E9p0", "0x0.00001F04B391A38FEp0",
                "0x0.00001F31101D05611p0", "0x0.00001F5D6CA86EE23p0", "0x0.00001F89C933E0135p0", "0x0.00001FB625BF58F45p0",
                "0x0.00001FE2824AD9855p0", "0x0.0000200EDED661C63p0", "0x0.0000203B3B61F1B71p0", "0x0.0000206797ED8957Dp0",
                "0x0.00002093F47928A89p0", "0x0.000020C05104CFA93p0", "0x0.000020ECAD907E59Dp0", "0x0.000021190A1C34BA6p0",
                "0x0.0000214566A7F2CAEp0", "0x0.00002171C333B88B4p0", "0x0.0000219E1FBF85FBAp0", "0x0.000021CA7C4B5B1BFp0",
                "0x0.000021F6D8D737EC3p0", "0x0.0000222335631C6C6p0", "0x0.0000224F91EF089C7p0", "0x0.0000227BEE7AFC7C8p0",
                "0x0.000022A84B06F80C8p0", "0x0.000022D4A792FB4C7p0", "0x0.00002301041F063C5p0", "0x0.0000232D60AB18DC3p0",
                "0x0.00002359BD37332BFp0", "0x0.0000238619C3552BAp0", "0x0.000023B2764F7EDB4p0", "0x0.000023DED2DBB03ADp0",
                "0x0.0000240B2F67E94A5p0", "0x0.000024378BF42A09Dp0", "0x0.00002463E88072793p0", "0x0.00002490450CC2988p0",
                "0x0.000024BCA1991A67Dp0", "0x0.000024E8FE2579E70p0", "0x0.000025155AB1E1163p0", "0x0.00002541B73E4FF54p0",
                "0x0.0000256E13CAC6845p0", "0x0.0000259A705744C34p0", "0x0.000025C6CCE3CAB23p0", "0x0.000025F3297058511p0",
                "0x0.0000261F85FCED9FDp0", "0x0.0000264BE2898A9E9p0", "0x0.000026783F162F4D4p0", "0x0.000026A49BA2DBABEp0",
                "0x0.000026D0F82F8FBA7p0", "0x0.000026FD54BC4B78Fp0", "0x0.00002729B1490EE75p0", "0x0.000027560DD5DA05Bp0",
                "0x0.000027826A62ACD41p0", "0x0.000027AEC6EF87525p0", "0x0.000027DB237C69808p0", "0x0.000028078009535EAp0",
                "0x0.00002833DC9644ECBp0", "0x0.0000286039233E2ABp0", "0x0.0000288C95B03F18Bp0", "0x0.000028B8F23D47B69p0",
                "0x0.000028E54ECA58046p0", "0x0.00002911AB5770023p0", "0x0.0000293E07E48FAFEp0", "0x0.0000296A6471B70D9p0",
                "0x0.00002996C0FEE61B2p0", "0x0.000029C31D8C1CD8Bp0", "0x0.000029EF7A195B463p0", "0x0.00002A1BD6A6A1639p0",
                "0x0.00002A483333EF30Fp0", "0x0.00002A748FC144AE4p0", "0x0.00002AA0EC4EA1DB8p0", "0x0.00002ACD48DC06B8Bp0",
                "0x0.00002AF9A5697345Dp0", "0x0.00002B2601F6E782Ep0", "0x0.00002B525E84636FEp0", "0x0.00002B7EBB11E70CDp0",
                "0x0.00002BAB179F7259Bp0", "0x0.00002BD7742D05568p0", "0x0.00002C03D0BAA0035p0", "0x0.00002C302D4842600p0"
            };
            ap_ufixed<50,-18> exp2_x_msb_4_m_1 = exp2_x_msb_4_m_1_table[x_msb_ind_4];
            ap_ufixed<92,-44> f_x_msb_4_lsb = exp2_x_lsb_m_1 * exp2_x_msb_4_m_1;
            ap_ufixed<24,-44> f_x_msb_4_lsb_s = f_x_msb_4_lsb;
            ap_ufixed<50,-18> exp2_x_msb_4_lsb_m_1 = f_x_msb_4_lsb_s + exp2_x_msb_4_m_1 + exp2_x_lsb_m_1;

            const static ap_ufixed<58,-10> exp2_x_msb_3_m_1_table[256] = {
                "0x0.0p0", "0x0.00002C5C89D5EC6CAp0", "0x0.000058B91B5BC9AE3p0", "0x0.00008515B4919919Ap0",
                "0x0.0000B17255775C040p0", "0x0.0000DDCEFE0D13C26p0", "0x0.00010A2BAE52C1A9Bp0", "0x0.000136886648670F0p0",
                "0x0.000162E525EE05475p0", "0x0.00018F41ED439DA7Bp0", "0x0.0001BB9EBC4931853p0", "0x0.0001E7FB92FEC234Bp0",
                "0x0.000214587164510B6p0", "0x0.000240B55779DF5E3p0", "0x0.00026D12453F6E823p0", "0x0.0002996F3AB4FFCC6p0",
                "0x0.0002C5CC37DA9491Dp0", "0x0.0002F2293CB02E278p0", "0x0.00031E864935CDE29p0", "0x0.00034AE35D6B7517Ep0",
                "0x0.000377407951251C9p0", "0x0.0003A39D9CE6DF45Bp0", "0x0.0003CFFAC82CA4E84p0", "0x0.0003FC57FB2277595p0",
                "0x0.000428B535C857EDDp0", "0x0.00045512781E47FAFp0", "0x0.0004816FC22448D5Ap0", "0x0.0004ADCD13DA5BD2Fp0",
                "0x0.0004DA2A6D408247Ep0", "0x0.00050687CE56BD89Ap0", "0x0.000532E5371D0EED1p0", "0x0.00055F42A79377C75p0",
                "0x0.00058BA01FB9F96D7p0", "0x0.0005B7FD9F9095347p0", "0x0.0005E45B27174C716p0", "0x0.000610B8B64E20794p0",
                "0x0.00063D164D3512A14p0", "0x0.00066973EBCC243E4p0", "0x0.000695D1921356A57p0", "0x0.0006C22F400AAB2BCp0",
                "0x0.0006EE8CF5B223266p0", "0x0.00071AEAB309BFEA4p0", "0x0.00074748781182CC7p0", "0x0.000773A644C96D221p0",
                "0x0.0007A004193180402p0", "0x0.0007CC61F549BD7BCp0", "0x0.0007F8BFD9122629Ep0", "0x0.0008251DC48ABB9FAp0",
                "0x0.0008517BB7B37F322p0", "0x0.00087DD9B28C72365p0", "0x0.0008AA37B51596015p0", "0x0.0008D695BF4EEBE83p0",
                "0x0.000902F3D13875400p0", "0x0.00092F51EAD2335DCp0", "0x0.00095BB00C1C2796Ap0", "0x0.0009880E3516533FAp0",
                "0x0.0009B46C65C0B7ADCp0", "0x0.0009E0CA9E1B56363p0", "0x0.000A0D28DE26302DFp0", "0x0.000A398725E146EA2p0",
                "0x0.000A65E5754C9BBFBp0", "0x0.000A9243CC683003Ep0", "0x0.000ABEA22B34050BAp0", "0x0.000AEB0091B01C2C1p0",
                "0x0.000B175EFFDC76BA4p0", "0x0.000B43BD75B9160B4p0", "0x0.000B701BF345FB742p0", "0x0.000B9C7A7883284A1p0",
                "0x0.000BC8D905709DE20p0", "0x0.000BF5379A0E5D912p0", "0x0.000C2196365C68AC6p0", "0x0.000C4DF4DA5AC0890p0",
                "0x0.000C7A538609667C0p0", "0x0.000CA6B239685BDA6p0", "0x0.000CD310F477A1F96p0", "0x0.000CFF6FB7373A2DFp0",
                "0x0.000D2BCE81A725CD4p0", "0x0.000D582D53C7662C6p0", "0x0.000D848C2D97FCA05p0", "0x0.000DB0EB0F18EA7E4p0",
                "0x0.000DDD49F84A311B4p0", "0x0.000E09A8E92BD1CC6p0", "0x0.000E3607E1BDCDE6Cp0", "0x0.000E6266E20026BF7p0",
                "0x0.000E8EC5E9F2DDAB9p0", "0x0.000EBB24F995F4003p0", "0x0.000EE78410E96B126p0", "0x0.000F13E32FED44375p0",
                "0x0.000F404256A180C40p0", "0x0.000F6CA18506220D9p0", "0x0.000F9900BB1B29692p0", "0x0.000FC55FF8E0982BDp0",
                "0x0.000FF1BF3E566FAAAp0", "0x0.00101E1E8B7CB13ACp0", "0x0.00104A7DE0535E314p0", "0x0.001076DD3CDA77E34p0",
                "0x0.0010A33CA111FFA5Dp0", "0x0.0010CF9C0CF9F6CE1p0", "0x0.0010FBFB80925EB11p0", "0x0.0011285AFBDB38A40p0",
                "0x0.001154BA7ED485FC0p0", "0x0.0011811A097E480E0p0", "0x0.0011AD799BD8802F5p0", "0x0.0011D9D935E32FB4Fp0",
                "0x0.00120638D79E57F3Fp0", "0x0.001232988109FA419p0", "0x0.00125EF8322617F2Dp0", "0x0.00128B57EAF2B25CDp0",
                "0x0.0012B7B7AB6FCAD4Bp0", "0x0.0012E417739D62AFAp0", "0x0.00131077437B7B42Ap0", "0x0.00133CD71B0A15E2Ep0",
                "0x0.00136936FA4933E58p0", "0x0.00139596E138D69F9p0", "0x0.0013C1F6CFD8FF663p0", "0x0.0013EE56C629AF8E9p0",
                "0x0.00141AB6C42AE86DBp0", "0x0.00144716C9DCAB58Dp0", "0x0.00147376D73EF9A50p0", "0x0.00149FD6EC51D4A76p0",
                "0x0.0014CC3709153DB51p0", "0x0.0014F8972D8936234p0", "0x0.001524F759ADBF46Fp0", "0x0.001551578D82DA755p0",
                "0x0.00157DB7C90889038p0", "0x0.0015AA180C3ECC46Bp0", "0x0.0015D6785725A593Fp0", "0x0.001602D8A9BD16406p0",
                "0x0.00162F3904051FA13p0", "0x0.00165B9965FDC30B7p0", "0x0.001687F9CFA701D45p0", "0x0.0016B45A4100DD50Ep0",
                "0x0.0016E0BABA0B56D66p0", "0x0.00170D1B3AC66FB9Ep0", "0x0.0017397BC33229508p0", "0x0.001765DC534E84EF7p0",
                "0x0.0017923CEB1B83EBCp0", "0x0.0017BE9D8A99279ABp0", "0x0.0017EAFE31C771515p0", "0x0.0018175EE0A66264Cp0",
                "0x0.001843BF9735FC2A3p0", "0x0.0018702055763FF6Cp0", "0x0.00189C811B672F1FAp0", "0x0.0018C8E1E908CAF9Ep0",
                "0x0.0018F542BE5B14DABp0", "0x0.001921A39B5E0E174p0", "0x0.00194E048011B804Ap0", "0x0.00197A656C7613F81p0",
                "0x0.0019A6C6608B2346Ap0", "0x0.0019D3275C50E7458p0", "0x0.0019FF885FC76149Dp0", "0x0.001A2BE96AEE92A8Cp0",
                "0x0.001A584A7DC67CB77p0", "0x0.001A84AB984F20CB1p0", "0x0.001AB10CBA888038Cp0", "0x0.001ADD6DE4729C55Ap0",
                "0x0.001B09CF160D7676Fp0", "0x0.001B36304F590FF1Dp0", "0x0.001B629190556A1B5p0", "0x0.001B8EF2D9028648Cp0",
                "0x0.001BBB54296065CF2p0", "0x0.001BE7B5816F0A03Cp0", "0x0.001C1416E12E743BBp0", "0x0.001C4078489EA5CC2p0",
                "0x0.001C6CD9B7BFA00A4p0", "0x0.001C993B2E91644B3p0", "0x0.001CC59CAD13F3E42p0", "0x0.001CF1FE3347502A4p0",
                "0x0.001D1E5FC12B7A72Bp0", "0x0.001D4AC156C07412Ap0", "0x0.001D7722F4063E5F4p0", "0x0.001DA38498FCDAADBp0",
                "0x0.001DCFE645A44A533p0", "0x0.001DFC47F9FC8EA4Dp0", "0x0.001E28A9B605A8F7Dp0", "0x0.001E550B79BF9AA16p0",
                "0x0.001E816D452A64F6Ap0", "0x0.001EADCF1846094CCp0", "0x0.001EDA30F31288F8Ep0", "0x0.001F0692D58FE5505p0",
                "0x0.001F32F4BFBE1FA82p0", "0x0.001F5F56B19D39559p0", "0x0.001F8BB8AB2D33ADCp0", "0x0.001FB81AAC6E1005Ep0",
                "0x0.001FE47CB55FCFB33p0", "0x0.002010DEC602740ACp0", "0x0.00203D40DE55FE61Ep0", "0x0.002069A2FE5A700DAp0",
                "0x0.00209605260FCA635p0", "0x0.0020C26755760EB80p0", "0x0.0020EEC98C8D3E60Fp0", "0x0.00211B2BCB555AB35p0",
                "0x0.0021478E11CE65045p0", "0x0.002173F05FF85EA93p0", "0x0.0021A052B5D348F70p0", "0x0.0021CCB5135F25430p0",
                "0x0.0021F917789BF4E26p0", "0x0.00222579E589B92A6p0", "0x0.002251DC5A2873702p0", "0x0.00227E3ED6782508Ep0",
                "0x0.0022AAA15A78CF49Cp0", "0x0.0022D703E62A73880p0", "0x0.00230366798D1318Dp0", "0x0.00232FC914A0AF516p0",
                "0x0.00235C2BB7654986Fp0", "0x0.0023888E61DAE30EAp0", "0x0.0023B4F114017D3DBp0", "0x0.0023E153CDD919695p0",
                "0x0.00240DB68F61B8E6Cp0", "0x0.00243A19589B5D0B2p0", "0x0.0024667C2986072BAp0", "0x0.002492DF0221B89D9p0",
                "0x0.0024BF41E26E72B62p0", "0x0.0024EBA4CA6C36CA7p0", "0x0.00251807BA1B062FDp0", "0x0.0025446AB17AE23B5p0",
                "0x0.002570CDB08BCC425p0", "0x0.00259D30B74DC599Fp0", "0x0.0025C993C5C0CF977p0", "0x0.0025F5F6DBE4EB900p0",
                "0x0.00262259F9BA1AD8Dp0", "0x0.00264EBD1F405EC72p0", "0x0.00267B204C77B8B03p0", "0x0.0026A783816029E92p0",
                "0x0.0026D3E6BDF9B3C74p0", "0x0.0027004A0244579FCp0", "0x0.00272CAD4E4016C7Dp0", "0x0.00275910A1ECF294Bp0",
                "0x0.00278573FD4AEC5BAp0", "0x0.0027B1D7605A0571Cp0", "0x0.0027DE3ACB1A3F2C6p0", "0x0.00280A9E3D8B9AE0Cp0",
                "0x0.00283701B7AE19E40p0", "0x0.002863653981BD8B6p0", "0x0.00288FC8C306872C3p0", "0x0.0028BC2C543C781B9p0",
                "0x0.0028E88FED2391AECp0", "0x0.002914F38DBBD53B1p0", "0x0.0029415736054415Ap0", "0x0.00296DBAE5FFDF93Cp0",
                "0x0.00299A1E9DABA90A9p0", "0x0.0029C6825D08A1CF7p0", "0x0.0029F2E62416CB378p0", "0x0.002A1F49F2D626981p0",
                "0x0.002A4BADC946B5464p0", "0x0.002A7811A76878977p0", "0x0.002AA4758D3B71E0Cp0", "0x0.002AD0D97ABFA2778p0",
                "0x0.002AFD3D6FF50BB0Ep0", "0x0.002B29A16CDBAEE23p0", "0x0.002B560571738D609p0", "0x0.002B82697DBCA8816p0",
                "0x0.002BAECD91B70199Cp0", "0x0.002BDB31AD6299FF0p0", "0x0.002C0795D0BF73066p0", "0x0.002C33F9FBCD8E052p0"
            };
            ap_ufixed<58,-10> exp2_x_msb_3_m_1 = exp2_x_msb_3_m_1_table[x_msb_ind_3];
            ap_ufixed<108,-28> f_x_msb_3_lsb = exp2_x_msb_3_m_1 * exp2_x_msb_4_lsb_m_1;
            ap_ufixed<40, -28> f_x_msb_3_lsb_s = f_x_msb_3_lsb;
            ap_ufixed<58, -10> exp2_x_msb_3_4_lsb_m_1 = f_x_msb_3_lsb_s + exp2_x_msb_3_m_1 + exp2_x_msb_4_lsb_m_1;

            const static ap_ufixed<68,0> exp2_x_msb_2_m_1_table[256] = {
                "0x0.0p0", "0x0.002C605E2E8CEC507p0", "0x0.0058C86DA1C09EA20p0", "0x0.0085382FAEF831DA9p0",
                "0x0.00B1AFA5ABCBED613p0", "0x0.00DE2ED0EE0F4F5FDp0", "0x0.010AB5B2CBD117074p0", "0x0.0137444C9B5B4ED49p0",
                "0x0.0163DA9FB33356D85p0", "0x0.019078AD6A19EEFF7p0", "0x0.01BD1E77170B415E7p0", "0x0.01E9CBFE113EEC7DCp0",
                "0x0.02168143B0280DA82p0", "0x0.02433E494B754B3ADp0", "0x0.027003103B10DEF7Dp0", "0x0.029CCF99D720A0593p0",
                "0x0.02C9A3E778060EE6Fp0", "0x0.02F67FFA765E5C8E5p0", "0x0.032363D42B0277FAAp0", "0x0.03504F75EF0716F0Cp0",
                "0x0.037D42E11BBCC0AB4p0", "0x0.03AA3E170AAFD8396p0", "0x0.03D7411915A8A6DF0p0", "0x0.04044BE896AB66771p0",
                "0x0.04315E86E7F84BD74p0", "0x0.045E78F5640B9135Cp0", "0x0.048B9B35659D8090Ep0", "0x0.04B8C54847A27E186p0",
                "0x0.04E5F72F654B12987p0", "0x0.051330EC1A03F5E6Ap0", "0x0.0540727FC1761950Dp0", "0x0.056DBBEBB786B20D9p0",
                "0x0.059B0D31585743AE8p0", "0x0.05C866520045AA948p0", "0x0.05F5C74F0BEC2665Bp0", "0x0.06233029D82164855p0",
                "0x0.0650A0E3C1F88A8D2p0", "0x0.067E197E26C140C90p0", "0x0.06AB99FA6407BCB43p0", "0x0.06D92259D794CB783p0",
                "0x0.0706B29DDF6DDC6DCp0", "0x0.07344AC7D9D50B9FCp0", "0x0.0761EAD925492C4F5p0", "0x0.078F92D32085D37A9p0",
                "0x0.07BD42B72A8362646p0", "0x0.07EAFA86A277111EFp0", "0x0.0818BA42E7D2F916Ep0", "0x0.084681ED5A461FA1Ap0",
                "0x0.0874518759BC808C3p0", "0x0.08A22912465F18AD3p0", "0x0.08D0088F8093F0774p0", "0x0.08FDF00068FE268ECp0",
                "0x0.092BDF66607DFA5FEp0", "0x0.0959D6C2C830D6B7Fp0", "0x0.0987D61701715C5F5p0", "0x0.09B5DD646DD76CB61p0",
                "0x0.09E3ECAC6F3834522p0", "0x0.0A1203F067A6359F1p0", "0x0.0A402331B97153804p0", "0x0.0A6E4A71C726DBF42p0",
                "0x0.0A9C79B1F39192BA3p0", "0x0.0ACAB0F3A1B9BBF9Fp0", "0x0.0AF8F03834E526EC8p0", "0x0.0B273781109738876p0",
                "0x0.0B5586CF9890F6299p0", "0x0.0B83DE2530D1104A2p0", "0x0.0BB23D833D93ED290p0", "0x0.0BE0A4EB2353B3818p0",
                "0x0.0C0F145E46C8553E6p0", "0x0.0C3D8BDE0CE79A306p0", "0x0.0C6C0B6BDAE52AC5Dp0", "0x0.0C9A930916329AC51p0",
                "0x0.0CC922B7247F7407Bp0", "0x0.0CF7BA776BB94138Ap0", "0x0.0D265A4B520B98932p0", "0x0.0D5502343DE026A4Bp0",
                "0x0.0D83B23395DEB90FBp0", "0x0.0DB26A4AC0ED4950Dp0", "0x0.0DE12A7B263007860p0", "0x0.0E0FF2C62D0965371p0",
                "0x0.0E3EC32D3D1A20207p0", "0x0.0E6D9BB1BE414CFFDp0", "0x0.0E9C7C55189C62628p0", "0x0.0ECB6518B4874375Bp0",
                "0x0.0EFA55FDFA9C4AD89p0", "0x0.0F294F0653B45570Ap0", "0x0.0F58503328E6CD3F5p0", "0x0.0F875985E389B439Ep0",
                "0x0.0FB66AFFED31AF232p0", "0x0.0FE584A2AFB210670p0", "0x0.1014A66F951CE2F7Ep0", "0x0.1043D06807C2F52E1p0",
                "0x0.1073028D7233E3A8Ep0", "0x0.10A23CE13F3E2431Dp0", "0x0.10D17F64D9EF10A19p0", "0x0.1100CA19AD92F1C6Bp0",
                "0x0.11301D0125B50A4ECp0", "0x0.115F781CAE1FA1B08p0", "0x0.118EDB6DB2DC0F18Dp0", "0x0.11BE46F5A032C458Fp0",
                "0x0.11EDBAB5E2AB58D6Fp0", "0x0.121D36AFE70C947FBp0", "0x0.124CBAE51A5C7ABB5p0", "0x0.127C4756E9E055631p0",
                "0x0.12ABDC06C31CBFB93p0", "0x0.12DB78F613D5B162Dp0", "0x0.130B1E264A0E8963Cp0", "0x0.133ACB98D40A191C1p0",
                "0x0.136A814F204AAF478p0", "0x0.139A3F4A9D9222FF2p0", "0x0.13CA058CBAE1DEBC9p0", "0x0.13F9D416E77AEB5F6p0",
                "0x0.1429AAEA92DDFB341p0", "0x0.14598A092CCB74FD3p0", "0x0.1489717425437EFE9p0", "0x0.14B9612CEC860A09Ep0",
                "0x0.14E95934F312DC8DCp0", "0x0.1519598DA9A99DA67p0", "0x0.154962388149E0304p0", "0x0.15797336EB332DDCAp0",
                "0x0.15A98C8A58E512481p0", "0x0.15D9AE343C1F26130p0", "0x0.1609D83606E119FBFp0", "0x0.163A0A912B6AC1FBBp0",
                "0x0.166A45471C3C2063Dp0", "0x0.169A88594C1570FE6p0", "0x0.16CAD3C92DF734306p0", "0x0.16FB279835223A1D7p0",
                "0x0.172B83C7D517ADCDFp0", "0x0.175BE85981992056Cp0", "0x0.178C554EAEA894030p0", "0x0.17BCCAA8D088877FCp0",
                "0x0.17ED48695BBC0109Ep0", "0x0.181DCE91C506999D8p0", "0x0.184E5D23816C88275p0", "0x0.187EF4200632ACB89p0",
                "0x0.18AF9388C8DE9BBBFp0", "0x0.18E03B5F3F36A92D4p0", "0x0.1910EBA4DF41F3D2Ap0", "0x0.1941A45B1F487077Ap0",
                "0x0.1972658375D2F52ABp0", "0x0.19A32F1F59AB447C4p0", "0x0.19D4013041DC18BF8p0", "0x0.1A04DBB7A5B12F4DCp0",
                "0x0.1A35BEB6FCB753CB7p0", "0x0.1A66AA2FBEBC6B6ECp0", "0x0.1A979E2363CF8048Fp0", "0x0.1AC89A936440CC90Dp0",
                "0x0.1AF99F8138A1C5EFEp0", "0x0.1B2AACEE59C528D0Dp0", "0x0.1B5BC2DC40BF03B07p0", "0x0.1B8CE14C66E4C2704p0",
                "0x0.1BBE084045CD39AB2p0", "0x0.1BEF37B95750B20C0p0", "0x0.1C206FB91588F3A67p0", "0x0.1C51B040FAD151512p0",
                "0x0.1C82F95281C6B4026p0", "0x0.1CB44AEF2547A62ECp0", "0x0.1CE5A51860745F298p0", "0x0.1D1707CFAEAECE86Cp0",
                "0x0.1D4873168B9AA7806p0", "0x0.1D79E6EE731D6C5BDp0", "0x0.1DAB6358E15E79D2Fp0", "0x0.1DDCE85752C7127E2p0",
                "0x0.1E0E75EB44026A409p0", "0x0.1E400C1631FDB1B6Ap0", "0x0.1E71AAD999E821A64p0", "0x0.1EA35236F9330670Ep0",
                "0x0.1ED5022FCD91CB882p0", "0x0.1F06BAC594FA06E38p0", "0x0.1F387BF9CDA384793p0", "0x0.1F6A45CDF60851B7Cp0",
                "0x0.1F9C18438CE4C902Bp0", "0x0.1FCDF35C11379D307p0", "0x0.1FFFD7190241E50A9p0", "0x0.2031C37BDF8726CFFp0",
                "0x0.2063B88628CD63B8Fp0", "0x0.2095B6395E1D237DAp0", "0x0.20C7BC96FFC17FDDEp0", "0x0.20F9CBA08E48302B7p0",
                "0x0.212BE3578A8194D65p0", "0x0.215E03BD7580C2FABp0", "0x0.21902CD3D09B8FF15p0", "0x0.21C25E9C1D6A9CE17p0",
                "0x0.21F49917DDC962553p0", "0x0.2226DC4893D63BCFAp0", "0x0.2259282FC1F273650p0", "0x0.228B7CCEEAC24D54Fp0",
                "0x0.22BDDA27912D13A6Ap0", "0x0.22F0403B385D21C70p0", "0x0.2322AF0B63BFF0291p0", "0x0.2355269997061FE83p0",
                "0x0.2387A6E75623866C2p0", "0x0.23BA2FF6254F390FBp0", "0x0.23ECC1C7890398C8Ap0", "0x0.241F5C5D05FE5DD26p0",
                "0x0.2451FFB82140A35A0p0", "0x0.2484ABDA600EF32CEp0", "0x0.24B760C547F15168Fp0", "0x0.24EA1E7A5EB3482F4p0",
                "0x0.251CE4FB2A63F3583p0", "0x0.254FB44931560C2A2p0", "0x0.25828C65FA1FF511Fp0", "0x0.25B56D530B9BC55D9p0",
                "0x0.25E85711ECE754F87p0", "0x0.261B49A42564482A2p0", "0x0.264E450B3CB81B573p0", "0x0.26814948BACC2EC3Ap0",
                "0x0.26B4565E27CDD257Ap0", "0x0.26E76C4D0C2E51669p0", "0x0.271A8B16F0A2FE778p0", "0x0.274DB2BD5E253F101p0",
                "0x0.2780E341DDF29781Ap0", "0x0.27B41CA5F98CB6B7Ep0", "0x0.27E75EEB3AB9820A2p0", "0x0.281AAA132B83210E1p0",
                "0x0.284DFE1F5638096CFp0", "0x0.28815B11456B0ABADp0", "0x0.28B4C0EA83F35A4FAp0", "0x0.28E82FAC9CEC9F225p0",
                "0x0.291BA7591BB6FDA67p0", "0x0.294F27F18BF723AB3p0", "0x0.2982B1777996543D0p0", "0x0.29B643EC70C273890p0",
                "0x0.29E9DF51FDEE12C26p0", "0x0.2A1D83A9ADD07C0A3p0", "0x0.2A5130F50D65BE58Dp0", "0x0.2A84E735A9EEB96A0p0",
                "0x0.2AB8A66D10F129AA3p0", "0x0.2AEC6E9CD037B426Bp0", "0x0.2B203FC675D1F27F9p0", "0x0.2B5419EB90147EDB7p0",
                "0x0.2B87FD0DAD98FFDDFp0", "0x0.2BBBE92E5D3E349F5p0", "0x0.2BEFDE4F2E2800A73p0", "0x0.2C23DC71AFBF77E86p0",
                "0x0.2C57E39771B2EABFBp0", "0x0.2C8BF3C203F5F1F3Fp0", "0x0.2CC00CF2F6C17AB8Dp0", "0x0.2CF42F2BDA93D2B35p0",
                "0x0.2D285A6E4030B4009p0", "0x0.2D5C8EBBB8A1513E7p0", "0x0.2D90CC15D53461967p0", "0x0.2DC5127E277E2CCAFp0",
                "0x0.2DF961F641589745Bp0", "0x0.2E2DBA7FB4E32E298p0", "0x0.2E621C1C148333651p0", "0x0.2E9686CCF2E3A9C88p0",
                "0x0.2ECAFA93E2F5611CAp0", "0x0.2EFF777277EF023C8p0", "0x0.2F33FD6A454D1B313p0", "0x0.2F688C7CDED22B4F1p0",
                "0x0.2F9D24ABD886AF562p0", "0x0.2FD1C5F8C6B92D937p0", "0x0.300670653DFE42058p0", "0x0.303B23F2D330AA821p0"
            };
            ap_ufixed<68,0> exp2_x_msb_2_m_1 = exp2_x_msb_2_m_1_table[x_msb_ind_2];
            ap_ufixed<126,-10> f_x_msb_2_lsb = exp2_x_msb_2_m_1 * exp2_x_msb_3_4_lsb_m_1;
            ap_ufixed<58, -10> f_x_msb_2_lsb_s = f_x_msb_2_lsb;
            ap_ufixed<68,0> exp2_x_msb_2_3_4_lsb_m_1 = f_x_msb_2_lsb_s + exp2_x_msb_2_m_1 + exp2_x_msb_3_4_lsb_m_1;

            const static ap_ufixed<68,32> exp2_x_msb_1_table[256] = {
                "0x1.000000000p0", "0x1.306FE0A32p0", "0x1.6A09E667Fp0", "0x1.AE89F995Bp0",
                "0x2.000000000p0", "0x2.60DFC1463p0", "0x2.D413CCCFEp0", "0x3.5D13F32B6p0",
                "0x4.000000000p0", "0x4.C1BF828C7p0", "0x5.A827999FDp0", "0x6.BA27E656Bp0",
                "0x8.000000000p0", "0x9.837F0518Ep0", "0xB.504F333FAp0", "0xD.744FCCAD7p0",
                "0x10.000000000p0", "0x13.06FE0A31Bp0", "0x16.A09E667F4p0", "0x1A.E89F995ADp0",
                "0x20.000000000p0", "0x26.0DFC14637p0", "0x2D.413CCCFE7p0", "0x35.D13F32B5Ap0",
                "0x40.000000000p0", "0x4C.1BF828C6Ep0", "0x5A.827999FCFp0", "0x6B.A27E656B5p0",
                "0x80.000000000p0", "0x98.37F0518DCp0", "0xB5.04F333F9Ep0", "0xD7.44FCCAD6Ap0",
                "0x100.000000000p0", "0x130.6FE0A31B7p0", "0x16A.09E667F3Cp0", "0x1AE.89F995AD4p0",
                "0x200.000000000p0", "0x260.DFC14636Ep0", "0x2D4.13CCCFE78p0", "0x35D.13F32B5A7p0",
                "0x400.000000000p0", "0x4C1.BF828C6DCp0", "0x5A8.27999FCEFp0", "0x6BA.27E656B4Fp0",
                "0x800.000000000p0", "0x983.7F0518DB9p0", "0xB50.4F333F9DEp0", "0xD74.4FCCAD69Dp0",
                "0x1000.000000000p0", "0x1306.FE0A31B71p0", "0x16A0.9E667F3BDp0", "0x1AE8.9F995AD3Bp0",
                "0x2000.000000000p0", "0x260D.FC14636E3p0", "0x2D41.3CCCFE77Ap0", "0x35D1.3F32B5A76p0",
                "0x4000.000000000p0", "0x4C1B.F828C6DC5p0", "0x5A82.7999FCEF3p0", "0x6BA2.7E656B4EBp0",
                "0x8000.000000000p0", "0x9837.F0518DB8Bp0", "0xB504.F333F9DE6p0", "0xD744.FCCAD69D7p0",
                "0x10000.000000000p0", "0x1306F.E0A31B715p0", "0x16A09.E667F3BCDp0", "0x1AE89.F995AD3ADp0",
                "0x20000.000000000p0", "0x260DF.C14636E2Ap0", "0x2D413.CCCFE7799p0", "0x35D13.F32B5A75Bp0",
                "0x40000.000000000p0", "0x4C1BF.828C6DC55p0", "0x5A827.999FCEF32p0", "0x6BA27.E656B4EB5p0",
                "0x80000.000000000p0", "0x9837F.0518DB8A9p0", "0xB504F.333F9DE65p0", "0xD744F.CCAD69D6Bp0",
                "0x100000.000000000p0", "0x1306FE.0A31B7153p0", "0x16A09E.667F3BCC9p0", "0x1AE89F.995AD3AD6p0",
                "0x200000.000000000p0", "0x260DFC.14636E2A6p0", "0x2D413C.CCFE77992p0", "0x35D13F.32B5A75ACp0",
                "0x400000.000000000p0", "0x4C1BF8.28C6DC54Bp0", "0x5A8279.99FCEF324p0", "0x6BA27E.656B4EB58p0",
                "0x800000.000000000p0", "0x9837F0.518DB8A97p0", "0xB504F3.33F9DE648p0", "0xD744FC.CAD69D6AFp0",
                "0x1000000.000000000p0", "0x1306FE0.A31B7152Ep0", "0x16A09E6.67F3BCC91p0", "0x1AE89F9.95AD3AD5Fp0",
                "0x2000000.000000000p0", "0x260DFC1.4636E2A5Cp0", "0x2D413CC.CFE779921p0", "0x35D13F3.2B5A75ABDp0",
                "0x4000000.000000000p0", "0x4C1BF82.8C6DC54B8p0", "0x5A82799.9FCEF3242p0", "0x6BA27E6.56B4EB57Ap0",
                "0x8000000.000000000p0", "0x9837F05.18DB8A96Fp0", "0xB504F33.3F9DE6484p0", "0xD744FCC.AD69D6AF4p0",
                "0x10000000.000000000p0", "0x1306FE0A.31B7152DFp0", "0x16A09E66.7F3BCC909p0", "0x1AE89F99.5AD3AD5E8p0",
                "0x20000000.000000000p0", "0x260DFC14.636E2A5BDp0", "0x2D413CCC.FE7799211p0", "0x35D13F32.B5A75ABD1p0",
                "0x40000000.000000000p0", "0x4C1BF828.C6DC54B7Ap0", "0x5A827999.FCEF32423p0", "0x6BA27E65.6B4EB57A2p0",
                "0x80000000.000000000p0", "0x9837F051.8DB8A96F4p0", "0xB504F333.F9DE64846p0", "0xD744FCCA.D69D6AF44p0",
                "0x0.000000010p0", "0x0.000000013p0", "0x0.000000017p0", "0x0.00000001Bp0",
                "0x0.000000020p0", "0x0.000000026p0", "0x0.00000002Dp0", "0x0.000000036p0",
                "0x0.000000040p0", "0x0.00000004Cp0", "0x0.00000005Bp0", "0x0.00000006Cp0",
                "0x0.000000080p0", "0x0.000000098p0", "0x0.0000000B5p0", "0x0.0000000D7p0",
                "0x0.000000100p0", "0x0.000000130p0", "0x0.00000016Ap0", "0x0.0000001AFp0",
                "0x0.000000200p0", "0x0.000000261p0", "0x0.0000002D4p0", "0x0.00000035Dp0",
                "0x0.000000400p0", "0x0.0000004C2p0", "0x0.0000005A8p0", "0x0.0000006BAp0",
                "0x0.000000800p0", "0x0.000000983p0", "0x0.000000B50p0", "0x0.000000D74p0",
                "0x0.000001000p0", "0x0.000001307p0", "0x0.0000016A1p0", "0x0.000001AE9p0",
                "0x0.000002000p0", "0x0.00000260Ep0", "0x0.000002D41p0", "0x0.0000035D1p0",
                "0x0.000004000p0", "0x0.000004C1Cp0", "0x0.000005A82p0", "0x0.000006BA2p0",
                "0x0.000008000p0", "0x0.000009838p0", "0x0.00000B505p0", "0x0.00000D745p0",
                "0x0.000010000p0", "0x0.000013070p0", "0x0.000016A0Ap0", "0x0.00001AE8Ap0",
                "0x0.000020000p0", "0x0.0000260E0p0", "0x0.00002D414p0", "0x0.000035D14p0",
                "0x0.000040000p0", "0x0.00004C1C0p0", "0x0.00005A828p0", "0x0.00006BA28p0",
                "0x0.000080000p0", "0x0.00009837Fp0", "0x0.0000B504Fp0", "0x0.0000D7450p0",
                "0x0.000100000p0", "0x0.0001306FEp0", "0x0.00016A09Ep0", "0x0.0001AE8A0p0",
                "0x0.000200000p0", "0x0.000260DFCp0", "0x0.0002D413Dp0", "0x0.00035D13Fp0",
                "0x0.000400000p0", "0x0.0004C1BF8p0", "0x0.0005A827Ap0", "0x0.0006BA27Ep0",
                "0x0.000800000p0", "0x0.0009837F0p0", "0x0.000B504F3p0", "0x0.000D744FDp0",
                "0x0.001000000p0", "0x0.001306FE1p0", "0x0.0016A09E6p0", "0x0.001AE89FAp0",
                "0x0.002000000p0", "0x0.00260DFC1p0", "0x0.002D413CDp0", "0x0.0035D13F3p0",
                "0x0.004000000p0", "0x0.004C1BF83p0", "0x0.005A8279Ap0", "0x0.006BA27E6p0",
                "0x0.008000000p0", "0x0.009837F05p0", "0x0.00B504F33p0", "0x0.00D744FCDp0",
                "0x0.010000000p0", "0x0.01306FE0Ap0", "0x0.016A09E66p0", "0x0.01AE89F99p0",
                "0x0.020000000p0", "0x0.0260DFC14p0", "0x0.02D413CCDp0", "0x0.035D13F33p0",
                "0x0.040000000p0", "0x0.04C1BF829p0", "0x0.05A82799Ap0", "0x0.06BA27E65p0",
                "0x0.080000000p0", "0x0.09837F052p0", "0x0.0B504F334p0", "0x0.0D744FCCBp0",
                "0x0.100000000p0", "0x0.1306FE0A3p0", "0x0.16A09E668p0", "0x0.1AE89F996p0",
                "0x0.200000000p0", "0x0.260DFC146p0", "0x0.2D413CCD0p0", "0x0.35D13F32Bp0",
                "0x0.400000000p0", "0x0.4C1BF828Cp0", "0x0.5A82799A0p0", "0x0.6BA27E657p0",
                "0x0.800000000p0", "0x0.9837F0519p0", "0x0.B504F3340p0", "0x0.D744FCCADp0"
            };
            ap_ufixed<68,32> exp2_x_msb_1 = exp2_x_msb_1_table[x_msb_ind_1];
            ap_ufixed<136,32> y_lo = exp2_x_msb_1 * exp2_x_msb_2_3_4_lsb_m_1;
            ap_ufixed<68,32> y_lo_s = y_lo;
            ap_ufixed<68,32> y_l = y_lo_s + exp2_x_msb_1;
            y = y_l;
        }

        if(I<33) {
            bool overf_2 = 0;
#pragma unroll
            for(int j=63; j>=I+31; j--) {
                if(y[j]) {
                    overf_2 = 1;
                }
            }
            if(overf_2) {
#pragma unroll
                for(int j=63; j>=I+31; j--) {
                    y[j] = 0;
                }
#pragma unroll
                for(int j=I+30; j>=0; j--) {
                    y[j] = 1;
                }
            }
        }
        r = y;
    }
    return r;
}

template<int W, int I>
ap_ufixed<W,I> exp2(ap_ufixed<W,I> x) {
    ap_fixed<W+1,I+1> xf = x;
    return exp2(xf);
}

template<int I>
ap_int<I> exp2(ap_int<I> x) {
    ap_fixed<I,I> xf = x;
    return exp2(xf);
}

template<int I>
ap_uint<I> exp2(ap_uint<I> x) {
    ap_fixed<I+1,I+1> xf = x;
    return exp2(xf);
}


}
#1026 "C:/Xilinx/Vivado/2018.3/include/hls_math.h" 2
#1 "C:/Xilinx/Vivado/2018.3/include/hls_log_apfixed.h" 1
#35 "C:/Xilinx/Vivado/2018.3/include/hls_log_apfixed.h"
#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/assert.h" 1 3
#36 "C:/Xilinx/Vivado/2018.3/include/hls_log_apfixed.h" 2


namespace log_apfixed_reduce {


template <typename T, int p, int alpha, int size> class log_lut_table { public:
log_lut_table<T,p,alpha,size>();
static const T array [size];};
template <> class log_lut_table<ap_fixed<29, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<29, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<29, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
template <> class log_lut_table<ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
template <> class log_lut_table<ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
template <> class log_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
template <> class log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
template <> class log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};
template <> class log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16> { public:
log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,4,4,16>();
static const ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [16];};

template <> class log_lut_table<ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64> { public:
log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,7,6,64>();
static const ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64> { public:
log_lut_table<ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>();
static const ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64> { public:
log_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>();
static const ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64> { public:
log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>();
static const ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64> { public:
log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>();
static const ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64> { public:
log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,12,6,64>();
static const ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};

template <> class log_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64> { public:
log_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64>();
static const ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64> { public:
log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64>();
static const ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64> { public:
log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64>();
static const ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64> { public:
log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,17,6,64>();
static const ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};

template <> class log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64> { public:
log_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64>();
static const ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64> { public:
log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64>();
static const ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64> { public:
log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,22,6,64>();
static const ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};

template <> class log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,27,6,64> { public:
log_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,27,6,64>();
static const ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,27,6,64> { public:
log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,27,6,64>();
static const ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};

template <> class log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,32,6,64> { public:
log_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,32,6,64>();
static const ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};

template <typename T, int p, int alpha, int size> class log0_lut_table { public:
log0_lut_table<T,p,alpha,size>();
static const T array[size];};
template <> class log0_lut_table<ap_fixed<20, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64> { public:
log0_lut_table<ap_fixed<20, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64>();

static const ap_fixed<20, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log0_lut_table<ap_fixed<29, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64> { public:
log0_lut_table<ap_fixed<29, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64>();
static const ap_fixed<29, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log0_lut_table<ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64> { public:
log0_lut_table<ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64>();
static const ap_fixed<44, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log0_lut_table<ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64> { public:
log0_lut_table<ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64>();
static const ap_fixed<59, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log0_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64> { public:
log0_lut_table<ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64>();
static const ap_fixed<74, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log0_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64> { public:
log0_lut_table<ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64>();
static const ap_fixed<89, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log0_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64> { public:
log0_lut_table<ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64>();
static const ap_fixed<104, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};
template <> class log0_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64> { public:
log0_lut_table<ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0>,0,5,64>();
static const ap_fixed<119, 7, (ap_q_mode)5, (ap_o_mode)3, 0> array [64];};

class log_inverse_lut_table { public:
log_inverse_lut_table();
static const ap_ufixed<6, 1, (ap_q_mode)5, (ap_o_mode)3, 0> array[64];};


template <typename LOG_TYPE, int p, int alpha, int size, int sizeout>
void range_reduce(ap_ufixed<size, -p> zN, LOG_TYPE &log, ap_ufixed<sizeout, -(p+alpha-1)> &zN1)
{

    const int T1size = 1 << alpha;




    ap_ufixed<alpha, -p> a = zN;
    ap_ufixed<size-alpha, -p-alpha> b = zN;
    ap_ufixed<size+p+2*p+1, 1> zNext = 1+zN;
    int e_shift = (p!=4 || a[a.wl()-1]==1) ? 2*p : 2*p+1;
    ap_ufixed<size+p+1, 1-2*p> eZ = zNext >> e_shift;

    zN1 = ((b + eZ) - a*zN);
    ap_uint<alpha> index = a(alpha-1,0);
    log = log_lut_table<LOG_TYPE, p,alpha,T1size>::array[index];


}




const int p0 = 0;
const int alpha0 = 5;
const int p1 = (alpha0 == 5) ? 4 : (alpha0-2);
const int alpha1 = 4;
const int p2 = p1 + alpha1 - 1;
const int alpha2 = 6;
const int p3 = p2 + alpha2 - 1;
const int alpha3 = 6;
const int p4 = p3 + alpha3 - 1;
const int alpha4 = 6;
const int p5 = p4 + alpha4 - 1;
const int alpha5 = 6;
const int p6 = p5 + alpha5 - 1;
const int alpha6 = 6;
const int p7 = p6 + alpha6 - 1;
const int alpha7 = 6;
const int p8 = p7 + alpha7 - 1;

template <int W_s_> class log_traits{};

template <>
class log_traits<1>{
public:
    const static int we = 6;
    const static int wf = 11;
    const static int org_wf = wf;

    const static int gbits = 1;
    const static int p_generic = p1;
    const static int MaxPrecision = wf+gbits+1;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we > LOG_TYPE;

    template <int size>
    static ap_ufixed<MaxPrecision-p_generic, -p_generic> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        return z1;
    }
};

template <>
class log_traits<2>{
public:
    const static int we = 6;
    const static int wf = 19;
    const static int org_wf = wf;

    const static int gbits = 2;
    const static int p_generic = p2;
    const static int MaxPrecision =wf+gbits+1;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we > LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p_generic, -p_generic> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        LOG_TYPE logn;

        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        return z2;
    }
};

template <>
class log_traits<3>{
public:
    const static int we = 6;
    const static int wf = 33;
    const static int org_wf = wf;

    const static int gbits = 3;
    const static int p_generic = p3;
    const static int MaxPrecision = wf+gbits+1;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we > LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);
    const static int w3 = w2+2*p2+1-(alpha2-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p_generic, -p_generic> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < MaxPrecision-p3) ? w3 : (MaxPrecision-p3), -p3> z3;
        LOG_TYPE logn;

        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;
        return z3;
    }
};

template <>
class log_traits<4>{
public:
    const static int we = 6;
    const static int wf = 48;
    const static int org_wf = wf;

    const static int gbits = 3;
    const static int p_generic = p4;
    const static int MaxPrecision = wf+gbits+1;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we > LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);
    const static int w3 = w2+2*p2+1-(alpha2-1);
    const static int w4 = w3+2*p3+1-(alpha3-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p_generic, -p_generic> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < MaxPrecision-p3) ? w3 : (MaxPrecision-p3), -p3> z3;
        ap_ufixed<(w4 < MaxPrecision-p4) ? w4 : (MaxPrecision-p4), -p4> z4;
        LOG_TYPE logn;

        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;
        range_reduce<LOG_TYPE, p3, alpha3> (z3, logn, z4);
        log_sum += logn;
        return z4;
    }
};

template <>
class log_traits<5>{
public:
    const static int we = 6;
    const static int wf = 63;
    const static int org_wf = wf;

    const static int gbits = 3;
    const static int p_generic = p5;
    const static int MaxPrecision = wf+gbits+1;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we > LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);
    const static int w3 = w2+2*p2+1-(alpha2-1);
    const static int w4 = w3+2*p3+1-(alpha3-1);
    const static int w5 = w4+2*p4+1-(alpha4-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p_generic, -p_generic> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < MaxPrecision-p3) ? w3 : (MaxPrecision-p3), -p3> z3;
        ap_ufixed<(w4 < MaxPrecision-p4) ? w4 : (MaxPrecision-p4), -p4> z4;
        ap_ufixed<(w5 < MaxPrecision-p5) ? w5 : (MaxPrecision-p5), -p5> z5;
        LOG_TYPE logn;

        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;
        range_reduce<LOG_TYPE, p3, alpha3> (z3, logn, z4);
        log_sum += logn;
        range_reduce<LOG_TYPE, p4, alpha4> (z4, logn, z5);
        log_sum += logn;
        return z5;
    }
};

template <>
class log_traits<6>{
public:
    const static int we = 6;
    const static int wf = 76;
    const static int org_wf = wf;

    const static int gbits = 4;
    const static int p_generic = p6;
    const static int MaxPrecision = wf+gbits+2;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we > LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);
    const static int w3 = w2+2*p2+1-(alpha2-1);
    const static int w4 = w3+2*p3+1-(alpha3-1);
    const static int w5 = w4+2*p4+1-(alpha4-1);
    const static int w6 = w5+2*p5+1-(alpha5-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p_generic, -p_generic> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < MaxPrecision-p3) ? w3 : (MaxPrecision-p3), -p3> z3;
        ap_ufixed<(w4 < MaxPrecision-p4) ? w4 : (MaxPrecision-p4), -p4> z4;
        ap_ufixed<(w5 < MaxPrecision-p5) ? w5 : (MaxPrecision-p5), -p5> z5;
        ap_ufixed<(w6 < MaxPrecision-p6) ? w6 : (MaxPrecision-p6), -p6> z6;
        LOG_TYPE logn;

        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;
        range_reduce<LOG_TYPE, p3, alpha3> (z3, logn, z4);
        log_sum += logn;
        range_reduce<LOG_TYPE, p4, alpha4> (z4, logn, z5);
        log_sum += logn;
        range_reduce<LOG_TYPE, p5, alpha5> (z5, logn, z6);
        log_sum += logn;
        return z6;
    }
};

template <>
class log_traits<7>{
public:
    const static int we = 6;
    const static int wf = 91;
    const static int org_wf = wf;

    const static int gbits = 4;
    const static int p_generic = p7;
    const static int MaxPrecision = wf+gbits+2;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we > LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);
    const static int w3 = w2+2*p2+1-(alpha2-1);
    const static int w4 = w3+2*p3+1-(alpha3-1);
    const static int w5 = w4+2*p4+1-(alpha4-1);
    const static int w6 = w5+2*p5+1-(alpha5-1);
    const static int w7 = w6+2*p6+1-(alpha6-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p_generic, -p_generic> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < MaxPrecision-p3) ? w3 : (MaxPrecision-p3), -p3> z3;
        ap_ufixed<(w4 < MaxPrecision-p4) ? w4 : (MaxPrecision-p4), -p4> z4;
        ap_ufixed<(w5 < MaxPrecision-p5) ? w5 : (MaxPrecision-p5), -p5> z5;
        ap_ufixed<(w6 < MaxPrecision-p6) ? w6 : (MaxPrecision-p6), -p6> z6;
        ap_ufixed<(w7 < MaxPrecision-p7) ? w7 : (MaxPrecision-p7), -p7> z7;
        LOG_TYPE logn;

        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;
        range_reduce<LOG_TYPE, p3, alpha3> (z3, logn, z4);
        log_sum += logn;
        range_reduce<LOG_TYPE, p4, alpha4> (z4, logn, z5);
        log_sum += logn;
        range_reduce<LOG_TYPE, p5, alpha5> (z5, logn, z6);
        log_sum += logn;
        range_reduce<LOG_TYPE, p6, alpha6> (z6, logn, z7);
        log_sum += logn;
        return z7;
    }
};

template <>
class log_traits<8>{
public:
    const static int we = 6;
    const static int wf = 106;
    const static int org_wf = wf;

    const static int gbits = 4;
    const static int p_generic = p8;
    const static int MaxPrecision = wf+gbits+2;
    typedef ap_fixed<1 + we + MaxPrecision, 1 + we > LOG_TYPE;

    const static int w1 = wf+1;
    const static int w2 = w1+2*p1+1-(alpha1-1);
    const static int w3 = w2+2*p2+1-(alpha2-1);
    const static int w4 = w3+2*p3+1-(alpha3-1);
    const static int w5 = w4+2*p4+1-(alpha4-1);
    const static int w6 = w5+2*p5+1-(alpha5-1);
    const static int w7 = w6+2*p6+1-(alpha6-1);
    const static int w8 = w7+2*p7+1-(alpha7-1);

    template <int size>
    static ap_ufixed<MaxPrecision-p_generic, -p_generic> range_reduction(ap_ufixed<size, -p1> z1, LOG_TYPE &log_sum) {
        ap_ufixed<(w2 < MaxPrecision-p2) ? w2 : (MaxPrecision-p2), -p2> z2;
        ap_ufixed<(w3 < MaxPrecision-p3) ? w3 : (MaxPrecision-p3), -p3> z3;
        ap_ufixed<(w4 < MaxPrecision-p4) ? w4 : (MaxPrecision-p4), -p4> z4;
        ap_ufixed<(w5 < MaxPrecision-p5) ? w5 : (MaxPrecision-p5), -p5> z5;
        ap_ufixed<(w6 < MaxPrecision-p6) ? w6 : (MaxPrecision-p6), -p6> z6;
        ap_ufixed<(w7 < MaxPrecision-p7) ? w7 : (MaxPrecision-p7), -p7> z7;
        ap_ufixed<(w8 < MaxPrecision-p8) ? w8 : (MaxPrecision-p8), -p8> z8;
        LOG_TYPE logn;

        range_reduce<LOG_TYPE, p1, alpha1> (z1, logn, z2);
        log_sum += logn;
        range_reduce<LOG_TYPE, p2, alpha2> (z2, logn, z3);
        log_sum += logn;
        range_reduce<LOG_TYPE, p3, alpha3> (z3, logn, z4);
        log_sum += logn;
        range_reduce<LOG_TYPE, p4, alpha4> (z4, logn, z5);
        log_sum += logn;
        range_reduce<LOG_TYPE, p5, alpha5> (z5, logn, z6);
        log_sum += logn;
        range_reduce<LOG_TYPE, p6, alpha6> (z6, logn, z7);
        log_sum += logn;
        range_reduce<LOG_TYPE, p7, alpha7> (z7, logn, z8);
        log_sum += logn;
        return z8;
    }
};
template<int W_, int I_>
ap_fixed<W_,I_> log(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline


    const static int F_ = W_ - I_;
    if (I_>34) return 0;
    else if (F_>100) return 0;


    ap_fixed<W_,I_> r = 0;
    ap_ufixed<W_-1,I_-1> x_s = x;

    if (F_==0) {
        if (I_<=7) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4p0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xcp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x21p0")) r = 3;
            else r = 4;
        } else if (I_<=10) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4p0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xcp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x21p0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5ap0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf4p0")) r = 5;
            else r = 6;
        } else if (I_<=13) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4p0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xcp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x21p0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5ap0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf4p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x299p0")) r = 6;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x710p0")) r = 7;
            else r = 8;
        } else if (I_<=17) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4p0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xcp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x21p0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5ap0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf4p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x299p0")) r = 6;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x710p0")) r = 7;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1332p0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x342fp0")) r = 9;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8ddbp0")) r = 10;
            else r = 11;
        } else if (I_<=19) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4p0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xcp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x21p0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5ap0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf4p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x299p0")) r = 6;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x710p0")) r = 7;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1332p0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x342fp0")) r = 9;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8ddbp0")) r = 10;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1819bp0")) r = 11;
            else r = 12;
        } else if (I_<=26) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4p0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xcp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x21p0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5ap0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf4p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x299p0")) r = 6;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x710p0")) r = 7;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1332p0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x342fp0")) r = 9;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8ddbp0")) r = 10;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1819bp0")) r = 11;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x41831p0")) r = 12;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xb2148p0")) r = 13;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1e4127p0")) r = 14;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x523d82p0")) r = 15;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xdf8d5fp0")) r = 16;
            else r = 17;
        } else if (I_<=32) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4p0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xcp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x21p0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5ap0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf4p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x299p0")) r = 6;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x710p0")) r = 7;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1332p0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x342fp0")) r = 9;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8ddbp0")) r = 10;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1819bp0")) r = 11;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x41831p0")) r = 12;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xb2148p0")) r = 13;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1e4127p0")) r = 14;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x523d82p0")) r = 15;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xdf8d5fp0")) r = 16;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x25fad90p0")) r = 17;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x673d70bp0")) r = 18;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x118a2aaep0")) r = 19;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2fad89e1p0")) r = 20;
            else r = 21;
        } else {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4p0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xcp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x21p0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5ap0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf4p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x299p0")) r = 6;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x710p0")) r = 7;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1332p0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x342fp0")) r = 9;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8ddbp0")) r = 10;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1819bp0")) r = 11;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x41831p0")) r = 12;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xb2148p0")) r = 13;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1e4127p0")) r = 14;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x523d82p0")) r = 15;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xdf8d5fp0")) r = 16;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x25fad90p0")) r = 17;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x673d70bp0")) r = 18;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x118a2aaep0")) r = 19;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2fad89e1p0")) r = 20;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x819a1801p0")) r = 21;
            else r = 22;
        }
    } else if (F_<=4 && I_<=5) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.1p0")) r = "-0x2.cp0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.2p0")) r = "-0x2.1p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.3p0")) r = "-0x1.bp0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.4p0")) r = "-0x1.6p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.5p0")) r = "-0x1.3p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.6p0")) r = "-0x1p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.7p0")) r = "-0x0.dp0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.8p0")) r = "-0x0.bp0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.9p0")) r = "-0x0.9p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.ap0")) r = "-0x0.8p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.bp0")) r = "-0x0.6p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.cp0")) r = "-0x0.5p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.dp0")) r = "-0x0.3p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.ep0")) r = "-0x0.2p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.fp0")) r = "-0x0.1p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x1p0")) r = "0x0p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.1p0")) r = "0x0.1p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.2p0")) r = "0x0.2p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x1.3p0")) r = "0x0.3p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.5p0")) r = "0x0.4p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.6p0")) r = "0x0.5p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.8p0")) r = "0x0.6p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.9p0")) r = "0x0.7p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.bp0")) r = "0x0.8p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.cp0")) r = "0x0.9p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.ep0")) r = "0x0.ap0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2p0")) r = "0x0.bp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.2p0")) r = "0x0.cp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.5p0")) r = "0x0.dp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.7p0")) r = "0x0.ep0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.ap0")) r = "0x0.fp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.cp0")) r = "0x1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.fp0")) r = "0x1.1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.2p0")) r = "0x1.2p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.6p0")) r = "0x1.3p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.9p0")) r = "0x1.4p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.dp0")) r = "0x1.5p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.1p0")) r = "0x1.6p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.5p0")) r = "0x1.7p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.9p0")) r = "0x1.8p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.ep0")) r = "0x1.9p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.3p0")) r = "0x1.ap0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.9p0")) r = "0x1.bp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.ep0")) r = "0x1.cp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.5p0")) r = "0x1.dp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.bp0")) r = "0x1.ep0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7.2p0")) r = "0x1.fp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7.9p0")) r = "0x2p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8.1p0")) r = "0x2.1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8.ap0")) r = "0x2.2p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x9.3p0")) r = "0x2.3p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x9.cp0")) r = "0x2.4p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xa.6p0")) r = "0x2.5p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xb.1p0")) r = "0x2.6p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xb.cp0")) r = "0x2.7p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc.9p0")) r = "0x2.8p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xd.6p0")) r = "0x2.9p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xe.3p0")) r = "0x2.ap0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf.2p0")) r = "0x2.bp0";
            else r = "0x2.cp0";
    } else {

        if (x<=0) {r[W_-1] = 1;}
        else {


            const static int W_s_ = (F_+F_/77*2+12)/15-(100+F_)/133+(99+F_)/133-(100+F_)/118+(98+F_)/118+1;
#715 "C:/Xilinx/Vivado/2018.3/include/hls_log_apfixed.h"
            const static int wf = log_traits<W_s_>::wf;
            const static int I_s= I_>0? I_:-I_;
            const static int org_wf = log_traits<W_s_>::org_wf+I_s;
            const static int MaxPrecision = log_traits<W_s_>::MaxPrecision;




            ap_int<7> b_exp;
            ap_ufixed<1 + org_wf,1> b_frac=0;
            b_frac[org_wf] = 0;
            b_frac(org_wf-1,org_wf-W_+1) = x(W_-2,0);
#pragma unroll
            for (b_exp = I_-1; b_exp >= -F_; b_exp--) {
                if ((!b_frac[org_wf]&b_frac[org_wf-1]&b_frac[org_wf-2])|(b_frac[org_wf]&!b_frac[org_wf-1]))
                    break;
                b_frac <<= 1;
            }



            const ap_ufixed<MaxPrecision,0> LOG2 = "0x0.B17217F7D1CF79ABC9E3B39803p0";
            ap_fixed<MaxPrecision,6> Elog2 = LOG2 * b_exp;



            typedef typename log_traits<W_s_>::LOG_TYPE LOG_TYPE;
            const static int bypass_threshold = log_traits<W_s_>::p_generic;


            ap_uint<1+alpha0> index0;
            if (b_frac[org_wf]) index0 = b_frac(org_wf-1,org_wf-6);
            else index0 = b_frac(org_wf-2,org_wf-7);

            const int T0size = 1 << (1+alpha0);




            ap_ufixed<1 + alpha0, 1> b_frac_tilde_inverse = log_inverse_lut_table::array[index0];


            LOG_TYPE log_sum = log0_lut_table<LOG_TYPE,p0,alpha0,T0size>::array[index0];

            ap_ufixed<1 + org_wf+1+(1+alpha0), 1> b_frac1 = b_frac * b_frac_tilde_inverse;




#763 "C:/Xilinx/Vivado/2018.3/include/hls_log_apfixed.h" 3
           (void) ((!!(
#763 "C:/Xilinx/Vivado/2018.3/include/hls_log_apfixed.h"
           b_frac1( b_frac1.wl()-b_frac1.iwl()-1, b_frac1.wl()-b_frac1.iwl()-p1) == 0
#763 "C:/Xilinx/Vivado/2018.3/include/hls_log_apfixed.h" 3
           )) || (_assert(
#763 "C:/Xilinx/Vivado/2018.3/include/hls_log_apfixed.h"
           "b_frac1( b_frac1.wl()-b_frac1.iwl()-1, b_frac1.wl()-b_frac1.iwl()-p1) == 0"
#763 "C:/Xilinx/Vivado/2018.3/include/hls_log_apfixed.h" 3
           ,"C:/Xilinx/Vivado/2018.3/include/hls_log_apfixed.h",763),0))
#763 "C:/Xilinx/Vivado/2018.3/include/hls_log_apfixed.h"
                                                                                             ;

            const int z1_width = 1+wf+1+(1+alpha0)-p1+1;
            ap_ufixed<z1_width, -p1> z1 = b_frac1;


            ap_fixed<1-bypass_threshold+1+MaxPrecision, -bypass_threshold+1> zk;
            zk = log_traits<W_s_>::range_reduction(z1,log_sum);


            ap_fixed<1-2*bypass_threshold+1+MaxPrecision, -bypass_threshold+1> zk_trunc = zk;
            LOG_TYPE sum = zk-(zk_trunc*zk_trunc/2);

            LOG_TYPE log_base;
            log_base = Elog2 + log_sum + sum;



            ap_fixed<2 + F_, 1> delta = 0;
            delta[delta.wl()-1] = log_base[log_base.wl()-1];
            delta[delta.wl()-delta.iwl()-1] = 1;
            log_base = log_base + ( delta >> F_ );

            r = log_base;
        }

    }

    return r;
}

template<int W_, int I_>
ap_ufixed<W_,I_> log(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xf = x;
    return log(xf);
}

template<int I_>
ap_int<I_> log(ap_int<I_> x) {
    ap_fixed<I_,I_> xf = x;
    return log(xf);
}

template<int I_>
ap_uint<I_> log(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xf = x;
    return log(xf);
}


template<int W_, int I_>
ap_fixed<W_,I_> log10(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline


    const static int F_ = W_ - I_;
    if (I_>33) return 0;
    else if (F_>32) return 0;


    ap_fixed<W_,I_> r = 0;
    ap_ufixed<W_-1,I_-1> x_s = x;

    if (F_==0) {
        if (I_<=9) {
            if (x<=0) {r[W_-1] = 1;}
            else {
                ap_ufixed<8,8> x_s_l = x_s;
                if (x_s_l(7,2)==0) r = 0;
                else if (x_s_l(7,5)==0) r = 1;
                else r = 2;
            }
        } else if (I_<=15) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1fp0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x13cp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc5ap0")) r = 3;
            else r = 4;
        } else if (I_<=19) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1fp0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x13cp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc5ap0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7b86p0")) r = 4;
            else r = 5;
        } else if (I_<=25) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1fp0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x13cp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc5ap0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7b86p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4d343p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3040a5p0")) r = 6;
            else r = 7;
        } else if (I_<=32) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1fp0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x13cp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc5ap0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7b86p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4d343p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3040a5p0")) r = 6;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1e28678p0")) r = 7;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x12d940b6p0")) r = 8;
            else r = 9;
        } else {
            if (x<=0) r[W_-1] = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3p0")) r = 0;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1fp0")) r = 1;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x13cp0")) r = 2;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc5ap0")) r = 3;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7b86p0")) r = 4;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4d343p0")) r = 5;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3040a5p0")) r = 6;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1e28678p0")) r = 7;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x12d940b6p0")) r = 8;
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xbc7c871cp0")) r = 9;
            else r = 10;
        }
    } else if (F_<=4 && I_<=5) {
            if (x<=0) r[W_-1] = 1;
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.1p0")) r = "-0x1.3p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.2p0")) r = "-0x0.ep0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.3p0")) r = "-0x0.cp0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.4p0")) r = "-0x0.ap0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.5p0")) r = "-0x0.8p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.6p0")) r = "-0x0.7p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.7p0")) r = "-0x0.6p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.8p0")) r = "-0x0.5p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.9p0")) r = "-0x0.4p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x0.bp0")) r = "-0x0.3p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.cp0")) r = "-0x0.2p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x0.ep0")) r = "-0x0.1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.1p0")) r = "0x0p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.3p0")) r = "0x0.1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.6p0")) r = "0x0.2p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.ap0")) r = "0x0.3p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.ep0")) r = "0x0.4p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.3p0")) r = "0x0.5p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.8p0")) r = "0x0.6p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.fp0")) r = "0x0.7p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.6p0")) r = "0x0.8p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.ep0")) r = "0x0.9p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.8p0")) r = "0x0.ap0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.3p0")) r = "0x0.bp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6p0")) r = "0x0.cp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.fp0")) r = "0x0.dp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8p0")) r = "0x0.ep0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x9.4p0")) r = "0x0.fp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xa.bp0")) r = "0x1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc.6p0")) r = "0x1.1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xe.5p0")) r = "0x1.2p0";
            else r = "0x1.3p0";
    } else {

        if (x<=0) {r[W_-1] = 1;}
        else {
            const static int W_s_= (F_+F_/77*2+12)/15-(100+F_)/133+(99+F_)/133-(100+F_)/118+(98+F_)/118+1;






            const static int wf = log_traits<W_s_>::wf;
            const static int I_s= I_>0? I_:-I_;
            const static int org_wf = log_traits<W_s_>::org_wf+I_s;
            const static int MaxPrecision = log_traits<W_s_>::MaxPrecision;





            ap_int<7> b_exp=0;
            ap_ufixed<1 + org_wf,1> b_frac=0;
            b_frac[org_wf] = 0;
            b_frac(org_wf-1,org_wf-W_+1) = x(W_-2,0);
#pragma unroll
            for (b_exp = I_-1; b_exp >= -F_; b_exp--) {
                if ((!b_frac[org_wf]&b_frac[org_wf-1]&b_frac[org_wf-2])|(b_frac[org_wf]&!b_frac[org_wf-1]))
                    break;
                b_frac <<= 1;
            }

            const ap_ufixed<25,0> LOG1_35_s = 0.3010300099849700927734375;
            const ap_ufixed<43,0> LOG1_35_l = 0.30102999566395283181918784976006;
            ap_fixed<30,5> Elog2_s = LOG1_35_s * b_exp;
            ap_fixed<48,5> Elog2_l = LOG1_35_l * b_exp;


            typedef typename log_traits<W_s_>::LOG_TYPE LOG_TYPE;
            const static int bypass_threshold = log_traits<W_s_>::p_generic;

            ap_uint<1+alpha0> index0;
            if (b_frac[org_wf]) index0 = b_frac(org_wf-1,org_wf-6);
            else index0 = b_frac(org_wf-2,org_wf-7);

            const int T0size = 1 << (1+alpha0);




            ap_ufixed<1 + alpha0, 1> b_frac_tilde_inverse = log_inverse_lut_table::array[index0];

            LOG_TYPE log_sum = log0_lut_table<LOG_TYPE,p0,alpha0,T0size>::array[index0];

            ap_ufixed<1 + org_wf+1+(1+alpha0), 1> b_frac1 = b_frac * b_frac_tilde_inverse;



#977 "C:/Xilinx/Vivado/2018.3/include/hls_log_apfixed.h" 3
           (void) ((!!(
#977 "C:/Xilinx/Vivado/2018.3/include/hls_log_apfixed.h"
           b_frac1( b_frac1.wl()-b_frac1.iwl()-1, b_frac1.wl()-b_frac1.iwl()-p1) == 0
#977 "C:/Xilinx/Vivado/2018.3/include/hls_log_apfixed.h" 3
           )) || (_assert(
#977 "C:/Xilinx/Vivado/2018.3/include/hls_log_apfixed.h"
           "b_frac1( b_frac1.wl()-b_frac1.iwl()-1, b_frac1.wl()-b_frac1.iwl()-p1) == 0"
#977 "C:/Xilinx/Vivado/2018.3/include/hls_log_apfixed.h" 3
           ,"C:/Xilinx/Vivado/2018.3/include/hls_log_apfixed.h",977),0))
#977 "C:/Xilinx/Vivado/2018.3/include/hls_log_apfixed.h"
                                                                                             ;

            const int z1_width = 1+wf+1+(1+alpha0)-p1+1;
            ap_ufixed<z1_width, -p1> z1 = b_frac1;

            ap_fixed<1-bypass_threshold+1+MaxPrecision, -bypass_threshold+1> zk;
            zk = log_traits<W_s_>::range_reduction(z1,log_sum);

            ap_fixed<1-2*bypass_threshold+1+MaxPrecision, -bypass_threshold+1> zk_trunc = zk;
            LOG_TYPE sum = zk-(zk_trunc*zk_trunc/2);

            LOG_TYPE log_base = log_sum + sum;

            const ap_ufixed<25,0> LOG1_54_s = 0.4342944920063018798828125;
            const ap_ufixed<43,0> LOG1_54_l = 0.43429448190329367207596078515053;

            if (F_<=16) log_base = Elog2_s + log_base * LOG1_54_s;
            else log_base = Elog2_l + log_base * LOG1_54_l;
#1003 "C:/Xilinx/Vivado/2018.3/include/hls_log_apfixed.h"
            r = log_base;
        }

    }

    return r;
}

template<int W_, int I_>
ap_ufixed<W_,I_> log10(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xf = x;
    return log10(xf);
}

template<int I_>
ap_int<I_> log10(ap_int<I_> x) {
    ap_fixed<I_,I_> xf = x;
    return log10(xf);
}

template<int I_>
ap_uint<I_> log10(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xf = x;
    return log10(xf);
}

template<int W, int I>
ap_fixed<W,I> log1p(ap_fixed<W,I> x) {
    ap_ufixed<1,1> inc = 1;
    ap_fixed<W+1,I+1> xp1 = x + inc;
    return log(xp1);
}

template<int W, int I>
ap_ufixed<W,I> log1p(ap_ufixed<W,I> x) {
    ap_fixed<W+1,I+1> xf = x;
    return log1p(xf);
}

template<int I>
ap_int<I> log1p(ap_int<I> x) {
    ap_fixed<I,I> xf = x;
    return log1p(xf);
}

template<int I>
ap_uint<I> log1p(ap_uint<I> x) {
    ap_fixed<I+1,I+1> xf = x;
    return log1p(xf);
}

template<int W,int I>
ap_fixed<W,I> ilogb(ap_fixed<W,I> x) {
    int F = W - I;
    if(F>32 || I>33) {
        return 0;
    }
    ap_fixed<W+1,I+1> xf;
    if(x>0) {
        xf = x;
    }
    else {
        xf = -x;
    }
    return I + 1 - xf.countLeadingZeros() - 1;
}

template<int W,int I>
ap_ufixed<W,I> ilogb(ap_ufixed<W,I> x) {
    ap_fixed<W+1,I+1> xf = x;
    return ilogb(xf);
}

template<int I>
ap_int<I> ilogb(ap_int<I> x) {
    ap_fixed<I,I> xf = x;
    return ilogb(xf);
}

template<int I>
ap_uint<I> ilogb(ap_uint<I> x) {
    ap_fixed<I+1,I+1> xf = x;
    return ilogb(xf);
}

}
#1027 "C:/Xilinx/Vivado/2018.3/include/hls_math.h" 2
#1 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h" 1
#33 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h"
#1 "C:/Xilinx/Vivado/2018.3/include/ap_int.h" 1
#34 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h" 2



#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/x86_64-w64-mingw32/include/assert.h" 1 3
#38 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h" 2


template <int W_, int I_>
ap_fixed<W_,I_> sqrt_fixed(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline


    const int F_ = W_ - I_;
    if (I_>34) return 0;
    else if (F_>32) return 0;


    ap_ufixed<F_+(I_+1)/2,(I_+1)/2> r;
    ap_ufixed<W_-1,I_-1> x_s = x;

    if ((F_==0)&&(I_==2)) {
            r = x_s;
    } else if ((F_==0)&&(I_<=13)) {
        ap_ufixed<W_,I_> x_s_l = x_s + 1;
        ap_ufixed<W_-1,I_-1> x_s_1;
        x_s_1(W_-2,0) = x_s_l(W_-1,1);
        if (I_<=8) {
            if (x_s_1==ap_ufixed<W_-1,I_-1>("0x0p0")) r = 0;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x1p0")) r = 1;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x3p0")) r = 2;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x6p0")) r = 3;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xap0")) r = 4;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xfp0")) r = 5;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x15p0")) r = 6;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x1cp0")) r = 7;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x24p0")) r = 8;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x2dp0")) r = 9;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x37p0")) r = 10;
            else r = 11;
        } else if (I_<=9) {
            if (x_s_1==ap_ufixed<W_-1,I_-1>("0x0p0")) r = 0;
            else if (x_s_1==ap_ufixed<W_-1,I_-1>("0x1p0")) r = 1;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x3p0")) r = 2;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x6p0")) r = 3;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xap0")) r = 4;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xfp0")) r = 5;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x15p0")) r = 6;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x1cp0")) r = 7;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x24p0")) r = 8;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x2dp0")) r = 9;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x37p0")) r = 10;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x42p0")) r = 11;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x4ep0")) r = 12;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x5bp0")) r = 13;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x69p0")) r = 14;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x78p0")) r = 15;
            else r = 16;
        } else {
            if (x_s_1==ap_ufixed<W_-1,I_-1>("0x0p0")) r = 0;
            else if (x_s_1==ap_ufixed<W_-1,I_-1>("0x1p0")) r = 1;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x3p0")) r = 2;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x6p0")) r = 3;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xap0")) r = 4;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xfp0")) r = 5;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x15p0")) r = 6;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x1cp0")) r = 7;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x24p0")) r = 8;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x2dp0")) r = 9;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x37p0")) r = 10;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x42p0")) r = 11;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x4ep0")) r = 12;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x5bp0")) r = 13;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x69p0")) r = 14;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x78p0")) r = 15;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x88p0")) r = 16;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x99p0")) r = 17;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xabp0")) r = 18;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xbep0")) r = 19;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xd2p0")) r = 20;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xe7p0")) r = 21;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0xfdp0")) r = 22;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x114p0")) r = 23;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x12cp0")) r = 24;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x145p0")) r = 25;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x15fp0")) r = 26;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x17ap0")) r = 27;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x196p0")) r = 28;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x1b3p0")) r = 29;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x1d1p0")) r = 30;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x1f0p0")) r = 31;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x210p0")) r = 32;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x231p0")) r = 33;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x253p0")) r = 34;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x276p0")) r = 35;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x29ap0")) r = 36;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x2bfp0")) r = 37;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x2e5p0")) r = 38;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x30cp0")) r = 39;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x334p0")) r = 40;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x35dp0")) r = 41;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x387p0")) r = 42;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x3b2p0")) r = 43;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x3dep0")) r = 44;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x40bp0")) r = 45;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x439p0")) r = 46;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x468p0")) r = 47;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x498p0")) r = 48;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x4c9p0")) r = 49;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x4fbp0")) r = 50;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x52ep0")) r = 51;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x562p0")) r = 52;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x597p0")) r = 53;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x5cdp0")) r = 54;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x604p0")) r = 55;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x63cp0")) r = 56;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x675p0")) r = 57;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x6afp0")) r = 58;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x6eap0")) r = 59;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x726p0")) r = 60;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x763p0")) r = 61;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x7a1p0")) r = 62;
            else if (x_s_1<=ap_ufixed<W_-1,I_-1>("0x7e0p0")) r = 63;
            else r = 64;
        }
    } else if (F_<=4 && I_<=5) {
            if (x_s==ap_ufixed<W_-1,I_-1>("0x0.0p0")) r = "0x0.0p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.1p0")) r = "0x0.4p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.2p0")) r = "0x0.6p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.3p0")) r = "0x0.7p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.4p0")) r = "0x0.8p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.5p0")) r = "0x0.9p0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.6p0")) r = "0x0.ap0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x0.8p0")) r = "0x0.bp0";
            else if (x_s==ap_ufixed<W_-1,I_-1>("0x0.9p0")) r = "0x0.cp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x0.bp0")) r = "0x0.dp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x0.dp0")) r = "0x0.ep0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x0.fp0")) r = "0x0.fp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.1p0")) r = "0x1.0p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.3p0")) r = "0x1.1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.5p0")) r = "0x1.2p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.7p0")) r = "0x1.3p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.ap0")) r = "0x1.4p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.cp0")) r = "0x1.5p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x1.fp0")) r = "0x1.6p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.2p0")) r = "0x1.7p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.5p0")) r = "0x1.8p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.8p0")) r = "0x1.9p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.bp0")) r = "0x1.ap0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x2.fp0")) r = "0x1.bp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.2p0")) r = "0x1.cp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.6p0")) r = "0x1.dp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.ap0")) r = "0x1.ep0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x3.ep0")) r = "0x1.fp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.2p0")) r = "0x2.0p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.6p0")) r = "0x2.1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.ap0")) r = "0x2.2p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x4.ep0")) r = "0x2.3p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.3p0")) r = "0x2.4p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.7p0")) r = "0x2.5p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x5.cp0")) r = "0x2.6p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.1p0")) r = "0x2.7p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.6p0")) r = "0x2.8p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x6.bp0")) r = "0x2.9p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7.0p0")) r = "0x2.ap0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7.6p0")) r = "0x2.bp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x7.bp0")) r = "0x2.cp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8.1p0")) r = "0x2.dp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8.7p0")) r = "0x2.ep0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x8.dp0")) r = "0x2.fp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x9.3p0")) r = "0x3.0p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x9.9p0")) r = "0x3.1p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0x9.fp0")) r = "0x3.2p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xa.5p0")) r = "0x3.3p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xa.cp0")) r = "0x3.4p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xb.2p0")) r = "0x3.5p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xb.9p0")) r = "0x3.6p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc.0p0")) r = "0x3.7p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc.7p0")) r = "0x3.8p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xc.ep0")) r = "0x3.9p0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xd.5p0")) r = "0x3.ap0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xd.dp0")) r = "0x3.bp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xe.4p0")) r = "0x3.cp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xe.cp0")) r = "0x3.dp0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf.4p0")) r = "0x3.ep0";
            else if (x_s<=ap_ufixed<W_-1,I_-1>("0xf.cp0")) r = "0x3.fp0";
            else r = "0x4.0p0";
    } else {

        if (x[W_-1]) return 0;
        if (I_<=0) {
            const static int lsbx = (-I_+2<=W_) ? (W_+I_-2) : 0;
            if ( x(W_-1,lsbx) != 0 ) return 0;
        }

        const static int prcs = (F_+1)*2;
        const static int msbr = (I_>0) ? (I_+1)/2 : 1;
        const static int msbx = (I_>0) ? I_+3 : 4;
        const static int msbm = (I_>0) ? I_+1 : 2;


        ap_ufixed<msbx , msbx> x_l_I = x;
        ap_ufixed< prcs/2, 0> x_l_FH = x;
        ap_ufixed< prcs/2, -prcs/2> x_l_FL = 0;
        ap_ufixed<msbr + prcs , msbr> res = 0;
        ap_ufixed<msbr , msbr> res_I = 0;
        ap_ufixed< prcs/2, 0> res_FH = 0;
#264 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h"
    if (I_>0)
#pragma unroll
        for ( int pos = msbr-1; pos >= 0; pos-- ) {
            ap_ufixed<msbm , msbm> mul_I = 0;


#269 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h" 3
           (void) ((!!(
#269 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h"
           res_I(pos,0)==0
#269 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h" 3
           )) || (_assert(
#269 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h"
           "res_I(pos,0)==0"
#269 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h" 3
           ,"C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h",269),0))
#269 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h"
                                     ;

            mul_I ( msbr+pos , pos*2+1 ) = res_I ( msbr-1 , pos );


#273 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h" 3
           (void) ((!!(
#273 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h"
           !mul_I[I_-1]
#273 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h" 3
           )) || (_assert(
#273 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h"
           "!mul_I[I_-1]"
#273 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h" 3
           ,"C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h",273),0))
#273 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h"
                                  ;

            mul_I [ pos*2 ] = 1;



#278 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h" 3
           (void) ((!!(
#278 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h"
           x_l_I(I_+2,msbr+pos+2)==0
#278 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h" 3
           )) || (_assert(
#278 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h"
           "x_l_I(I_+2,msbr+pos+2)==0"
#278 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h" 3
           ,"C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h",278),0))
#278 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h"
                                               ;

            if ( x_l_I ( msbr+pos+1 , pos*2 ) >= mul_I ( msbr+pos , pos*2 ) ) {


#282 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h" 3
               (void) ((!!(
#282 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h"
               x_l_I >= mul_I
#282 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h" 3
               )) || (_assert(
#282 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h"
               "x_l_I >= mul_I"
#282 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h" 3
               ,"C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h",282),0))
#282 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h"
                                        ;

                ap_ufixed<msbx,msbx> x_l_I_ = x_l_I;
                x_l_I ( msbr+pos+1 , pos*2 ) = x_l_I ( msbr+pos+1 , pos*2 ) - mul_I ( msbr+pos , pos*2 );


#287 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h" 3
               (void) ((!!(
#287 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h"
               x_l_I == x_l_I_ - mul_I
#287 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h" 3
               )) || (_assert(
#287 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h"
               "x_l_I == x_l_I_ - mul_I"
#287 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h" 3
               ,"C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h",287),0))
#287 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h"
                                                 ;


                res_I [ pos ] = 1;
            }
        }
#pragma unroll
        for ( int pos = -1; pos >= -F_-1; pos-- ) {
            ap_ufixed<msbm + prcs , msbm> mul = 0;


#297 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h" 3
           (void) ((!!(
#297 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h"
           res_FH(pos+prcs/2,0)==0
#297 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h" 3
           )) || (_assert(
#297 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h"
           "res_FH(pos+prcs/2,0)==0"
#297 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h" 3
           ,"C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h",297),0))
#297 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h"
                                             ;


            mul ( msbr+pos + prcs , pos +1 + prcs ) = res_I ( msbr-1 , 0 );
            mul ( pos + prcs , pos*2+1 + prcs ) = res_FH ( -1+prcs/2 , pos+prcs/2 );


#303 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h" 3
           (void) ((!!(
#303 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h"
           !mul[I_-1+prcs]
#303 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h" 3
           )) || (_assert(
#303 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h"
           "!mul[I_-1+prcs]"
#303 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h" 3
           ,"C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h",303),0))
#303 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h"
                                     ;

            mul [ pos*2 + prcs ] = 1;
            ap_ufixed<msbm , msbm> mul_I = mul;
            ap_ufixed< prcs/2, 0> mul_FH = mul;
            ap_ufixed< prcs/2, -prcs/2> mul_FL = mul;

            ap_ufixed<msbx + prcs , msbx> x_l;
            x_l ( -1+msbx + prcs , prcs ) = x_l_I ( -1+msbx , 0 );
            x_l ( -1 + prcs , prcs/2 ) = x_l_FH ( -1+prcs/2 , 0 );
            x_l ( -1 + prcs/2 , 0 ) = x_l_FL ( -1+prcs/2 , 0 );


#315 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h" 3
           (void) ((!!(
#315 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h"
           x_l(I_+2+prcs,msbr+pos+2+prcs)==0
#315 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h" 3
           )) || (_assert(
#315 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h"
           "x_l(I_+2+prcs,msbr+pos+2+prcs)==0"
#315 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h" 3
           ,"C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h",315),0))
#315 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h"
                                                       ;

            if ( (x_l_I>mul_I) || ((x_l_I==mul_I)&&(x_l_FH>mul_FH)) || ((x_l_I==mul_I)&&(x_l_FH==mul_FH)&&(x_l_FL>=mul_FL)) ) {


#319 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h" 3
               (void) ((!!(
#319 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h"
               x_l >= mul
#319 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h" 3
               )) || (_assert(
#319 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h"
               "x_l >= mul"
#319 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h" 3
               ,"C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h",319),0))
#319 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h"
                                    ;


                ap_ufixed< prcs/2+1 , -prcs/2+1 > x_l_FL_l = x_l_FL;
                if ( x_l_FL < mul_FL ) x_l_FL_l[prcs/2] = 1;
                                                  x_l_FL_l -= mul_FL;


#326 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h" 3
               (void) ((!!(
#326 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h"
               !x_l_FL_l[prcs/2]
#326 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h" 3
               )) || (_assert(
#326 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h"
               "!x_l_FL_l[prcs/2]"
#326 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h" 3
               ,"C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h",326),0))
#326 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h"
                                           ;


                ap_ufixed< prcs/2+1 , 1 > x_l_FH_l = x_l_FH;
                if ( (x_l_FH<mul_FH)||((x_l_FH==mul_FH)&&(x_l_FL<mul_FL)) ) x_l_FH_l[prcs/2] = 1;
                ap_ufixed< 1 , -prcs/2+1 > delta = 0;
                if ( x_l_FL < mul_FL ) delta[0] = 1;
                                                                             x_l_FH_l -= delta;
                                                                             x_l_FH_l -= mul_FH;


#336 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h" 3
               (void) ((!!(
#336 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h"
               !x_l_FH_l[prcs/2]
#336 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h" 3
               )) || (_assert(
#336 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h"
               "!x_l_FH_l[prcs/2]"
#336 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h" 3
               ,"C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h",336),0))
#336 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h"
                                           ;

                if ( (x_l_FH<mul_FH)||((x_l_FH==mul_FH)&&(x_l_FL<mul_FL)) ) x_l_I --;
                                                                             x_l_I -= mul_I;

                                                                             x_l_FH = x_l_FH_l;
                                                                             x_l_FL = x_l_FL_l;

                ap_ufixed<msbx + prcs , msbx> x_l_ = x_l;
                x_l ( -1+msbx + prcs , prcs ) = x_l_I ( -1+msbx , 0 );
                x_l ( -1 + prcs , prcs/2 ) = x_l_FH ( -1+prcs/2 , 0 );
                x_l ( -1 + prcs/2 , 0 ) = x_l_FL ( -1+prcs/2 , 0 );


#349 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h" 3
               (void) ((!!(
#349 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h"
               x_l == x_l_ - mul
#349 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h" 3
               )) || (_assert(
#349 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h"
               "x_l == x_l_ - mul"
#349 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h" 3
               ,"C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h",349),0))
#349 "C:/Xilinx/Vivado/2018.3/include/hls_sqrt_apfixed.h"
                                           ;

                res_FH [ pos+prcs/2 ] = 1;
            }
        }



        ap_ufixed< prcs/2+1 , 1 > res_FH_l = res_FH;
        ap_ufixed< prcs/2 , 0 > delta;
                                  delta[delta.wl()-1] = 1;
                                  res_FH_l += ( delta >> F_ );
                                  res_FH = res_FH_l;
        if (res_FH_l[prcs/2]) res_I ++;

        res ( msbr-1 + prcs , prcs ) = res_I ( msbr-1 , 0 );
        res ( -1 + prcs , prcs/2 ) = res_FH ( -1+prcs/2 , 0 );

        r = res;
    }

    return r;
}
template<int W_, int I_>
ap_ufixed<W_,I_> sqrt_fixed(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xf = x;
    return sqrt_fixed(xf);
}
template<int I_>
ap_int<I_> sqrt_fixed(ap_int<I_> x) {
    ap_fixed<I_,I_> xf = x;
    return sqrt_fixed(xf);
}
template<int I_>
ap_uint<I_> sqrt_fixed(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xf = x;
    return sqrt_fixed(xf);
}


template <int W_, int I_>
ap_fixed<W_,I_> rsqrt_fixed(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline
    ap_ufixed<W_-1,I_-1> xs = x;
    const int Ix = ( I_ > 1 )? I_-1 : 1;
    ap_ufixed<Ix,Ix> xs_I = xs;
    ap_ufixed<W_-1,I_-1> r;
    const int I = ( I_-1 > W_-I_+1 ) ? I_-1 : W_-I_+1;
    ap_ufixed<I+W_-I_,I> y1;
    ap_ufixed<I+W_-I_,I> y2;
    if ( xs == 0 ) {
        return 0;
    } else if ( xs_I != 0 ) {
        y1 = xs;
    } else {
        y1 = 1;
        y1 = y1/xs;
    }
    y2 = sqrt_fixed(y1);
    if ( y2 == 0 ) {
        return 0;
    } else if ( xs_I != 0 ) {
        r = 1;
        r = r/y2;
    } else {
        r = y2;
    }
    return r;
}
template<int W_, int I_>
ap_ufixed<W_,I_> rsqrt_fixed(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xf = x;
    return rsqrt_fixed(xf);
}
template<int I_>
ap_int<I_> rsqrt_fixed(ap_int<I_> x) {
    ap_fixed<I_,I_> xf = x;
    return rsqrt_fixed(xf);
}
template<int I_>
ap_uint<I_> rsqrt_fixed(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xf = x;
    return rsqrt_fixed(xf);
}


template<int W_, int I_>
ap_fixed<W_,I_> recip_fixed(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline
    if ( x == 0 ) return 0;
    ap_fixed<W_,I_> r = 1;
    return r/x;
}
template<int W_, int I_>
ap_ufixed<W_,I_> recip_fixed(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xf = x;
    return recip_fixed(xf);
}
template<int I_>
ap_int<I_> recip_fixed(ap_int<I_> x) {
    ap_fixed<I_,I_> xf = x;
    return recip_fixed(xf);
}
template<int I_>
ap_uint<I_> recip_fixed(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xf = x;
    return recip_fixed(xf);
}
#1028 "C:/Xilinx/Vivado/2018.3/include/hls_math.h" 2
#1 "C:/Xilinx/Vivado/2018.3/include/hls_round_copysign_apfixed.h" 1
#34 "C:/Xilinx/Vivado/2018.3/include/hls_round_copysign_apfixed.h"
#1 "C:/Xilinx/Vivado/2018.3/include/ap_int.h" 1
#35 "C:/Xilinx/Vivado/2018.3/include/hls_round_copysign_apfixed.h" 2

template <int W_, int I_>
ap_fixed<W_,I_> ceil_fixed(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline
    if(W_ == I_) {
        return x;
    }
    else {
        if ( x(W_-I_-1,0) != 0 ) {
            x(W_-I_-1,0) = 0;
            x += 1;
        }
        return x;
    }
}
template <int W_, int I_>
ap_ufixed<W_,I_> ceil_fixed(ap_ufixed<W_,I_> x)
{
#pragma HLS pipeline
    if(W_ == I_) {
        return x;
    }
    else {
        if ( x(W_-I_-1,0) != 0 ) {
            x(W_-I_-1,0) = 0;
            x += 1;
        }
        return x;
    }
}
template <int I_>
ap_int<I_> ceil_fixed(ap_int<I_> x)
{
    return x;
}
template <int I_>
ap_uint<I_> ceil_fixed(ap_uint<I_> x)
{
    return x;
}

template <int W_, int I_>
ap_fixed<W_,I_> floor_fixed(ap_fixed<W_,I_> x)
{
    if(W_ == I_) {
        return x;
    }
    else {
        if ( x(W_-I_-1,0) != 0 ) x(W_-I_-1,0) = 0;
        return x;
    }
}
template <int W_, int I_>
ap_ufixed<W_,I_> floor_fixed(ap_ufixed<W_,I_> x)
{
    if(W_ == I_) {
        return x;
    }
    else {
        if ( x(W_-I_-1,0) != 0 ) x(W_-I_-1,0) = 0;
        return x;
    }
}
template <int I_>
ap_int<I_> floor_fixed(ap_int<I_> x)
{
    return x;
}
template <int I_>
ap_uint<I_> floor_fixed(ap_uint<I_> x)
{
    return x;
}

template <int W_, int I_>
ap_fixed<W_,I_> trunc_fixed(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline
    if(W_ == I_) {
        return x;
    }
    else {
        if ( x(W_-I_-1,0) != 0 ) {
            x(W_-I_-1,0) = 0;
            if ( x[W_-1] )
                x += 1;
        }
        return x;
    }
}
template <int W_, int I_>
ap_ufixed<W_,I_> trunc_fixed(ap_ufixed<W_,I_> x)
{
#pragma HLS pipeline
    if(W_ == I_) {
        return x;
    }
    else {
        if ( x(W_-I_-1,0) != 0 )
            x(W_-I_-1,0) = 0;
        return x;
    }
}
template <int I_>
ap_int<I_> trunc_fixed(ap_int<I_> x)
{
    return x;
}
template <int I_>
ap_uint<I_> trunc_fixed(ap_uint<I_> x)
{
    return x;
}

template <int W_, int I_>
ap_fixed<W_,I_> copysign_fixed(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y)
{
    x[W_-1] = y[W_-1];
    return x;
}
template <int W_, int I_>
ap_ufixed<W_,I_> copysign_fixed(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y)
{
    return x;
}
template <int I_>
ap_int<I_> copysign_fixed(ap_int<I_> x, ap_int<I_> y)
{
    x[I_-1] = y[I_-1];
    return x;
}
template <int I_>
ap_uint<I_> copysign_fixed(ap_uint<I_> x, ap_uint<I_> y)
{
    return x;
}

template <int W_, int I_>
ap_fixed<W_,I_> fabs_fixed(ap_fixed<W_,I_> x)
{
    ap_fixed<W_,I_> xs = -x;
                    xs[W_-1] = 0;
    return ( ( x[W_-1] ) ? xs : x );
}
template <int W_, int I_>
ap_ufixed<W_,I_> fabs_fixed(ap_ufixed<W_,I_> x)
{
    return x;
}
template <int I_>
ap_int<I_> fabs_fixed(ap_int<I_> x)
{
    ap_int<I_> xs = -x;
               xs[I_-1] = 0;
    return ( ( x[I_-1] ) ? xs : x );
}
template <int I_>
ap_uint<I_> fabs_fixed(ap_uint<I_> x)
{
    return x;
}

template <int W_, int I_>
ap_fixed<W_,I_> round_fixed(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline
    if(W_ == I_) {
        return x;
    }
    else {
        if ( x(W_-I_-1,0) != 0 ) {
            ap_fixed<W_+1,I_+1> xs = 0;
            ap_fixed<W_, I_> half_val = 0.5;

            if(x[W_-1]) {
                xs = -x;
                xs = xs + half_val;
                xs(W_-I_-1,0) = 0;
                x = -xs;
            }
            else {
                xs = x + half_val;
                xs(W_-I_-1,0) = 0;
                x = xs;
            }
        }
        return x;
    }
}
template <int W_, int I_>
ap_ufixed<W_,I_> round_fixed(ap_ufixed<W_,I_> x)
{
#pragma HLS pipeline
    if(W_ == I_) {
        return x;
    }
    else {
        if ( x(W_-I_-1,0) != 0 ) {
            ap_fixed<W_, I_> half_val = 0.5;
            x = x + half_val;
            x(W_-I_-1,0) = 0;
        }
        return x;
    }
}
template <int I_>
ap_int<I_> round_fixed(ap_int<I_> x)
{
    return x;
}
template <int I_>
ap_uint<I_> round_fixed(ap_uint<I_> x)
{
    return x;
}

template <int W_, int I_>
ap_fixed<W_,I_> rint_fixed(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline
    if(W_ == I_) {
        return x;
    }
    else {
        if ( x(W_-I_-1,0) != 0 ) {
            ap_fixed<W_+1,I_+1> xs = 0;
            ap_fixed<W_, I_> half_val = 0.5;

            if(x[W_-1]) {
                xs = -x;
                xs = xs + half_val;
                if (xs(W_-I_-1,0)) {
                    xs(W_-I_-1,0) = 0;
                }
                else {
                    xs[W_-I_] = 0;
                }
                x = -xs;
            }
            else {
                xs = x + half_val;
                if( xs(W_-I_-1,0) ) {
                    xs(W_-I_-1,0) = 0;
                }
                else {
                    xs[W_-I_] = 0;
                }
                x = xs;
            }
        }
        return x;
    }
}
template <int W_, int I_>
ap_ufixed<W_,I_> rint_fixed(ap_ufixed<W_,I_> x)
{
#pragma HLS pipeline
    if(W_ == I_) {
        return x;
    }
    else {
        if ( x(W_-I_-1,0) != 0 ) {
            ap_fixed<W_, I_> half_val = 0.5;
            x = x + half_val;
            if (x(W_-I_-1,0)) {
                x(W_-I_-1,0) = 0;
            }
            else {
                x[W_-I_] = 0;
            }
        }
        return x;
    }
}
template <int I_>
ap_int<I_> rint_fixed(ap_int<I_> x)
{
    return x;
}
template <int I_>
ap_uint<I_> rint_fixed(ap_uint<I_> x)
{
    return x;
}

template <int W_, int I_>
ap_fixed<W_,I_> nearbyint_fixed(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline
    if(W_ == I_) {
        return x;
    }
    else {
        if ( x(W_-I_-1,0) != 0 ) {
            ap_fixed<W_+1,I_+1> xs = 0;
            ap_fixed<W_, I_> half_val = 0.5;

            if(x[W_-1]) {
                xs = -x;
                xs = xs + half_val;
                if (xs(W_-I_-1,0)) {
                    xs(W_-I_-1,0) = 0;
                }
                else {
                    xs[W_-I_] = 0;
                }
                x = -xs;
            }
            else {
                xs = x + half_val;
                if (xs(W_-I_-1,0)) {
                    xs(W_-I_-1,0) = 0;
                }
                else {
                    xs[W_-I_] = 0;
                }
                x = xs;
            }
        }
        return x;
    }
}
template <int W_, int I_>
ap_ufixed<W_,I_> nearbyint_fixed(ap_ufixed<W_,I_> x)
{
#pragma HLS pipeline
    if(W_ == I_) {
        return x;
    }
    else {
        if ( x(W_-I_-1,0) != 0 ) {
            ap_fixed<W_+1,I_+1> xs = 0;
            ap_fixed<W_, I_> half_val = 0.5;
            xs = x + half_val;
            if (xs(W_-I_-1,0) ) {
                xs(W_-I_-1,0) = 0;
            }
            else {
                xs[W_-I_] = 0;
            }
            x = xs;
        }
        return x;
    }
}
template <int I_>
ap_int<I_> nearbyint_fixed(ap_int<I_> x)
{
    return x;
}
template <int I_>
ap_uint<I_> nearbyint_fixed(ap_uint<I_> x)
{
    return x;
}

template <int W_, int I_>
bool signbit_fixed(ap_fixed<W_, I_> x){
    if(x[W_-1]) return true;
    else return false;
}
template <int W_, int I_>
bool signbit_fixed(ap_ufixed<W_, I_> x){
    return false;
}

template <int I_>
bool signbit_fixed(ap_int<I_> x){
    if(x[I_-1]) return true;
    else return false;
}

template <int I_>
bool signbit_fixed(ap_uint<I_> x){
    return false;
}
namespace fp_internal {
  template<int W, int I>
  ap_fixed<W, I> nextafter(ap_fixed<W, I> x, ap_fixed<W, I> y){
     const static int F = W - I;
     ap_ufixed<1, -F+1> ulp = 0;
     ulp[0] = 1;
     ap_fixed<W, I> r = 0;
     if(x == y) r = y;
     else if(x < y) r = x + ulp;
     else r = x - ulp;
     return r;
  }
  template<int W, int I>
  ap_ufixed<W, I> nextafter(ap_ufixed<W, I> x, ap_ufixed<W, I> y) {
     ap_fixed<W+1, I+1> xi = x;
     ap_fixed<W+1, I+1> yi = y;
     return nextafter(xi, yi);

  }
  template<int I>
  ap_int<I> nextafter(ap_int<I> x, ap_int<I> y) {
     ap_fixed<I, I> xi = x;
     ap_fixed<I, I> yi = y;
     return nextafter(xi, yi);
  }
  template<int I>
  ap_uint<I> nextafter(ap_uint<I> x, ap_uint<I> y) {
     ap_fixed<I+1, I+1> xi = x;
     ap_fixed<I+1, I+1> yi = y;
     return nextafter(xi, yi);
  }
  template<int W, int I>
  ap_fixed<W, I> nexttoward(ap_fixed<W, I> x, ap_fixed<W, I> y){
     return nextafter(x,y);
  }
  template<int W, int I>
  ap_ufixed<W, I> nexttoward(ap_ufixed<W, I> x, ap_ufixed<W, I> y){
     return nextafter(x,y);
  }
  template<int I>
  ap_int<I> nexttoward(ap_int<I> x, ap_int<I> y){
     return nextafter(x,y);
  }
  template<int I>
  ap_uint<I> nexttoward(ap_uint<I> x, ap_uint<I> y){
     return nextafter(x,y);
  }
}
#1029 "C:/Xilinx/Vivado/2018.3/include/hls_math.h" 2
#1 "C:/Xilinx/Vivado/2018.3/include/hls_pow_apfixed.h" 1
#37 "C:/Xilinx/Vivado/2018.3/include/hls_pow_apfixed.h"
namespace pow_apfixed_reduce{
#52 "C:/Xilinx/Vivado/2018.3/include/hls_pow_apfixed.h"
template<int W_,int I_>
ap_fixed<W_,I_> pow(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y) {
    const static int F_ = W_ - I_;

    if (I_>34) return 0;
    else if (F_>33) return 0;
    ap_fixed<W_,I_> r = 0;

    bool r_is_neg = 0;
    bool y_is_frac = 0;

    if (F_>0&&y(F_-1,0)>0)
        y_is_frac =1;
    if (x==0) {

        if (y==0&&I_>1) {
            return 1;

        } else if (y>0) {
            return 0;
        } else {

#pragma unroll
            for (int j = 0; j < W_-1; j++) r[j] = 1;
               r[W_-1] = 0;
            return r;
        }
    } else if (x<0) {

        if (y_is_frac) return 0;

        else {
            if (y==0||(I_>1&&y[F_]==0))
                r_is_neg = 0;
            else
                r_is_neg = 1;
        }
    }

    ap_fixed<W_+1,I_+1> x_e_1 = x;

    ap_fixed<W_+1,I_+1> x_p = 0;
    x_p = fabs_fixed(x_e_1);


    const static int E_l = I_+2;
    const static int F_l = W_+E_l;

    const static int I_l = I_+1>6?I_+1:6;
    const static int W_l = F_l + I_l;

    ap_fixed<W_l,I_l> x_l = x_p;


    ap_fixed<W_l,I_l> ln_x = log_apfixed_reduce::log(x_l);


    ap_fixed<F_l+6,6> ln_x_s = ln_x;


    const static int FI_m = W_+2;

    const static int I_m = I_>6 ? I_ : 6;
    const static int WI_m = FI_m + I_m;
    const static int WO_m = F_ + I_m;
    ap_fixed<F_l+W_+6,6+I_> mul_y_ln = ln_x_s * y;
#127 "C:/Xilinx/Vivado/2018.3/include/hls_pow_apfixed.h"
    ap_fixed<WO_m,I_m> exp_r = 0;
    ap_fixed<W_,I_> r_1 = 0;
    bool m_overf = 0;
    bool e_overf = 0;
    bool overf = 0;

#pragma unroll
    for (int j = F_l+F_+I_m-1; j < F_l+W_+5; j++)
        if (mul_y_ln[F_l+W_+5]!=mul_y_ln[j])
            m_overf = 1;

    if (!m_overf) {

        ap_fixed<WI_m,I_m> mul_y_ln_s = mul_y_ln;

        exp_r = exp_reduce::exp_core<WO_m,I_m,WI_m>(mul_y_ln_s);


        if (I_<I_m) {
#pragma unroll
            for (int j = WO_m-1; j >= W_-1; j--) {
                if (exp_r[j])
                    e_overf=1;
            }
        }
        r_1 = exp_r;
    }

    if (e_overf||(m_overf&&!mul_y_ln[F_l+W_+5])) {
        overf = 1;
    }

    if (r_is_neg) {

        if (overf) {
            r=0;
            r[W_-1]=1;

        } else {
            if (r_1!=0) {
                r = -r_1;
                r[W_-1] = 1;
            }
        }

    } else {

        if(overf) {
            r[W_-1] = 0;
#pragma unroll
            for (int j = W_-2; j >= 0; j--)
               r[j] = 1;

        } else {
            r = r_1;
        }
    }

    return r;
}

template<int W_, int I_>
ap_ufixed<W_,I_> pow(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y) {
    ap_fixed<W_+1,I_+1> xf = x;
    ap_fixed<W_+1,I_+1> yf = y;
    return pow(xf,yf);
}

template<int I_>
ap_int<I_> pow(ap_int<I_> x, ap_int<I_> y) {
    ap_fixed<I_,I_> xf = x;
    ap_fixed<I_,I_> yf = y;
    return pow(xf,yf);
}

template<int I_>
ap_uint<I_> pow(ap_uint<I_> x,ap_uint<I_> y) {
    ap_fixed<I_+1,I_+1> xf = x;
    ap_fixed<I_+1,I_+1> yf = y;
    return pow(xf,yf);
}
}
#1030 "C:/Xilinx/Vivado/2018.3/include/hls_math.h" 2
#1 "C:/Xilinx/Vivado/2018.3/include/hls_diff_apfixed.h" 1
#34 "C:/Xilinx/Vivado/2018.3/include/hls_diff_apfixed.h"
#1 "C:/Xilinx/Vivado/2018.3/include/ap_int.h" 1
#35 "C:/Xilinx/Vivado/2018.3/include/hls_diff_apfixed.h" 2
#45 "C:/Xilinx/Vivado/2018.3/include/hls_diff_apfixed.h"
template <int W_, int I_>
ap_fixed<W_,I_> fdim_fixed(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y )
{
#pragma HLS PIPELINE II=1
    ap_fixed<W_+1,I_+1> x_overf = 0;
    ap_fixed<W_ ,I_ > xs = 0;
        bool overf = 0;

    if(x > y)
    {
        x_overf = x - y;
        overf = x_overf[W_-1];
        if(overf) {
#pragma UNROLL
            for (int i = 0; i < W_-1; i++){
                xs[i] = 1;
            }
            xs[W_-1] = 0;
        }
        else{
            x_overf[W_] = 0;
            xs = x_overf;
        }
    }
    return xs;
}
template <int W_, int I_>
ap_ufixed<W_,I_> fdim_fixed(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y)
{
    ap_ufixed<W_ ,I_ > xs = 0;
    if(x > y){ xs = x - y; }
    return xs;
}
template <int I_>
ap_int<I_> fdim_fixed(ap_int<I_> x, ap_int<I_> y)
{
    ap_fixed<I_,I_> xs = x;
    ap_fixed<I_,I_> ys = y;
    return fdim_fixed(xs, ys);
}
template <int I_>
ap_uint<I_> fdim_fixed(ap_uint<I_> x, ap_uint<I_> y)
{
    ap_uint<I_ > xs = 0;
    if(x > y) { xs = x - y; }
    return xs;
}
#101 "C:/Xilinx/Vivado/2018.3/include/hls_diff_apfixed.h"
template <int W_, int I_>
ap_fixed<W_,I_> fmax_fixed(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y )
{
    ap_fixed<W_ ,I_ > xs = 0;
    if(x >= y) xs = x ;
        else xs = y ;
    return xs;
}
template <int W_, int I_>
ap_ufixed<W_,I_> fmax_fixed(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y)
{
    ap_ufixed<W_ ,I_ > xs = 0;
    if(x >= y) xs = x;
        else xs = y ;
    return xs;
}
template <int I_>
ap_int<I_> fmax_fixed(ap_int<I_> x, ap_int<I_> y)
{
    ap_int<I_ > xs = 0;
    if(x >= y) xs = x;
        else xs = y ;
    return xs;
}
template <int I_>
ap_uint<I_> fmax_fixed(ap_uint<I_> x, ap_uint<I_> y)
{
    ap_uint<I_ > xs = 0;
    if(x >= y) xs = x;
        else xs = y ;
    return xs;
}
#142 "C:/Xilinx/Vivado/2018.3/include/hls_diff_apfixed.h"
template <int W_, int I_>
ap_fixed<W_,I_> fmin_fixed(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y )
{
    ap_fixed<W_ ,I_ > xs = 0;
    if(x <= y) xs = x ;
        else xs = y ;
    return xs;
}
template <int W_, int I_>
ap_ufixed<W_,I_> fmin_fixed(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y)
{
    ap_ufixed<W_ ,I_ > xs = 0;
    if(x <= y) xs = x;
        else xs = y ;
    return xs;
}
template <int I_>
ap_int<I_> fmin_fixed(ap_int<I_> x, ap_int<I_> y)
{
    ap_int<I_ > xs = 0;
    if(x <= y) xs = x;
        else xs = y ;
    return xs;
}
template <int I_>
ap_uint<I_> fmin_fixed(ap_uint<I_> x, ap_uint<I_> y)
{
    ap_uint<I_ > xs = 0;
    if(x <= y) xs = x;
        else xs = y ;
    return xs;
}
#185 "C:/Xilinx/Vivado/2018.3/include/hls_diff_apfixed.h"
template <int W_, int I_>
ap_fixed<W_,I_> maxmag_fixed(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y )
{
#pragma HLS PIPELINE II=1
    ap_fixed<W_+1,I_+1> xm = -x;
    ap_fixed<W_+1,I_+1> ym = -y;
    ap_fixed<W_+1,I_+1> x_fabs = ( x[W_-1] ) ? xm : ap_fixed<W_+1,I_+1>(x);
    ap_fixed<W_+1,I_+1> y_fabs = ( y[W_-1] ) ? ym : ap_fixed<W_+1,I_+1>(y);

    ap_fixed<W_+1,I_+1> xs_t = 0;
    ap_fixed<W_,I_> xs = 0;
    if(x_fabs >= y_fabs)
    {
     xs_t = x_fabs ;
     xs = x;
    }
    else{
     xs_t = y_fabs ;
     xs = y;
    }

    if(xs_t[W_-1])
    {
#pragma UNROLL
            for (int i = 0; i < W_-1; i++){
                xs[i] = 1;
            }
            xs[W_-1] = 0;
    }

    return xs;
}
template <int W_, int I_>
ap_ufixed<W_,I_> maxmag_fixed(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y)
{
    ap_ufixed<W_ ,I_ > xs = 0;
    if(x >= y) xs = x;
        else xs = y ;
    return xs;
}
template <int I_>
ap_int<I_> maxmag_fixed(ap_int<I_> x, ap_int<I_> y)
{
    ap_fixed<I_,I_> xs = x;
    ap_fixed<I_,I_> ys = y;
    return maxmag_fixed(xs, ys);
}
template <int I_>
ap_uint<I_> maxmag_fixed(ap_uint<I_> x, ap_uint<I_> y)
{
    ap_uint<I_ > xs = 0;
    if(x >= y) xs = x;
        else xs = y ;
    return xs;
}
#251 "C:/Xilinx/Vivado/2018.3/include/hls_diff_apfixed.h"
template <int W_, int I_>
ap_fixed<W_,I_> minmag_fixed(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y )
{
#pragma HLS PIPELINE II=1
    ap_fixed<W_+1,I_+1> xm = -x;
    ap_fixed<W_+1,I_+1> ym = -y;
    ap_fixed<W_+1,I_+1> x_fabs = ( x[W_-1] ) ? xm : ap_fixed<W_+1,I_+1>(x);
    ap_fixed<W_+1,I_+1> y_fabs = ( y[W_-1] ) ? ym : ap_fixed<W_+1,I_+1>(y);

    ap_fixed<W_+1,I_+1> xs_t = 0;
    ap_fixed<W_,I_> xs = 0;
    if(x_fabs <= y_fabs)
    {
     xs_t = x_fabs ;
     xs = x;
    }
    else{
     xs_t = y_fabs ;
     xs = y;
    }
    if(xs_t[W_-1])
    {
#pragma UNROLL
            for (int i = 0; i < W_-1; i++){
                xs[i] = 1;
            }
            xs[W_-1] = 0;
    }

    return xs;
}
template <int W_, int I_>
ap_ufixed<W_,I_> minmag_fixed(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y)
{
    ap_ufixed<W_ ,I_ > xs = 0;
    if(x <= y) xs = x;
        else xs = y ;
    return xs;
}
template <int I_>
ap_int<I_> minmag_fixed(ap_int<I_> x, ap_int<I_> y)
{
    ap_fixed<I_,I_> xs = x;
    ap_fixed<I_,I_> ys = y;
    return minmag_fixed(xs, ys);
}
template <int I_>
ap_uint<I_> minmag_fixed(ap_uint<I_> x, ap_uint<I_> y)
{
    ap_uint<I_ > xs = 0;
    if(x <= y) xs = x;
        else xs = y ;
    return xs;
}
#1031 "C:/Xilinx/Vivado/2018.3/include/hls_math.h" 2
#1 "C:/Xilinx/Vivado/2018.3/include/hls_comparison_apfixed.h" 1
#34 "C:/Xilinx/Vivado/2018.3/include/hls_comparison_apfixed.h"
#1 "C:/Xilinx/Vivado/2018.3/include/ap_int.h" 1
#35 "C:/Xilinx/Vivado/2018.3/include/hls_comparison_apfixed.h" 2



template<int W, int I>
bool isgreater_fixed(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    if(x1 > x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int W, int I>
bool isgreater_fixed(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    if(x1 > x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool isgreater_fixed(ap_int<I> x1, ap_int<I> x2){
    if(x1 > x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool isgreater_fixed(ap_uint<I> x1, ap_uint<I> x2){
    if(x1 > x2) {
        return true;
    }
    else {
        return false;
    }
}


template<int W, int I>
bool isgreaterequal_fixed(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    if(x1 >= x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int W, int I>
bool isgreaterequal_fixed(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    if(x1 >= x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool isgreaterequal_fixed(ap_int<I> x1, ap_int<I> x2){
    if(x1 >= x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool isgreaterequal_fixed(ap_uint<I> x1, ap_uint<I> x2){
    if(x1 >= x2) {
        return true;
    }
    else {
        return false;
    }
}


template<int W, int I>
bool isless_fixed(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    if(x1 < x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int W, int I>
bool isless_fixed(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    if(x1 < x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool isless_fixed(ap_int<I> x1, ap_int<I> x2){
    if(x1 < x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool isless_fixed(ap_uint<I> x1, ap_uint<I> x2){
    if(x1 < x2) {
        return true;
    }
    else {
        return false;
    }
}


template<int W, int I>
bool islessequal_fixed(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    if(x1 <= x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int W, int I>
bool islessequal_fixed(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    if(x1 <= x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool islessequal_fixed(ap_int<I> x1, ap_int<I> x2){
    if(x1 <= x2) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool islessequal_fixed(ap_uint<I> x1, ap_uint<I> x2){
    if(x1 <= x2) {
        return true;
    }
    else {
        return false;
    }
}


template<int W, int I>
bool islessgreater_fixed(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    if((x1 < x2) || (x1 > x2)) {
        return true;
    }
    else {
        return false;
    }
}
template<int W, int I>
bool islessgreater_fixed(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    if((x1 < x2) || (x1 > x2)) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool islessgreater_fixed(ap_int<I> x1, ap_int<I> x2){
    if((x1 < x2) || (x1 > x2)) {
        return true;
    }
    else {
        return false;
    }
}
template<int I>
bool islessgreater_fixed(ap_uint<I> x1, ap_uint<I> x2){
    if((x1 < x2) || (x1 > x2)) {
        return true;
    }
    else {
        return false;
    }
}
#1032 "C:/Xilinx/Vivado/2018.3/include/hls_math.h" 2
#1 "C:/Xilinx/Vivado/2018.3/include/hls_frexp_apfixed.h" 1
#40 "C:/Xilinx/Vivado/2018.3/include/hls_frexp_apfixed.h"
namespace frexp_internal {

template<int W, int I>
ap_fixed<W,I> frexp(ap_fixed<W,I> x,
                    ap_fixed<W,I>* exp){
    if(I<0) {
           *exp = 0;
           return x;
    }
    static const int F = W - I;
    static const int we = W > 5 ? W/2 : 3;

    ap_int<we> e = 0;
    ap_ufixed<W, I> r_p = 0;

    ap_fixed<W+1, I+1> xi = x;
    ap_ufixed<W, I> x_p = fabs_fixed(xi);

    static const ap_uint<3> clz_table_6bit[64] = {7, 6, 5, 5, 4, 4, 4, 4,
                                                  3, 3, 3, 3, 3, 3, 3, 3,
                                                  2, 2, 2, 2, 2, 2, 2, 2,
                                                  2, 2, 2, 2, 2, 2, 2, 2,
                                                  1, 1, 1, 1, 1, 1, 1, 1,
                                                  1, 1, 1, 1, 1, 1, 1, 1,
                                                  1, 1, 1, 1, 1, 1, 1, 1,
                                                  1, 1, 1, 1, 1, 1, 1, 1};
    int pos = 0;

    static const int loop_nm = W > 6 ? (W + 5)/6 : 1;
    CLZ_LOOP:
    for(int l = loop_nm; l > 0; --l){
#pragma HLS pipeline II=1
       ap_uint<6> t = 0;
       if(l*6 > W) t = x_p(W - 1, (l - 1) * 6);
       else t = x_p(l * 6 - 1, (l - 1) * 6);
       if((t & 0x3f) != 0) {
          pos = l * 6 - clz_table_6bit[t];
          break;
       }
    }
    if(pos >= 0) {
        e = pos + 1 - F;
        if(F > 0) {
           ap_uint<we> w_f = (pos + 1) < F ? (pos + 1) : F;
           r_p(F - 1,F - w_f) = x_p(pos, pos + 1 - w_f);
        }
    } else {
        e = 0;
        r_p = 0;
    }
    ap_fixed<W, I> r = 0;
    if(xi[W-1]) r = -r_p;
    else r = r_p;


#94 "C:/Xilinx/Vivado/2018.3/include/hls_frexp_apfixed.h" 3
   (void) ((!!(
#94 "C:/Xilinx/Vivado/2018.3/include/hls_frexp_apfixed.h"
   r > -1 && r < 1
#94 "C:/Xilinx/Vivado/2018.3/include/hls_frexp_apfixed.h" 3
   )) || (_assert(
#94 "C:/Xilinx/Vivado/2018.3/include/hls_frexp_apfixed.h"
   "r > -1 && r < 1"
#94 "C:/Xilinx/Vivado/2018.3/include/hls_frexp_apfixed.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/hls_frexp_apfixed.h",94),0))
#94 "C:/Xilinx/Vivado/2018.3/include/hls_frexp_apfixed.h"
                          ;

    *exp = e;
    return r;
}
template<int W, int I>
ap_ufixed<W,I> frexp(ap_ufixed<W,I> x,
                     ap_ufixed<W,I>* exp){
    ap_fixed<W+1, I+1> xe = x;
    ap_fixed<W+1, I+1> ee = 0;
    ap_fixed<W+1, I+1> r = frexp(xe,&ee);
    *exp = ee;
    return r;
}
template<int I>
ap_uint<I> frexp(ap_uint<I> x,
                 ap_uint<I>* exp) {
   ap_fixed<I, I> xe = x;
   ap_fixed<I, I> ee = 0;
   ap_fixed<I, I> r = frexp(xe,&ee);
   *exp = ee;
   return r;
}
template<int I>
ap_int<I> frexp(ap_int<I> x,
                ap_int<I>* exp) {
   ap_fixed<I+1, I+1> xe = x;
   ap_fixed<I+1, I+1> ee = 0;
   ap_fixed<I+1, I+1> r = frexp(xe,&ee);
   *exp = ee;
   return r;
}
}
#1033 "C:/Xilinx/Vivado/2018.3/include/hls_math.h" 2
#1 "C:/Xilinx/Vivado/2018.3/include/hls_modf_apfixed.h" 1
#39 "C:/Xilinx/Vivado/2018.3/include/hls_modf_apfixed.h"
namespace modf_internal {
template<int W, int I>
ap_fixed<W,I> modf(ap_fixed<W, I> x,
                   ap_fixed<W, I>* int_part){
    ap_fixed<W, I> frac_part = 0;
    if(W == I) {
        *int_part = x;
        frac_part = 0;
    } else if(I > 0) {
        ap_fixed<W+1, I+1> xi = x;
        ap_ufixed<W, I> x_p = fabs_fixed(xi);
        frac_part(W - I - 1,0) = x_p(W - I - 1,0);
        if(xi[W-1]) frac_part = - frac_part;
        *int_part = x_p(W-1, W-I);
        if(xi[W-1]) *int_part = -*int_part;
    } else {
       *int_part = 0;
       frac_part = x;
    }
    return frac_part;
}
template<int W, int I>
ap_ufixed<W,I> modf(ap_ufixed<W, I> x,
                    ap_ufixed<W, I>* int_part){
    ap_fixed<W+1, I+1> xi = x;
    ap_fixed<W+1, I+1> ii = 0;
    ap_fixed<W+1, I+1> r = modf(xi, &ii);
    *int_part = ii;
    return r;
}
template<int I>
ap_int<I> modf(ap_int<I> x,
               ap_int<I>* int_part){
    *int_part = x;
    return 0;
}
template<int I>
ap_uint<I> modf(ap_uint<I> x,
                ap_uint<I>* int_part){
    *int_part = x;
    return 0;
}
}
#1034 "C:/Xilinx/Vivado/2018.3/include/hls_math.h" 2
#1 "C:/Xilinx/Vivado/2018.3/include/hls_isequal_isnotequal_apfixed.h" 1
#39 "C:/Xilinx/Vivado/2018.3/include/hls_isequal_isnotequal_apfixed.h"
template <int W_, int I_>
bool generic_isequal(ap_fixed<W_,I_> x,ap_fixed<W_,I_> y)
{
#pragma HLS pipeline
    return (x==y);
}


template <int W_, int I_>
bool generic_isnotequal(ap_fixed<W_,I_> x,ap_fixed<W_,I_> y)
{
#pragma HLS pipeline
    return (!(x==y));
}


template <int W_, int I_>
bool generic_isequal(ap_ufixed<W_,I_> x,ap_fixed<W_,I_> y)
{
#pragma HLS pipeline
 return (x==y);
}


template <int W_, int I_>
bool generic_isnotequal(ap_ufixed<W_,I_> x,ap_fixed<W_,I_> y)
{
#pragma HLS pipeline
 return (!(x==y));
}


template <int W_, int I_>
bool generic_isequal(ap_fixed<W_,I_> x,ap_ufixed<W_,I_> y)
{
#pragma HLS pipeline
 return (x==y);
}


template <int W_, int I_>
bool generic_isnotequal(ap_fixed<W_,I_> x,ap_ufixed<W_,I_> y)
{
#pragma HLS pipeline
 return (!(x==y));
}


template <int W_, int I_>
bool generic_isequal(ap_ufixed<W_,I_> x,ap_ufixed<W_,I_> y)
{
#pragma HLS pipeline
 return (x==y);
}


template <int W_, int I_>
bool generic_isnotequal(ap_ufixed<W_,I_> x,ap_ufixed<W_,I_> y)
{
#pragma HLS pipeline
 return (!(x==y));
}



template <int I_>
bool generic_isequal(ap_int<I_> x,ap_int<I_> y)
{
#pragma HLS pipeline
    return (x==y);
}


template <int I_>
bool generic_isnotequal(ap_int<I_> x,ap_int<I_> y)
{
#pragma HLS pipeline
    return (!(x==y));
}


template <int I_>
bool generic_isequal(ap_uint<I_> x,ap_int<I_> y)
{
#pragma HLS pipeline
 return (x==y);
}


template <int I_>
bool generic_isnotequal(ap_uint<I_> x,ap_int<I_> y)
{
#pragma HLS pipeline
 return (!(x==y));
}


template <int I_>
bool generic_isequal(ap_int<I_> x,ap_uint<I_> y)
{
#pragma HLS pipeline
 return (x==y);
}


template <int I_>
bool generic_isnotequal(ap_int<I_> x,ap_uint<I_> y)
{
#pragma HLS pipeline
 return (!(x==y));
}


template <int I_>
bool generic_isequal(ap_uint<I_> x,ap_uint<I_> y)
{
#pragma HLS pipeline
 return (x==y);
}


template <int I_>
bool generic_isnotequal(ap_uint<I_> x,ap_uint<I_> y)
{
#pragma HLS pipeline
 return (!(x==y));
}
#1035 "C:/Xilinx/Vivado/2018.3/include/hls_math.h" 2
#1 "C:/Xilinx/Vivado/2018.3/include/hls_all_any_apfixed.h" 1
#34 "C:/Xilinx/Vivado/2018.3/include/hls_all_any_apfixed.h"
#1 "C:/Xilinx/Vivado/2018.3/include/ap_int.h" 1
#35 "C:/Xilinx/Vivado/2018.3/include/hls_all_any_apfixed.h" 2


template <int W_, int I_>
bool generic_all(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline II=1
    for (int i=0; i<W_;i++)
     if (x[i]==0)
      return false;
    return true;
}


template <int W_, int I_>
bool generic_all(ap_ufixed<W_,I_> x)
{
#pragma HLS pipeline II=1
    for (int i=0; i<W_;i++)
     if (x[i]==0)
      return false;
    return true;
}


template <int I_>
bool generic_all(ap_int<I_> x)
{
#pragma HLS pipeline II=1
    for (int i=0; i<I_;i++)
     if (x[i]==0)
      return false;
    return true;
}


template <int I_>
bool generic_all(ap_uint<I_> x)
{
#pragma HLS pipeline II=1
    for (int i=0; i<I_;i++)
     if (x[i]==0)
      return false;
    return true;
}


template <int W_, int I_>
bool generic_any(ap_fixed<W_,I_> x)
{
#pragma HLS pipeline II=1
    for (int i=0; i<W_;i++)
     if (x[i]==1)
      return true;
    return false;
}


template <int W_, int I_>
bool generic_any(ap_ufixed<W_,I_> x)
{
#pragma HLS pipeline II=1
    for (int i=0; i<W_;i++)
     if (x[i]==1)
      return true;
    return false;
}


template <int I_>
bool generic_any(ap_int<I_> x)
{
#pragma HLS pipeline II=1
    for (int i=0; i<I_;i++)
     if (x[i]==1)
      return true;
    return false;
}


template <int I_>
bool generic_any(ap_uint<I_> x)
{
#pragma HLS pipeline II=1
    for (int i=0; i<I_;i++)
     if (x[i]==1)
      return true;
    return false;
}
#1036 "C:/Xilinx/Vivado/2018.3/include/hls_math.h" 2
#1 "C:/Xilinx/Vivado/2018.3/include/hls_select_bitselect_apfixed.h" 1
#34 "C:/Xilinx/Vivado/2018.3/include/hls_select_bitselect_apfixed.h"
#1 "C:/Xilinx/Vivado/2018.3/include/ap_int.h" 1
#35 "C:/Xilinx/Vivado/2018.3/include/hls_select_bitselect_apfixed.h" 2
#61 "C:/Xilinx/Vivado/2018.3/include/hls_select_bitselect_apfixed.h"
template <int W_, int I_>
ap_fixed<W_,I_> generic_bitselect(ap_fixed<W_,I_> x,ap_fixed<W_,I_> y, ap_fixed<W_,I_> z)
{
#pragma HLS pipeline
    return (z & y)|(~z & x);
}


template <int W_, int I_>
ap_ufixed<W_,I_> generic_bitselect(ap_ufixed<W_,I_> x,ap_ufixed<W_,I_> y, ap_ufixed<W_,I_> z)
{
#pragma HLS pipeline
    return (z & y)|(~z & x);
}


template <int I_>
ap_int<I_> generic_bitselect(ap_int<I_> x,ap_int<I_> y, ap_int<I_> z)
{
#pragma HLS pipeline
    return (z & y)|(~z & x);
}

template <int I_>
ap_uint<I_> generic_bitselect(ap_uint<I_> x,ap_uint<I_> y, ap_uint<I_> z)
{
#pragma HLS pipeline
    return (z & y)|(~z & x);
}
#1037 "C:/Xilinx/Vivado/2018.3/include/hls_math.h" 2
#1 "C:/Xilinx/Vivado/2018.3/include/hls_erf_apfixed.h" 1
#34 "C:/Xilinx/Vivado/2018.3/include/hls_erf_apfixed.h"
#1 "C:/Xilinx/Vivado/2018.3/include/ap_int.h" 1
#35 "C:/Xilinx/Vivado/2018.3/include/hls_erf_apfixed.h" 2



namespace erf_erfc_fixed {

    namespace {
 template <typename T> class coeff { };

 template <> class coeff<double> {

 public:
   static const double tiny;
   static const double one_over_two;
   static const double one;
   static const double two;
   static const double erx;
   static const double efx;
   static const double efx8;
   static const double pp[5];
   static const double qq[6];
   static const double pa[7];
   static const double qa[7];
   static const double ra[8];
   static const double sa[9];
   static const double rb[7];
   static const double sb[8];
 };
 const double coeff<double>::tiny = 1e-300;
 const double coeff<double>::one_over_two= 5.00000000000000000000e-01;
 const double coeff<double>::one = 1.00000000000000000000e+00;
 const double coeff<double>::two = 2.00000000000000000000e+00;

 const double coeff<double>::erx = 8.45062911510467529297e-01;



 const double coeff<double>::efx = 1.28379167095512586316e-01;
 const double coeff<double>::efx8= 1.02703333676410069053e+00;
 const double coeff<double>::pp[] =
   {1.28379167095512558561e-01,
    -3.25042107247001499370e-01,
    -2.84817495755985104766e-02,
    -5.77027029648944159157e-03,
    -2.37630166566501626084e-05};
 const double coeff<double>::qq[] =
   {0.0, 3.97917223959155352819e-01,
    6.50222499887672944485e-02,
    5.08130628187576562776e-03,
    1.32494738004321644526e-04,
    -3.96022827877536812320e-06};



 const double coeff<double>::pa[] =
   {-2.36211856075265944077e-03,
    4.14856118683748331666e-01,
    -3.72207876035701323847e-01,
    3.18346619901161753674e-01,
    -1.10894694282396677476e-01,
    3.54783043256182359371e-02,
    -2.16637559486879084300e-03};
 const double coeff<double>::qa[] =
   {0.0, 1.06420880400844228286e-01,
    5.40397917702171048937e-01,
    7.18286544141962662868e-02,
    1.26171219808761642112e-01,
    1.36370839120290507362e-02,
    1.19844998467991074170e-02};



 const double coeff<double>::ra[] =
   {-9.86494403484714822705e-03,
    -6.93858572707181764372e-01,
    -1.05586262253232909814e+01,
    -6.23753324503260060396e+01,
    -1.62396669462573470355e+02,
    -1.84605092906711035994e+02,
    -8.12874355063065934246e+01,
    -9.81432934416914548592e+00};
 const double coeff<double>::sa[] =
   {0.0,1.96512716674392571292e+01,
    1.37657754143519042600e+02,
    4.34565877475229228821e+02,
    6.45387271733267880336e+02,
    4.29008140027567833386e+02,
    1.08635005541779435134e+02,
    6.57024977031928170135e+00,
    -6.04244152148580987438e-02};



 const double coeff<double>::rb[] =
   {-9.86494292470009928597e-03,
    -7.99283237680523006574e-01,
    -1.77579549177547519889e+01,
    -1.60636384855821916062e+02,
    -6.37566443368389627722e+02,
    -1.02509513161107724954e+03,
    -4.83519191608651397019e+02};
 const double coeff<double>::sb[] =
   {0.0,3.03380607434824582924e+01,
    3.25792512996573918826e+02,
    1.53672958608443695994e+03,
    3.19985821950859553908e+03,
    2.55305040643316442583e+03,
    4.74528541206955367215e+02,
    -2.24409524465858183362e+01};
#244 "C:/Xilinx/Vivado/2018.3/include/hls_erf_apfixed.h"
 template<typename T> class erf_traits{ };
#266 "C:/Xilinx/Vivado/2018.3/include/hls_erf_apfixed.h"
 template<> class erf_traits<double> {
 public:
   static const uint64_t mask;
   static const uint32_t segment[10];
 };
 const uint64_t erf_traits<double>::mask = 0xffffffff00000000;
 const uint32_t erf_traits<double>::segment[10] =
   {
  0x7fffffff,
  0x7ff00000,
  0x3feb0000,
  0x3e300000,
  0x00800000,
  0x3ff40000,
  0x40180000,
  0x4006DB6E,
  63,
  32
   };

 template<typename T> class erfc_traits{};
#307 "C:/Xilinx/Vivado/2018.3/include/hls_erf_apfixed.h"
 template<> class erfc_traits<double>{
 public:
   static const uint32_t segment[11];
 };
 const uint32_t erfc_traits<double>::segment[11] =
   {
  0x7fffffff,
  0x7ff00000,
  0x3feb0000,
  0x3c700000,
  0x3fd00000,
  0x3ff40000,
  0x403c0000,
  0x4006DB6D,
  0x40180000,
  63,
  32
   };
  }
#345 "C:/Xilinx/Vivado/2018.3/include/hls_erf_apfixed.h"
template <int W_, int I_>
ap_fixed<W_,I_> erf(ap_fixed<W_,I_> x_fixed )
{
    int F_ = W_ - I_;

    if (I_>33) return 0;
    else if (F_>32) return 0;

    double x = x_fixed.to_double();
 int32_t hx;
    uint32_t ix;
 double R,S,P,Q,s,y,z,r;

    fp_struct<double> fp_abs(x);
      fp_abs.sign=0;
    fp_struct<double> fp_x(x);
    ap_uint<32> tmp = fp_x.data()(erf_traits<double>::segment[8],erf_traits<double>::segment[9]);
    hx = tmp.to_int();
 ix = hx & erf_traits<double>::segment[0];






    if(fp_x.exp == 0x0 && fp_x.sign!= 0x0){
   return 0;
 }

 if(ix>=erf_traits<double>::segment[1]) {

   if(hx>0)
  return ap_fixed<W_,I_>((double)1.0 +coeff<double>::one/x);
   else
  return ap_fixed<W_,I_>(coeff<double>::one/x-(double)1.0);
 }

 if(ix < erf_traits<double>::segment[2]) {
   double r1,r2,s1,s2,s3,z2,z4;
   if(ix < erf_traits<double>::segment[3]) {
  if (ix < erf_traits<double>::segment[2])
    return ap_fixed<W_,I_>(((double)0.125)*((double)8.0*x+coeff<double>::efx8*x));
  return ap_fixed<W_,I_>(x + coeff<double>::efx*x);
   }
   z = x*x;




   r1 = coeff<double>::pp[0]+z*coeff<double>::pp[1]; z2=z*z;
   r2 = coeff<double>::pp[2]+z*coeff<double>::pp[3]; z4=z2*z2;
   s1 = coeff<double>::one+z* coeff<double>::qq[1];
   s2 = coeff<double>::qq[2]+z*coeff<double>::qq[3];
   s3 = coeff<double>::qq[4]+z*coeff<double>::qq[5];
   r = r1 + z2*r2 + z4*coeff<double>::pp[4];
   s = s1 + z2*s2 + z4*s3;

   y = r/s;
   return ap_fixed<W_,I_>(x + x*y);
 }
 if(ix < erf_traits<double>::segment[5]) {
   double s2,s4,s6,P1,P2,P3,P4,Q1,Q2,Q3,Q4;

      s = fp_abs.to_ieee()-coeff<double>::one;




   P1 = coeff<double>::pa[0]+s*coeff<double>::pa[1]; s2=s*s;
   Q1 = coeff<double>::one+s*coeff<double>::qa[1]; s4=s2*s2;
   P2 = coeff<double>::pa[2]+s*coeff<double>::pa[3]; s6=s4*s2;
   Q2 = coeff<double>::qa[2]+s*coeff<double>::qa[3];
   P3 = coeff<double>::pa[4]+s*coeff<double>::pa[5];
   Q3 = coeff<double>::qa[4]+s*coeff<double>::qa[5];
   P4 = coeff<double>::pa[6];
   Q4 = coeff<double>::qa[6];
   P = P1 + s2*P2 + s4*P3 + s6*P4;
   Q = Q1 + s2*Q2 + s4*Q3 + s6*Q4;

   if(hx>=0) return ap_fixed<W_,I_>(coeff<double>::erx + P/Q);
      else return ap_fixed<W_,I_>(-coeff<double>::erx - P/Q);
 }
 if (ix >= erf_traits<double>::segment[6]) {
   if(hx>=0) return ap_fixed<W_,I_>(coeff<double>::one-coeff<double>::tiny);
      else return ap_fixed<W_,I_>(coeff<double>::tiny-coeff<double>::one);
 }
 x = fp_abs.to_ieee();
  s = coeff<double>::one/(x*x);
 if(ix< erf_traits<double>::segment[7]) {






   double R1,R2,R3,R4,S1,S2,S3,S4,s2,s4,s6,s8;
   R1 = coeff<double>::ra[0]+s*coeff<double>::ra[1];s2 = s*s;
   S1 = coeff<double>::one+ s*coeff<double>::sa[1]; s4 = s2*s2;
   R2 = coeff<double>::ra[2]+s*coeff<double>::ra[3];s6 = s4*s2;
   S2 = coeff<double>::sa[2]+s*coeff<double>::sa[3];s8 = s4*s4;
   R3 = coeff<double>::ra[4]+s*coeff<double>::ra[5];
   S3 = coeff<double>::sa[4]+s*coeff<double>::sa[5];
   R4 = coeff<double>::ra[6]+s*coeff<double>::ra[7];
   S4 = coeff<double>::sa[6]+s*coeff<double>::sa[7];
   R = R1 + s2*R2 + s4*R3 + s6*R4;
   S = S1 + s2*S2 + s4*S3 + s6*S4 + s8*coeff<double>::sa[8];

 } else {






   double R1,R2,R3,S1,S2,S3,S4,s2,s4,s6;
   R1 = coeff<double>::rb[0]+s*coeff<double>::rb[1];s2 = s*s;
   S1 = coeff<double>::one+ s*coeff<double>::sb[1]; s4 = s2*s2;
   R2 = coeff<double>::rb[2]+s*coeff<double>::rb[3];s6 = s4*s2;
   S2 = coeff<double>::sb[2]+s*coeff<double>::sb[3];
   R3 = coeff<double>::rb[4]+s*coeff<double>::rb[5];
   S3 = coeff<double>::sb[4]+s*coeff<double>::sb[5];
   S4 = coeff<double>::sb[6]+s*coeff<double>::sb[7];
   R = R1 + s2*R2 + s4*R3 + s6*coeff<double>::rb[6];
   S = S1 + s2*S2 + s4*S3 + s6*S4;

 }
 z = x;

    fp_struct<double> fp_z(z);
    ap_uint<Type_BitWidth<double>::Value> data = fp_z.data() & erf_traits<double>::mask;
    fp_struct<double> fp_z_new(data);
    z = fp_z_new.to_ieee();


    ap_fixed<W_, I_> r_fixed = exp_reduce::exp(ap_fixed<W_, I_>(-z*z-(double)0.5625))*exp_reduce::exp(ap_fixed<W_, I_>((z-x)*(z+x)+R/S));
 r = r_fixed.to_double();

 if(hx>=0) return ap_fixed<W_,I_>(coeff<double>::one-r/x);
    else return ap_fixed<W_,I_>(r/x-coeff<double>::one);
  }


template <int W_, int I_>
ap_ufixed<W_,I_> erf(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xs = x;
    return erf(xs);
}

template <int I_>
ap_int<I_> erf(ap_int<I_> x) {
    ap_fixed<I_,I_> xs = x;
    return erf(xs);
}

template <int I_>
ap_uint<I_> erf(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xs = x;
    return erf(xs);
}
#512 "C:/Xilinx/Vivado/2018.3/include/hls_erf_apfixed.h"
template <int W_, int I_>
ap_fixed<W_,I_> erfc(ap_fixed<W_,I_> x_fixed)
{
#pragma HLS PIPELINE II=1
    int F_ = W_ - I_;

    if (I_>33) return 0;
    else if (F_>32) return 0;

    double x = x_fixed.to_double();
    int32_t hx;
    uint32_t ix;
 double R,S,P,Q,s,y,z,r;

    fp_struct<double> fp_abs(x);
    fp_abs.sign=0;
    fp_struct<double> fp_x(x);
    ap_uint<32> tmp = fp_x.data()(erfc_traits<double>::segment[9],erfc_traits<double>::segment[10]);
    hx = tmp.to_int();
 ix = hx & erfc_traits<double>::segment[0];
 if(ix>=erfc_traits<double>::segment[1]) {

   if(hx>0)
  return ap_fixed<W_,I_>(coeff<double>::one/x);
   else
  return ap_fixed<W_,I_>(coeff<double>::two + coeff<double>::one/x);

 }

 if(ix < erfc_traits<double>::segment[2]) {
   double r1,r2,s1,s2,s3,z2,z4;
   if(ix < erfc_traits<double>::segment[3])
  return ap_fixed<W_,I_>(coeff<double>::one-x);
   z = x*x;




   r1 = coeff<double>::pp[0]+z*coeff<double>::pp[1]; z2=z*z;
   r2 = coeff<double>::pp[2]+z*coeff<double>::pp[3]; z4=z2*z2;
   s1 = coeff<double>::one+z*coeff<double>::qq[1];
   s2 = coeff<double>::qq[2]+z*coeff<double>::qq[3];
   s3 = coeff<double>::qq[4]+z*coeff<double>::qq[5];
   r = r1 + z2*r2 + z4*coeff<double>::pp[4];
   s = s1 + z2*s2 + z4*s3;

   y = r/s;
   if(ix < erfc_traits<double>::segment[4]) {
  return ap_fixed<W_,I_>(coeff<double>::one-(x+x*y));
   } else {
  r = x*y;
  r += (x-coeff<double>::one_over_two);
  return ap_fixed<W_,I_>(coeff<double>::one_over_two - r) ;
   }
 }
 if(ix < erfc_traits<double>::segment[5]) {
   double s2,s4,s6,P1,P2,P3,P4,Q1,Q2,Q3,Q4;
   s =fp_abs.to_ieee()-coeff<double>::one;




   P1 = coeff<double>::pa[0]+s*coeff<double>::pa[1]; s2=s*s;
   Q1 = coeff<double>::one+s*coeff<double>::qa[1]; s4=s2*s2;
   P2 = coeff<double>::pa[2]+s*coeff<double>::pa[3]; s6=s4*s2;
   Q2 = coeff<double>::qa[2]+s*coeff<double>::qa[3];
   P3 = coeff<double>::pa[4]+s*coeff<double>::pa[5];
   Q3 = coeff<double>::qa[4]+s*coeff<double>::qa[5];
   P4 = coeff<double>::pa[6];
   Q4 = coeff<double>::qa[6];
   P = P1 + s2*P2 + s4*P3 + s6*P4;
   Q = Q1 + s2*Q2 + s4*Q3 + s6*Q4;

   if(hx>=0) {
  z = coeff<double>::one-coeff<double>::erx;
        return ap_fixed<W_,I_>(z - P/Q);
   } else {
  z = coeff<double>::erx+P/Q; return ap_fixed<W_,I_>(coeff<double>::one+z);
   }
 }
 if (ix < erfc_traits<double>::segment[6]) {
   x = fp_abs.to_ieee();
   s = coeff<double>::one/(x*x);
   if(ix< erfc_traits<double>::segment[7]) {






  double R1,R2,R3,R4,S1,S2,S3,S4,s2,s4,s6,s8;
     R1 = coeff<double>::ra[0]+s*coeff<double>::ra[1];s2 = s*s;
     S1 = coeff<double>::one+s*coeff<double>::sa[1]; s4 = s2*s2;
     R2 = coeff<double>::ra[2]+s*coeff<double>::ra[3];s6 = s4*s2;
     S2 = coeff<double>::sa[2]+s*coeff<double>::sa[3];s8 = s4*s4;
     R3 = coeff<double>::ra[4]+s*coeff<double>::ra[5];
     S3 = coeff<double>::sa[4]+s*coeff<double>::sa[5];
     R4 = coeff<double>::ra[6]+s*coeff<double>::ra[7];
     S4 = coeff<double>::sa[6]+s*coeff<double>::sa[7];
     R = R1 + s2*R2 + s4*R3 + s6*R4;
     S = S1 + s2*S2 + s4*S3 + s6*S4 + s8*coeff<double>::sa[8];

   } else {
  double R1,R2,R3,S1,S2,S3,S4,s2,s4,s6;
  if(hx<0&&ix>=erfc_traits<double>::segment[8]) return ap_fixed<W_,I_>(coeff<double>::two-coeff<double>::tiny);






  R1 = coeff<double>::rb[0]+s*coeff<double>::rb[1];s2 = s*s;
  S1 = coeff<double>::one+s*coeff<double>::sb[1]; s4 = s2*s2;
  R2 = coeff<double>::rb[2]+s*coeff<double>::rb[3];s6 = s4*s2;
  S2 = coeff<double>::sb[2]+s*coeff<double>::sb[3];
  R3 = coeff<double>::rb[4]+s*coeff<double>::rb[5];
  S3 = coeff<double>::sb[4]+s*coeff<double>::sb[5];
  S4 = coeff<double>::sb[6]+s*coeff<double>::sb[7];
  R = R1 + s2*R2 + s4*R3 + s6*coeff<double>::rb[6];
  S = S1 + s2*S2 + s4*S3 + s6*S4;

   }
   z = x;

   fp_struct<double> fp_z(z);
   ap_uint<Type_BitWidth<double>::Value> data = fp_z.data() & erf_traits<double>::mask;
   fp_struct<double> fp_z_new(data);
   z = fp_z_new.to_ieee();


   ap_fixed<W_, I_> r_fixed = exp_reduce::exp((ap_fixed<W_, I_>)(-z*z-(double)0.5625))*exp_reduce::exp((ap_fixed<W_, I_>)((z-x)*(z+x)+R/S));
   double r = r_fixed.to_double();
   double r_x = r/x;
   if(hx>0) {





        if(fp_x.exp == 0x0 && fp_x.sign!= 0x0){
   return 0;
        }
  return ap_fixed<W_,I_>(r_x);
   } else
  return ap_fixed<W_,I_>(coeff<double>::two-r_x);
 } else {
   if(hx>0) return ap_fixed<W_,I_>(coeff<double>::tiny*coeff<double>::tiny);
      else return ap_fixed<W_,I_>(coeff<double>::two-coeff<double>::tiny);
 }

}
template <int W_, int I_>
ap_ufixed<W_,I_> erfc(ap_ufixed<W_,I_> x) {
    ap_fixed<W_+1,I_+1> xs = x;
    return erfc(xs);
}

template <int I_>
ap_int<I_> erfc(ap_int<I_> x) {
    ap_fixed<I_,I_> xs = x;
    return erfc(xs);
}

template <int I_>
ap_uint<I_> erfc(ap_uint<I_> x) {
    ap_fixed<I_+1,I_+1> xs = x;
    return erfc(xs);
}

}
#1038 "C:/Xilinx/Vivado/2018.3/include/hls_math.h" 2
#1 "C:/Xilinx/Vivado/2018.3/include/hls_fmod_rem_quo_remainder_divide_apfixed.h" 1
#39 "C:/Xilinx/Vivado/2018.3/include/hls_fmod_rem_quo_remainder_divide_apfixed.h"
#1 "C:/Xilinx/Vivado/2018.3/include/ap_int.h" 1
#40 "C:/Xilinx/Vivado/2018.3/include/hls_fmod_rem_quo_remainder_divide_apfixed.h" 2




#1 "C:/Xilinx/Vivado/2018.3/include/utils/x_hls_traits.h" 1
#37 "C:/Xilinx/Vivado/2018.3/include/utils/x_hls_traits.h"
#1 "C:/Xilinx/Vivado/2018.3/include/utils/x_hls_utils.h" 1
#38 "C:/Xilinx/Vivado/2018.3/include/utils/x_hls_traits.h" 2
#1 "C:/Xilinx/Vivado/2018.3/include/utils/x_hls_defines.h" 1
#39 "C:/Xilinx/Vivado/2018.3/include/utils/x_hls_traits.h" 2


namespace hls
{

template<typename T>
struct x_traits_default {
  typedef T ADD_T;
  typedef T SUB_T;
  typedef T SAT_T;
  typedef T MULT_T;
  typedef T MADD_T;
};

template<typename T1, typename T2>
struct x_traits {
#66 "C:/Xilinx/Vivado/2018.3/include/utils/x_hls_traits.h"
};

template<>
struct x_traits<double, double> : public x_traits_default<double> { };

template<typename T2>
struct x_traits<double, T2> : public x_traits_default<double> { };

template<typename T1>
struct x_traits<T1, double> : public x_traits_default<double> { };

template<>
struct x_traits<float, float> : public x_traits_default<float> { };

template<typename T2>
struct x_traits<float, T2> : public x_traits_default<float> { };

template<typename T1>
struct x_traits<T1, float> : public x_traits_default<float> { };

template<>
struct x_traits<half, half> : public x_traits_default<half> { };

template<typename T2>
struct x_traits<half, T2> : public x_traits_default<float> { };

template<typename T1>
struct x_traits<T1, half> : public x_traits_default<float> { };

template<>
struct x_traits<double, float> : public x_traits_default<double> { };

template<>
struct x_traits<float, double> : public x_traits_default<double> { };

template<>
struct x_traits<double, half> : public x_traits_default<double> { };

template<>
struct x_traits<half, double> : public x_traits_default<double> { };

template<>
struct x_traits<int, int> : public x_traits_default<int> { };

template<>
struct x_traits<unsigned int, unsigned int> : public x_traits_default<unsigned int> { };

template<>
struct x_traits<int64_t, int64_t> : public x_traits_default<int64_t> { };

template<int A,int B> class MAX{
  public:
    const static int value = (A > B) ? A : B;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_fixed<W2,I2,Q2,O2> > {
    typedef typename ap_fixed<W1,I1>::template RType<W2,I2,true> RTYPE;
    typedef ap_fixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_fixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
 typedef ap_fixed<W1,I1,AP_RND,AP_SAT> SAT_T;
 typedef ap_fixed<W1+W2+1,I1+I2+1> MADD_T;
 typedef ap_fixed<W1+W2+2,I1+I2+2> CMADD_T;
 typedef ap_fixed<(2*W1)+1,(2*I1)> CONJ_SQ_T;
 typedef ap_fixed<(2*W1)+2,(2*I1)+1> CONJ_SQ_2_T;
    typedef ap_fixed<2*(MAX<I1,W1-I1>::value+1),(MAX<I1,W1-I1>::value+1)> INV_T;
    typedef int INT_T;
    typedef float_struct<24,8> FLOAT_STRUCT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_ufixed<W2,I2,Q2,O2> > {
    typedef typename ap_fixed<W1,I1>::template RType<W2,I2,false> RTYPE;
    typedef ap_fixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_fixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_fixed<W2,I2,Q2,O2> > {
    typedef typename ap_ufixed<W1,I1>::template RType<W2,I2,true> RTYPE;
    typedef ap_fixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_fixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_ufixed<W2,I2,Q2,O2> > {
    typedef typename ap_ufixed<W1,I1>::template RType<W2,I2,false> RTYPE;
    typedef ap_ufixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_ufixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
 typedef ap_ufixed<W1,I1,AP_RND,AP_SAT> SAT_T;
 typedef ap_ufixed<W1+W2+1,I1+I2+1> MADD_T;
 typedef ap_ufixed<W1+W2+2,I1+I2+2> CMADD_T;
 typedef ap_ufixed<(2*W1)+1,(2*I1)> CONJ_SQ_T;
 typedef ap_ufixed<(2*W1)+2,(2*I1)+1> CONJ_SQ_2_T;
    typedef ap_ufixed<2*(MAX<I1,W1-I1>::value+1),(MAX<I1,W1-I1>::value+1)> INV_T;
    typedef int INT_T;
    typedef float_struct<24,8> FLOAT_STRUCT_T;
};

template<int W1, int W2>
struct x_traits<ap_int<W1>,ap_int<W2> > {
 typedef ap_int<MAX<W1,W2>::value + 1> ADD_T;
 typedef ap_int<MAX<W1,W2>::value + 1> SUB_T;
 typedef ap_int<W1+W2> MULT_T;
 typedef ap_int<(W1 > W2)? W1:W2> MADD_T;
};

template<int W1, int W2>
struct x_traits<ap_int<W1>,ap_uint<W2> > {
 typedef ap_int<MAX<W1,W2+1>::value + 1> ADD_T;
 typedef ap_int<MAX<W1,W2+1>::value + 1> SUB_T;
 typedef ap_int<W1+W2> MULT_T;
};

template<int W1, int W2>
struct x_traits<ap_uint<W1>,ap_int<W2> > {
 typedef ap_int<MAX<W1+1,W2>::value + 1> ADD_T;
 typedef ap_int<MAX<W1+1,W2>::value + 1> SUB_T;
 typedef ap_int<W1+W2> MULT_T;
};

template<int W1, int W2>
struct x_traits<ap_uint<W1>,ap_uint<W2> > {
 typedef ap_uint<MAX<W1,W2>::value + 1> ADD_T;
 typedef ap_int<MAX<W1,W2>::value + 1> SUB_T;
 typedef ap_uint<W1+W2> MULT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_int<W2> > : public x_traits<ap_fixed<W1,I1>, ap_fixed<W2,W2> > {};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_uint<W2> > : public x_traits<ap_fixed<W1,I1>, ap_ufixed<W2,W2> > {};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_int<W2> > : public x_traits<ap_ufixed<W1,I1>, ap_fixed<W2,W2> > {};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_uint<W2> > : public x_traits<ap_ufixed<W1,I1>, ap_ufixed<W2,W2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_int<W1>, ap_fixed<W2,I2,Q2,O2> > : public x_traits<ap_fixed<W1,W1>, ap_fixed<W2,I2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_int<W1>, ap_ufixed<W2,I2,Q2,O2> > : public x_traits<ap_fixed<W1,W1>, ap_ufixed<W2,I2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_uint<W1>, ap_fixed<W2,I2,Q2,O2> > : public x_traits<ap_ufixed<W1,W1>, ap_fixed<W2,I2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_uint<W1>, ap_ufixed<W2,I2,Q2,O2> > : public x_traits<ap_ufixed<W1,W1>, ap_ufixed<W2,I2> > {};




    template<typename T> struct fixed_type { };
    template<> struct fixed_type<char> { typedef ap_fixed<8,8> T; };
    template<> struct fixed_type<unsigned char> { typedef ap_ufixed<8,8> T; };
    template<> struct fixed_type<short> { typedef ap_fixed<16,16> T; };
    template<> struct fixed_type<unsigned short> { typedef ap_ufixed<16,16> T; };
    template<> struct fixed_type<int> { typedef ap_fixed<32,32> T; };
    template<> struct fixed_type<unsigned int> { typedef ap_ufixed<32,32> T; };
    template<> struct fixed_type<float> { typedef ap_ufixed<64,32> T; };
    template<int W> struct fixed_type<ap_int<W> > { typedef ap_fixed<W,W> T; };
    template<int W> struct fixed_type<ap_uint<W> > { typedef ap_ufixed<W,W> T; };
    template<int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O> struct fixed_type<ap_fixed<W,I, _AP_Q, _AP_O> > { typedef ap_fixed<W,I> T; };
    template<int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O> struct fixed_type<ap_ufixed<W,I, _AP_Q, _AP_O> > { typedef ap_ufixed<W,I> T; };

template<typename T1, int DIM>
struct x_traits_d_default {
    typedef T1 ACCUM_T;
    typedef T1 ACCUM2_T;
    typedef T1 ADD_TREE_T;
};

template<typename T1, int DIM>
struct x_traits_d {};

template<int DIM>
struct x_traits_d <float,DIM>:x_traits_d_default<float, DIM> {};

template<int DIM>
struct x_traits_d <double,DIM>:x_traits_d_default<double, DIM> {};

template<int DIM>
struct x_traits_d <half,DIM>:x_traits_d_default<half, DIM> {};

template<int W, int DIM>
struct x_traits_d <ap_int<W>,DIM> {
    typedef ap_int<W> ACCUM_T;
    typedef ap_int<2*W> ACCUM2_T;
    typedef ap_int<25+W> ADD_TREE_T;
};

template<int W, int DIM>
struct x_traits_d <ap_uint<W>,DIM> {
    typedef ap_uint<W> ACCUM_T;
    typedef ap_uint<2*W> ACCUM2_T;
    typedef ap_uint<25+W> ADD_TREE_T;
};

template<int W, int I, ap_q_mode Q, ap_o_mode O, int DIM>
struct x_traits_d <ap_fixed<W,I,Q,O>,DIM> {
    typedef ap_fixed<W+BitWidth<DIM>::Value,I+BitWidth<DIM>::Value,Q,O> ACCUM_T;
    typedef ap_fixed<(2*W)+BitWidth<DIM>::Value,(2*I)+BitWidth<DIM>::Value,Q,O> ACCUM2_T;
    typedef ap_fixed<25+W+BitWidth<DIM>::Value,25+I+BitWidth<DIM>::Value,Q,O> ADD_TREE_T;
};

template<int W, int I, ap_q_mode Q, ap_o_mode O, int DIM>
struct x_traits_d <ap_ufixed<W,I,Q,O>,DIM> {
    typedef ap_ufixed<W+BitWidth<DIM>::Value,I+BitWidth<DIM>::Value,Q,O> ACCUM_T;
    typedef ap_ufixed<(2*W)+BitWidth<DIM>::Value,(2*I)+BitWidth<DIM>::Value,Q,O> ACCUM2_T;
    typedef ap_ufixed<25+W+BitWidth<DIM>::Value,25+I+BitWidth<DIM>::Value,Q,O> ADD_TREE_T;
};

}



namespace hlstmp
{

template<typename T>
struct x_traits_default {
  typedef T ADD_T;
  typedef T SUB_T;
  typedef T SAT_T;
  typedef T MULT_T;
  typedef T MADD_T;
};

template<typename T1, typename T2>
struct x_traits {
#314 "C:/Xilinx/Vivado/2018.3/include/utils/x_hls_traits.h"
};

template<>
struct x_traits<double, double> : public x_traits_default<double> { };

template<typename T2>
struct x_traits<double, T2> : public x_traits_default<double> { };

template<typename T1>
struct x_traits<T1, double> : public x_traits_default<double> { };

template<>
struct x_traits<float, float> : public x_traits_default<float> { };

template<typename T2>
struct x_traits<float, T2> : public x_traits_default<float> { };

template<typename T1>
struct x_traits<T1, float> : public x_traits_default<float> { };

template<>
struct x_traits<half, half> : public x_traits_default<half> { };

template<typename T2>
struct x_traits<half, T2> : public x_traits_default<float> { };

template<typename T1>
struct x_traits<T1, half> : public x_traits_default<float> { };

template<>
struct x_traits<double, float> : public x_traits_default<double> { };

template<>
struct x_traits<float, double> : public x_traits_default<double> { };

template<>
struct x_traits<double, half> : public x_traits_default<double> { };

template<>
struct x_traits<half, double> : public x_traits_default<double> { };

template<>
struct x_traits<int, int> : public x_traits_default<int> { };

template<>
struct x_traits<unsigned int, unsigned int> : public x_traits_default<unsigned int> { };

template<>
struct x_traits<int64_t, int64_t> : public x_traits_default<int64_t> { };

template<int A,int B> class MAX{
  public:
    const static int value = (A > B) ? A : B;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_fixed<W2,I2,Q2,O2> > {
    typedef typename ap_fixed<W1,I1>::template RType<W2,I2,true> RTYPE;
    typedef ap_fixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_fixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
 typedef ap_fixed<W1,I1,AP_RND,AP_SAT> SAT_T;
 typedef ap_fixed<W1+W2+1,I1+I2+1> MADD_T;
 typedef ap_fixed<W1+W2+2,I1+I2+2> CMADD_T;
 typedef ap_fixed<(2*W1)+1,(2*I1)> CONJ_SQ_T;
 typedef ap_fixed<(2*W1)+2,(2*I1)+1> CONJ_SQ_2_T;
    typedef ap_fixed<2*(MAX<I1,W1-I1>::value+1),(MAX<I1,W1-I1>::value+1)> INV_T;
    typedef int INT_T;
    typedef float_struct<24,8> FLOAT_STRUCT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_ufixed<W2,I2,Q2,O2> > {
    typedef typename ap_fixed<W1,I1>::template RType<W2,I2,false> RTYPE;
    typedef ap_fixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_fixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_fixed<W2,I2,Q2,O2> > {
    typedef typename ap_ufixed<W1,I1>::template RType<W2,I2,true> RTYPE;
    typedef ap_fixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_fixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_ufixed<W2,I2,Q2,O2> > {
    typedef typename ap_ufixed<W1,I1>::template RType<W2,I2,false> RTYPE;
    typedef ap_ufixed<RTYPE::plus_w, RTYPE::plus_i> ADD_T;
    typedef ap_fixed<RTYPE::minus_w, RTYPE::minus_i> SUB_T;
    typedef ap_ufixed<RTYPE::mult_w, RTYPE::mult_i> MULT_T;
 typedef ap_ufixed<W1,I1,AP_RND,AP_SAT> SAT_T;
 typedef ap_ufixed<W1+W2+1,I1+I2+1> MADD_T;
 typedef ap_ufixed<W1+W2+2,I1+I2+2> CMADD_T;
 typedef ap_ufixed<(2*W1)+1,(2*I1)> CONJ_SQ_T;
 typedef ap_ufixed<(2*W1)+2,(2*I1)+1> CONJ_SQ_2_T;
    typedef ap_ufixed<2*(MAX<I1,W1-I1>::value+1),(MAX<I1,W1-I1>::value+1)> INV_T;
    typedef int INT_T;
    typedef float_struct<24,8> FLOAT_STRUCT_T;
};

template<int W1, int W2>
struct x_traits<ap_int<W1>,ap_int<W2> > {
 typedef ap_int<MAX<W1,W2>::value + 1> ADD_T;
 typedef ap_int<MAX<W1,W2>::value + 1> SUB_T;
 typedef ap_int<W1+W2> MULT_T;
 typedef ap_int<(W1 > W2)? W1:W2> MADD_T;
};

template<int W1, int W2>
struct x_traits<ap_int<W1>,ap_uint<W2> > {
 typedef ap_int<MAX<W1,W2+1>::value + 1> ADD_T;
 typedef ap_int<MAX<W1,W2+1>::value + 1> SUB_T;
 typedef ap_int<W1+W2> MULT_T;
};

template<int W1, int W2>
struct x_traits<ap_uint<W1>,ap_int<W2> > {
 typedef ap_int<MAX<W1+1,W2>::value + 1> ADD_T;
 typedef ap_int<MAX<W1+1,W2>::value + 1> SUB_T;
 typedef ap_int<W1+W2> MULT_T;
};

template<int W1, int W2>
struct x_traits<ap_uint<W1>,ap_uint<W2> > {
 typedef ap_uint<MAX<W1,W2>::value + 1> ADD_T;
 typedef ap_int<MAX<W1,W2>::value + 1> SUB_T;
 typedef ap_uint<W1+W2> MULT_T;
};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_int<W2> > : public x_traits<ap_fixed<W1,I1>, ap_fixed<W2,W2> > {};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_fixed<W1,I1,Q1,O1>,ap_uint<W2> > : public x_traits<ap_fixed<W1,I1>, ap_ufixed<W2,W2> > {};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_int<W2> > : public x_traits<ap_ufixed<W1,I1>, ap_fixed<W2,W2> > {};

template<int W1, int I1, ap_q_mode Q1, ap_o_mode O1, int W2>
struct x_traits<ap_ufixed<W1,I1,Q1,O1>,ap_uint<W2> > : public x_traits<ap_ufixed<W1,I1>, ap_ufixed<W2,W2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_int<W1>, ap_fixed<W2,I2,Q2,O2> > : public x_traits<ap_fixed<W1,W1>, ap_fixed<W2,I2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_int<W1>, ap_ufixed<W2,I2,Q2,O2> > : public x_traits<ap_fixed<W1,W1>, ap_ufixed<W2,I2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_uint<W1>, ap_fixed<W2,I2,Q2,O2> > : public x_traits<ap_ufixed<W1,W1>, ap_fixed<W2,I2> > {};

template<int W1, int W2, int I2, ap_q_mode Q2, ap_o_mode O2>
struct x_traits<ap_uint<W1>, ap_ufixed<W2,I2,Q2,O2> > : public x_traits<ap_ufixed<W1,W1>, ap_ufixed<W2,I2> > {};




    template<typename T> struct fixed_type { };
    template<> struct fixed_type<char> { typedef ap_fixed<8,8> T; };
    template<> struct fixed_type<unsigned char> { typedef ap_ufixed<8,8> T; };
    template<> struct fixed_type<short> { typedef ap_fixed<16,16> T; };
    template<> struct fixed_type<unsigned short> { typedef ap_ufixed<16,16> T; };
    template<> struct fixed_type<int> { typedef ap_fixed<32,32> T; };
    template<> struct fixed_type<unsigned int> { typedef ap_ufixed<32,32> T; };
    template<> struct fixed_type<float> { typedef ap_ufixed<64,32> T; };
    template<int W> struct fixed_type<ap_int<W> > { typedef ap_fixed<W,W> T; };
    template<int W> struct fixed_type<ap_uint<W> > { typedef ap_ufixed<W,W> T; };
    template<int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O> struct fixed_type<ap_fixed<W,I, _AP_Q, _AP_O> > { typedef ap_fixed<W,I> T; };
    template<int W, int I, ap_q_mode _AP_Q, ap_o_mode _AP_O> struct fixed_type<ap_ufixed<W,I, _AP_Q, _AP_O> > { typedef ap_ufixed<W,I> T; };

template<typename T1, int DIM>
struct x_traits_d_default {
    typedef T1 ACCUM_T;
    typedef T1 ACCUM2_T;
    typedef T1 ADD_TREE_T;
};

template<typename T1, int DIM>
struct x_traits_d {};

template<int DIM>
struct x_traits_d <float,DIM>:x_traits_d_default<float, DIM> {};

template<int DIM>
struct x_traits_d <double,DIM>:x_traits_d_default<double, DIM> {};

template<int DIM>
struct x_traits_d <half,DIM>:x_traits_d_default<half, DIM> {};

template<int W, int DIM>
struct x_traits_d <ap_int<W>,DIM> {
    typedef ap_int<W> ACCUM_T;
    typedef ap_int<2*W> ACCUM2_T;
    typedef ap_int<25+W> ADD_TREE_T;
};

template<int W, int DIM>
struct x_traits_d <ap_uint<W>,DIM> {
    typedef ap_uint<W> ACCUM_T;
    typedef ap_uint<2*W> ACCUM2_T;
    typedef ap_uint<25+W> ADD_TREE_T;
};

template<int W, int I, ap_q_mode Q, ap_o_mode O, int DIM>
struct x_traits_d <ap_fixed<W,I,Q,O>,DIM> {
    typedef ap_fixed<W+BitWidth<DIM>::Value,I+BitWidth<DIM>::Value,Q,O> ACCUM_T;
    typedef ap_fixed<(2*W)+BitWidth<DIM>::Value,(2*I)+BitWidth<DIM>::Value,Q,O> ACCUM2_T;
    typedef ap_fixed<25+W+BitWidth<DIM>::Value,25+I+BitWidth<DIM>::Value,Q,O> ADD_TREE_T;
};

template<int W, int I, ap_q_mode Q, ap_o_mode O, int DIM>
struct x_traits_d <ap_ufixed<W,I,Q,O>,DIM> {
    typedef ap_ufixed<W+BitWidth<DIM>::Value,I+BitWidth<DIM>::Value,Q,O> ACCUM_T;
    typedef ap_ufixed<(2*W)+BitWidth<DIM>::Value,(2*I)+BitWidth<DIM>::Value,Q,O> ACCUM2_T;
    typedef ap_ufixed<25+W+BitWidth<DIM>::Value,25+I+BitWidth<DIM>::Value,Q,O> ADD_TREE_T;
};

}
#45 "C:/Xilinx/Vivado/2018.3/include/hls_fmod_rem_quo_remainder_divide_apfixed.h" 2

#1 "C:/Xilinx/Vivado/2018.3/msys64/mingw64/include/c++/6.2.0/stdlib.h" 1 3
#47 "C:/Xilinx/Vivado/2018.3/include/hls_fmod_rem_quo_remainder_divide_apfixed.h" 2


namespace hls_my{

 template <int W_, int I_>
 ap_fixed<W_,I_> generic_divide(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y){
  if(y==0){

  printf("ERROR:hls_math.h:divisor cannot be zero");
  exit(1);

  }
  else{
   return(x/y);
  }
 }

 template <int W_, int I_>
 ap_ufixed<W_,I_> generic_divide(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y){
  ap_fixed<W_+1,I_+1> x1 = x;
  ap_fixed<W_+1,I_+1> y1 = y;
  return generic_divide(x1,y1);
 }

 template <int I_>
 ap_int<I_> generic_divide(ap_int<I_> x, ap_int<I_> y){
  ap_fixed<I_,I_> x1 = x;
  ap_fixed<I_,I_> y1 = y;
  return generic_divide(x1,y1);
 }

 template <int I_>
 ap_uint<I_> generic_divide(ap_uint<I_> x, ap_uint<I_> y){
  ap_ufixed<I_,I_> x1 = x;
  ap_ufixed<I_,I_> y1 = y;
  return generic_divide(x1,y1);
 }

 template <int W_, int I_>
 ap_fixed<W_,I_> generic_fmod(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y){
  if((x==y)||(x==-y))
   return 0;
  return (x-ap_int<2*W_+2>(x/y)*y);
 }


 template <int W_, int I_>
 ap_ufixed<W_,I_> generic_fmod(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y){
  if(x==y)
   return 0;
  return (x-ap_uint<2*W_+2>(x/y)*y);
 }

 template <int I_>
 ap_int<I_> generic_fmod(ap_int<I_> x, ap_int<I_> y){
  ap_fixed<I_,I_> x1 = x;
  ap_fixed<I_,I_> y1 = y;
  return generic_fmod(x1,y1);
 }

 template <int I_>
 ap_uint<I_> generic_fmod(ap_uint<I_> x, ap_uint<I_> y){
  ap_ufixed<I_,I_> x1 = x;
  ap_ufixed<I_,I_> y1 = y;
  return generic_fmod(x1,y1);
 }

 template <int W_, int I_>
 ap_fixed<W_,I_> generic_remainder(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y){
  if(y==0){

     printf("ERROR:hls_math.h:divisor cannot be zero");
     exit(1);

  }
  else if((x==y)||(x==-y)||(x==0))
   return 0;
  else{
   ap_fixed<2*W_,2*I_> temp_quotient = x/y;
   ap_fixed<2*(W_-I_)+1,1> temp = 0;

   if(temp_quotient[2*W_-1]==1){
    ap_fixed<2*W_,2*I_> temp_quotient2=-temp_quotient;
    temp=temp_quotient2;
   }
   else {
    temp=temp_quotient;
   }

   if(((temp>0.5)&&(temp_quotient[2*W_-1]==0))||((temp==0.5)&&(temp_quotient[2*W_-1]==0)&&(temp_quotient[2*W_-2*I_]==1))){
    return (x-(ap_int<2*W_+2>(temp_quotient)+ap_int<2>(1))*y);
   }
   else if (((temp>0.5)&&(temp_quotient[2*W_-1]==1))||((temp==0.5)&&(temp_quotient[2*W_-1]==1)&&(temp_quotient[2*W_-2*I_]==1))){
    return (x-(ap_int<2*W_+2>(temp_quotient)-ap_int<2>(1))*y);
   }
   else return (x-ap_int<2*W_+2>(temp_quotient)*y);
  }
 }


 template <int W_, int I_>
 ap_ufixed<W_,I_> generic_remainder(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y){
  if(y==0){

     printf("ERROR:hls_math.h:divisor cannot be zero");
     exit(1);

  }
  else if((x==y)||(x==0))
   return 0;
  else{
   return (x-ap_uint<2*W_+2>(x/y)*y);
  }
 }

 template <int I_>
 ap_int<I_> generic_remainder(ap_int<I_> x, ap_int<I_> y){
  ap_fixed<I_,I_> x1 = x;
  ap_fixed<I_,I_> y1 = y;
  return generic_remainder(x1,y1);
 }

 template <int I_>
 ap_uint<I_> generic_remainder(ap_uint<I_> x, ap_uint<I_> y){
  ap_ufixed<I_,I_> x1 = x;
  ap_ufixed<I_,I_> y1 = y;
  return generic_remainder(x1,y1);
 }

 template <int W_, int I_>
 ap_fixed<W_,I_> generic_remquo(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y, int* quo){
  ap_fixed<W_,I_> x22 = x;
  ap_fixed<W_,I_> y22 = y;
  ap_fixed<W_,I_> z;
  ap_fixed<W_+1,I_+1> x33;
  ap_fixed<W_+1,I_+1> y33;
  ap_int<(I_>(W_-I_))?I_:(W_-I_)> x_exp;
  ap_int<(I_>(W_-I_))?I_:(W_-I_)> y_exp;
  ap_uint<W_-1> x_sig;
  ap_uint<W_-1> y_sig;
  if(y==0){

     printf("ERROR:hls_math.h:divisor cannot be zero");
     exit(1);

  }
  else if(x==0){
   *quo =0;
   return 0;
  }
  else if((x==y)||(x==-y)){
   *quo = (x==y)?1:-1;
   return 0;
  }

  if(x[W_-1]){
   x33=-x;
  }
  else{
   x33=x;
  }
  if(y[W_-1]){
   y33=-y;
  }
  else{
   y33=y;
  }

  ap_uint<9> flag_x = x33.countLeadingZeros();
  ap_uint<9> flag_y = y33.countLeadingZeros();
  if(flag_x==W_){
   x_exp=I_+1-flag_x-1;;
   x_sig=0;
  }else {
   x_exp=I_+1-flag_x-1;
   x_sig=x33(W_+1-flag_x-1-1,0);
  }
  if(flag_y==W_){
   y_exp=I_+1-flag_y-1;;
   y_sig=0;
  }else {
   y_exp=I_+1-flag_y-1;
   y_sig=y33(W_+1-flag_y-1-1,0);
  }

  ap_uint<W_> FF_max = ((ap_uint<W_>(1)<<(W_-1))-1);
  ap_uint<W_-1> FF_M = ((ap_uint<W_>(1)<<(W_-1))-1);
  ap_uint<1> isE_s = y[W_-1]==x[W_-1]?1:0;
  if ((y_exp-x_exp)>1){
   z = x;
   *quo =0;
   return z;
  }else if ((y_exp-x_exp)==1){
   ap_uint<W_> sigx_2;
   sigx_2(W_-1,1) =x_sig(W_-2,0);
   if(x_exp==0){
    if(sigx_2(W_-2,0)<=y_sig){
     z = x;
     *quo =0;
     return z;
    }
   }else if (y_sig>x_sig){
    z = x;
    *quo =0;
    return z;
   }else if (x_sig==y_sig){
    z = x;
    *quo =0;
    return z;
   }
  }else if ((x_exp==y_exp)&&(y_exp==0)){
   ap_uint<W_> sigx_2;
   sigx_2(W_-1,1) =x_sig(W_-2,0);
   if(y_sig>=sigx_2){
    z = x;
    *quo =0;
    return z;
   }
  }

  ap_fixed<W_+2,I_+1> x11 = x;
  ap_fixed<W_+2,I_+1> y11 = y;
  ap_fixed<2*W_+2,W_+1> temp_quotient = x11/y11;
  ap_fixed<W_+2,1> temp = 0;
  ap_fixed<2*W_+2,W_+1> temp_quotient2=-temp_quotient;

  if(temp_quotient[2*W_+1]==1){
   temp(W_,0)=temp_quotient2(W_,0);
  }
  else {
   temp(W_,0)=temp_quotient(W_,0);
  }

  ap_int<2*W_+2> temp_quo;
  if(((temp>0.5)&&(temp_quotient[2*W_+1]==0))||((temp==0.5)&&(temp_quotient[2*W_+1]==0)&&(temp_quotient[W_+1]==1))){
   temp_quo = (ap_int<2*W_+2>(temp_quotient)+ap_int<2>(1));
  }
  else if (((temp>0.5)&&(temp_quotient[2*W_+1]==1))||((temp==0.5)&&(temp_quotient[2*W_+1]==1)&&(temp_quotient2[W_+1]==1))){
   temp_quo = (ap_int<2*W_+2>(temp_quotient)-ap_int<2>(1));
  }
  else{
   temp_quo = (ap_int<2*W_+2>(temp_quotient));
  }

      if((x_exp-y_exp)>=32){
       *quo = 0;
      }
      else{
          ap_int<4> temquo1;
          temquo1(2,0)=temp_quo(2,0);
          temquo1[3]=temp_quotient[2*W_+1];
          if(temquo1==-8) temquo1=0;
          *quo = temquo1;
      }
    return (x-(temp_quo)*y);
 }

 template <int W_, int I_>
 ap_ufixed<W_,I_> generic_remquo(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y, int* quo){
  ap_fixed<W_+1,I_+1> x1 = x;
  ap_fixed<W_+1,I_+1> y1 = y;
  return generic_remquo(x1,y1,quo);
 }

 template <int I_>
 ap_int<I_> generic_remquo(ap_int<I_> x, ap_int<I_> y, int*quo){
  ap_fixed<I_,I_> x1 = x;
  ap_fixed<I_,I_> y1 = y;
  return generic_remquo(x1,y1,quo);
 }

 template <int I_>
 ap_uint<I_> generic_remquo(ap_uint<I_> x, ap_uint<I_> y, int*quo){
  ap_ufixed<I_,I_> x1 = x;
  ap_ufixed<I_,I_> y1 = y;
  return generic_remquo(x1,y1,quo);
 }
}
#1039 "C:/Xilinx/Vivado/2018.3/include/hls_math.h" 2
#1 "C:/Xilinx/Vivado/2018.3/include/hls_lgamma_apfixed.h" 1
#34 "C:/Xilinx/Vivado/2018.3/include/hls_lgamma_apfixed.h"
#1 "C:/Xilinx/Vivado/2018.3/include/ap_int.h" 1
#35 "C:/Xilinx/Vivado/2018.3/include/hls_lgamma_apfixed.h" 2







    double lgamma_neg_apfixed (double x, int *signgamp);

namespace lgamma_fixed{

    template <typename T>
    int generic_isinf(T x) {
      fp_struct<T> fs = x;
      int ret = ((fs.exp == fp_struct<T>::EXP_INFNAN) && (fs.sig == 0x0)) ? 1 : 0;
      return ret;
    }

    template <typename T>
    int generic_isnan(T x) {
      fp_struct<T> fs = x;
      int ret = ((fs.exp == fp_struct<T>::EXP_INFNAN) && (fs.sig != 0x0)) ? 1 : 0;
      return ret;
    }

    template<int W, int I>
    ap_fixed<W,I> lgamma_r_generic (ap_fixed<W,I> x_fixed, int *signgamp)
    {
#pragma HLS pipeline

      double x = x_fixed.to_double();
      fp_struct<double> xs(x);
      fp_struct<double> out;
      fp_struct<double> fp_abs(x);
      fp_abs.sign=0;
      out.sign[0] = 0;
      out.sig = 0;
      out.exp = fp_struct<double>::EXP_INFNAN;



      if ( generic_isinf(x) )
        return ap_fixed<W,I>( out.to_ieee());
      if ( generic_isnan(x) ) {
        out.sig = -1;
        return ap_fixed<W,I>( out.to_ieee());
      }
      if ( xs.exp==0 ) {
        if ( xs.sign[0] )
          *signgamp = -1;
        out.sig = -1;
        return ap_fixed<W,I>( out.to_ieee());
      }
      if ( xs.exp<953 ) {
        if ( xs.sign[0] )
          *signgamp = -1;
        return -log_apfixed_reduce::log<W,I>(ap_fixed<W,I>(fp_abs.to_ieee()));
      }
      double nadj = 0;
      if ( xs.sign[0] ) {
        if ( xs.exp>=1075 ) {
          out.sig = -1;
          return ap_fixed<W,I>( out.to_ieee());
        }
        if ( (xs.exp>1 && xs.exp<4) || (xs.exp==1 && (xs.sig!=0)) || (xs.exp==4 && ~(xs.sig[51] & xs.sig[50])) )
          return ap_fixed<W,I>( lgamma_neg_apfixed(x,signgamp));
        const double pi = 3.14159265358979311600e+00;

        ap_fixed<1 - 1 + 52, 1 - 1> pix=(pi*x);
        ap_fixed<1 - 1 + 52, 2> t_fixed = hotbm_apfixed::sinf_or_cosf<52,0>(pix, 0, 0);
         double t = t_fixed.to_double();
        fp_struct<double> ts(t);
        fp_struct<double> tabs(t);
        if ( ts.exp==0 ) {
          out.sig = -1;
          return ap_fixed<W,I>( out.to_ieee());
        }
        ap_fixed<W,I> nadj_fixed = pi/(tabs.to_ieee()*fp_abs.to_ieee());
        nadj = log_apfixed_reduce::log<W,I>(nadj_fixed);
        if ( ts.sign[0] )
          *signgamp = -1;
        x = -x;
        xs.sign[0] = 0;
      }
      double r;
      if ( (xs.sig==0) && ((xs.exp==1023)||(xs.exp==1024)) ) {
        r = 0;
      } else if ( xs.exp<1024 ) {
        double y,z,p,p1,p2,p3;
        int i;
        const double tc = 1.46163214496836224576e+00;
        const double tc_m1 = 0.46163214496836224576e+00;
        ap_uint<20> x_sig_hi = (xs.sig>>32);
        if ( (xs.exp<1022) || ((xs.exp==1022)&&(x_sig_hi<=838860)) ) {

          r = -log_apfixed_reduce::log<W,I>(x_fixed);
          if ( (xs.exp>1022) || ((xs.exp==1022)&&(x_sig_hi>=485700)) ) {
            y = 1-x;
            i = 0;
          } else if ( (xs.exp>1020) || ((xs.exp==1020)&&(x_sig_hi>=894561)) ) {
            y = x-tc_m1;
            i = 1;
          } else {
            y = x;
            i = 2;
          }
        } else {
          r = 0;
          if ( (xs.exp>1023) || ((xs.exp==1023)&&(x_sig_hi>=767171)) ) {
            y = 2-x;
            i = 0;
          } else if ( (xs.exp>1023) || ((xs.exp==1023)&&(x_sig_hi>=242884)) ) {
            y = x-tc;
            i = 1;
          } else {
            y = x-1;
            i = 2;
          }
        }
        switch(i) {

        case 0:
          {
            const double a0 = 7.72156649015328655494e-02;
            const double a1 = 3.22467033424113591611e-01;
            const double a2 = 6.73523010531292681824e-02;
            const double a3 = 2.05808084325167332806e-02;
            const double a4 = 7.38555086081402883957e-03;
            const double a5 = 2.89051383673415629091e-03;
            const double a6 = 1.19270763183362067845e-03;
            const double a7 = 5.10069792153511336608e-04;
            const double a8 = 2.20862790713908385557e-04;
            const double a9 = 1.08011567247583939954e-04;
            const double a10 = 2.52144565451257326939e-05;
            const double a11 = 4.48640949618915160150e-05;

            z = y*y;
            p1 = a0+z*(a2+z*(a4+z*(a6+z*(a8+z*a10))));
            p2 = z*(a1+z*(a3+z*(a5+z*(a7+z*(a9+z*a11)))));
            p = y*p1+p2;
            r += (p-0.5*y); break;
          }
        case 1:
          {
            const double tf = -1.21486290535849611461e-01;
            const double tt = -3.63867699703950536541e-18;
            const double t0 = 4.83836122723810047042e-01;
            const double t1 = -1.47587722994593911752e-01;
            const double t2 = 6.46249402391333854778e-02;
            const double t3 = -3.27885410759859649565e-02;
            const double t4 = 1.79706750811820387126e-02;
            const double t5 = -1.03142241298341437450e-02;
            const double t6 = 6.10053870246291332635e-03;
            const double t7 = -3.68452016781138256760e-03;
            const double t8 = 2.25964780900612472250e-03;
            const double t9 = -1.40346469989232843813e-03;
            const double t10 = 8.81081882437654011382e-04;
            const double t11 = -5.38595305356740546715e-04;
            const double t12 = 3.15632070903625950361e-04;
            const double t13 = -3.12754168375120860518e-04;
            const double t14 = 3.35529192635519073543e-04;

            z = y*y;
            double w = z*y;
            p1 = t0+w*(t3+w*(t6+w*(t9 +w*t12)));
            p2 = t1+w*(t4+w*(t7+w*(t10+w*t13)));
            p3 = t2+w*(t5+w*(t8+w*(t11+w*t14)));
            p = z*p1-(tt-w*(p2+y*p3));
            r += (tf + p); break;
          }
        case 2:
          {
            const double u0 = -7.72156649015328655494e-02;
            const double u1 = 6.32827064025093366517e-01;
            const double u2 = 1.45492250137234768737e+00;
            const double u3 = 9.77717527963372745603e-01;
            const double u4 = 2.28963728064692451092e-01;
            const double u5 = 1.33810918536787660377e-02;
            const double v1 = 2.45597793713041134822e+00;
            const double v2 = 2.12848976379893395361e+00;
            const double v3 = 7.69285150456672783825e-01;
            const double v4 = 1.04222645593369134254e-01;
            const double v5 = 3.21709242282423911810e-03;

            p1 = y*(u0+y*(u1+y*(u2+y*(u3+y*(u4+y*u5)))));
            p2 = 1+y*(v1+y*(v2+y*(v3+y*(v4+y*v5))));
            r += (-0.5*y + p1/p2);
          }
        }
      }
      else if ( xs.exp<1026 ) {

        const double s0 = -7.72156649015328655494e-02;
        const double s1 = 2.14982415960608852501e-01;
        const double s2 = 3.25778796408930981787e-01;
        const double s3 = 1.46350472652464452805e-01;
        const double s4 = 2.66422703033638609560e-02;
        const double s5 = 1.84028451407337715652e-03;
        const double s6 = 3.19475326584100867617e-05;
        const double r1 = 1.39200533467621045958e+00;
        const double r2 = 7.21935547567138069525e-01;
        const double r3 = 1.71933865632803078993e-01;
        const double r4 = 1.86459191715652901344e-02;
        const double r5 = 7.77942496381893596434e-04;
        const double r6 = 7.32668430744625636189e-06;

        ap_uint<3> i;
        ap_uint<51> x_frac = 0;
        if (~xs.exp[0]) {
          i[2] = 0;
          i[1] = 1;
          i[0] = xs.sig[51];
          x_frac(50,0) = xs.sig(50,0);
        } else {
          i[2] = 1;
          i[1] = xs.sig[51];
          i[0] = xs.sig[50];
          x_frac(50,1) = xs.sig(49,0);
        }
        fp_struct<double> ys(double(0));
#pragma unroll
        for ( ap_uint<6> pos = 50; pos >=0; pos-- ) {
          if ( x_frac[pos] ) {
            ys.exp = pos - 51;
            ys.sig(51,51-pos) = x_frac(pos,0);
            break;
          }
        }
        double y = ys.to_ieee();



        double p = y*(s0+y*(s1+y*(s2+y*(s3+y*(s4+y*(s5+y*s6))))));
        double q = 1+y*(r1+y*(r2+y*(r3+y*(r4+y*(r5+y*r6)))));
        r = 0.5*y+p/q;
        double z = 1;
        switch(i) {
        case 7: z *= (y+6.0);
        case 6: z *= (y+5.0);
        case 5: z *= (y+4.0);
        case 4: z *= (y+3.0);
        case 3: z *= (y+2.0);
          r =r + log_apfixed_reduce::log<W,I>(ap_fixed<W,I>(z)).to_double(); break;
        }

      } else if ( xs.exp<1081 ) {

        const double w0 = 4.18938533204672725052e-01;
        const double w1 = 8.33333333333329678849e-02;
        const double w2 = -2.77777777728775536470e-03;
        const double w3 = 7.93650558643019558500e-04;
        const double w4 = -5.95187557450339963135e-04;
        const double w5 = 8.36339918996282139126e-04;
        const double w6 = -1.63092934096575273989e-03;

        double t = log_apfixed_reduce::log<W,I>(x_fixed);
        double z = 1/x;
        double y = z*z;
        double w = w0+z*(w1+y*(w2+y*(w3+y*(w4+y*(w5+y*w6)))));
        r = (x-0.5)*(t-1)+w;

      } else{
      ap_fixed<W,I> logx = log_apfixed_reduce::log<W,I>(x_fixed);
        r = x*((double)logx-1);
      }
      if ( x<0 )
        r = nadj-r;
      return ap_fixed<W,I>( r);
    }

    template<int W, int I>
    ap_fixed<W,I> lgamma_generic (ap_fixed<W,I> x) {
      int *signgamp = 0;
      return lgamma_r_generic(x,signgamp);
    }

    template<int W, int I>
    ap_ufixed<W,I> lgamma_generic (ap_ufixed<W,I> x) {
      ap_fixed<W+1,I+1> xf = x;
      return lgamma_generic(xf);
    }
    template<int I_>
    ap_int<I_> lgamma_generic(ap_int<I_> x) {
        ap_fixed<I_,I_> xf = x;
        return lgamma_generic(xf);
    }
    template<int I_>
    ap_uint<I_> lgamma_generic(ap_uint<I_> x) {
        ap_fixed<I_+1,I_+1> xf = x;
        return lgamma_generic(xf);
    }

    template<int W, int I>
        ap_ufixed<W,I> lgamma_r_generic (ap_ufixed<W,I> x, int *signgamp) {
       ap_fixed<W+1,I+1> xf = x;
       return lgamma_r_generic(xf, signgamp);
     }
     template<int I_>
     ap_int<I_> lgamma_r_generic(ap_int<I_> x, int *signgamp) {
         ap_fixed<I_,I_> xf = x;
         return lgamma_r_generic(xf, signgamp);
     }
     template<int I_>
     ap_uint<I_> lgamma_r_generic(ap_uint<I_> x, int *signgamp) {
         ap_fixed<I_+1,I_+1> xf = x;
         return lgamma_r_generic(xf, signgamp);
     }
}
#1040 "C:/Xilinx/Vivado/2018.3/include/hls_math.h" 2
#1 "C:/Xilinx/Vivado/2018.3/include/hls_tgamma_apfixed.h" 1
#34 "C:/Xilinx/Vivado/2018.3/include/hls_tgamma_apfixed.h"
#1 "C:/Xilinx/Vivado/2018.3/include/ap_int.h" 1
#35 "C:/Xilinx/Vivado/2018.3/include/hls_tgamma_apfixed.h" 2
#44 "C:/Xilinx/Vivado/2018.3/include/hls_tgamma_apfixed.h"
ap_fixed<20 + 52, 20> gamma_product_fixed (ap_ufixed<4 + 52, 4> x , ap_uint<3> n );

namespace tgamma_fixed {
template <typename T>
int generic_isinf(T x) {
  fp_struct<T> fs = x;
  int ret = ((fs.exp == fp_struct<T>::EXP_INFNAN) && (fs.sig == 0x0)) ? 1 : 0;
  return ret;
}

template <typename T>
int generic_isnan(T x) {
  fp_struct<T> fs = x;
  int ret = ((fs.exp == fp_struct<T>::EXP_INFNAN) && (fs.sig != 0x0)) ? 1 : 0;
  return ret;
}

template<int W, int I>
double gamma_positive_fixed (ap_fixed<W,I> x_fixed, int *exp2_adj)
{
#pragma HLS pipeline

  double x = x_fixed.to_double();
  fp_struct<double> xs(x);
  ap_ufixed<8 + 52, 8> x_fix = 1;
  x_fix(51,0) = xs.sig(51,0);
  ap_uint<3> shl;
  shl(2,0) = xs.exp(2,0);
  shl++;
  x_fix <<= shl;

  if ( xs.exp<126 )
    {
      *exp2_adj = 0;

      ap_fixed<W+1,I+1> x_1 = x_fixed+1;
      double logx1 = exp_reduce::exp(lgamma_fixed::lgamma_generic(x_1));
      return logx1/x;
    }
  else if ( (xs.exp<127)||((xs.exp==127)&&(xs.sig[51]==0)) )
    {
      *exp2_adj = 0;

      return exp_reduce::exp(lgamma_fixed::lgamma_generic(x_fixed));
    }
  else if ( (xs.exp<129)||((xs.exp==129)&&(xs.sig(51,49)<5)) )
    {
      *exp2_adj = 0;
      ap_uint<4> nl;
      nl(3,0) = x_fix(54,51);
      nl -= 3;
      ap_uint<3> n;
      n(2,0) = nl(3,1);
      ap_ufixed<2 + 52, 2> x_adj;
      x_adj(51,0) = x_fix(51,0);
      x_adj[52] = x_fix[51];
      x_adj[53] = ~x_fix[51];



      double prod = gamma_product_fixed(x_adj ,n );

      double rt = exp_reduce::exp(lgamma_fixed::lgamma_generic(x_adj));
      return (rt)*prod ;
    }
  else
    {
      ap_ufixed<8 + 52, 8> x_adj = x_fix;



      double prod = 1;
      if ( (xs.exp<130)||((xs.exp==130)&&(xs.sig(51,50)<3)) )
        {
          ap_uint<4> xi = x_fix(55,52);
          ap_uint<3> n = 11-xi;
          x_adj[52] = 1;
          x_adj[53] = 1;
          x_adj[54] = 0;
          x_adj[55] = 1;
          if (x_fix(51,0)==0) {
            n++;
            x_adj[52] = 0;
            x_adj[53] = 0;
            x_adj[54] = 1;
          }



          prod = gamma_product_fixed(x_fix,n);

        }
      ap_uint<8> x_adj_int;
      x_adj_int(7,0) = x_adj(59,52) + x_adj[51];
      ap_fixed<1 - 1 + 52, 1 - 1> x_adj_frac;
      x_adj_frac(51,0) = x_adj(51,0);



      ap_uint<3> x_adj_log2;
      ap_ufixed<1 + 52, 1> x_adj_mant;
#pragma unroll
      for ( ap_uint<3> pos = 6; pos >= 2; pos-- ) {
        ap_uint<9> x_adj_hi;
        x_adj_hi(8,0) = x_adj(53+pos,45+pos);
        if ( x_adj_hi > 181 ) {
          x_adj_log2 = pos;
          x_adj_mant(52,0) = x_adj(53+pos,1+pos);
        }
      }







      *exp2_adj = x_adj_log2*x_adj_int;
      ap_ufixed<65, 11> x_sq =((ap_fixed<3 + 52, 3>(
#162 "C:/Xilinx/Vivado/2018.3/include/hls_tgamma_apfixed.h" 3
                                                   3.14159265358979323846
#162 "C:/Xilinx/Vivado/2018.3/include/hls_tgamma_apfixed.h"
                                                       )<<1)/x_adj);
      ap_ufixed<8 + 52, 8> x_adjn = -x_adj;

      double ret_1 = ( pow_apfixed_reduce::pow(ap_ufixed<8 + 52, 8>(x_adj_mant),(x_adj))
                          * exp_reduce::exp(ap_ufixed<65,33>(double(x_adj_log2*x_adj_frac)))
                          * exp_reduce::exp((x_adjn))
                          * sqrt_fixed(x_sq)

                          );
      double ret = ret_1 / prod;

      const ap_fixed<1 - 3 + 52, 1 - 3> gamma_coeff[6] = { "0x1.5555555555555p-4", "-0xb.60b60b60b60b8p-12", "0x3.4034034034034p-12",
                                                              "-0x2.7027027027028p-12", "0x3.72a3c5631fe46p-12", "-0x7.daac36664f1f4p-12",
      };
      ap_fixed<1 - 3 + 52, 1 - 3> bsum = gamma_coeff[5];
      ap_fixed<16 + 52, 16> x_adj2 = x_adj*x_adj;
      for ( ap_uint<3> i = 1; i <= 5; i++ )
        bsum = bsum/x_adj2+gamma_coeff[5-i];
      ap_fixed<1 - 3 + 52, 1 - 3> exp_adj = bsum/x_adj;

      double rout = exp_reduce::exp(exp_adj);
      return ret*rout;
    }
}

template<int W, int I>
ap_fixed<W,I> tgamma_generic (ap_fixed<W,I> x_fixed)
{
#pragma HLS pipeline

  double x = x_fixed.to_double();
  fp_struct<double> xs(x);
  fp_struct<double> out;
  out.sign[0] = 0;
  out.sig = 0;
  out.exp = fp_struct<double>::EXP_INFNAN;

  ap_ufixed<1 + 52, 1> x_sig = 1;
  x_sig(51,0) = xs.sig(51,0);
  int x_exp = xs.expv();
  if ( x_exp>0 ) x_sig <<= x_exp;

  if ( (xs.exp==0) || ((xs.sign[0])&(generic_isinf(x))) || (generic_isnan(x)) || ((xs.sign[0]==1)&&(x_exp>=0)&&(x_sig==0)) )
    {
      out.sig = -1;
      return out.to_ieee();
    }
  if ( (generic_isinf(x)) || ((xs.sign[0]==0)&&((xs.exp>7)||((xs.exp==7)&&(xs.sig(51,47)>=11)))) )
    {
      return out.to_ieee();
    }
  else
    {
      double ret;
      double rt;
      if ( ~xs.sign[0] )
        {
          int exp2_adj;
          double tret = gamma_positive_fixed(x_fixed,&exp2_adj);

           rt = exp_reduce::exp(ap_fixed<65,0>(exp2_adj));
          ret = rt*tret;
        }





      else
        {
          fp_struct<double> xs(x);
          ap_ufixed<8 + 52, 8> x_fix = 1;
          x_fix(51,0) = xs.sig(51,0);
          ap_uint<3> shl;
          shl(2,0) = xs.exp(2,0);
          shl++;
          x_fix <<= shl;


          if ( (xs.sign[0]==1)&&((xs.exp>7)||((xs.exp==7)&&(xs.sig(51,48)>=7))) )
            ret = 0;
          else
            {
              ap_ufixed<0 + 52, 0> frac;
              frac(51,0) = x_fix(51,0);

              if ( frac[51] )
                frac = 1-frac;
              ap_fixed<64,32> hot1 = ((ap_fixed<2 + 52, 2>)
#250 "C:/Xilinx/Vivado/2018.3/include/hls_tgamma_apfixed.h" 3
                                                          3.14159265358979323846
#250 "C:/Xilinx/Vivado/2018.3/include/hls_tgamma_apfixed.h"
                                                              *frac);
              ap_fixed<64,32> hot2 = ((ap_fixed<2 + 52, 2>)
#251 "C:/Xilinx/Vivado/2018.3/include/hls_tgamma_apfixed.h" 3
                                                          3.14159265358979323846
#251 "C:/Xilinx/Vivado/2018.3/include/hls_tgamma_apfixed.h"
                                                              *((ap_ufixed<0 + 52, 0>)0.5-frac));
              ap_fixed<64,4> sin1 = hotbm_apfixed::sinf_or_cosf(hot1,0,0);
              ap_fixed<64,4> sin2 = hotbm_apfixed::sinf_or_cosf(hot2,1,0);
              double sinpix = ((~frac[51])&(~frac[50])) ? sin1 : sin2;
              int exp2_adj;
              ap_fixed<W,I> x_fixedn = -x_fixed;
              double tret = 
#257 "C:/Xilinx/Vivado/2018.3/include/hls_tgamma_apfixed.h" 3
                           3.14159265358979323846
#257 "C:/Xilinx/Vivado/2018.3/include/hls_tgamma_apfixed.h"
                               /(-x*sinpix*gamma_positive_fixed(x_fixedn,&exp2_adj));

              rt = exp_reduce::exp(ap_fixed<65,0>(-exp2_adj));
              ret = rt*tret;

            }
        }
      return ap_fixed<W,I>(ret);
    }
}

    template<int W, int I>
    ap_ufixed<W,I> tgamma_generic (ap_ufixed<W,I> x) {
      ap_fixed<W+1,I+1> xf = x;
      return tgamma_generic(xf);
    }
    template<int I_>
    ap_int<I_> tgamma_generic(ap_int<I_> x) {
        ap_fixed<I_,I_> xf = x;
        return tgamma_generic(xf);
    }
    template<int I_>
    ap_uint<I_> tgamma_generic(ap_uint<I_> x) {
        ap_fixed<I_+1,I_+1> xf = x;
        return tgamma_generic(xf);
    }


}
#1041 "C:/Xilinx/Vivado/2018.3/include/hls_math.h" 2
#1 "C:/Xilinx/Vivado/2018.3/include/hls_fma_apfixed.h" 1







namespace hls_fma {

template <int W_, int I_>
ap_fixed<W_,I_> generic_fma(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y, ap_fixed<W_,I_> z){
 ap_fixed<2*W_,2*I_> x1=x;
 ap_fixed<2*W_,2*I_> y1=y;
 return x1*y1+z;
}

template <int W_, int I_>
ap_ufixed<W_,I_> generic_fma(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y, ap_ufixed<W_,I_> z){
 ap_ufixed<2*W_,2*I_> x1=x;
 ap_ufixed<2*W_,2*I_> y1=y;
 return x1*y1+z;
}

template <int I_>
ap_int<I_> generic_fma(ap_int<I_> x, ap_int<I_> y, ap_int<I_> z){
 ap_fixed<I_,I_> x1 = x;
 ap_fixed<I_,I_> y1 = y;
 ap_fixed<I_,I_> z1 = z;
 return generic_fma(x1,y1,z1);
}

template <int I_>
ap_uint<I_> generic_fma(ap_uint<I_> x, ap_uint<I_> y, ap_uint<I_> z){
 ap_ufixed<I_,I_> x1 = x;
 ap_ufixed<I_,I_> y1 = y;
 ap_ufixed<I_,I_> z1 = z;
 return generic_fma(x1,y1,z1);
}
}
#1042 "C:/Xilinx/Vivado/2018.3/include/hls_math.h" 2
#1 "C:/Xilinx/Vivado/2018.3/include/hls_fract_apfixed.h" 1







namespace hls_fract {

template <int W_, int I_>
ap_fixed<W_,I_> generic_fract(ap_fixed<W_,I_> x){
 if (W_==I_)return 0;
 ap_fixed<W_-I_+1,1> x1=x;
 ap_fixed<W_-I_+1,1> x2=x1+ap_int<2>(1);
 return x[W_-1]?x2:x1;
}

template <int W_, int I_>
ap_ufixed<W_,I_> generic_fract(ap_ufixed<W_,I_> x){
 ap_fixed<W_+1,I_+1> x1=x;
 return generic_fract(x1);
}

template <int I_>
ap_int<I_> generic_fract(ap_int<I_> x){
 ap_fixed<I_,I_> x1 = x;
 return generic_fract(x1);
}

template <int I_>
ap_uint<I_> generic_fract(ap_uint<I_> x){
 ap_ufixed<I_,I_> x1 = x;
 return generic_fract(x1);
}
}
#1043 "C:/Xilinx/Vivado/2018.3/include/hls_math.h" 2
#1 "C:/Xilinx/Vivado/2018.3/include/hls_mad_apfixed.h" 1







namespace hls_mad {

template <int W_, int I_>
ap_fixed<W_,I_> generic_mad(ap_fixed<W_,I_> x, ap_fixed<W_,I_> y, ap_fixed<W_,I_> z){
 ap_fixed<2*W_,2*I_> x1=x;
 ap_fixed<2*W_,2*I_> y1=y;
 ap_fixed<2*W_,2*I_> result;
 ap_fixed<2*W_,2*I_> temp=x1<<(-2*W_+2*I_);
 int i=0;
 while(i!=2*W_){
  result += temp*y1[i];
  temp = temp << 1;
  i++;
 }
 result+=z;
 return result;
}

template <int W_, int I_>
ap_ufixed<W_,I_> generic_mad(ap_ufixed<W_,I_> x, ap_ufixed<W_,I_> y, ap_ufixed<W_,I_> z){
 ap_fixed<W_+1,I_+1> x1=x;
 ap_fixed<W_+1,I_+1> y1=y;
 ap_fixed<W_+1,I_+1> z1=z;
 return generic_mad(x1,y1,z1);
}

template <int I_>
ap_int<I_> generic_mad(ap_int<I_> x, ap_int<I_> y, ap_int<I_> z){
 ap_fixed<I_,I_> x1 = x;
 ap_fixed<I_,I_> y1 = y;
 ap_fixed<I_,I_> z1 = z;
 return generic_mad(x1,y1,z1);
}

template <int I_>
ap_uint<I_> generic_mad(ap_uint<I_> x, ap_uint<I_> y, ap_uint<I_> z){
 ap_ufixed<I_,I_> x1 = x;
 ap_ufixed<I_,I_> y1 = y;
 ap_ufixed<I_,I_> z1 = z;
 return generic_mad(x1,y1,z1);
}
}
#1044 "C:/Xilinx/Vivado/2018.3/include/hls_math.h" 2
#1 "C:/Xilinx/Vivado/2018.3/include/hls_cbrt_apfixed.h" 1
#39 "C:/Xilinx/Vivado/2018.3/include/hls_cbrt_apfixed.h"
namespace cbrt_internal{
template <int W, int I>
ap_fixed<W, I> cbrt_fixed(ap_fixed<W,I> x) {






   const int F = W - I;
   if(I > 33) return 0;
   else if(F > 32) return 0;

   ap_fixed<W+1, I+1> xi = x;
   ap_ufixed<W, I> x_p = fabs_fixed(xi);





   ap_ufixed<F +(I+2)/3, (I+2)/3> r = 0;;
      const static int prcs = (F+1)*3;
      const static int msbr = (I>0)? (I+2)/3 : 1;
      ap_ufixed<2*msbr+prcs+2,2*msbr+2> resq = 0;
      ap_ufixed<msbr+prcs+1, msbr+1> res = 0;
      ap_ufixed<3*msbr+prcs+4, 3*msbr+4> x_rem = x_p;
      for(int pos = msbr - 1 ; pos >= -F-1; pos--) {
          ap_ufixed<3*msbr+prcs+2, 3*msbr+2> mul1a = 0;
          ap_ufixed<3*msbr+prcs+1, 3*msbr+1> mul1b = 0;


#69 "C:/Xilinx/Vivado/2018.3/include/hls_cbrt_apfixed.h" 3
         (void) ((!!(
#69 "C:/Xilinx/Vivado/2018.3/include/hls_cbrt_apfixed.h"
         resq(prcs+2*pos+1,0)==0
#69 "C:/Xilinx/Vivado/2018.3/include/hls_cbrt_apfixed.h" 3
         )) || (_assert(
#69 "C:/Xilinx/Vivado/2018.3/include/hls_cbrt_apfixed.h"
         "resq(prcs+2*pos+1,0)==0"
#69 "C:/Xilinx/Vivado/2018.3/include/hls_cbrt_apfixed.h" 3
         ,"C:/Xilinx/Vivado/2018.3/include/hls_cbrt_apfixed.h",69),0))
#69 "C:/Xilinx/Vivado/2018.3/include/hls_cbrt_apfixed.h"
                                        ;


          mul1a(pos+2*msbr+prcs+2, prcs+3*pos+3) = resq(prcs+2*msbr+1, prcs+2*pos+2);

          mul1b(pos+2*msbr+prcs+1, prcs+3*pos+2) = resq(prcs+2*msbr+1, prcs+2*pos+2);


#76 "C:/Xilinx/Vivado/2018.3/include/hls_cbrt_apfixed.h" 3
         (void) ((!!(
#76 "C:/Xilinx/Vivado/2018.3/include/hls_cbrt_apfixed.h"
         res(prcs+pos,0)==0
#76 "C:/Xilinx/Vivado/2018.3/include/hls_cbrt_apfixed.h" 3
         )) || (_assert(
#76 "C:/Xilinx/Vivado/2018.3/include/hls_cbrt_apfixed.h"
         "res(prcs+pos,0)==0"
#76 "C:/Xilinx/Vivado/2018.3/include/hls_cbrt_apfixed.h" 3
         ,"C:/Xilinx/Vivado/2018.3/include/hls_cbrt_apfixed.h",76),0))
#76 "C:/Xilinx/Vivado/2018.3/include/hls_cbrt_apfixed.h"
                                   ;

          ap_ufixed<3*msbr+prcs, 3*msbr> mul2a = 0;
          ap_ufixed<3*msbr+prcs-1, 3*msbr-1> mul2b = 0;

          mul2a(pos*2+msbr+prcs+1, pos*3+2+prcs) = res(msbr+prcs, pos+1+prcs);

          mul2b(pos*2+msbr+prcs, pos*3+1+prcs) = res(msbr+prcs, pos+1+prcs);

          ap_ufixed<3*msbr+prcs+3, 3*msbr+3> mulL = 0;
          ap_ufixed<3*msbr+prcs+3, 3*msbr+3> mulH = 0;


          mulL(pos*2+msbr+prcs+3, pos*3+1+prcs) = mul2b(pos*2+msbr+prcs, pos*3+1+prcs) + mul2a(pos*2+msbr+prcs+1, pos*3+1+prcs) + mul1a(pos*2+msbr+prcs+1, pos*3+1+prcs) + mul1b(pos*2+msbr+prcs+1,pos*3+1+prcs);

          mulH(pos+2*msbr+prcs+3, pos*2+msbr+prcs+2) = mulL(pos*2+msbr+prcs+3, pos*2+msbr+prcs+2) + mul1a(pos+2*msbr+prcs+2,pos*2+msbr+prcs+2) + mul1b(pos+2*msbr+prcs+1,pos*2+msbr+prcs+2);
          mulL[3*pos+prcs] = 1;







          bool cond1 = (x_rem(pos+2*msbr+prcs+4,pos*2+msbr+prcs+2) > mulH(pos+2*msbr+prcs+3,pos*2+msbr+prcs+2));
          bool cond2 = (x_rem(pos+2*msbr+prcs+4,pos*2+msbr+prcs+2) == mulH(pos+2*msbr+prcs+3,pos*2+msbr+prcs+2));
          bool cond3 = (x_rem(pos*2+msbr+prcs+1,pos*3+prcs) >= mulL(pos*2+msbr+prcs+1,pos*3+prcs));
          if(cond1 | (cond2 & cond3)) {
             ap_ufixed<3*msbr+prcs+3,3*msbr+3> x_rem_L = 0;
             x_rem_L(pos*2+msbr+prcs+1, pos*3+prcs) = x_rem(pos*2+msbr+prcs+1, pos*3+prcs);

             x_rem_L[pos*2+msbr+prcs+2] = cond3? 0 : 1;
             x_rem(pos+2*msbr+prcs+4,pos*2+msbr+prcs+2) = x_rem(pos+2*msbr+prcs+4, pos*2+msbr+prcs+2) - mulH(pos+2*msbr+prcs+3,pos*2+msbr+prcs+2) - x_rem_L(pos*2+msbr+prcs+2,pos*2+msbr+prcs+2);
             x_rem(pos*2+msbr+prcs+1,pos*3+prcs) = x_rem_L(pos*2+msbr+prcs+2, pos*3+prcs) - mulL(pos*2+msbr+prcs+1,pos*3+prcs);



#112 "C:/Xilinx/Vivado/2018.3/include/hls_cbrt_apfixed.h" 3
            (void) ((!!(
#112 "C:/Xilinx/Vivado/2018.3/include/hls_cbrt_apfixed.h"
            res(pos+prcs,0)==0
#112 "C:/Xilinx/Vivado/2018.3/include/hls_cbrt_apfixed.h" 3
            )) || (_assert(
#112 "C:/Xilinx/Vivado/2018.3/include/hls_cbrt_apfixed.h"
            "res(pos+prcs,0)==0"
#112 "C:/Xilinx/Vivado/2018.3/include/hls_cbrt_apfixed.h" 3
            ,"C:/Xilinx/Vivado/2018.3/include/hls_cbrt_apfixed.h",112),0))
#112 "C:/Xilinx/Vivado/2018.3/include/hls_cbrt_apfixed.h"
                                      ;

#113 "C:/Xilinx/Vivado/2018.3/include/hls_cbrt_apfixed.h" 3
            (void) ((!!(
#113 "C:/Xilinx/Vivado/2018.3/include/hls_cbrt_apfixed.h"
            resq(pos*2+1+prcs,0)==0
#113 "C:/Xilinx/Vivado/2018.3/include/hls_cbrt_apfixed.h" 3
            )) || (_assert(
#113 "C:/Xilinx/Vivado/2018.3/include/hls_cbrt_apfixed.h"
            "resq(pos*2+1+prcs,0)==0"
#113 "C:/Xilinx/Vivado/2018.3/include/hls_cbrt_apfixed.h" 3
            ,"C:/Xilinx/Vivado/2018.3/include/hls_cbrt_apfixed.h",113),0))
#113 "C:/Xilinx/Vivado/2018.3/include/hls_cbrt_apfixed.h"
                                           ;

             ap_ufixed<2*msbr+prcs+1,2*msbr+1> mul1 = 0;
             mul1(pos+msbr+prcs+1, 2*pos+2+prcs) = res(msbr+prcs, pos+1+prcs);
             ap_ufixed<2*msbr+prcs+2,2*msbr+2> resq_L = 0;
             resq_L(pos+msbr+prcs+2,2*pos+2+prcs) = resq(pos+msbr+prcs+1,2*pos+2+prcs) + mul1(pos+msbr+prcs+1,2*pos+2+prcs);
             resq(pos+msbr+prcs+1,2*pos+2+prcs) = resq_L(pos+msbr+prcs+1,2*pos+2+prcs);
             resq(2*msbr+prcs+1,pos+msbr+2+prcs) = resq(2*msbr+prcs+1,pos+msbr+2+prcs) + resq_L(pos+msbr+2+prcs,pos+msbr+2+prcs);
             resq[2*pos+prcs] = 1;
             res[pos+prcs] = 1;
         }
#132 "C:/Xilinx/Vivado/2018.3/include/hls_cbrt_apfixed.h"
      }





      ap_ufixed<1,-F-1> delta;
      delta[0] = 1;
      ap_ufixed<msbr+F+1,msbr> res_s = res;
      res_s += delta;
      r = res_s;
      if(x[W-1]) return -r;
      else return r;
}

template<int W, int I>
ap_ufixed<W, I> cbrt_fixed(ap_ufixed<W, I> x) {
   ap_fixed<W+1,I+1> xi = x;
   return cbrt_fixed(xi);
}
template<int I>
ap_int<I> cbrt_fixed(ap_int<I> x) {
   ap_fixed<I,I> xi = x;
   return cbrt_fixed(xi);
}
template<int I>
ap_uint<I> cbrt_fixed(ap_uint<I> x) {
   ap_fixed<I+1,I+1> xi = x;
   return cbrt_fixed(xi);
}
}
#1045 "C:/Xilinx/Vivado/2018.3/include/hls_math.h" 2
#1 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h" 1
#38 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h"
#1 "C:/Xilinx/Vivado/2018.3/include/ap_int.h" 1
#39 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h" 2

namespace hypot_internal {
template<int W, int I>
ap_fixed<W, I> hypot_fixed(ap_fixed<W, I> x, ap_fixed<W, I> y) {
    const static int F = W - I;
    if(I > 33) return 0;
    else if(F > 32) return 0;
#54 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h"
    if(x==0) return fabs_fixed(y);
    if(y==0) return fabs_fixed(x);

    ap_ufixed<2*W, I*2> x_sq = x * x;
    ap_ufixed<2*W, I*2> y_sq = y * y;
    ap_ufixed<2*W, I*2> xy_sq = x_sq + y_sq;
#68 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h"
    const static int prcs = (F+1)*2;
    const static int msbr = I > 0? I : 1;
    ap_ufixed<msbr, msbr> res_I = 0;
    ap_ufixed<2*msbr+1,2*msbr+1> x_l_I = 0;
    if(I>0) {
        x_l_I = xy_sq(2*W-1, 2*W-2*I);
        for(int pos = msbr - 1; pos >= 0; pos--) {
            ap_ufixed<2*msbr,2*msbr> mul_I = 0;


#77 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h" 3
           (void) ((!!(
#77 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h"
           res_I(pos, 0)==0
#77 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h" 3
           )) || (_assert(
#77 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h"
           "res_I(pos, 0)==0"
#77 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h" 3
           ,"C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h",77),0))
#77 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h"
                                   ;

            mul_I(msbr+pos, 2*pos+1) = res_I(msbr-1, pos);
            mul_I[2*pos] = 1;
            if(x_l_I(msbr+pos+1, 2*pos) >= mul_I(msbr+pos, 2*pos)){


#83 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h" 3
               (void) ((!!(
#83 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h"
               x_l_I >= mul_I
#83 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h" 3
               )) || (_assert(
#83 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h"
               "x_l_I >= mul_I"
#83 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h" 3
               ,"C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h",83),0))
#83 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h"
                                     ;

                ap_ufixed<2*msbr+1, 2*msbr+1> x_l_I_ = x_l_I;
                x_l_I(msbr+pos+1, 2*pos) = x_l_I(msbr+pos+1,2*pos) - mul_I(msbr+pos, 2*pos);


#88 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h" 3
               (void) ((!!(
#88 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h"
               x_l_I == x_l_I_ - mul_I
#88 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h" 3
               )) || (_assert(
#88 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h"
               "x_l_I == x_l_I_ - mul_I"
#88 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h" 3
               ,"C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h",88),0))
#88 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h"
                                              ;

                res_I[pos] = 1;
           }
       }
    }
    ap_ufixed<msbr+1, msbr+1> x_l_I_s = x_l_I;


#96 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h" 3
   (void) ((!!(
#96 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h"
   x_l_I_s == x_l_I
#96 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h" 3
   )) || (_assert(
#96 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h"
   "x_l_I_s == x_l_I"
#96 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h" 3
   ,"C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h",96),0))
#96 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h"
                           ;






    ap_ufixed<prcs/2,0> res_F = 0;
    ap_ufixed<prcs/2,0> x_l_FH = xy_sq;
    ap_ufixed<prcs/2, -prcs/2> x_l_FL = xy_sq;
    for(int pos = -1; pos >= -F-1; pos--) {
        ap_ufixed<msbr+prcs, msbr> mul = 0;


#109 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h" 3
       (void) ((!!(
#109 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h"
       res_F(pos+prcs/2,0)==0
#109 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h" 3
       )) || (_assert(
#109 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h"
       "res_F(pos+prcs/2,0)==0"
#109 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h" 3
       ,"C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h",109),0))
#109 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h"
                                     ;

        mul(msbr+pos+prcs, pos+1+prcs) = res_I(msbr-1, 0);
        mul(pos+prcs, 2*pos+1+prcs) = res_F(prcs/2-1,pos+prcs/2);
        mul[2*pos+prcs] = 1;

        ap_ufixed<msbr, msbr> mul_I = 0;
        mul_I = mul;
        ap_ufixed<prcs/2, 0> mul_FH = mul;
        ap_ufixed<prcs/2, -prcs/2> mul_FL = mul;
#133 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h"
        ap_ufixed<msbr+prcs+1, msbr+1> x_l_1 = 0;
        x_l_1(prcs+msbr, prcs) = x_l_I_s (msbr, 0);
        x_l_1(prcs-1, prcs/2) = x_l_FH(prcs/2-1, 0);
        x_l_1(prcs/2-1, 0 ) = x_l_FL(prcs/2-1, 0);

        if((x_l_I_s > mul_I) || ((x_l_I_s == mul_I) && (x_l_FH > mul_FH)) || ((x_l_I_s == mul_I) && (x_l_FH == mul_FH) && (x_l_FL >= mul_FL))) {






#144 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h" 3
          (void) ((!!(
#144 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h"
          x_l_1 >= mul
#144 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h" 3
          )) || (_assert(
#144 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h"
          "x_l_1 >= mul"
#144 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h" 3
          ,"C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h",144),0))
#144 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h"
                              ;

           ap_ufixed<prcs/2+1, -prcs/2+1> x_l_FL_1 = x_l_FL;

           if(x_l_FL < mul_FL) x_l_FL_1[prcs/2] = 1;
           x_l_FL_1 -= mul_FL;


#151 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h" 3
          (void) ((!!(
#151 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h"
          !x_l_FL_1[prcs/2]
#151 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h" 3
          )) || (_assert(
#151 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h"
          "!x_l_FL_1[prcs/2]"
#151 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h" 3
          ,"C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h",151),0))
#151 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h"
                                   ;

           ap_ufixed<prcs/2+1,1> x_l_FH_1 = x_l_FH;

           if((x_l_FH < mul_FH) || ((x_l_FH == mul_FH) && (x_l_FL < mul_FL))) x_l_FH_1[prcs/2] = 1;
           ap_ufixed<1, -prcs/2+1> delta = 0;
           if(x_l_FL < mul_FL) delta[0] = 1;

           x_l_FH_1 -= delta;
           x_l_FH_1 -= mul_FH;

           if((x_l_FH < mul_FH) || ((x_l_FH == mul_FH) && (x_l_FL < mul_FL))) x_l_I_s--;
           x_l_I_s -= mul_I;
           x_l_FH = x_l_FH_1;
           x_l_FL = x_l_FL_1;

           ap_ufixed<msbr+prcs+1, msbr+1> x_l_2 = 0;
           x_l_2(msbr+prcs, prcs) = x_l_I_s(msbr, 0);
           x_l_2(prcs-1, prcs/2)= x_l_FH(prcs/2-1, 0);
           x_l_2(prcs/2-1, 0) = x_l_FL(prcs/2-1, 0);

#171 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h" 3
          (void) ((!!(
#171 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h"
          x_l_2 == x_l_1 - mul
#171 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h" 3
          )) || (_assert(
#171 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h"
          "x_l_2 == x_l_1 - mul"
#171 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h" 3
          ,"C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h",171),0))
#171 "C:/Xilinx/Vivado/2018.3/include/hls_hypot_apfixed.h"
                                      ;

           res_F[pos+prcs/2] = 1;
       }
    }
    ap_ufixed<prcs/2+1, 1> res_F_1 = res_F;

    ap_ufixed<1, -prcs/2+1> delta = 0;
    delta[0] = 1;
    res_F_1 += delta;
    if(res_F_1[prcs/2]) res_I++;
    ap_ufixed<msbr+prcs/2, msbr> res = 0;
    res(msbr+prcs/2-1, prcs/2) = res_I(msbr-1,0);
    res(prcs/2-1, 0) = res_F(prcs/2-1, 0);






    ap_fixed<W,I> r = 0;
    if(res[msbr+prcs/2-1]) {

       for(int i = 0; i < W - 1; ++i) {
#pragma HLS unroll
            r[i] = 1;
       }
    } else {
       r = res;
    }





    return r;
}
template<int W, int I>
ap_ufixed<W, I> hypot_fixed(ap_ufixed<W, I> x, ap_fixed<W, I> y) {
   ap_fixed<W+1, I+1> xi = x;
   ap_fixed<W+1, I+1> yi = y;
   return hypot_fixed(xi, yi);
}
template<int I>
ap_int<I> hypot_fixed(ap_int<I> x, ap_int<I> y) {
   ap_fixed<I, I> xi = x;
   ap_fixed<I, I> yi = y;
   return hypot_fixed(xi, yi);
}
template<int I>
ap_uint<I> hypot_fixed(ap_uint<I> x, ap_uint<I> y) {
   ap_fixed<I+1, I+1> xi = x;
   ap_fixed<I+1, I+1> yi = y;
   return hypot_fixed(xi, yi);
}
}
#1046 "C:/Xilinx/Vivado/2018.3/include/hls_math.h" 2
namespace hls {
#1069 "C:/Xilinx/Vivado/2018.3/include/hls_math.h"
  template<int W, int I>
  ap_fixed<W, 2> sinpi(ap_fixed<W,I> x){
    return hotbm_apfixed::sinf_or_cosf<W,I>(x, 0, 1);
  }




  template<int W, int I>
  ap_ufixed<W, 2> sinpi(ap_ufixed<W,I> x){
      ap_fixed<W+1, I+1> xin = x;
      ap_fixed<W+1, 3> xout = hls::sinpi<W+1, I+1>(x);
   ap_ufixed<W, 2> out = 0;
   if(xout[W]==0){
    out = xout;
   }
   return out;
  }

  template<int W, int I>
  ap_fixed<W, 2> cospi(ap_fixed<W,I> x){
    return hotbm_apfixed::sinf_or_cosf<W,I>(x, 1, 1);
  }
  template<int W, int I>
  ap_ufixed<W, 2> cospi(ap_ufixed<W,I> x){
   ap_fixed<W+1, I+1> xin = x;
   ap_fixed<W+1, 3> xout = hls::cospi<W+1, I+1>(x);
   ap_ufixed<W, 2> out = 0;
   if(xout[W]==0){
    out = xout;
   }
   return out;
  }





  template<int I>
  ap_int<I> sinpi(ap_int<I> in){
 return ap_int<I>(0);
  }

  template<int I>
  ap_int<I> cospi(ap_int<I> in){
 return ap_int<I>(0);
  }

  template<int I>
  ap_uint<I> sinpi(ap_uint<I> in){
 return ap_uint<I>(0);
  }

  template<int I>
  ap_uint<I> cospi(ap_uint<I> in){
 return ap_uint<I>(0);
  }
  int8_t sinpi(int8_t);
  uint8_t sinpi(uint8_t);
  int16_t sinpi(int16_t);
  uint16_t sinpi(uint16_t);
  int32_t sinpi(int32_t);
  uint32_t sinpi(uint32_t);

  int8_t cospi(int8_t);
  uint8_t cospi(uint8_t);
  int16_t cospi(int16_t);
  uint16_t cospi(uint16_t);
  int32_t cospi(int32_t);
  uint32_t cospi(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> exp(ap_fixed<W,I> x){
    return exp_reduce::exp(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> exp(ap_ufixed<W,I> x){
    return exp_reduce::exp(x);
  }
  template<int I>
  ap_int<I> exp(ap_int<I> x){
    return exp_reduce::exp(x);
  }
  template<int I>
  ap_uint<I> exp(ap_uint<I> x){
    return exp_reduce::exp(x);
  }


  template<int W, int I>
  ap_fixed<W,I> log(ap_fixed<W,I> x){
    return log_apfixed_reduce::log(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> log(ap_ufixed<W,I> x){
    return log_apfixed_reduce::log(x);
  }
  template<int I>
  ap_int<I> log(ap_int<I> x){
    return log_apfixed_reduce::log(x);
  }
  template<int I>
  ap_uint<I> log(ap_uint<I> x){
    return log_apfixed_reduce::log(x);
  }


  template<int W, int I>
  ap_fixed<W,I> log10(ap_fixed<W,I> x){
    return log_apfixed_reduce::log10(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> log10(ap_ufixed<W,I> x){
    return log_apfixed_reduce::log10(x);
  }
  template<int I>
  ap_int<I> log10(ap_int<I> x){
    return log_apfixed_reduce::log10(x);
  }
  template<int I>
  ap_uint<I> log10(ap_uint<I> x){
 return log_apfixed_reduce::log10(x);
  }



  template<int W, int I>
  ap_fixed<W,I> sqrt(ap_fixed<W,I> x){
    return sqrt_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> sqrt(ap_ufixed<W,I> x){
    return sqrt_fixed(x);
  }
  template<int I>
  ap_int<I> sqrt(ap_int<I> x){
    return sqrt_fixed(x);
  }
  template<int I>
  ap_uint<I> sqrt(ap_uint<I> x){
    return sqrt_fixed(x);
  }


  template<int W, int I>
  ap_fixed<W,I> rsqrt(ap_fixed<W,I> x){
    return rsqrt_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> rsqrt(ap_ufixed<W,I> x){
    return rsqrt_fixed(x);
  }
  template<int I>
  ap_int<I> rsqrt(ap_int<I> x){
    return rsqrt_fixed(x);
  }
  template<int I>
  ap_uint<I> rsqrt(ap_uint<I> x){
    return rsqrt_fixed(x);
  }


  template<int W, int I>
  ap_fixed<W,I> recip(ap_fixed<W,I> x){
    return recip_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> recip(ap_ufixed<W,I> x){
    return recip_fixed(x);
  }
  template<int I>
  ap_int<I> recip(ap_int<I> x){
    return recip_fixed(x);
  }
  template<int I>
  ap_uint<I> recip(ap_uint<I> x){
    return recip_fixed(x);
  }


  template<int W, int I>
  ap_fixed<W,I> ceil(ap_fixed<W,I> x){
    return ceil_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> ceil(ap_ufixed<W,I> x){
    return ceil_fixed(x);
  }
  template<int I>
  ap_int<I> ceil(ap_int<I> x){
    return ceil_fixed(x);
  }
  template<int I>
  ap_uint<I> ceil(ap_uint<I> x){
    return ceil_fixed(x);
  }


  template<int W, int I>
  ap_fixed<W,I> floor(ap_fixed<W,I> x){
    return floor_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> floor(ap_ufixed<W,I> x){
    return floor_fixed(x);
  }
  template<int I>
  ap_int<I> floor(ap_int<I> x){
    return floor_fixed(x);
  }
  template<int I>
  ap_uint<I> floor(ap_uint<I> x){
    return floor_fixed(x);
  }

  template<int W, int I>
  ap_fixed<W,I> trunc(ap_fixed<W,I> x){
    return trunc_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> trunc(ap_ufixed<W,I> x){
    return trunc_fixed(x);
  }
  template<int I>
  ap_int<I> trunc(ap_int<I> x){
    return trunc_fixed(x);
  }
  template<int I>
  ap_uint<I> trunc(ap_uint<I> x){
    return trunc_fixed(x);
  }


  template<int W, int I>
  ap_fixed<W,I> copysign(ap_fixed<W,I> x, ap_fixed<W,I> y){
    return copysign_fixed(x,y);
  }
  template<int W, int I>
  ap_ufixed<W,I> copysign(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return copysign_fixed(x,y);
  }
  template<int I>
  ap_int<I> copysign(ap_int<I> x, ap_int<I> y){
    return copysign_fixed(x,y);
  }
  template<int I>
  ap_uint<I> copysign(ap_uint<I> x, ap_uint<I> y){
    return copysign_fixed(x,y);
  }


  template<int W, int I>
  ap_fixed<W,I> fabs(ap_fixed<W,I> x){
    return fabs_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> fabs(ap_ufixed<W,I> x){
    return fabs_fixed(x);
  }
  template<int I>
  ap_int<I> fabs(ap_int<I> x){
    return fabs_fixed(x);
  }
  template<int I>
  ap_uint<I> fabs(ap_uint<I> x){
    return fabs_fixed(x);
  }

  template<int W, int I>
  ap_fixed<W,I> abs(ap_fixed<W,I> x){
    return fabs_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> abs(ap_ufixed<W,I> x){
    return fabs_fixed(x);
  }
  template<int I>
  ap_int<I> abs(ap_int<I> x){
    return fabs_fixed(x);
  }
  template<int I>
  ap_uint<I> abs(ap_uint<I> x){
    return fabs_fixed(x);
  }


  template<int W, int I>
  ap_fixed<W,I> fdim(ap_fixed<W,I> x, ap_fixed<W,I> y){
    return fdim_fixed(x,y);
  }
  template<int W, int I>
  ap_ufixed<W,I> fdim(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return fdim_fixed(x,y);
  }
  template<int I>
  ap_int<I> fdim(ap_int<I> x, ap_int<I> y){
    return fdim_fixed(x,y);
  }
  template<int I>
  ap_uint<I> fdim(ap_uint<I> x, ap_uint<I> y){
    return fdim_fixed(x,y);
  }

  template<int W, int I>
  ap_fixed<W,I> fmax(ap_fixed<W,I> x, ap_fixed<W,I> y){
    return fmax_fixed(x,y);
  }
  template<int W, int I>
  ap_ufixed<W,I> fmax(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return fmax_fixed(x,y);
  }
  template<int I>
  ap_int<I> fmax(ap_int<I> x, ap_int<I> y){
    return fmax_fixed(x,y);
  }
  template<int I>
  ap_uint<I> fmax(ap_uint<I> x, ap_uint<I> y){
    return fmax_fixed(x,y);
  }

  template<int W, int I>
  ap_fixed<W,I> fmin(ap_fixed<W,I> x, ap_fixed<W,I> y){
    return fmin_fixed(x,y);
  }
  template<int W, int I>
  ap_ufixed<W,I> fmin(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return fmin_fixed(x,y);
  }
  template<int I>
  ap_int<I> fmin(ap_int<I> x, ap_int<I> y){
    return fmin_fixed(x,y);
  }
  template<int I>
  ap_uint<I> fmin(ap_uint<I> x, ap_uint<I> y){
    return fmin_fixed(x,y);
  }

  template<int W, int I>
  ap_fixed<W,I> maxmag(ap_fixed<W,I> x, ap_fixed<W,I> y){
    return maxmag_fixed(x,y);
  }
  template<int W, int I>
  ap_ufixed<W,I> maxmag(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return maxmag_fixed(x,y);
  }
  template<int I>
  ap_int<I> maxmag(ap_int<I> x, ap_int<I> y){
    return maxmag_fixed(x,y);
  }
  template<int I>
  ap_uint<I> maxmag(ap_uint<I> x, ap_uint<I> y){
    return maxmag_fixed(x,y);
  }

  template<int W, int I>
  ap_fixed<W,I> minmag(ap_fixed<W,I> x, ap_fixed<W,I> y){
    return minmag_fixed(x,y);
  }
  template<int W, int I>
  ap_ufixed<W,I> minmag(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return minmag_fixed(x,y);
  }
  template<int I>
  ap_int<I> minmag(ap_int<I> x, ap_int<I> y){
    return minmag_fixed(x,y);
  }
  template<int I>
  ap_uint<I> minmag(ap_uint<I> x, ap_uint<I> y){
    return minmag_fixed(x,y);
  }



  template<int W, int I>
  ap_fixed<W,I> sinh(ap_fixed<W,I> x){
 return cordic_apfixed::generic_sinh(x);
  }


  template<int W, int I>
  ap_ufixed<W,I> sinh(ap_ufixed<W,I> x){
 return cordic_apfixed::generic_sinh(x);
  }


  template<int I>
  ap_int<I> sinh(ap_int<I> x){
 return cordic_apfixed::generic_sinh(x);
  }


  template<int I>
  ap_uint<I> sinh(ap_uint<I> x){
 return cordic_apfixed::generic_sinh(x);
  }


  template<int W, int I>
  ap_fixed<W,I> cosh(ap_fixed<W,I> x){
 return cordic_apfixed::generic_cosh(x);
  }


  template<int W, int I>
  ap_ufixed<W,I> cosh(ap_ufixed<W,I> x){
 return cordic_apfixed::generic_cosh(x);
  }


  template<int I>
  ap_int<I> cosh(ap_int<I> x){
 return cordic_apfixed::generic_cosh(x);
  }


  template<int I>
  ap_uint<I> cosh(ap_uint<I> x){
 return cordic_apfixed::generic_cosh(x);
  }


  template<int W, int I>
  ap_fixed<W,I> tanh(ap_fixed<W,I> x){
    return cordic_apfixed::generic_tanh(x);
  }


  template<int W, int I>
  ap_ufixed<W,I> tanh(ap_ufixed<W,I> x){
    return cordic_apfixed::generic_tanh(x);
  }


  template<int I>
  ap_int<I> tanh(ap_int<I> x){
    return cordic_apfixed::generic_tanh(x);
  }


  template<int I>
  ap_uint<I> tanh(ap_uint<I> x){
    return cordic_apfixed::generic_tanh(x);
  }


  template<int W, int I>
  ap_fixed<W,I> atanh(ap_fixed<W,I> x){
    ap_fixed<W,I> one_plus_x = 1 + x;
    ap_fixed<W,I> one_minus_x = 1 - x;
    ap_fixed<W,I> input = one_plus_x / one_minus_x ;
    ap_fixed<W,I> result = log_apfixed_reduce::log(input);
    result >>= 1;
    return result;
  }


  template<int W, int I>
  ap_ufixed<W,I> atanh(ap_ufixed<W,I> x){
  ap_fixed<W+1,I+1> input = x;
    ap_fixed<W+1,I+1> result = hls::atanh(input);
    return result;
  }


  template<int I>
  ap_int<I> atanh(ap_int<I> x){
    ap_fixed<I,I> input = x;
    ap_fixed<I,I> result = hls::atanh(input);
    return result;
  }


  template<int I>
  ap_uint<I> atanh(ap_uint<I> x){
    ap_fixed<I+1,I+1> input = x;
    ap_fixed<I+1,I+1> result = hls::atanh(input);
    return result;
  }


  template<int W, int I>
  ap_fixed<W,I> asinh(ap_fixed<W,I> x){
    return cordic_apfixed::generic_asinh(x);
  }


  template<int W, int I>
  ap_ufixed<W,I> asinh(ap_ufixed<W,I> x){
    return cordic_apfixed::generic_asinh(x);
  }


  template<int I>
  ap_int<I> asinh(ap_int<I> x){
    return cordic_apfixed::generic_asinh(x);
  }


  template<int I>
  ap_uint<I> asinh(ap_uint<I> x){
    return cordic_apfixed::generic_asinh(x);
  }


  template<int W, int I>
  ap_fixed<W,I> acosh(ap_fixed<W,I> x){
    return cordic_apfixed::generic_acosh(x);
  }


  template<int W, int I>
  ap_ufixed<W,I> acosh(ap_ufixed<W,I> x){
    return cordic_apfixed::generic_acosh(x);
  }


  template<int I>
  ap_int<I> acosh(ap_int<I> x){
    return cordic_apfixed::generic_acosh(x);
  }


  template<int I>
  ap_uint<I> acosh(ap_uint<I> x){
    return cordic_apfixed::generic_acosh(x);
  }

  int8_t sinh(int8_t);
  uint8_t sinh(uint8_t);
  int16_t sinh(int16_t);
  uint16_t sinh(uint16_t);
  int32_t sinh(int32_t);
  uint32_t sinh(uint32_t);

  int8_t cosh(int8_t);
  uint8_t cosh(uint8_t);
  int16_t cosh(int16_t);
  uint16_t cosh(uint16_t);
  int32_t cosh(int32_t);
  uint32_t cosh(uint32_t);

  int8_t tanh(int8_t);
  uint8_t tanh(uint8_t);
  int16_t tanh(int16_t);
  uint16_t tanh(uint16_t);
  int32_t tanh(int32_t);
  uint32_t tanh(uint32_t);

  int8_t atanh(int8_t);
  uint8_t atanh(uint8_t);
  int16_t atanh(int16_t);
  uint16_t atanh(uint16_t);
  int32_t atanh(int32_t);
  uint32_t atanh(uint32_t);

  int8_t asinh(int8_t);
  uint8_t asinh(uint8_t);
  int16_t asinh(int16_t);
  uint16_t asinh(uint16_t);
  int32_t asinh(int32_t);
  uint32_t asinh(uint32_t);

  int8_t acosh(int8_t);
  uint8_t acosh(uint8_t);
  int16_t acosh(int16_t);
  uint16_t acosh(uint16_t);
  int32_t acosh(int32_t);
  uint32_t acosh(uint32_t);


  template<int W, int I>
  ap_fixed<W-I+3,3> asin(ap_fixed<W,I> x){
 return cordic_apfixed::generic_asin(x);
  }


  template<int W, int I>
  ap_fixed<W-I+3,3> acos(ap_fixed<W,I> x){
 return cordic_apfixed::generic_acos(x);
  }


  template<int W, int I>
  ap_fixed<W,2> atan(ap_fixed<W,I> x){
 return cordic_apfixed::generic_atan(x);
  }


  template<int W, int I>
  ap_ufixed<W,2> atan(ap_ufixed<W,I> x){
 return cordic_apfixed::generic_atan(x);
  }


  template<int I>
  ap_int<2> atan(ap_int<I> x){
   return cordic_apfixed::generic_atan(x);
  }


  template<int I>
  ap_uint<1> atan(ap_uint<I> x){
   return cordic_apfixed::generic_atan(x);
  }

  int8_t asin(int8_t);
  uint8_t asin(uint8_t);
  int16_t asin(int16_t);
  uint16_t asin(uint16_t);
  int32_t asin(int32_t);
  uint32_t asin(uint32_t);

  int8_t acos(int8_t);
  uint8_t acos(uint8_t);
  int16_t acos(int16_t);
  uint16_t acos(uint16_t);
  int32_t acos(int32_t);
  uint32_t acos(uint32_t);

  int8_t atan(int8_t);
  uint8_t atan(uint8_t);
  int16_t atan(int16_t);
  uint16_t atan(uint16_t);
  int32_t atan(int32_t);
  uint32_t atan(uint32_t);


  template<int W, int I>
  ap_fixed<W,3> atan2(ap_fixed<W,I> x, ap_fixed<W,I> y){
 return cordic_apfixed::generic_atan2(x,y);
  }


  template<int W, int I>
  ap_ufixed<W,3> atan2(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
 return cordic_apfixed::generic_atan2(x,y);
  }


  template<int I>
  ap_int<3> atan2(ap_int<I> x, ap_int<I> y){
   return cordic_apfixed::generic_atan2(x,y);
  }


  template<int I>
  ap_uint<2> atan2(ap_uint<I> x, ap_uint<I> y){
   return cordic_apfixed::generic_atan2(x,y);
  }

  int8_t atan2(int8_t, int8_t);
  uint8_t atan2(uint8_t, uint8_t);
  int16_t atan2(int16_t, int16_t);
  uint16_t atan2(uint16_t, uint16_t);
  int32_t atan2(int32_t, int32_t);
  uint32_t atan2(uint32_t, uint32_t);

  template<int W, int I>
  void sincos(ap_fixed<W,I> in,
       ap_fixed<W-I+2,2>* outsin, ap_fixed<W-I+2,2>* outcos){
   cordic_apfixed::generic_sincos(in, *outsin, *outcos);
  }

  template<int W, int I>
  ap_fixed<W-I+2,2> sin(ap_fixed<W,I> x){
        ap_fixed<W-I+2,2> outsin;
        ap_fixed<W-I+2,2> outcos;
        cordic_apfixed::generic_sincos(x, outsin, outcos);
        return outsin;
  }

  template<int W, int I>
  ap_ufixed<W-I+2,2> sin(ap_ufixed<W,I> x){
  ap_fixed<W+1, I+1> xin = x;
  ap_fixed<W-I+3, 3> xout = hls::sin(x);
  ap_fixed<W-I+2, 2> out = 0;
  if(xout[W-I+2]==0){
   out=xout;
  }
  return out;
  }

  template<int W, int I>
  ap_fixed<W-I+2,2> cos(ap_fixed<W,I> x){
        ap_fixed<W-I+2,2> outsin;
        ap_fixed<W-I+2,2> outcos;
        cordic_apfixed::generic_sincos(x, outsin, outcos);
        return outcos;
  }

  template<int W, int I>
  ap_ufixed<W-I+2,2> cos(ap_ufixed<W,I> x){
  ap_fixed<W+1, I+1> xin = x;
  ap_fixed<W-I+3, 3> xout = hls::cos(x);
  ap_fixed<W-I+2, 2> out = 0;
  if(xout[W-I+2]==0){
   out=xout;
  }
  return out;
  }
#1788 "C:/Xilinx/Vivado/2018.3/include/hls_math.h"
  template<int I>
  ap_int<I> sin(ap_int<I> in) {
 return ap_int<I>(0);
  };
  template<int I>
  ap_int<I> cos(ap_int<I> in) {
 return ap_int<I>(0);
  };


  template<int I>
  ap_uint<I> sin(ap_uint<I> in) {
 return ap_uint<I>(0);
  };
  template<int I>
  ap_uint<I> cos(ap_uint<I> in) {
 return ap_uint<I>(0);
  };

  void sincos(int8_t, int8_t*, int8_t*);
  void sincos(uint8_t, uint8_t*, uint8_t*);
  void sincos(int16_t, int16_t*, int16_t*);
  void sincos(uint16_t, uint16_t*, uint16_t*);
  void sincos(int32_t, int32_t*, int32_t*);
  void sincos(uint32_t, uint32_t*, uint32_t*);

  int8_t sin(int8_t);
  uint8_t sin(uint8_t);
  int16_t sin(int16_t);
  uint16_t sin(uint16_t);
  int32_t sin(int32_t);
  uint32_t sin(uint32_t);

  int8_t cos(int8_t);
  uint8_t cos(uint8_t);
  int16_t cos(int16_t);
  uint16_t cos(uint16_t);
  int32_t cos(int32_t);
  uint32_t cos(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> tan(ap_fixed<W,I> x){
 return cordic_apfixed::generic_tan(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> tan(ap_ufixed<W,I> x){
 return cordic_apfixed::generic_tan(x);
  }
  template<int I>
  ap_int<I> tan(ap_int<I> x){
   return cordic_apfixed::generic_tan(x);
  }
  template<int I>
  ap_uint<I> tan(ap_uint<I> x){
   return cordic_apfixed::generic_tan(x);
  }

  int8_t tan(int8_t);
  uint8_t tan(uint8_t);
  int16_t tan(int16_t);
  uint16_t tan(uint16_t);
  int32_t tan(int32_t);
  uint32_t tan(uint32_t);

  template<int W, int I>
  ap_fixed<W,I> pow(ap_fixed<W,I> x, ap_fixed<W,I> y) {
    return pow_apfixed_reduce::pow(x,y);
  }

  template<int W, int I>
  ap_ufixed<W,I> pow(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return pow_apfixed_reduce::pow(x,y);
  }
  template<int I>
  ap_int<I> pow(ap_int<I> x, ap_int<I> y){
    return pow_apfixed_reduce::pow(x,y);
  }
  template<int I>
  ap_uint<I> pow(ap_uint<I> x,ap_uint<I> y){
    return pow_apfixed_reduce::pow(x,y);
  }


  template<int W, int I>
  ap_fixed<W,I> round(ap_fixed<W,I> x){
    return round_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> round(ap_ufixed<W,I> x){
    return round_fixed(x);
  }
  template<int I>
  ap_int<I> round(ap_int<I> x){
    return round_fixed(x);
  }
  template<int I>
  ap_uint<I> round(ap_uint<I> x){
    return round_fixed(x);
  }
  int8_t round(int8_t);
  uint8_t round(uint8_t);
  int16_t round(int16_t);
  uint16_t round(uint16_t);
  int32_t round(int32_t);
  uint32_t round(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> rint(ap_fixed<W,I> x){
    return rint_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> rint(ap_ufixed<W,I> x){
    return rint_fixed(x);
  }
  template<int I>
  ap_int<I> rint(ap_int<I> x){
    return rint_fixed(x);
  }
  template<int I>
  ap_uint<I> rint(ap_uint<I> x){
    return rint_fixed(x);
  }
  int8_t rint(int8_t);
  uint8_t rint(uint8_t);
  int16_t rint(int16_t);
  uint16_t rint(uint16_t);
  int32_t rint(int32_t);
  uint32_t rint(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> nearbyint(ap_fixed<W,I> x){
    return nearbyint_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> nearbyint(ap_ufixed<W,I> x){
    return nearbyint_fixed(x);
  }
  template<int I>
  ap_int<I> nearbyint(ap_int<I> x){
    return nearbyint_fixed(x);
  }
  template<int I>
  ap_uint<I> nearbyint(ap_uint<I> x){
    return nearbyint_fixed(x);
  }
  int8_t nearbyint(int8_t);
  uint8_t nearbyint(uint8_t);
  int16_t nearbyint(int16_t);
  uint16_t nearbyint(uint16_t);
  int32_t nearbyint(int32_t);
  uint32_t nearbyint(uint32_t);



  template<int W, int I>
  bool isgreater(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    return isgreater_fixed(x1, x2);
  }
  template<int W, int I>
  bool isgreater(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    return isgreater_fixed(x1, x2);
  }
  template<int I>
  bool isgreater(ap_int<I> x1, ap_int<I> x2){
    return isgreater_fixed(x1, x2);
  }
  template<int I>
  bool isgreater(ap_uint<I> x1, ap_uint<I> x2){
    return isgreater_fixed(x1, x2);
  }
  bool isgreater(int8_t, int8_t);
  bool isgreater(uint8_t, uint8_t);
  bool isgreater(int16_t, int16_t);
  bool isgreater(uint16_t, uint16_t);
  bool isgreater(int32_t, int32_t);
  bool isgreater(uint32_t, uint32_t);


  template<int W, int I>
  bool isgreaterequal(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    return isgreaterequal_fixed(x1, x2);
  }
  template<int W, int I>
  bool isgreaterequal(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    return isgreaterequal_fixed(x1, x2);
  }
  template<int I>
  bool isgreaterequal(ap_int<I> x1, ap_int<I> x2){
    return isgreaterequal_int(x1, x2);
  }
  template<int I>
  bool isgreaterequal(ap_uint<I> x1, ap_uint<I> x2){
    return isgreaterequal_fixed(x1, x2);
  }
  bool isgreaterequal(int8_t, int8_t);
  bool isgreaterequal(uint8_t, uint8_t);
  bool isgreaterequal(int16_t, int16_t);
  bool isgreaterequal(uint16_t, uint16_t);
  bool isgreaterequal(int32_t, int32_t);
  bool isgreaterequal(uint32_t, uint32_t);


  template<int W, int I>
  bool isless(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    return isless_fixed(x1, x2);
  }
  template<int W, int I>
  bool isless(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    return isless_fixed(x1, x2);
  }
  template<int I>
  bool isless(ap_int<I> x1, ap_int<I> x2){
    return isless_fixed(x1, x2);
  }
  template<int I>
  bool isless(ap_uint<I> x1, ap_uint<I> x2){
    return isless_fixed(x1, x2);
  }
  bool isless(int8_t, int8_t);
  bool isless(uint8_t, uint8_t);
  bool isless(int16_t, int16_t);
  bool isless(uint16_t, uint16_t);
  bool isless(int32_t, int32_t);
  bool isless(uint32_t, uint32_t);


  template<int W, int I>
  bool islessequal(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    return islessequal_fixed(x1, x2);
  }
  template<int W, int I>
  bool islessequal(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    return islessequal_fixed(x1, x2);
  }
  template<int I>
  bool islessequal(ap_int<I> x1, ap_int<I> x2){
    return islessequal_fixed(x1, x2);
  }
  template<int I>
  bool islessequal(ap_uint<I> x1, ap_uint<I> x2){
    return islessequal_fixed(x1, x2);
  }
  bool islessequal(int8_t, int8_t);
  bool islessequal(uint8_t, uint8_t);
  bool islessequal(int16_t, int16_t);
  bool islessequal(uint16_t, uint16_t);
  bool islessequal(int32_t, int32_t);
  bool islessequal(uint32_t, uint32_t);


  template<int W, int I>
  bool islessgreater(ap_fixed<W,I> x1, ap_fixed<W,I> x2){
    return islessgreater_fixed(x1, x2);
  }
  template<int W, int I>
  bool islessgreater(ap_ufixed<W,I> x1, ap_ufixed<W,I> x2){
    return islessgreater_fixed(x1, x2);
  }
  template<int I>
  bool islessgreater(ap_int<I> x1, ap_int<I> x2){
    return islessgreater_fixed(x1, x2);
  }
  template<int I>
  bool islessgreater(ap_uint<I> x1, ap_uint<I> x2){
    return islessgreater_fixed(x1, x2);
  }

  bool islessgreater(int8_t, int8_t);
  bool islessgreater(uint8_t, uint8_t);
  bool islessgreater(int16_t, int16_t);
  bool islessgreater(uint16_t, uint16_t);
  bool islessgreater(int32_t, int32_t);
  bool islessgreater(uint32_t, uint32_t);

  int8_t frexp(int8_t,int8_t*);
  uint8_t frexp(uint8_t, uint8_t*);
  int16_t frexp(int16_t, int16_t*);
  uint16_t frexp(uint16_t, uint16_t*);
  int32_t frexp(int32_t, int32_t*);
  uint32_t frexp(uint32_t, uint32_t*);

  template<int W, int I>
  ap_fixed<W,I> frexp(ap_fixed<W,I> x, ap_fixed<W,I>* exp) {
    return frexp_internal::frexp(x,exp);
  }

  template<int W, int I>
  ap_ufixed<W,I> frexp(ap_ufixed<W,I> x, ap_ufixed<W,I>* exp){
    return frexp_internal::frexp(x,exp);
  }
  template<int I>
  ap_int<I> frexp(ap_int<I> x, ap_int<I>* exp){
    return frexp_internal::frexp(x,exp);
  }
  template<int I>
  ap_uint<I> frexp(ap_uint<I> x,ap_uint<I>* exp){
    return frexp_internal::frexp(x,exp);
  }

  int8_t modf(int8_t, int8_t*);
  uint8_t modf(uint8_t, uint8_t*);
  int16_t modf(int16_t, int16_t*);
  uint16_t modf(uint16_t, uint16_t*);
  int32_t modf(int32_t, int32_t*);
  uint32_t modf(uint32_t, uint32_t*);

  template<int W, int I>
  ap_fixed<W,I> modf(ap_fixed<W,I> x, ap_fixed<W,I>* intpart) {
    return modf_internal::modf(x,intpart);
  }

  template<int W, int I>
  ap_ufixed<W,I> modf(ap_ufixed<W,I> x, ap_ufixed<W,I>* intpart){
    return modf_internal::modf(x,exp);
  }
  template<int I>
  ap_int<I> modf(ap_int<I> x, ap_int<I>* intpart){
    return modf_internal::modf(x,intpart);
  }
  template<int I>
  ap_uint<I> modf(ap_uint<I> x,ap_uint<I>* intpart){
    return modf_internal::modf(x,intpart);
  }


  bool isequal(int8_t,int8_t);
  bool isequal(uint8_t,uint8_t);
  bool isequal(int16_t,int16_t);
  bool isequal(uint16_t,uint16_t);
  bool isequal(int32_t,int32_t);
  bool isequal(uint32_t,uint32_t);

  bool isnotequal(int8_t,int8_t);
  bool isnotequal(uint8_t,uint8_t);
  bool isnotequal(int16_t,int16_t);
  bool isnotequal(uint16_t,uint16_t);
  bool isnotequal(int32_t,int32_t);
  bool isnotequal(uint32_t,uint32_t);

  template<int W,int I>
  bool isequal(ap_fixed<W,I> x,ap_fixed<W,I> y){
    return generic_isequal(x,y);
  };
  template<int W,int I>
  bool isequal(ap_ufixed<W,I> x,ap_ufixed<W,I> y){
    return generic_isequal(x,y);
  };
  template<int I>
  bool isequal(ap_int<I> x,ap_int<I> y){
    return generic_isequal(x,y);
  };
  template<int I>
  bool isequal(ap_uint<I> x,ap_uint<I> y){
    return generic_isequal(x,y);
  };

  template<int W,int I>
  bool isnotequal(ap_fixed<W,I> x,ap_fixed<W,I> y){
    return generic_isnotequal(x,y);
  };
  template<int W,int I>
  bool isnotequal(ap_ufixed<W,I> x,ap_ufixed<W,I> y){
    return generic_isnotequal(x,y);
  };
  template<int I>
  bool isnotequal(ap_int<I> x,ap_int<I> y){
    return generic_isnotequal(x,y);
  };
  template<int I>
  bool isnotequal(ap_uint<I> x,ap_uint<I> y){
    return generic_isnotequal(x,y);
  };

  template<int W,int I>
  bool any(ap_fixed<W,I> x){
    return generic_any(x);
  };
  template<int W,int I>
  bool any(ap_ufixed<W,I> x){
    return generic_any(x);
  };
  template<int I>
  bool any(ap_int<I> x){
    return generic_any(x);
  };
  template<int I>
  bool any(ap_uint<I> x){
    return generic_any(x);
  };

  template<int W,int I>
  bool all(ap_fixed<W,I> x){
    return generic_all(x);
  };
  template<int W,int I>
  bool all(ap_ufixed<W,I> x){
    return generic_all(x);
  };
  template<int I>
  bool all(ap_int<I> x){
    return generic_all(x);
  };
  template<int I>
  bool all(ap_uint<I> x){
    return generic_all(x);
  };

  template<int W,int I>
  ap_fixed<W,I> bitselect(ap_fixed<W,I> x,ap_fixed<W,I> y, ap_fixed<W,I> z){
    return generic_bitselect(x,y,z);
  };
  template<int W,int I>
  ap_ufixed<W,I> bitselect(ap_ufixed<W,I> x,ap_ufixed<W,I> y,ap_ufixed<W,I> z){
    return generic_bitselect(x,y,z);
  };
  template<int I>
  ap_int<I> bitselect(ap_int<I> x,ap_int<I> y,ap_int<I> z){
    return generic_bitselect(x,y,z);
  };
  template<int I>
  ap_uint<I> bitselect(ap_uint<I> x,ap_uint<I> y,ap_uint<I> z){
    return generic_bitselect(x,y,z);
  };

  template<int W, int I>
  ap_fixed<W,I> erf(ap_fixed<W,I> x){
    return erf_erfc_fixed::erf(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> erf(ap_ufixed<W,I> x){
    return erf_erfc_fixed::erf(x);
  }
  template<int I>
  ap_int<I> erf(ap_int<I> x){
    return erf_erfc_fixed::erf(x);
  }
  template<int I>
  ap_uint<I> erf(ap_uint<I> x){
    return erf_erfc_fixed::erf(x);
  }

  template<int W, int I>
  ap_fixed<W,I> erfc(ap_fixed<W,I> x){
    return erf_erfc_fixed::erfc(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> erfc(ap_ufixed<W,I> x){
    return erf_erfc_fixed::erfc(x);
  }
  template<int I>
  ap_int<I> erfc(ap_int<I> x){
    return erf_erfc_fixed::erfc(x);
  }
  template<int I>
  ap_uint<I> erfc(ap_uint<I> x){
    return erf_erfc_fixed::erfc(x);
  }

  int8_t divide(int8_t,int8_t);
  int16_t divide(int16_t,int16_t);
  int32_t divide(int32_t,int32_t);
  uint8_t divide(uint8_t,uint8_t);
  uint16_t divide(uint16_t,uint16_t);
  uint32_t divide(uint32_t,uint32_t);

  template<int W, int I>
  ap_fixed<W,I> divide(ap_fixed<W,I> x, ap_fixed<W,I> y){
    return hls_my::generic_divide(x, y);
  }
  template<int W, int I>
  ap_ufixed<W,I> divide(ap_ufixed<W,I> x, ap_ufixed<W,I> y){
    return hls_my::generic_divide(x, y);
  }
  template<int I>
  ap_int<I> divide(ap_int<I> x, ap_int<I> y){
    return hls_my::generic_divide(x, y);
  }
  template<int I>
  ap_uint<I> divide(ap_uint<I> x, ap_uint<I> y){
    return hls_my::generic_divide(x, y);
  }
#2345 "C:/Xilinx/Vivado/2018.3/include/hls_math.h"
  template<int W, int I>
  bool signbit(ap_fixed<W, I> x) {
    return signbit_fixed(x);
  }
  template<int W, int I>
  bool signbit(ap_ufixed<W, I> x) {
    return signbit_fixed(x);
  }
  template<int I>
  bool signbit(ap_int<I> x) {
    return signbit_fixed(x);
  }
  template<int I>
  bool signbit(ap_uint<I> x) {
    return signbit_fixed(x);
  }
  bool signbit(int8_t);
  bool signbit(uint8_t);
  bool signbit(int16_t);
  bool signbit(uint16_t);
  bool signbit(int32_t);
  bool signbit(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> lgamma_r(ap_fixed<W,I> x, int *signgamp){
    return lgamma_fixed::lgamma_r_generic(x, signgamp);
  }
  template<int W, int I>
  ap_ufixed<W,I> lgamma_r(ap_ufixed<W,I> x, int *signgamp){
    return lgamma_fixed::lgamma_r_generic(x, signgamp);
  }
  template<int I>
  ap_int<I> lgamma_r(ap_int<I> x, int *signgamp){
    return lgamma_fixed::lgamma_r_generic(x, signgamp);
  }
  template<int I>
  ap_uint<I> lgamma_r(ap_uint<I> x, int *signgamp){
    return lgamma_fixed::lgamma_r_generic(x, signgamp);
  }

  template<int W, int I>
  ap_fixed<W,I> lgamma(ap_fixed<W,I> x){
    return lgamma_fixed::lgamma_generic(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> lgamma(ap_ufixed<W,I> x){
    return lgamma_fixed::lgamma_generic(x);
  }
  template<int I>
  ap_int<I> lgamma(ap_int<I> x){
    return lgamma_fixed::lgamma_generic(x);
  }
  template<int I>
  ap_uint<I> lgamma(ap_uint<I> x){
    return lgamma_fixed::lgamma_generic(x);
  }
#2451 "C:/Xilinx/Vivado/2018.3/include/hls_math.h"
  int8_t fract(int8_t);
 int16_t fract(int16_t);
 int32_t fract(int32_t);
 uint8_t fract(uint8_t);
 uint16_t fract(uint16_t);
 uint32_t fract(uint32_t);

  template<int W, int I>
  ap_fixed<W,I> fract(ap_fixed<W,I> x){
    return hls_fract::generic_fract(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> fract(ap_ufixed<W,I> x){
    return hls_fract::generic_fract(x);
  }
  template<int I>
  ap_int<I> fract(ap_int<I> x){
    return hls_fract::generic_fract(x);
  }
  template<int I>
  ap_uint<I> fract(ap_uint<I> x){
    return hls_fract::generic_fract(x);
  }

  template<int W, int I>
  ap_fixed<W,I> cbrt(ap_fixed<W,I> x) {
    return cbrt_internal::cbrt_fixed(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> cbrt(ap_ufixed<W,I> x) {
    return cbrt_internal::cbrt_fixed(x);
  }
  template<int I>
  ap_int<I> cbrt(ap_int<I> x) {
    return cbrt_internal::cbrt_fixed(x);
  }
  template<int I>
  ap_uint<I> cbrt(ap_uint<I> x) {
    return cbrt_internal::cbrt_fixed(x);
  }
  int8_t cbrt(int8_t);
  uint8_t cbrt(uint8_t);
  int16_t cbrt(int16_t);
  uint16_t cbrt(uint16_t);
  int32_t cbrt(int32_t);
  uint32_t cbrt(uint32_t);


  template<int W, int I>
  ap_fixed<W,I> tgamma(ap_fixed<W,I> x){
    return tgamma_fixed::tgamma_generic(x);
  }
  template<int W, int I>
  ap_ufixed<W,I> tgamma(ap_ufixed<W,I> x){
    return tgamma_fixed::tgamma_generic(x);
  }
  template<int I>
  ap_int<I> tgamma(ap_int<I> x){
    return tgamma_fixed::tgamma_generic(x);
  }
  template<int I>
  ap_uint<I> tgamma(ap_uint<I> x){
    return tgamma_fixed::tgamma_generic(x);
  }


  template<int W, int I>
  ap_fixed<W,I> nextafter(ap_fixed<W, I> x, ap_fixed<W, I> y) {
    return fp_internal::nextafter(x, y);
  }
  template<int W, int I>
  ap_ufixed<W,I> nextafter(ap_ufixed<W, I> x, ap_ufixed<W, I> y) {
    return fp_internal::nextafter(x, y);
  }
  template<int I>
  ap_int<I> nextafter(ap_int<I> x, ap_int<I> y) {
    return fp_internal::nextafter(x, y);
  }
  template<int I>
  ap_uint<I> nextafter(ap_uint<I> x, ap_uint<I> y) {
    return fp_internal::nextafter(x, y);
  }
  int8_t nextafter(int8_t, int8_t);
  uint8_t nextafter(uint8_t, uint8_t);
  int16_t nextafter(int16_t, int16_t);
  uint16_t nextafter(uint16_t, uint16_t);
  int32_t nextafter(int32_t, int32_t);
  uint32_t nextafter(uint32_t, uint32_t);


  template<int W, int I>
  ap_fixed<W,I> nexttoward(ap_fixed<W, I> x, ap_fixed<W, I> y) {
    return fp_internal::nexttoward(x, y);
  }
  template<int W, int I>
  ap_ufixed<W,I> nexttoward(ap_ufixed<W, I> x, ap_ufixed<W, I> y) {
    return fp_internal::nexttoward(x, y);
  }
  template<int I>
  ap_int<I> nexttoward(ap_int<I> x, ap_int<I> y) {
    return fp_internal::nexttoward(x, y);
  }
  template<int I>
  ap_uint<I> nexttoward(ap_uint<I> x, ap_uint<I> y) {
    return fp_internal::nexttoward(x, y);
  }
  int8_t nexttoward(int8_t, int8_t);
  uint8_t nexttoward(uint8_t, uint8_t);
  int16_t nexttoward(int16_t, int16_t);
  uint16_t nexttoward(uint16_t, uint16_t);
  int32_t nexttoward(int32_t, int32_t);
  uint32_t nexttoward(uint32_t, uint32_t);


  template<int W, int I>
  ap_fixed<W,I> hypot(ap_fixed<W,I> x, ap_fixed<W,I> y) {
    return hypot_internal::hypot_fixed(x,y);
  }
  template<int W, int I>
  ap_ufixed<W,I> hypot(ap_ufixed<W,I> x, ap_ufixed<W,I> y) {
    return hypot_internal::hypot_fixed(x,y);
  }
  template<int I>
  ap_int<I> hypot(ap_int<I> x, ap_int<I> y) {
    return hypot_internal::hypot_fixed(x,y);
  }
  template<int I>
  ap_uint<I> hypot(ap_uint<I> x, ap_uint<I> y) {
    return hypot_internal::hypot_fixed(x,y);
  }
  int8_t hypot(int8_t, int8_t);
  uint8_t hypot(uint8_t, uint8_t);
  int16_t hypot(int16_t, int16_t);
  uint16_t hypot(uint16_t, uint16_t);
  int32_t hypot(int32_t, int32_t);
  uint32_t hypot(uint32_t, uint32_t);

  template<int W, int I>
  ap_fixed<W,I> exp2(ap_fixed<W,I> x) {
    return exp_reduce::exp2(x);
  }

  template<int W, int I>
  ap_ufixed<W,I> exp2(ap_ufixed<W,I> x) {
    return exp_reduce::exp2(x);
  }

  template<int I>
  ap_int<I> exp2(ap_int<I> x) {
    return exp_reduce::exp2(x);
  }

  template<int I>
  ap_uint<I> exp2(ap_uint<I> x) {
    return exp_reduce::exp2(x);
  }

  template<int W, int I>
  ap_fixed<W,I> expm1(ap_fixed<W,I> x) {
    return exp_reduce::expm1(x);
  }

  template<int W, int I>
  ap_ufixed<W,I> expm1(ap_ufixed<W,I> x) {
    return exp_reduce::expm1(x);
  }

  template<int I>
  ap_int<I> expm1(ap_int<I> x) {
    return exp_reduce::expm1(x);
  }

  template<int I>
  ap_uint<I> expm1(ap_uint<I> x) {
    return exp_reduce::expm1(x);
  }

  template<int W, int I>
  ap_fixed<W,I> log1p(ap_fixed<W,I> x) {
    return log_apfixed_reduce::log1p(x);
  }

  template<int W, int I>
  ap_ufixed<W,I> log1p(ap_ufixed<W,I> x) {
    return log_apfixed_reduce::log1p(x);
  }

  template<int I>
  ap_int<I> log1p(ap_int<I> x) {
    return log_apfixed_reduce::log1p(x);
  }

  template<int I>
  ap_uint<I> log1p(ap_uint<I> x) {
    return log_apfixed_reduce::log1p(x);
  }

  template<int W, int I>
  ap_fixed<W,I> ilogb(ap_fixed<W,I> x) {
    return log_apfixed_reduce::ilogb(x);
  }

  template<int W, int I>
  ap_ufixed<W,I> ilogb(ap_ufixed<W,I> x) {
    return log_apfixed_reduce::ilogb(x);
  }

  template<int I>
  ap_int<I> ilogb(ap_int<I> x) {
    return log_apfixed_reduce::ilogb(x);
  }

  template<int I>
  ap_uint<I> ilogb(ap_uint<I> x) {
    return log_apfixed_reduce::ilogb(x);
  }

    int8_t exp2(int8_t x);
    int16_t exp2(int16_t x);
    int32_t exp2(int32_t x);
    uint8_t exp2(uint8_t x);
    uint16_t exp2(uint16_t x);
    uint32_t exp2(uint32_t x);

    int8_t expm1(int8_t x);
    int16_t expm1(int16_t x);
    int32_t expm1(int32_t x);
    uint8_t expm1(uint8_t x);
    uint16_t expm1(uint16_t x);
    uint32_t expm1(uint32_t x);

    int8_t ilogb(int8_t x);
    int16_t ilogb(int16_t x);
    int32_t ilogb(int32_t x);
    uint8_t ilogb(uint8_t x);
    uint16_t ilogb(uint16_t x);
    uint32_t ilogb(uint32_t x);

    int8_t log1p(int8_t x);
    int16_t log1p(int16_t x);
    int32_t log1p(int32_t x);
    uint8_t log1p(uint8_t x);
    uint16_t log1p(uint16_t x);
    uint32_t log1p(uint32_t x);

};
#3 "C:/Users/91917/Downloads/VLSI_Project/vlsi_project/hand_chrc_nn.cpp" 2





char hand_chrc_nn(float X[784],int y){





#pragma HLS INTERFACE s_axilite port=return bundle=CRTL_BUS
#pragma HLS INTERFACE s_axilite port=y bundle=CRTL_BUS
#pragma HLS INTERFACE bram port=X

    float lay1[100][784] = {{0.0556659, 0.0636551, 0.0629186, 0.0186724, -0.0151459, -0.0612485, -0.0161196, 0.0605795, -0.00320268, 0.00507902, 0.043251, 0.00870509, -0.0654379, -0.0797493, -0.0777559, -0.025043, 0.0392408, 0.0559368, 0.0333988, -0.0756259, -0.0567275, 0.0643013, 0.0130673, -0.00970284, -0.00828988, 0.0168699, -0.0366695, -0.0478944, 0.00164177, -0.0686722, 0.0351397, -0.0173233, 0.00437048, -0.0800408, 0.0156798, -0.0279445, -0.0775467, -0.0232014, -0.00178143, 0.0118459, 0.0603915, 0.0141582, 0.07823, 0.00567765, -0.0475628, 0.0223308, -0.062604, 0.0526912, -0.0254395, 0.0383406, -0.06252, 0.000916839, -0.0573338, -0.0160757, -0.0370529, 0.0734465, 0.0280458, -0.0564, 0.0258544, -0.0490246, 0.0438418, 0.0748817, 0.0769757, -0.0490709, 0.0789281, -0.0535684, 0.0619255, -0.0495803, -0.016663, 0.0737076, -0.0709866, -0.0393101, -0.0334613, 0.0364187, 0.073725, 0.0121582, -0.0383965, -0.00321236, 0.00855519, -0.0485507, 0.0568535, -0.0174437, -0.0113002, 0.00774749, -0.0218457, -0.0549639, -0.0636073, -0.035019, -0.0458115, 0.0145699, -0.0375673, 0.00827641, -0.00377821, -0.0170439, 0.0738579, -0.0207099, -0.004399, -0.0171266, 0.0260068, 0.0723658, -0.0308162, 0.0289558, 0.00283008, 0.0598505, -0.0677977, -0.00655114, 0.0467023, 0.0215832, 0.0759647, -0.00485165, -0.0585866, -0.027854, -0.0506154, -0.000485554, 0.0631278, -0.0646375, -0.0421816, 0.00465602, 0.0524292, 0.0197235, 0.00487346, -0.0304602, -0.00859646, 0.0332613, -0.0416031, -0.078549, 0.0630727, -0.00589847, -0.00153852, 0.0396535, -0.0642361, 0.0590864, 0.0298842, -0.0169931, -0.0694145, 0.0610781, -0.0351277, -0.0664429, -0.0814458, -0.0766318, -0.00734627, 0.0415423, -0.0172086, -0.0321658, -0.0785907, -0.0763613, -0.0539849, -0.00680022, -0.0612833, -0.0485624, 0.078817, -0.0527255, 0.0018765, -0.0362012, -0.00139683, 0.0028214, 0.0639572, -0.0364781, -0.00299249, -0.0347086, -0.0745922, 0.0554751, -0.0460324, 0.023505, -0.0770092, -0.0748601, -0.0627079, -0.065211, -0.0708254, -0.0423189, 0.0105201, 0.0180036, -0.0746103, -0.0487911, -0.022161, -0.00296787, 0.0270964, -0.0177763, 0.0518767, 0.0723865, 0.0325219, 0.0345609, -0.0255787, 0.0248203, -0.0272492, -0.0533554, 0.0141939, -0.045264, 0.0323777, -0.068824, 0.0223837, 0.0307059, -0.016929, 0.0475254, -0.0765247, 0.0132621, -0.0258781, -0.0821572, 0.0656338, 0.0353557, 0.0153422, -0.080289, -0.0464923, -0.0282383, -0.0634972, -0.0381199, -0.052076, 0.0616489, -0.0762696, 0.0109624, -0.058401, 0.0534027, -0.0778907, -0.0761261, -0.0424435, -0.00771882, 0.0597071, 0.0234488, 0.0182271, -0.0768879, -0.0754151, -0.0115944, 0.0372649, -0.0416934, 0.0541395, -0.0737606, -0.074845, -0.064182, -0.052953, -0.00559427, 0.0709206, 0.0212028, 0.0644394, -0.0813631, 0.0452647, 0.0299077, -0.0423197, 0.0251137, 0.0346267, -0.0657133, 0.0343168, 0.0584651, -0.0776439, 0.081601, -0.0116228, -0.0188296, 0.0293199, -0.0320394, 0.0344769, 0.0580984, -0.064597, -0.0426558, -0.0185065, -0.0019675, 0.0642232, -0.056991, 0.0811089, 0.0592631, 0.0404176, -0.0377328, -0.0780107, -0.0559677, -0.0543129, 0.0245739, 0.062428, -0.0694094, 0.0317122, 0.0782693, 0.0678324, -0.0736073, 0.00241194, 0.022444, -0.0465258, -0.071648, -0.0734048, 0.0684523, 0.00819049, 0.0471588, -0.0786859, -0.0328857, 0.0207375, 0.0321649, -0.0715295, -0.0202067, 0.0531843, 0.00118737, -0.0671467, 0.0563652, -0.0540448, 0.0575481, 0.0201032, 0.0500644, 0.0159178, 0.0363584, -0.0482857, -0.0138691, -0.0197331, -0.0241852, 0.0530298, -0.0246977, 0.0582983, -0.0124366, -0.0168268, 0.0242576, -0.0209697, 0.0724521, -0.030918, -0.0469141, 0.00208525, -0.0170261, -0.0236911, 0.0489517, 0.0475787, -0.0734969, -0.0807576, 0.0663418, 0.0192849, -0.0119383, -0.00858012, -0.0483117, 0.0229145, -0.00516854, 0.0157535, 0.0436412, -1.61454e-05, -0.0440318, -0.0696195, -0.0204148, 0.0534386, 0.0394681, 0.0613732, 0.0160284, -0.0316208, -0.0657754, -0.0327519, -0.044429, -0.0631347, 0.0421359, 0.072308, -0.0141979, 0.0431622, -0.0557151, 0.0669123, -0.0259652, 0.0494369, 0.072087, 0.0750682, 0.0139434, -0.0804996, -0.0666632, 0.0658059, -0.0186727, 0.0809717, 0.01964, -0.0516436, -0.0418374, 0.0784293, 0.0518608, 0.0508353, 0.0530901, 0.0461298, 0.0508721, -0.038319, -0.0585063, 0.0212068, -0.0550679, -0.0610418, -0.0468939, 0.057389, 0.00195225, -0.0554395, -0.0429588, 0.0715976, -0.0727212, -0.028384, -0.0781705, -0.0450294, 0.0395718, -0.0373467, 0.0135771, -0.066813, -0.0275207, -0.0387095, -0.0465655, -0.0600433, -0.0678388, -0.0730372, 0.0140477, -0.0458247, 0.0118527, -0.0227624, 0.068729, -0.055267, 0.0707401, 0.0762735, -0.0306175, -0.0221441, 0.0602446, -0.0327818, -0.0505565, -0.0285717, -0.0534921, 0.059444, 0.00750962, 0.00996996, -0.0282197, 0.0277223, 0.0289513, 0.0656426, -0.066759, -0.0297761, 0.00733429, -0.00812025, -0.0654856, -0.0294509, 0.0252421, -0.0629293, 0.0607603, -0.0176397, -0.0504476, -0.0348014, 0.0432184, 0.0366104, 0.0456549, 0.081941, -0.0267652, -0.0465323, -0.0488728, 0.0637317, -0.0143756, 0.0354493, -0.036606, -0.00856631, 0.0247316, 0.078513, 0.0194427, 0.0243802, -0.00784693, 0.065837, 0.0104037, -0.0335462, -0.0718256, 0.0400703, -0.0508375, -0.055668, -0.0287734, 0.0369832, 0.0697643, 0.0748922, -0.0125782, -0.0516076, 0.0752075, 0.0662715, -0.0618561, 0.0281295, -0.0336137, 0.0819462, 0.0805618, -0.0684008, 0.0518285, -0.0447791, -0.0107319, 0.017086, -0.0122012, 0.0189244, 0.000405058, 0.0468663, 0.0290975, 0.0326737, 0.0589514, 0.00979748, 0.0300252, 0.0041535, 0.0576708, 0.0795605, 0.0116843, 0.062553, 0.0398611, 0.0595564, -0.0271489, -0.064312, -0.00360854, -0.0117167, 0.0667106, -0.0284014, 0.0561953, -0.00932208, -0.0566039, -0.0763654, 0.0167435, 0.0687132, -0.0601885, -0.0689352, -0.0189852, 0.00815832, -0.0202036, -0.0439105, 0.0653962, -0.0052455, -0.0245479, 0.0522691, -0.0629489, 0.0185215, -0.0347252, 0.0423134, -0.0603772, 0.0521124, -0.063073, 0.0397113, -0.0388355, -0.0257589, -0.0583053, 0.0733454, 0.0147903, 0.0275033, 0.0450052, -0.0382927, 0.0251347, -0.0252311, -0.0213428, 0.0464345, 0.0585642, -0.0698097, 0.0183683, 0.0124309, 0.0150227, -0.0235518, -0.00787121, 0.0687269, -0.0430544, -0.0287077, 0.0397837, 0.0806877, 0.0760787, -0.00156094, -0.0433763, -0.0120943, -0.07667, 0.0550683, -0.0510604, -0.0246839, -0.0595381, 0.0597646, 0.0362956, -0.030918, -0.042264, -0.0654712, 0.0404766, -0.000104241, 0.0699203, -0.0194976, -0.0255026, 0.0294998, 0.0582842, 0.0812163, -0.0046133, -0.0699214, 0.00388029, 0.0647982, -0.0386765, 0.0739343, -0.0719864, 0.0133111, 0.00577129, -0.0762336, 0.0357649, 0.0271157, -0.012643, 0.0344619, -0.0388003, -0.0764283, -0.0614218, 0.0164403, 0.0497245, 0.0548736, 0.0255637, 0.068978, -0.0743144, 0.0726073, 0.0404172, -0.0308623, -0.0745903, -0.0169209, -0.050046, 0.0142079, 0.00147191, -0.0443734, -0.00284077, 0.0640326, -0.0694208, -0.0757569, -0.0393838, -0.0510782, 0.0117666, -0.0266636, 0.0734279, 0.0691648, 0.0479484, -0.00827961, 0.0177923, 0.0259457, -0.0446645, 0.0285875, -0.02442, 0.0415255, 0.0486487, -0.0648312, 0.00147273, -0.0221815, 0.00390004, -0.0737706, 0.0184287, -0.0159309, -0.0558037, -0.0485464, -0.00529189, -0.0767895, 0.0783278, -0.00382794, -0.0774197, -0.0784543, -0.0414036, -0.0744921, -0.0791576, -0.000355266, 0.0115267, 0.017638, 0.00840659, 0.0716773, -0.0381014, 9.0152e-07, -0.0235393, 0.0680602, -0.0646226, 0.0385909, 0.0683174, 0.0444466, -0.0112214, -0.0773521, -0.0522785, 0.0167502, 0.0662156, 0.0542278, 0.0815188, -0.0410843, 0.0291361, -0.0229739, -0.0281403, 0.0403363, 0.0303963, -0.0517956, 0.0782849, -0.0457499, 0.0657346, -0.0383442, 0.0277891, 0.0306755, 0.0381038, 0.055632, -0.0750049, 0.0448513, -0.0185499, -0.00142667, -0.00667117, -0.00964782, 0.0656298, -0.0367628, 0.0650262, -0.0808827, -0.0364034, -0.0736303, 0.0620236, -0.00188575, -0.0446537, -0.0677607, 0.0819129, 0.0349958, -0.0765427, -0.0672943, 0.0688639, -0.046524, 0.0547181, -0.0796138, -0.070309, 0.0103053, -0.047285, -0.0459924, -0.0760713, -0.0587101, 0.0241656, 0.0508542, 0.0614916, 0.0300898, 0.00807056, 0.0707171, -0.053783, 0.0417348, -0.0469759, 0.0255682, -0.0225085, -0.00379769, -0.0219775, 0.0387688, 0.0823828, 0.0600053, 0.042975, -0.0215954, 0.0786178, -0.0693598, -0.0392646, 0.0647448, -0.00699414, 0.0678732, 0.0405738, 0.0263228, -0.0636081, 0.0435781, 0.0243528, 0.0431324, -0.028897, -0.0120744, 0.0660189, -0.0776453, -0.0412628, 0.0704305, -0.0607, -0.0681329, 0.0348121, -0.0445286, -0.00130446, 0.0623682, -0.0422703, -0.0599721, -0.0780785, -0.0617347, -0.0489902, -0.0580511, -0.0356342, 0.00566885, 0.0533173, 0.0549395, -0.0513825, -0.00333738, 0.0538913, 0.00517566, 0.0785423, -0.0470079, -0.0200678, -0.0689883, 0.072981, -0.021872, -0.0201815, -0.0567727, -0.0632266, -0.0640398, -0.0808985, 0.0140971, -0.0750614, 0.0203529, -0.0333748, -0.0379538, 0.0579624, 0.0219638, 0.0158226, -0.00810507, -0.0198587, 0.0244869, -0.0594865, 0.0702589, 0.00681725, -0.0563926, 0.0166847, 0.0645055, 0.0657859, 0.0151228, -0.0316137, -0.00202008, -0.0622412, -0.00256733, 0.053835, 0.0425759, -0.0313125, 0.0688163, -0.0642875}, {0.0797928, 0.0192412, 0.00814959, 0.0390702, -0.0183966, -0.0342694, 0.0471385, 0.0358382, -0.0694736, 0.0805933, -0.0502249, -0.0685332, 0.013903, -0.0663205, -0.0358481, 0.0128588, -0.0804503, -0.0530592, 0.0493746, -0.0777805, 0.0759205, 0.00369401, 0.0276904, 0.019038, -0.0550028, -0.00604889, 0.0772642, -0.025094, 0.0123913, -0.0710381, 0.0334486, 0.0110412, -0.0402256, 0.033796, -0.0626943, 0.0304426, 0.0773709, -0.0617886, 0.064785, -0.0523189, -0.0265069, -0.0168508, -0.0712316, 0.0521315, -0.0752846, -0.000190295, 0.0399637, 0.0773864, -0.0469953, -0.0454708, 0.0255991, 0.0711289, -0.0285599, 0.00837757, 0.0491409, -0.00770855, -0.0445938, 0.037511, -0.0432962, 0.0634514, 0.0100457, 0.0213342, 0.00779694, 0.0269666, 0.0288466, -0.0459535, 0.0176808, -0.00962565, -0.0448292, -0.0354437, -0.0801236, -0.0179733, -4.2662e-05, -0.0055488, -0.0483353, 0.0507426, 0.00830618, 0.0786235, -0.0101435, -0.0165437, -0.0248608, 0.0752742, -0.0344258, 0.0431541, 0.00575787, 0.00492319, 0.0635768, -0.0797995, -0.071635, -0.0577878, -0.0686283, 0.0496523, -0.0606361, -0.0441314, 0.0728152, 0.0150044, 0.0549548, 0.00535304, 0.0315891, 0.0685403, -0.0149197, -0.0334141, 0.0211746, -0.00410046, -0.015932, 0.0423038, -0.0801672, 0.0689346, -0.0646192, 0.0710449, -0.00123747, -0.0111723, 0.0263306, 0.0767995, 0.0209932, 0.0229535, -0.0660113, 0.0117697, -0.0249797, -0.0277054, -0.0589549, 0.0323048, -0.0500288, -0.0764067, -0.00308236, 0.0482902, -0.0183471, 0.00379296, 0.0473564, 0.0127631, -0.0678375, -0.0785785, -0.0813162, 0.0721916, -0.032966, -0.0529628, -0.0760601, -0.0311203, 0.0437328, 0.0288914, -0.0504998, 0.0207316, -0.0576061, -0.0593312, 0.0451526, -0.0236851, -0.0132947, -0.0265534, 0.0806021, -0.0386624, -0.0266281, 0.00866098, 0.036642, -0.063208, -0.0368513, -0.0103436, 0.00454614, -0.0601117, -0.0543625, -0.0409074, 0.0738974, -0.0775637, -0.0280447, 0.021784, 0.0751082, -0.00583143, -0.0522596, 0.0237772, -0.0115825, 0.0708515, -0.0742257, -0.0356559, -0.0393693, -0.0443531, -0.0560515, 0.0216865, -0.00463728, 0.0697168, 0.0573409, 0.02114, -0.0228085, -0.0529002, -0.0483462, -0.0537616, 0.0543354, 0.0741878, 0.0657596, -0.009871, 0.0443719, -0.0385405, -0.050572, -0.0148707, -0.0702946, -0.0182687, 0.0597629, 0.0694762, 0.0226794, 0.0803503, -0.0281359, -0.0519321, -0.0721477, 0.0426896, -0.0445744, -0.0680527, -0.0787086, 0.0556738, -0.0139314, 0.0680609, -0.0599736, -0.0201878, -0.0367807, -0.00668938, 0.0437305, -0.0605206, -0.0798195, 0.056219, -0.0635345, 0.0547135, -0.077983, 0.0496924, 0.065204, 0.0103971, -0.0584214, 0.0287955, -0.0569545, 0.0748645, 0.0145304, 0.0199082, 0.0778402, 0.0815776, 0.0744238, 0.0161368, 0.0379931, 0.0233923, 0.0684976, -0.00715841, -0.0530136, 0.00780717, 0.0585304, -0.0361712, 0.0172738, -0.00939914, 0.0136885, 0.0171262, 0.0432379, 0.0621552, -0.0233184, -0.025564, -0.064275, 0.00452489, -0.0750135, -0.0014566, -0.00822885, 0.0733094, -0.0696031, -0.0336909, -0.0342759, -0.0396817, -0.0454726, -0.0298483, 0.0328222, -0.078477, -0.0152436, 0.0802924, 0.0152123, -0.0800573, -0.0753771, -0.0234881, 0.00905669, -0.0353918, -0.0111623, 0.0367419, 0.0811124, -0.00422923, 0.0234339, 0.0584981, -0.0334146, 0.0295286, -0.0656789, 0.0323218, 0.0421815, 0.0730758, 0.00381469, -0.0210247, 0.0573051, -0.00777747, 0.0553505, -0.00140455, 0.0330153, -0.0290023, 0.0587996, 0.0417321, -0.00610695, -0.0131344, -0.0499662, -0.0106464, -0.0407972, 0.0650935, -0.0385597, 0.0727644, -0.00268202, -0.0425038, 0.0328528, -0.0467103, 0.0379155, -0.0637314, 0.0299963, 0.0377139, -0.0240056, -0.0639174, 0.066588, -0.0413259, -0.0172575, 0.0297106, 0.0648552, 0.0735031, 0.0773208, 0.0714005, -0.017441, -0.0669594, -0.0578957, -0.0288443, 0.0809174, 0.0728088, -0.0459186, -0.0103465, -0.00233828, 0.0733853, 0.0396609, 0.0326411, 0.0345955, -0.0807781, -0.0124704, 0.063365, 0.04107, -0.0693804, 0.051748, 0.0712968, 0.00754407, 0.0567372, -0.068309, 0.0112667, -0.075734, 0.0524344, -0.0716959, -0.0238868, 0.0525111, 0.0742463, -0.05916, -0.0406774, -0.072962, 0.0105286, -0.0658849, -0.0165972, 0.0545725, -0.068551, 0.0292189, -0.0327114, -0.0760066, -0.00896563, -0.0746189, 0.0568222, 0.0640253, 0.00929642, -0.0757664, -0.0595112, 0.00191863, -0.0558949, 0.00452355, -0.056048, -0.0758016, -0.0625472, -0.0115181, -0.0317991, -0.0423276, -0.0396248, 0.051129, -0.0518995, 0.047885, 0.00521129, -0.0229378, -0.0801101, 0.0732527, -0.0756387, -0.01253, -0.0460203, 0.0378289, -0.0536044, 0.0502607, 0.0455294, -0.0793083, 0.00626598, -0.0782636, -0.0137621, -0.00665414, 0.0437383, -0.0541116, -0.038953, -0.0400946, 0.00492555, -0.0348835, 0.0555077, 0.0318428, 0.0732866, 0.0407342, -0.0584735, -0.074002, 0.00424161, -0.0199752, 0.0239571, -0.0704845, 0.0693856, 0.0468147, -0.0631327, 0.0190691, 0.0155346, -0.0249186, -0.0510326, -0.0726596, -0.0552065, -0.0467525, -0.0462671, 0.0339348, -0.0266711, -0.0542772, 0.0343136, -0.0702779, 0.0406945, -0.0035516, 0.0249282, -0.0499416, 0.0243645, -0.0231117, 0.0726969, 0.0399753, -0.0610082, 0.0257678, -0.0772875, -0.0606955, 0.0355421, 0.00391208, -0.0123973, -0.0581005, 0.0122327, -0.0527093, -0.0595659, -0.000862606, 0.0743723, 0.0731632, 0.00590561, -0.0225307, -0.0187584, 0.0374367, -0.0686002, 0.0217003, 0.00557162, -0.00421117, -0.0419455, 0.0236575, 0.0768141, -0.0417666, -0.0494667, 0.0721512, -0.0358463, 0.0687027, -0.0746018, -0.0017249, 0.0468567, -0.0719969, 0.00958041, -0.0816572, 0.0784857, -0.080565, 0.0642436, 0.032603, 0.0492884, -0.0198115, -0.0111336, 0.0808114, 0.00680753, -0.0460331, 0.0354234, -0.0452239, -0.0777468, -0.0341175, -0.0408956, -0.060469, -0.0237003, 0.0557401, -0.05812, 0.047641, 0.0131834, -0.0629021, 0.0328312, -0.00369424, 0.058374, -0.0465653, 0.0222384, -0.0546983, 0.0375162, -0.0317608, -0.0560054, 0.0813252, 0.00232245, -0.0109729, 0.0526002, -0.0133377, -0.042269, -0.0117521, 0.0216772, -0.0375881, -0.069545, -0.00707272, 0.0739515, -0.0216205, -0.0542739, 0.00473484, -0.0162472, -0.0131558, 0.00869687, 0.0641038, -0.0564883, 0.00578574, -0.00328991, 0.0230611, 0.0539805, 0.0673085, 0.0375925, 0.0249681, 0.0701879, -0.0725011, 0.0727312, -0.0558259, 0.0478434, 0.0134963, 0.0790488, -0.0322358, 0.0235729, -0.0163835, 0.0253251, -0.0328652, -0.0105901, 0.0746435, 0.0636414, -0.0603243, -0.0551476, 0.0814281, 0.0175666, -0.0725642, 0.0763813, -0.0599414, -0.0426443, -0.0369569, -0.0676104, -0.0338286, 0.0583723, -0.0126658, -0.0221501, -0.0345688, -0.0156549, 0.0533459, -0.0191943, -0.0314788, 0.0290411, 0.0211352, 0.0314922, -0.0743866, 0.0639128, 0.0160865, -0.035439, -0.0751378, -0.0524409, 0.0196336, 0.0533828, -0.0818401, -0.00564931, 0.0312414, -0.0487853, 0.0652999, 0.0733897, -0.00277167, 0.0161793, 0.0424967, 0.0543368, 0.0419674, 0.0494313, 0.000209011, 0.0718101, 0.0768812, -0.0710782, -0.0297854, -0.0706382, -0.0756233, -0.022368, -0.0491636, 0.0716793, -0.0800576, 0.0693849, 0.0193053, 0.058104, 0.0388146, 0.0273462, 0.0763641, -0.0385026, -0.0597687, 0.0552457, 0.0808969, 0.0062608, -0.033544, -0.0686247, -0.0815403, 0.0197798, -0.018755, -0.0141054, -0.0606196, 0.0534039, -0.0664677, -0.0592114, -0.0573223, -0.00534414, 0.0674738, -0.0175266, -0.0103905, -0.0477542, -0.0067201, -0.0301512, -0.00201961, -0.0624557, 0.0576413, -0.00900053, -0.0012955, 0.0406465, -0.0745639, -0.0240427, -0.0529995, -0.0668372, -0.0640459, -0.0556605, 0.0521226, 0.0477303, -0.0675113, 0.0815245, -0.0704224, 0.0463946, -0.0285215, 0.0392827, -0.0418126, -0.0358281, -0.00452115, 0.033856, 0.0565939, -0.0268858, -0.0593655, -0.0813976, -0.0467005, -0.0431053, 0.0100715, -0.0489117, 0.0392, 0.0271788, -0.0815866, 0.0756592, -0.0459644, -0.0301695, 0.0627193, 0.0730089, 0.0635479, 0.0777438, 0.0375745, 0.0288936, -0.0178272, -0.0743207, -0.0322952, -0.014918, 0.000841312, 0.02696, -0.00788808, 0.013741, -0.0674505, -0.0197765, 0.0450872, -0.0250428, -0.00435031, 0.0636577, -0.071998, -0.0510653, -0.0558469, -0.0145309, 0.065511, -0.0258475, -0.0368011, -0.0200756, -0.0611793, -0.0375451, 0.068076, 0.013901, 0.0582066, 0.0135444, -0.0366431, -0.0681364, -0.0571054, -0.0314725, -0.0530206, 0.0537718, 0.0756735, -0.0684879, 0.0232916, -0.0395797, 0.0535904, 0.0459692, -0.0499282, -0.00312303, -0.042631, -0.0237281, 0.0638675, -0.0690003, 0.0455777, -0.0625877, -0.0066288, -0.0118937, -0.0551529, 0.00950477, -0.0600625, -0.00505164, 0.0739518, 0.0725897, 0.0343292, -0.0286816, 0.0268054, -0.0301899, -0.0406771, -0.0298656, 0.0445815, 0.0611103, -0.0312777, -0.0496235, -0.0785089, 0.0651526, 0.00816785, 0.0658555, -0.0245699, 0.0553172, 0.0667092, -0.00551941, -0.0399658, -0.0581766, -0.0264543, 0.077716, -0.000581622, 0.0395307, 0.0440959, -0.0297697, 0.0752687, -0.0311981, -0.0210936, -0.0713684, 0.0762623, 0.0249637, -0.0564873, 0.059178, 0.0536378, 0.0680366, 0.0238603, 0.0100782, -0.0266766, -0.0726198, -0.0165478, 0.072385, -0.0822658, -0.0603281, -0.0681241, 0.0483891, -0.0755563, 0.0758531, -0.062331, -0.0620212, -0.0549051, -0.0638285, -0.0813541, -0.0630699, -0.000232503, 0.0295963, -0.0464392, -0.060072}, {-0.0214847, 0.0747758, 0.00780609, -0.00876503, -0.047296, -0.0615035, 9.11579e-05, -0.00965888, 0.00765745, 0.0150242, -0.041342, -0.0138623, -0.0558195, 0.0363018, 0.0603773, -0.0337878, -0.00962958, 0.079902, -0.0512678, 0.0638866, -0.0173916, -0.0628312, 0.0679584, -0.0149361, -0.0367845, 0.0625765, -0.0146217, -0.0340658, 0.0579467, 0.0586992, 0.0749497, 0.04332, 0.0207256, -0.0152611, 0.0391786, -0.029146, 0.0208381, 0.00634574, 0.0432114, 0.041391, -0.0659347, -0.00835965, -0.0166019, 0.0528537, 0.00939558, 0.0304243, -0.0558, -0.033704, 0.0407066, -0.063427, 0.0620696, 0.0701109, -0.00741616, -0.0284095, 0.0351453, -0.0108945, 0.0217404, 0.0043628, 0.0208502, 0.0223637, -0.0596656, 0.0752321, 0.0642329, -0.0315073, 0.00865372, -0.0809137, -0.0484569, 0.0410316, 0.00708888, -0.0388504, 0.041777, -0.0539404, 0.0191308, 0.0081497, -0.0398402, 0.0359137, 0.032358, 0.0569867, -0.0528542, 0.058068, 0.0331317, 0.0338605, 0.0631523, 0.0414262, 0.00423414, -0.0619925, 0.0457828, -0.000341266, 0.0139651, 0.0110576, 0.024834, -0.0754154, -0.0305777, -0.00574011, 0.0666632, 0.00940681, 0.0292103, 0.0220099, -0.0333673, 0.00155257, 0.0272625, 0.0497413, 0.0326337, -0.0717949, 0.0216968, 0.0616895, -0.0416245, -0.0586306, -0.00564896, 0.0748121, -0.0638843, -0.0372667, 0.0225684, 0.0150847, 0.0427431, -0.0318797, -0.0427149, -0.0094348, -0.00648139, -0.0236396, 0.0730076, 0.0703853, 0.0116035, -0.0797632, 0.0520877, 0.0752068, 0.0314148, 0.0610003, -0.0022593, 0.0153293, 0.0477059, 0.0795081, 0.0321932, 0.0171582, -0.0693133, 0.027247, -0.0667208, 0.0288634, -0.0477966, -0.0359673, -0.0389959, -0.016747, -0.0430439, -0.05997, -0.0146044, 0.0682522, -0.0724401, -0.0613176, 0.00620791, -0.0247241, -0.00371693, 0.0608744, -0.0340009, 0.0282818, -0.0678168, 0.010897, 0.0742604, -0.0639704, -0.0510544, -0.018938, 0.0755716, -0.0129224, 0.0761942, -0.036194, 0.0252439, -0.0537145, -0.0437862, 0.0663569, 0.0680239, 0.0633997, 0.0601139, -0.0465392, -0.0110357, 0.0564202, 0.0758787, 0.0342951, -0.0423463, 0.0585874, 0.0756092, -0.0573006, -0.0449097, -0.0526654, -0.043733, 0.0797819, 0.039764, 0.0126712, 0.0813102, 0.0301839, -0.0252618, -0.0562422, -0.0382047, -0.0170803, -0.0469144, -0.0169049, -0.0250193, -0.00257143, 0.0593118, 0.0042839, -0.0474599, -0.0567116, 0.0410885, -0.0509257, -0.00920079, 0.0316598, -0.0201438, 0.029534, 0.00371657, 0.0336557, 0.0281477, -0.0651429, -0.0194745, -0.0255101, -0.0728143, 0.0823572, 0.0209069, 0.0114695, 0.0378876, -0.0786267, -0.00501274, 0.0357717, -0.0378242, -0.0535705, -0.0150044, 0.0542964, -0.0260211, 0.0700225, 0.0612605, -0.00168192, 0.0492887, -0.0286517, -0.0144824, -0.0449476, -0.0683177, 0.0474621, -0.0744011, 0.0460211, 0.079049, 0.0169387, -0.0302816, -0.0583246, -0.0416213, -0.0785049, 0.0756864, -0.0130286, -0.0217248, 0.0670346, -0.056907, -0.0778875, 0.0385546, 0.00736615, 0.0595599, 0.0253457, -0.00685115, -0.0206586, -0.0144829, 0.054973, -0.0497278, -0.0245117, -0.0544715, -0.0375948, 0.0485969, 0.0237493, 0.00364317, 0.0537151, 0.0796425, 0.0104686, 0.0530584, 0.0174481, -0.00834969, -0.0522343, -0.0253116, -0.0771185, 0.0355879, -0.0438988, 0.0252418, 0.0506076, 0.0454093, 0.0743911, -0.0526733, 0.0394032, 0.0377687, 0.0564253, -0.0732641, 0.0743447, 0.012661, 0.0459188, 0.069256, 0.0148226, 0.058723, -0.0754244, -0.0253627, -0.00453945, 0.0471119, -0.0605551, -0.00296919, 0.0653513, 0.0812208, -0.00484193, 0.0101477, 0.00405963, 0.0373608, -0.0237172, 0.0632385, -0.0302834, 0.0541641, 0.0259966, -0.0178728, -0.0301625, 0.0549474, 0.0771946, -0.0111973, -0.024572, 0.0522465, -0.0423641, 0.0703635, -0.00255994, 0.0274584, 0.00861103, -0.00422839, -0.0482548, 0.0629185, 0.00458621, -0.0712079, 0.0391917, 0.0809854, 0.0205648, 0.034884, 0.0823139, -0.0469148, -0.015639, -0.0177392, -0.0340671, 0.0445464, 0.0359203, -0.0602439, 0.0685379, -0.0241298, -0.0478842, 0.0419085, 0.00679631, 0.0371414, -0.00317413, 0.0675131, -0.0668017, -0.0606858, 0.00736505, 0.0229475, 0.0281502, 0.00546262, -0.05733, -0.0478576, -0.0676826, 0.00897088, -0.0459841, 0.00150587, 0.0776803, 0.0350407, 0.0122335, -0.0617025, -0.0648557, -0.0197231, -0.0648002, -0.0559046, 0.0334076, 0.0376097, -0.0726306, 0.0287903, 0.0631558, 0.0627888, -0.0374591, -0.029409, 0.0532834, 0.0148745, 0.0391004, 0.0820445, -0.0615616, -0.031067, -0.0160891, -0.0626066, -0.0516724, -0.0256173, -0.0799945, -0.0347589, -0.0557721, -0.00464901, -0.0708047, 0.0634278, 0.0365391, -0.0237765, 0.0580084, -0.0680613, -0.0475858, 0.0360566, -0.0509793, 0.0303259, 0.0737135, -0.0523505, 0.0138396, 0.0256501, -0.0516005, 0.00901695, 0.0384803, 0.0440352, 0.0552112, 0.0492872, -0.0113259, 0.0356318, -0.0732261, 0.0806278, 0.00581668, 0.0190437, -0.0735564, 0.0644797, 0.0537018, 0.0374925, 0.0423404, 0.0619691, -0.0561874, 0.0620709, -0.0649981, 0.0316289, -0.0702701, 0.0682827, 0.0540062, -0.0242162, 0.0401179, 0.0777611, -0.0419617, 0.0551983, -0.0518729, -0.0204622, -0.0810241, -0.202037, -0.0528955, -0.0113211, -0.0581641, -0.115659, -0.0453463, -0.0404314, -0.00704845, 0.0765816, 0.0586309, 0.137434, -0.0824504, 0.0464012, -0.162603, 0.16241, -0.0604203, -0.0444095, -0.0527996, -0.190978, 0.00860323, 0.0531552, -0.0213072, 0.0595992, 0.0543021, 0.110367, -0.0794568, 0.164839, -0.016189, -9.59637e-06, 0.0210238, 0.120846, -0.0391577, 0.021934, 0.00851075, 0.0554676, -0.0733567, 0.0234443, -0.0489188, 0.0126209, -0.0228363, -0.211063, 0.173338, 0.154531, 0.0471247, -0.0527204, 0.0771394, 0.0870407, 0.0719356, -0.0449819, 0.187766, 0.0602746, -0.0225923, -0.0537707, 0.0891551, -0.0301274, -0.110968, 0.0518367, 0.144146, 0.074536, -0.168384, -0.060151, -0.0234233, -0.0118358, 0.0132242, -0.0560548, -0.00233628, 0.0179856, 0.153807, -0.0949227, 0.0543403, -0.0069759, -0.050989, 0.0411538, -0.0103931, -0.0135343, 0.147657, 0.0553909, -0.0807831, 0.0371543, -0.0604924, -0.0265574, -0.0151748, 0.046312, -0.124343, -0.0113191, -0.0495323, -0.204932, -0.156197, -0.0282065, -0.064559, -0.0387299, -0.0990894, -0.0677893, -0.0334654, 0.0138854, 0.0701714, 0.0551164, 0.0531795, 0.0801284, -0.036381, -0.111751, 0.013138, 0.0151307, -0.0752896, -0.0780923, -0.00368795, -0.0347605, -0.0580285, -0.00750443, 0.106835, 0.0788587, -0.134777, 0.0174303, -0.0829876, 0.072248, -0.0597447, 0.0752539, 0.0309573, -0.146365, -0.0406288, -0.00582697, 0.0661494, 0.0960905, 0.0877428, 0.161461, -0.106661, 0.0753045, -0.0673755, -0.0106424, 0.0517848, 0.118402, -0.021461, -0.045043, 0.0825816, 0.129696, -0.211133, 0.0105706, -0.0465542, 0.0874121, -0.0447711, -0.0941538, 0.0569424, 0.0905305, 0.0764055, -0.047907, 0.137275, 0.0455078, 0.196815, -0.0115205, 0.0425741, -0.0106919, 0.0392922, -0.156138, 0.162908, -0.0387535, -0.0887281, 0.168094, 0.118271, 0.0735109, -0.133257, -0.0460087, -0.0363126, 0.085474, -0.109155, -0.0857321, 0.0587234, 0.0113177, 0.164226, -0.0705954, 0.0398643, 0.0323613, -0.142322, 0.0172174, -0.0342907, 0.0571484, 0.129307, -0.0166525, -0.0350767, 0.109657, -0.0649291, 0.0663415, 0.051893, 0.0464028, -0.084021, 0.0999899, -0.0800072, -0.0965217, -0.0274267, 0.0680063, -0.0547797, 0.00202402, -0.104507, 0.0295366, 0.0471403, 0.00513808, -0.0120839, 0.0672722, -0.0583479, -0.00148678, 0.00571918, -0.164605, -0.0118621, 0.0263534, -0.0621388, -0.0449889, 0.0309051, 0.0523202, -0.0530529, 0.047151, 0.137375, 0.0925705, -0.203469, 0.062289, -0.14605, 0.1923, -0.191151, 0.0402825, -0.0556728, -0.181629, -0.0405092, 0.0456026, -0.0532386, 0.0789368, -0.0534935, 0.0679688, -0.0666657, 0.1452, 0.0621773, 0.00846929, -0.0432272, 0.100565, 0.00738707, -0.0292102, 0.0511983, 0.129891, -0.191293, 0.00132068, -0.0770822, 0.0999775, -0.0181548, -0.134375, 0.173614, 0.136654, -0.0574934, 0.0224934, 0.153043, 0.0551672, 0.0703298, 0.0278239, 0.121762, 0.0504694, -0.0660447, -0.175846, 0.11595, -0.0266912, -0.0785151, 0.0685066, 0.163651, 0.0362288, -0.0946232, -0.0192726, 0.0468383, 0.108922, -0.0189005, 0.0353747, -0.0675409, 0.0320052, 0.00846555, -0.0135907, -0.00673055, -0.0905907, -0.0787187, -0.0063565, 0.0802852, 0.0669169, 0.14655, 0.0232099, -0.00618801, -0.0024237, -0.00905697, -0.0389916, 0.065763, 0.171989, -0.0258511, -0.0358256, 0.0765862, -0.123669, -0.166702, 0.106152, -0.0750637, -0.0566674, 0.0335713, -0.0465892, 0.0289192, 0.0354997, -0.0352374, 0.0529219, -0.0150098, -0.0479226, -0.078736, 0.0379141, -0.0342765, -0.0166025, -0.0220649, 0.0132888, 0.0480738, -0.00678148, 0.0457833, -0.0196009, -0.0179963, 0.0145443, 0.0537356, -0.0511333, -0.0415039, 0.0628455, 0.0108065, 0.00779942, -0.030775, 0.0396073, 0.0620959, 0.036499, -0.0376777, -0.0258508, 0.0560574, 0.00403922, 0.0701092, 0.0255549, 0.0375882, 0.0793344, -0.0559125, -0.0166685, -0.00284924, 0.0119611, -0.0705571, 0.0445786, 0.0305621, 0.0316501, -0.033588, -0.000976294, 0.0686939, -0.0815471, -0.061072, 0.0207288, -0.0447472, -0.0013221, -0.0818759, 0.0424601, 0.0771226, -0.0245841, -0.0452459, 0.0330755, -0.0763085}, {0.0481944, -0.0355727, -0.066205, 0.0653285, 0.0823775, 0.077114, -0.00949008, 0.0422155, -0.0536167, -0.00914235, 0.0191679, 0.0188983, -0.0586655, -0.0643038, -0.0024135, -0.0262424, -0.0704792, 0.0199476, -0.00887232, -0.0557112, 0.0500013, -0.0221233, 0.0030861, -0.0642191, 0.0570468, 0.0605214, 0.0660365, 0.0370612, 0.044281, -0.0422272, 0.0561188, 0.0362656, 0.0660409, -2.66358e-05, -0.0423085, 0.0586667, 0.0554863, -0.070567, 0.0727458, -0.0677544, 0.0174804, -0.0489748, 0.0756229, -0.061765, -0.0180222, 0.0347708, 0.0279601, 0.0680238, 0.0625992, -0.00788983, 0.0101869, -0.0595832, 0.0387527, -0.00423332, 0.0721389, -0.0470263, 0.0325592, -0.0558936, -0.069442, 0.0743955, 0.00595158, -0.0577111, 0.0145076, 0.0148519, 0.0255371, -0.00163572, 0.03752, -0.0547058, 0.00510626, 0.0478432, -0.0675923, -0.0111936, 0.0627716, -0.0139143, -0.0723627, -0.023793, 0.0532886, 0.011285, -0.0478335, -0.025625, 0.011363, -0.0175829, -0.0659736, 0.0581894, -0.00933432, -0.0497317, -0.0418457, 0.0763487, 0.0449134, 0.018554, -0.0768524, 0.0123934, -0.0391964, -0.0289105, 0.0570932, -0.0805464, -0.017923, -0.0744741, -0.0145579, -0.0370989, 0.0691426, -0.0384924, -0.039635, 0.0671512, -0.0815337, 0.000796117, 0.0294844, -0.0689922, -0.0561317, 0.0386624, -0.0309256, -0.0422726, -0.0332641, -0.0320987, 0.00189494, -0.0814907, 0.058616, 0.0614424, -0.0513959, -0.025919, -0.00816993, 0.0275445, 0.0407475, 0.0302181, 0.0594395, -0.0137087, 0.0376485, -0.0694895, -0.0550053, -0.0319271, -0.0809324, -0.0687357, -0.0694546, -0.00913277, -0.0720247, -0.0702665, -0.0417769, 0.0647303, -0.000410207, 0.0635118, 0.0768539, -0.041019, 0.0489442, 0.0705077, -0.0229702, -0.00993335, 0.0651945, -0.0681594, 0.0286176, 0.0155872, -0.0265002, -0.0443547, 0.0348943, 0.0700824, 0.0231148, 0.0213784, -0.0642007, -0.0278628, -0.0727525, -0.0445509, -0.0616507, 0.01584, 0.0714968, 0.0166189, -0.0761876, -0.0737874, 0.0493902, 0.0218016, 0.00383356, 0.00858455, -0.0447489, 0.0228527, -0.0464949, -0.0738875, 0.0784927, 0.0189297, -0.0502965, 0.063758, 0.051175, -0.0731869, -0.00113371, 0.0111131, 0.0176637, 0.0515391, -0.0175032, 0.0629527, 0.0139191, 0.0803901, -0.0160895, -0.0735786, -0.0707633, -0.0171483, -0.0357635, 0.00437078, -0.0523368, 0.0294378, 0.0179999, 0.0687602, -0.0721575, 0.0415421, -0.0105562, -0.0556996, 0.0416565, -0.0720969, 0.0522634, 0.0542288, -0.0506005, 0.0692689, -0.0493186, -0.0324831, 0.000608906, -0.0767993, 0.0499513, -0.00207673, 0.0185723, 0.054341, 0.0555829, 3.09721e-05, -0.0817271, 0.0536361, 0.0162112, 0.0820329, 0.0240686, -0.0702285, -0.0136485, 0.0661723, -0.0765944, 0.0653372, 0.0193035, -0.0731428, -0.0183873, 0.0281847, -0.0737245, -0.0782497, 0.040159, -0.0638232, -0.0233662, -0.0378519, -0.0557932, 0.0297206, -0.0497766, -0.0483416, -0.0287025, -0.0708942, -0.0170281, -0.0618628, 0.0614057, 0.00509019, -0.0277132, 0.0723085, 0.0704418, 0.0219143, 0.00274283, 0.051331, 0.0135031, -0.0400296, 0.0439847, 0.0216328, 0.0129388, 0.0391219, -0.00276434, 0.0677677, -0.0737793, -0.020566, -0.00486417, -0.0139319, 0.0771572, 0.00837112, -0.0591612, 0.0583181, 0.0405329, -0.00147012, 0.00635391, -0.0685769, -0.0461764, -0.0557748, 0.0134154, -0.0204041, -0.0731516, 0.0802544, 0.0422367, -0.0588763, 0.0527629, -0.0813424, -0.0226214, 0.0158719, 0.0403129, 0.0476142, 0.0619604, 0.0222198, 0.0702169, 0.0435496, 0.0456505, -0.0391028, -0.0688936, 0.0643994, 0.024536, 0.00551047, -0.0111974, 0.0297339, -0.00293311, 0.0804853, -0.0529594, -0.0121113, 0.00573549, -0.0197647, 0.0538861, -0.0396582, 0.0686802, -0.0311093, 0.0696248, 0.0133765, -0.055837, -0.0367618, -0.0589818, -0.0198006, 0.0203219, -0.00577074, 0.0749048, -0.0374862, 0.0376354, 0.013601, -0.0117196, -0.00464007, -0.0738801, 0.0119561, -0.0754346, -0.0503673, 0.0231167, 0.0629362, -0.0607052, -0.0433494, -0.0138263, -0.00676182, 0.0338342, -0.0163132, 0.0551567, 0.0335409, 0.0108226, 0.00238397, 0.0725704, 0.0221586, 0.0229196, 0.0692247, -0.0803865, 0.0370634, 0.0255669, -0.0490316, -0.030679, -0.0664191, -0.0314303, 0.0511372, 0.00441069, 0.0021712, -0.00310816, 0.0668242, -0.0649566, 0.00604362, 0.0319268, -0.0285015, 0.00310832, -0.0455422, 0.0280121, -0.0596379, -0.0249937, 0.030727, -0.0432322, -0.00252669, -0.0157458, 0.0475955, -0.0123067, 0.0136902, 0.0464483, -0.0178683, -0.0354408, 0.00681238, -0.018067, -0.0487888, -0.0736964, -0.0384459, -0.0566809, -0.0792065, 0.0586846, 0.0374126, 0.060123, -0.020278, -0.0167131, 0.068915, -0.0530866, -0.0477923, 0.0690819, -0.0361796, -0.00212079, 0.0101705, 0.0228235, 0.00915298, 0.00679549, 0.0456676, 0.0267053, 0.0762283, -0.0233333, 0.0318859, 0.0815056, 0.0480644, -0.00475681, -0.0605935, 0.00047911, -0.0222614, -0.0480099, -0.0813483, 0.0616254, 0.0480744, 0.00402559, -0.0809556, -0.0606414, -0.00553493, -0.0807683, 0.064227, -0.0620523, 0.062768, -0.0178641, 0.041929, -0.0362667, 0.0175523, -0.0571939, -0.0091439, -0.0726252, -0.0533102, -0.00407618, -0.0363018, 0.062943, -0.0649006, 0.0131788, 0.0297256, 0.0192019, 0.0812196, 0.0188034, 0.0334892, -0.00931703, -0.0767351, -0.0635259, 0.00329315, -0.0158714, -0.0153898, 0.0586367, -0.0579316, -0.0595778, 0.0745713, -0.0810495, -0.0424637, -0.0381628, -0.0201082, 0.0143444, -0.00438026, -0.0514184, 0.0577784, -0.039433, -0.0350163, -0.0272599, -0.0692374, 0.0224831, 0.0411083, 0.0723977, 0.0699811, 0.0125462, -0.0502798, 0.0599303, 0.0564396, 0.0707738, 0.0686307, -0.068886, 0.0341002, -0.0630548, -0.0438121, 0.0663874, -0.0634906, 0.077246, -0.00690505, -0.0629487, -0.0627993, 0.074961, -0.0658697, 0.00563707, 0.0542995, 0.0693663, 0.0610114, -0.0411675, -0.0657357, -0.0069243, -0.0220364, -0.0363872, 0.0551824, -0.0213955, 0.0463114, 0.0587504, 0.0258965, 0.0334324, -0.00029707, -0.0718627, 0.00437394, -0.0525748, 0.0657635, 0.0721187, 0.0189558, -0.0649316, 0.021325, -0.0143537, -0.0123708, 0.00575555, -0.0562083, -0.0299881, 0.0691567, 0.046799, 0.0520713, 0.0798027, 0.0759896, -0.0604153, 0.013101, -0.0512807, -0.0325824, 0.00963659, 0.0590962, -0.0496365, -0.0787237, 0.0257483, -0.0450657, 0.0438063, -0.00490987, -0.0607926, 0.00502276, 0.0578387, -0.0697953, -0.0315423, -0.0737019, -0.0363447, -0.0751307, 0.0510947, -0.0614408, 0.0461048, -0.0106836, -0.0318662, 0.0183377, -0.0569509, 0.0510565, -0.0683156, -0.00559949, -0.0449806, -0.0651901, -0.0635359, 0.0813472, 0.0407607, -0.0377905, -0.052979, -0.00869508, -0.0756978, 0.0633361, 0.0131161, 0.0501927, 0.0676567, -0.0438937, 0.0152526, -0.0493949, 0.0588681, -0.066314, -0.00439971, 0.0565125, -0.000932299, 0.0259634, -0.0175262, -0.000572808, 0.0817996, -0.0323835, -0.0690921, -0.0642631, -0.075021, -0.0517033, -0.0329538, 0.0488748, -0.0208782, -0.000473827, -0.0627866, -0.0208701, 0.00578091, 0.0236301, -0.0560925, 0.0784459, -0.0783269, 0.064778, -0.0363381, 0.077905, 0.0798964, 0.0176255, 0.00319055, -0.0319078, -0.0355419, -0.00184529, 0.0131738, 0.0509833, -0.042995, -0.071474, -0.00289483, 0.0231417, 0.0339118, -0.0512802, -0.0353195, -0.0623571, 0.0600111, 0.000973783, -0.0589212, -0.0611876, 0.000611342, -0.0607795, 0.00965258, 0.0408645, 0.0274623, -0.0740793, -0.0541479, -0.0508136, 0.0789352, 0.0582102, 0.0289364, 0.0725064, 0.0430188, 0.0299529, 0.0163904, -0.0384085, 0.0812539, -0.0252638, 0.0118666, 0.0518929, -0.0578942, 0.0604664, -0.06349, -0.0380091, -0.0287183, -0.0109232, -0.0139246, 0.0619056, -0.0352112, -0.0134866, 0.0148565, -0.0226579, 0.0132002, -0.0406258, 0.052959, 0.0445193, 0.072946, -0.0769613, -0.0645197, 0.0600693, -0.0549784, -0.0193487, 0.0608421, -0.0390974, -0.0786159, -0.00856145, -0.00311334, 0.0490922, 0.0557065, -0.0210744, -0.0429529, 0.0578818, -0.0795622, -0.0127106, -0.04255, -0.0754465, 0.0451799, -0.0645707, 0.0816741, 0.0808594, 0.016408, 0.0403444, -0.071097, -0.0196872, 0.0796784, -0.0660443, -0.0392345, -0.0614205, 0.069919, 0.00918633, 0.0537915, 0.00636041, -0.066944, -0.0584974, -0.0042555, 0.0168345, 0.0374664, 0.00896227, 0.0285142, 0.0528937, -0.00233341, 0.0451187, 0.071193, -0.0804452, 0.0252408, -0.0332254, 0.0518071, -0.0292518, -0.032188, 0.0596681, 0.0387111, 0.0229887, 0.0350037, -0.0330511, -0.00767235, -0.0436894, -0.0595411, 0.0427353, 0.0737739, 0.031056, 0.0668221, 0.0628571, -0.0118333, -0.0112635, 0.0617649, 0.00150695, 0.036069, 0.0586858, 0.00753488, -0.000900418, 0.0517834, 0.0735311, 0.044247, -0.0789601, 0.00974765, 0.050713, -0.074966, 0.00181537, 0.0145355, 0.0152052, 0.00970644, -0.0676118, -0.037857, -0.0221069, -0.0365443, 0.0655529, 0.00331949, -0.0794197, -0.078903, -0.0556962, 0.0607007, 0.0126573, 0.0361075, -0.0805319, -0.00247195, -0.0153763, 0.0429788, 0.0287911, -0.00364649, 0.0343776, 0.0697911, -0.0807745, -0.00462723, 0.0401701, 0.0760403, -0.0320577, -0.0530342, -0.0253893, 0.0221659, -0.00589053, -0.00585814, 0.0615467, -0.022711, 0.0138723, 0.0234871, -0.00455919, 0.0590404, -0.00517915, 0.0135357, 0.0609625, 0.0603111, -0.0327933, -0.0611412, -0.0071501, 0.0469854, -0.0538633, 0.05225, 0.00795173, 0.0648815, -0.0356363, 0.0176179, -0.0817976, 0.0871308, 0.08293}, {0.025238, -0.0787262, -0.0761155, 0.0353615, -0.00587995, 0.0445687, 0.0710436, 0.0487609, -0.0231644, 0.0525729, 0.0136777, 0.0496225, 0.0665855, -0.0540236, 0.0175348, -0.0509762, -0.0541012, 0.0381722, -0.0440016, 0.0364836, 0.0460836, 0.00436241, 0.0475808, -0.0187523, 0.0701011, 0.00271113, 0.0254726, -0.026532, 0.0410965, -0.0558414, -0.0383065, -0.0065058, -0.0585615, 0.0812638, -0.03458, 0.0471234, -0.0253912, 0.026095, -0.075084, -0.0604948, -0.0411091, -0.0516755, 0.0242327, 0.0565903, 0.05239, 0.0648866, 0.0648768, -0.0358949, -0.063166, -0.0032237, -0.0407995, 0.0463334, -0.0745153, -0.000855103, 0.0434603, -0.0753315, -0.0253339, 0.0180005, 0.0246141, 0.104461, -0.00826902, 0.00463396, 0.0731749, 0.036279, 0.0171843, 0.00513399, -0.0550098, 0.0712346, -0.0634706, 0.00728594, 0.0473435, 0.00220401, -0.0461967, 0.0793769, 0.0712916, 0.0349395, 0.0141603, -0.0144454, -0.0444439, 0.024262, -0.00343584, -0.00891834, 0.002759, 0.00702842, -0.112131, 0.0535989, 0.050541, 0.0408196, -0.0626798, -0.0844026, 0.0795919, 0.0594286, 0.00879423, 0.0692057, 0.0666133, -0.0658143, -0.0045046, -0.0236706, 0.0529899, 0.0661759, 0.00599083, 0.0557624, -0.0831622, 0.0590151, 0.0765033, 0.0990231, -0.00641064, -0.0166984, -0.0061723, 0.00870048, 0.0685292, 0.0575004, 0.0422569, -0.0390057, -0.0118333, 0.0756863, 0.00634041, -0.0204082, -0.00897082, 0.0420185, -0.00404295, 0.0710841, -0.040834, -0.0372566, -0.0231723, -0.015116, 0.0989332, -0.0321947, -0.00877887, -0.0815008, -0.040643, -0.0607652, -0.00456089, 0.0076135, 0.0674561, -0.00455633, 0.0760695, 0.0271243, -0.0184554, 0.0592962, -0.0798413, -0.0123039, 0.0525324, 0.0568767, -0.00432279, -0.0476398, 0.0718878, 0.0747999, -0.00131061, 0.0117467, -0.0309373, 0.0736618, -0.0286362, -0.00529303, 0.0332793, -0.00234355, -0.00455495, -0.0385806, 0.0617071, 0.0525567, 0.0351266, -0.0525111, 0.0488835, 0.0733103, 0.0446659, -0.0954884, -0.0713743, -0.0747149, 0.0316643, 0.0244009, 0.0183819, -0.0295402, 0.00939503, 0.0348843, 0.000387147, -0.00366156, 0.0019486, -0.0797162, 0.0543125, 0.00761314, 0.0478297, 0.0584115, 0.0346773, -0.0462095, -0.0948732, 0.00918065, -0.0525348, 0.0315072, -0.0107428, -0.0847524, -0.0208786, 0.0456018, 0.077974, 0.0222433, 0.0275468, -0.00507077, 0.0372951, -0.0174768, -0.0579035, -0.00202619, -0.0635483, 0.0637424, 0.0235175, -0.0164069, 0.0548966, -0.0415948, -0.00606303, -0.0768913, -0.048364, 0.0382539, 0.0723405, 0.0477357, 0.0651345, -0.0635508, 0.0244214, 0.0348237, 0.0774371, 0.0379244, -0.0114489, -0.0172536, -0.0505892, -0.0410974, -0.0420296, 0.0255948, -0.00173352, 0.0646953, -0.0392786, 0.00707053, 0.0499665, -0.0627561, 0.0481361, -0.0473935, -0.0394644, -0.0711834, -0.0148605, 0.05954, -0.0552827, 0.0538192, 0.00473502, -0.0603717, 0.0786144, 0.0239127, -0.0885241, 0.0122647, 0.0697112, 0.0395012, 0.0520921, 0.0132712, -0.0635109, -0.0421254, -0.0558552, -0.0601028, -0.0191144, -0.0572462, 0.0315571, 0.0263637, 0.0230114, -0.0303107, 0.0703007, 0.0148108, -0.00434334, 0.00897433, -0.0498057, -0.0214175, 0.045388, 0.0154483, -0.0563404, 0.0606088, -0.012904, 0.0110832, 0.0311641, -0.0669184, -0.0698789, 0.0337524, 0.053108, -0.0671627, 0.0194707, 0.062935, 0.00153097, -0.0508875, 0.0200108, 0.0057637, -0.0637966, -0.0808099, -0.0959658, 0.113634, -0.0462421, -0.0381982, -0.013452, 0.0616556, -0.0341551, -0.0260123, 0.071813, -0.0743043, 0.0120096, -0.00922469, -0.0554462, 0.0350273, 0.039221, 0.0656207, -0.0488806, -0.0078345, 0.0332047, 0.0385588, -0.0212556, 0.0757783, -0.0545589, 0.0246065, 0.0551887, -0.0170293, -0.0099644, -0.0158983, -0.0436243, 0.0332562, -0.0451641, -0.0547019, -0.0279751, 0.0843427, 0.0551441, 0.0602207, -0.0681918, 0.0460707, 0.0475393, -0.0285293, -0.0450193, -0.0656558, -0.0430251, -0.0183396, 0.0263464, 0.0149987, 0.0445421, -0.0286797, -0.0423251, -0.0231198, -0.016339, -0.0565318, -0.0394594, 0.0341152, -0.0199083, -0.0690773, 0.0344436, -0.0354669, 0.038285, 0.0682614, 0.0124879, -0.0443135, 0.00729738, -0.0166746, 0.0652863, 0.07288, 0.0026179, 0.00522309, -0.0164641, -0.0169653, 0.0879868, 0.016248, -0.0361283, 0.00132479, 0.0523075, -0.0425479, -0.0232161, 0.0740897, 0.0077992, 0.00887638, -0.0639469, -0.0320418, 0.0106467, 0.0254426, 0.0552292, 0.0748691, -0.0432707, -0.079752, 0.0233984, 0.0108155, 0.0302258, 0.0274697, -0.054737, -0.0364874, 0.0338149, -0.0304879, -0.0167869, 0.0394621, -0.037695, -0.0438504, -0.016585, -0.0812546, -0.00687584, 0.0610146, -0.0622567, 0.0475862, -0.0558353, 0.0528521, -0.0587236, 0.0555639, -0.0434763, -0.024605, -0.0499716, -0.0588018, -0.0563001, -0.0246408, -0.0496909, 0.0477698, -0.0466155, 0.0233409, 0.0293947, 0.0657477, 0.0709664, 0.0180389, 0.0477793, -0.0508383, 0.000748664, 0.0664346, -0.00369234, 0.0164284, -0.0720501, -0.0429122, 0.0385422, -0.0668541, -0.071036, 0.0303204, 0.0405603, 0.0519464, 0.0805725, 0.07105, 0.0137707, 0.034389, -0.0624001, 0.00553037, -0.0134221, 0.063866, 0.0299868, -0.0469472, -0.00209931, 0.0383123, -0.0144904, -0.0791248, -0.0504395, 0.0807623, 0.0783993, 0.0487383, -0.043099, 0.0497452, -0.0746044, -0.0391868, 0.077636, 0.0120853, -0.0399398, -0.0158177, 0.0701228, -0.0644103, -0.00062643, -0.0650111, 0.0144111, -0.0251419, -0.0559438, 0.0254766, -0.0644838, 0.0491436, 0.0302725, -0.0764018, 0.046857, -0.0732533, -0.0145409, -0.0543088, 0.00879292, -0.0154496, 0.0474597, -0.0590109, -0.0557672, -0.0120186, -0.0100712, -0.0327608, -0.00728147, 0.0400686, -0.0231691, 0.00336596, 0.054202, 0.0332219, 0.0640406, 0.0213531, -0.0765961, -0.0577193, 0.0522472, 0.0499155, -0.00361591, 0.0789672, -0.0422639, -0.0561292, 0.0611929, 0.0143242, 0.0714997, -0.049689, -0.0799674, -0.00816289, -0.081398, 0.0467828, 0.0354967, -0.057981, 0.0163936, -0.0351858, -0.0711244, -0.0812874, -0.0767755, 0.0218371, -0.0060591, 0.0593084, 0.0692748, -0.0388943, -0.0782436, 0.000821397, 0.0278004, -0.00601964, -0.080879, 0.0132899, -0.0580963, 0.00645593, -0.0750335, -0.0739739, -0.063262, 0.0419174, 0.0433721, 0.0742582, 0.0320237, -0.0527617, -0.0457562, -0.00288874, 0.0296508, 0.0734161, -0.0616595, 0.029309, -0.0125912, 0.0548277, -0.0141112, -0.0690069, -0.0292468, -0.0612729, 0.0589172, -0.0440089, 0.0517693, 0.0263494, 0.0611213, -0.0169229, -0.0685202, 0.063764, 0.0673253, -0.0125265, 0.0172463, -0.0289965, -0.032926, 0.0145745, 0.0199678, 0.0500457, 0.00872806, 0.0119823, -0.0794972, 0.0295456, -0.0297108, 0.0238422, 0.0609658, -0.0447135, 0.0533433, -0.0654542, -0.0205121, -0.0545727, -0.0557735, 0.0589742, -0.00145309, -0.0156326, -0.0539456, 0.0349457, -0.0322962, 0.0801127, 0.0145166, -0.0260043, 0.0318697, 0.0796786, 0.0213466, -0.00967721, -0.0210829, -0.00762959, 0.0704116, -0.0483721, -0.0377246, 0.0290484, 0.0759697, -0.0765889, -0.0433803, 0.0257149, -0.00458122, 0.0197193, -0.0105451, 0.0747739, 0.0237753, 0.0366029, 0.0813731, 0.0382044, -0.0195385, -0.0429753, -0.0633254, 0.0610849, -0.0745514, 0.00531225, 0.0662668, 0.0592639, 0.0432499, 0.0762166, -0.0690986, 0.0168907, 0.0257734, 0.0779189, -0.0325836, 0.018314, -0.00235911, -0.0751573, 0.0758886, 0.0765028, -0.0507422, 0.0195681, 0.0608424, -0.0816706, -0.0568372, -0.0267435, -0.0766346, -0.07958, 0.012107, -0.0297525, -0.0536846, -0.0199563, -0.0694704, 0.0247087, 0.0420785, -0.0726963, -0.016607, -0.0586471, 0.0815364, 0.0612681, -0.0695222, -0.0371853, 0.0554543, 0.0602014, -0.0315385, 0.00525982, 0.00256278, -0.0328532, 0.0592148, 0.0298155, 0.0330288, 0.0504226, 0.0780645, -0.0301524, -0.0799784, -0.0162862, 0.00667689, -0.00502641, 0.0126373, 0.0356725, 0.0675573, -0.0445202, -0.0500407, -0.0486791, -0.0652095, -0.0476755, 0.0649012, -0.0531776, -0.0306957, -0.0566821, 0.0248036, 0.0593962, -0.00710982, -0.0739747, 0.0756094, 0.0370492, -0.0465559, 0.0107951, 0.0471889, 0.0448168, -0.00520877, 0.00308205, 0.0218154, 0.00753026, -0.07862, -0.0291004, -0.00783958, 0.0672896, 0.0602327, -0.0263751, -0.00964445, -0.0287097, 0.0569771, -0.0125432, 0.0015117, 0.0411237, 0.074075, 0.0481196, 0.0812752, 0.0754759, 0.00661089, -0.0694856, -0.0135702, -0.0380658, 0.00837006, -0.078361, 0.0550581, -0.0536623, -0.0693959, -0.0265106, 0.0335972, -0.0304433, -0.0555131, 0.0263714, -0.0503996, 0.0336068, -0.0557956, -0.0651516, 0.032944, 0.0339784, 0.0342958, 0.00827193, -0.0122499, 0.0731988, 0.0758125, 0.0806744, -0.0557798, 0.00271327, -0.0456891, -0.0414576, -0.00129442, 0.0474456, 0.0163481, -0.0419049, 0.00111406, -0.0660965, -0.0466189, 0.039122, -0.000603169, 0.0663315, 0.0682152, -0.0646346, -0.0123971, 0.0802817, -0.0197788, 0.0741273, 0.0109372, 0.0326209, -0.0572199, 0.0520149, -0.0107378, -0.01954, -0.0117531, -0.0669582, 0.0130343, -0.0581157, -0.0650425, -0.0589094, 0.0702706, 0.0669143, 0.0541084, -0.000816174, 0.0262464, -0.0198996, -0.0645029, -0.054405, 0.0455674, -0.044163, 0.0412282, 0.0731906, -0.020603, 0.0820774, -0.0209998, 0.0100494, 0.0734452, -0.0319542, -0.0606899, -0.0448461, -0.0404321, -0.0682751, 0.0299361, 0.0749874, -0.0733155, 0.0374652, 0.0622037, 0.0581911, -0.0342921, 0.00774775}, {0.0366114, -0.0467178, -0.0344474, -0.00656954, 0.0609106, -0.0255288, 0.0474189, 0.0193507, -0.0192276, -0.0342663, 0.0599314, -0.0730542, 0.00172669, -0.00590204, -0.0516597, 0.0604658, 0.015217, -0.070683, 0.00410242, -0.0490624, -0.0810279, -0.0411822, 0.0239764, -0.0252827, -0.0171011, 0.0557368, -0.0768853, 0.0764281, 0.000495195, 0.0184076, 0.0336519, 0.0446707, 0.0506601, 0.0303383, -0.0332776, 0.0653251, -0.0397162, 0.0508711, -0.00815773, -0.00750962, 0.0390114, 0.00456463, -0.0403341, -0.0253625, -0.0545383, 0.00991203, 0.00120036, 0.0700007, -0.0129474, 0.00895734, 0.0559831, 0.0102673, 0.0281683, -0.03374, -0.000372432, 0.0385984, 0.0714429, -0.0526725, -0.0321586, 0.034145, -0.0127342, -0.0682541, -0.0446156, 0.0461335, 0.0664771, 0.0414203, 0.0519938, -0.0549954, 0.00616325, 0.0375866, -0.0395527, 0.0643246, 0.0552233, -0.016974, 0.0484136, 0.0341169, -0.0287261, -0.00332507, -0.0584084, 0.0711482, 0.0731136, -0.0802871, -0.00910071, 0.0359884, -0.0545551, -0.0534594, -0.0741151, -0.0816208, 0.00633077, 0.00807378, -0.0624272, 0.0175969, 0.0465427, -0.0526928, 0.013049, -0.0402486, -0.0454028, 0.0488333, 0.0319955, 0.0123415, -0.0124514, 0.0544967, -0.0506013, 0.0794601, -0.0199338, -0.0373654, -0.0613256, -0.0216224, -0.00567928, 0.00979909, -0.0783873, 0.0673316, -0.0673186, -0.0531841, -0.0461471, -0.0457129, 0.00643971, -0.0687137, 0.0161099, 0.0290937, 0.0162914, -0.0144587, 0.0688257, -0.080469, 0.0800917, 0.0205616, 0.00184807, -0.0654906, 0.0784337, -0.017999, 0.0268711, -0.0728273, -0.0485478, 0.0621301, -0.0128128, 0.0771188, -0.030496, -0.0252523, 0.0302546, 0.0803902, -0.0386302, 0.0252798, -0.053289, -0.0778912, 0.00518496, 4.51356e-05, 0.0218707, 0.010994, -0.0607911, 0.0714698, 0.0281483, -0.0821511, -0.00810684, -0.0803473, 0.00330841, 0.0818598, 0.0251981, -0.036446, -0.00163468, 0.0201235, 0.0347715, -0.078578, 0.00883497, 0.00277676, -0.0371703, -0.00994668, 0.044387, 0.0811221, 0.0644677, -0.0692523, -0.00774945, 0.0173979, 0.0686558, 0.0199812, -0.0452365, 0.0690667, -0.0648251, 0.0201176, 0.0101509, -0.0788824, -0.0639848, -0.0804843, 0.0135235, -0.0803414, 0.0182915, 0.0502359, -0.0802449, -0.0328823, -0.0665119, -0.0588994, 0.0352488, -0.0788505, 0.0636073, -0.0544159, -0.0647521, 0.0229786, -0.0154801, 0.0725456, -0.0821046, 0.0794534, 0.0405952, -0.0815418, 0.00179339, 0.0484165, -0.059358, 0.0809917, 0.0583728, 0.0121382, -0.0778815, -0.0758511, -0.0427954, -0.0805494, 0.0673807, -0.0225134, 0.0550407, -0.00838748, -0.0806489, 0.0293549, 0.0633234, -0.0545547, -0.0767069, -0.0506602, -0.0743013, -0.0128199, 0.0144642, -0.0576042, -0.0574754, 0.00156342, 0.00871659, -0.0816086, -0.0257848, 0.00269607, 0.0630033, -0.0632757, 0.0815137, 0.0665155, 0.0344494, -0.047813, 0.0181916, 0.0233393, 0.0498427, -0.0365702, 0.0686366, -0.00513779, 0.0712691, 0.0524535, 0.0685063, -0.0630385, -0.0279567, -0.0618498, -0.076267, 0.034661, 0.0499366, -0.030332, 0.0816263, -0.0580058, -0.047449, -0.0753007, -0.0537086, -0.0781861, 0.0773043, 0.000319444, -0.00970412, 0.0380168, -0.00838758, 0.0171138, -0.080525, 0.0690969, 0.0378403, -0.0528629, -0.0324042, 0.053718, 0.0083724, -0.0331723, -0.00656339, 0.0240922, 0.0456157, 0.0380187, -0.00390229, 0.0788817, -0.0420986, -0.0755688, -0.109665, -0.0259782, -0.0162153, -0.0132633, 0.0159489, 0.0316973, -0.00215496, -0.0182641, 0.0177246, -0.0639292, -0.0828871, -0.0619182, -0.0634208, -0.125779, -0.025887, 0.130597, -0.0895672, -0.0501964, -0.0321829, 0.0638822, 0.0715893, 0.101661, -0.0441878, 0.0412613, 0.0451056, 0.0128004, 0.0795001, 0.0502417, -0.0522231, -0.0327688, -0.0756366, 0.0547919, 0.0326579, 0.0805315, 0.0233064, 0.0221703, 0.01958, -0.00316469, 0.0239335, 0.0478539, 0.0537273, 0.115967, 0.0422081, 0.0504361, 0.0627302, 0.0399798, 0.0454716, 0.0113045, -0.0629917, 0.0767607, -0.00710454, -0.000872757, 0.00881009, 0.115584, -0.0498083, -0.0568931, -0.0173175, 0.110043, 0.0201459, -0.0262291, 0.070861, 0.0673056, 0.0846244, 0.0102326, 0.0302462, -0.000642061, 0.0634696, -0.0210474, 0.0798385, -0.0626938, 0.0767711, 0.0410857, 0.0183095, -0.00758235, -0.0122668, -0.03699, -0.00825304, -0.00832674, -0.0388284, -0.0521039, 0.0503708, 0.034773, -0.0178578, 0.0749193, -0.0423403, -0.103106, -0.031086, 0.0289866, 0.0053783, 0.058, 0.0385153, -0.030232, -0.0834677, -0.0452503, 0.0524834, -0.0871914, -0.00688611, 0.0194275, -0.0237817, 0.0473353, -0.0543204, 0.0647549, 0.0781286, -0.0364782, -0.0942386, 0.0538279, 0.00806282, -0.0380877, 0.055539, -0.0104479, 0.0397946, -0.0985646, -0.0156814, 0.0321277, 0.0150435, 0.119805, 0.0148738, 0.0558208, -0.133103, -0.0220845, 0.0717787, 0.0683487, -0.0172392, 0.0319014, -0.0285444, -0.00792521, 0.0133971, -0.00418992, 0.0721016, -0.00495786, -0.0767654, 0.0742356, -0.00922603, 0.109915, -0.0490125, -0.0700215, -0.0642637, -0.0288261, 0.02603, 0.00652449, 0.0298304, 0.0268997, 0.113554, -0.0751423, 0.0325864, 0.00260143, 0.0532235, -0.0289365, -0.0149883, -0.0751168, 0.0675872, 0.107371, -0.0440928, 0.0350589, -0.0437741, -0.0920378, -0.0137864, -0.0414409, -0.0782321, 0.0730569, 0.000797352, -0.0543294, 0.072677, 0.0299095, -0.0275705, 0.027958, 0.0706405, 0.0504545, -0.0300512, -0.0676051, -0.0134318, -0.0210271, 0.0435483, -0.0517944, -0.0687208, -0.102265, -0.110121, 0.0142059, -0.0887264, -0.0173865, -0.0573748, 0.0734588, -0.0298332, 0.0267713, -0.0739203, -0.0534002, 0.0546922, 0.0634696, -0.0195546, -0.0126183, -0.0462436, -0.0498359, 0.0349611, -0.0784991, -0.00632924, -0.0127096, -0.0529506, 0.054965, -0.0201836, 0.0460332, -0.00810853, -0.0305311, 0.0356486, 0.0362368, 0.0487365, 0.0681169, -0.0667802, -0.0306475, -0.0233118, -0.0743511, -0.043774, -0.0947225, -0.0319639, -0.0233032, 0.0352133, 0.00923061, -0.00872993, -0.0274617, -0.0980702, 0.0371798, 0.0302616, 0.0259121, 0.0786517, -0.0579892, 0.0249766, 0.0147064, 0.0161562, 0.00696594, -0.0706857, -0.0583594, -0.00238045, 0.0510267, 0.00378205, -0.0249386, -0.0454722, 0.0355378, 0.0124245, -0.0751875, -0.0436573, 0.0913698, -0.0676206, 0.0918572, 0.0799841, -0.00236926, 0.0509517, -0.055481, 0.0614221, 0.0230323, -0.00385843, -0.0328263, 0.0190755, 0.0253273, 0.0520851, 0.000316877, -0.0200113, -0.022028, -0.0136164, -0.0124129, -0.0806141, -0.0486086, -0.0450951, -0.0521757, 0.0441058, -0.0238074, 0.0588377, 0.000479914, 0.061231, -0.030533, 0.0381556, 0.0275163, 0.0671001, -0.044178, 0.0219776, -0.0637119, 0.00574605, 0.00491634, -0.014558, 0.0122069, 0.0658332, 0.0404841, -0.0438363, 0.0308703, -0.0733215, 0.0428628, 0.00541531, -0.047951, -0.0237421, 0.00063635, -0.035207, 0.0563552, 0.0840045, -0.0432346, -0.0530834, -0.0566062, -0.0869622, -0.0185789, 0.0286262, 0.0193115, -0.048119, 0.0703672, 0.0246992, -0.00917736, 0.0478224, 0.0729448, -0.0787294, 0.0190634, 0.069922, 0.0730954, -0.0537515, -0.0551991, -0.0210136, 0.0284402, 0.00743453, -0.118034, 0.0905845, 0.0489923, -0.110575, -0.0579265, -0.0223702, -0.0228769, -0.00555551, 0.0289664, 0.0444011, 0.0791492, 0.0202173, 0.026533, 0.0150157, 0.0476069, -0.00277028, 0.028235, -0.00962909, -0.0488006, -0.0314017, 0.10053, 0.0698256, -0.0416601, 0.0726301, 0.00884131, 0.0413026, 0.0839308, -0.00788349, -0.00792647, 0.0513157, 0.0269247, 0.0822942, -0.063162, 0.104363, 0.076598, -0.011205, -0.0814576, -0.0416565, 0.0775007, -0.0692722, -0.00141468, 0.0775891, -0.0672257, 0.0400495, 0.0561897, -0.0129052, 0.025831, -0.0393126, 0.074379, 0.0551803, 0.0172621, 0.0833935, -0.0694399, -0.0182552, 0.0629295, -0.00140528, 0.0671453, -0.0063208, 0.0793222, -0.105846, -0.000258235, -0.0489513, 0.0156265, 0.0452181, -0.0457867, 0.0634746, 0.0719075, -0.00555512, -0.000557754, 0.00926397, -0.00841534, 0.0303225, 0.0146785, -0.0745221, 0.111534, 0.0968749, 0.0155109, 0.0392386, -0.0928108, 0.0297097, -0.00163882, -0.00458745, 0.0258855, 0.0499977, -0.0179509, -0.0662162, -0.00486878, -0.00336402, 0.0516987, 0.0387335, -0.0325392, 0.0294001, 0.0130749, 0.0645167, -0.0435863, -0.0159116, -0.0741937, -0.0143501, 0.082022, -0.0534528, -0.0513384, 0.0777806, -0.0712571, 0.0648634, -0.0294443, 0.0614582, -0.0320412, 0.0535861, -0.0495662, -0.0812021, 0.0539676, 0.0542154, -0.0408576, -0.0707894, 0.0313638, 0.0121981, -0.0265376, 0.0425679, 0.0374547, -0.0180443, -0.0782135, -0.0734191, -0.0111103, -0.00374309, -0.000705138, -0.0641778, 0.0134999, -0.077433, -0.0205835, 0.0132984, -0.0326476, 0.0283835, -0.0191589, 0.0210347, -0.00194679, 0.0823491, 0.0771266, 0.0297238, -0.0395465, -0.0437343, 0.0447672, -0.0203283, -0.00369888, -0.010544, -0.0477378, 0.0544231, -0.0615792, 0.0197784, 0.0203933, -0.067925, -0.0654182, 0.0771975, -0.0186301, 0.0224378, 0.0768525, -0.0774983, -0.0107192, -0.0552688, -0.0146611, -0.0632786, 0.0770108, 0.0164019, 0.0220303, 0.0722289, 0.00634091, -0.0688168, -0.0766345, -0.0387839, 0.0609168, 0.03235, 0.0510659, -0.0178179, -0.0506631, 0.0218787, 0.0795902, -0.0157169, -0.0707997, 0.0590192, 0.0476388, 0.0735082, 0.0499002, -0.0631233, -0.0505399, -0.044482, -0.0645757, -0.0391538, 0.00442188, 0.0158733, 0.0429631}, {0.0624871, 0.0489706, -0.00326713, -0.0350277, -0.0648518, 0.0523285, 0.0583416, -0.0363205, -0.00652825, -0.0673191, 0.0820466, -0.0748253, -0.0417976, -0.0557277, -0.0120425, -0.0805362, 0.0137513, 0.0215822, -0.0595001, 0.058079, 0.0702289, -0.0124845, 0.0716576, -0.0653962, 0.0719032, -0.0562173, 0.0206372, 0.0477535, -0.00672086, 0.0265972, -0.0294315, -0.0253138, 0.0459244, 0.00434734, 0.0543495, -0.0915288, 0.0432808, -0.0155884, 0.0640485, 0.038499, -0.0745657, -0.0751143, 0.0174546, -0.0707001, -0.00672629, -0.0358131, -0.0259051, -0.0102742, -0.00130478, 0.0822642, 0.0615626, 0.0570729, 0.0541276, 0.0201517, 0.0235224, -0.0607016, -0.0124116, 0.0559362, -0.0118698, -0.0158095, -0.0559765, 0.00647141, -0.0100674, -0.0234805, 0.0650555, -0.0313546, -0.0550923, 0.0555194, 0.00354284, -0.0623148, -0.0422624, 0.0428202, 0.0104774, -0.0410511, -0.0581152, -0.035939, -0.0643394, 0.0445848, 0.0227997, -0.0723245, -0.0105503, -0.0795818, -0.011876, 0.0274983, 0.0400913, 0.00666501, 0.0729461, 0.040206, -0.0687133, 0.0110669, -0.0703595, -0.022114, 0.0183656, -0.0337963, 0.013392, 0.055903, 0.00150331, 0.0465415, -0.0686493, -0.00706553, -0.0568167, -0.0186544, -0.0439418, 0.0438966, -0.0591165, -0.0246718, 0.0458702, -0.044648, -0.016325, -0.0151772, 0.0800447, -0.0284214, -0.0269492, 0.0167065, -0.0620384, -0.0368594, 0.0347304, -0.0528058, -0.0501557, 0.00109117, 0.00611789, 0.0113935, -0.01989, -0.0407129, 0.056643, -0.0283099, 0.0142126, -0.0541737, 0.0457731, -0.0474392, 0.052233, 0.0523578, 0.00115316, -0.0484635, -0.0653574, -0.00553691, 0.0184083, 0.0130676, 0.027311, -0.0374278, 0.0506238, -0.062525, 0.00954309, -0.0506442, -0.0315658, -0.0551537, 0.0399713, -0.0652852, -0.0933524, 0.0762295, 0.0413003, -0.0352158, -0.0792444, -0.0315291, 0.0558691, -0.0427671, -0.0548816, 0.0100059, -0.0200062, -0.0234587, -0.0375046, 0.00471505, -0.0668267, 0.0157629, -0.0376138, -0.0214433, 0.0225517, -0.0643838, 0.0448058, 0.0228626, -0.055312, 0.0189857, -0.000857949, -0.02198, 0.0270633, -0.0117915, 0.0424594, -0.0263222, 0.0722701, 0.0155563, 0.0986149, 0.0280556, -0.0433854, -0.068336, -0.0751236, 0.0742023, -0.0318775, -0.0727136, 0.0492505, -0.0506123, 0.0534777, 0.0311044, -0.0492423, 0.00138811, -0.0493566, 0.039505, 0.0777121, -0.0409463, -0.0686275, -0.0742281, -0.0356475, 0.0581988, -0.0340776, -0.0630409, 0.06513, -0.0394329, 0.0210281, -0.0118308, -0.0481358, -0.071382, -0.0259864, -0.0178749, -0.00448429, -0.0608959, 0.0315913, -0.0654718, -0.0674464, 0.0821583, 0.00331675, -0.0494119, 0.08235, 0.0317439, 0.0568276, 0.0071986, -0.0577769, -0.0646897, -0.074064, -0.0255333, 0.0816913, 0.0779835, 0.0549706, -0.0972552, 0.0697523, -0.00905355, 0.00409567, 0.0202106, -0.00136497, -0.0406288, -0.0628921, -0.0544289, 0.0720884, -0.036753, 0.00318911, 0.0251017, -0.0558458, 0.00118159, -0.030706, 0.0340991, -0.0588466, 0.0876573, 0.0173331, 0.0309782, 0.0671227, 0.025068, 0.0784417, 0.00909072, -0.0350023, 0.0181453, 0.0195524, 0.010319, 0.0229745, -0.0331256, 0.0753688, -0.0147362, -0.0498371, 0.0133963, -0.0196923, -0.0757222, 0.0642396, 0.00215985, 0.0788852, 0.0460261, -0.00315312, 0.0236659, -0.0512538, -0.0158634, 0.0803916, 0.025436, 0.062084, -0.0190036, 0.0106941, 0.0260685, -0.00516765, -0.0239821, -0.0698866, -0.00779895, -0.0105629, -0.0746513, 0.0768587, 0.0195502, -0.0743777, -0.0675627, -0.0412534, -0.0521372, -0.00322451, 0.0206563, 0.0761605, -0.00931455, 0.0711939, -0.00734668, -0.0664662, -0.0791727, -0.0452499, -0.0430888, 0.0146799, 0.0336618, 0.0776134, 0.00244312, -0.0229637, 0.0593868, -0.0646983, -0.0553254, 0.00402765, 0.0418264, 0.000431971, 0.0477542, 0.0545075, 0.0454287, 0.0118351, 0.0592185, -0.0594228, -0.0566406, -0.0104912, 0.0758832, -0.00628677, 0.0268482, -0.00537012, 0.0532852, 0.0142418, -0.0408675, -0.0265684, -0.0141317, -0.0193051, -0.0287455, 0.0479013, 0.0660064, -0.031666, -0.00228857, 0.032971, -0.0197116, -0.0485682, 0.0614588, -0.0552297, -0.0382293, 0.0218074, -0.00928944, -0.034441, -0.0615416, 0.0224453, 0.0402934, -0.00445198, -0.0546842, -0.0516233, -0.0666375, 0.0616132, 0.0300487, -0.0191149, -0.0481727, 0.0396692, 0.0344658, 0.0416726, -0.0463743, 0.0157066, 0.00375364, -0.0451064, -0.0173299, 0.00312374, -0.0635249, 0.0596044, 0.0374204, 0.0188955, 0.0841463, -0.0497416, -0.0381211, 0.0539751, -0.0499001, 0.00372685, 0.00054672, -0.00148274, 0.0402111, -0.0520402, 0.0546942, -0.0873977, -0.0678547, -0.0655472, -0.079779, 0.0675482, 0.073649, 0.0111957, 0.0179011, -0.00151303, 0.0202476, -0.0364114, -0.0245612, -0.0152033, 0.0327834, 0.00873835, 0.0134735, -0.00235908, 0.0235623, -0.0268112, 0.0223021, -0.0627524, -0.0793329, -0.0222291, 0.00288502, 0.0426495, -0.036813, 0.071016, 0.0401838, 0.0116275, 0.0109804, -0.0686753, -0.0451311, -0.00426166, 0.0247255, 0.0394163, -0.0133502, -0.0222729, -0.0810136, -0.0600902, -0.0898374, 0.0454914, -0.068325, 0.0357724, 0.0274654, 0.0670514, -0.0442, 0.0459717, 0.0438422, -0.0379815, 0.0436677, 0.0706985, -0.0621428, 0.0945151, -0.0431301, 0.00566763, 0.0956728, 0.0274063, 0.00737739, 0.0522427, -0.0751954, 0.00633908, -0.00247012, -0.068551, -0.0240301, 0.0725392, -0.0359308, -0.0128632, 0.01138, 0.076893, -0.0344814, -0.051647, 0.0132825, -0.00152739, -0.0478316, -0.0214237, -0.0229673, -0.0462531, -0.0431754, -0.0628974, 0.0519786, -0.00294982, 0.0147953, -0.0762034, -0.0490259, 0.0377681, 0.0497067, 0.0191499, -0.0110002, -0.0327871, 0.0318848, -0.0412584, 0.0306399, -0.0322071, -0.0365509, -0.0654793, -0.0120307, 0.0732432, -0.00424155, 0.045779, 0.001786, -0.00449748, -0.0643986, 0.0331648, -0.0589107, -0.0444706, -0.0322831, 0.00562217, 0.0410364, -0.0612273, 0.0582021, -0.0192402, 0.0142114, 0.013202, 0.0398659, -0.0163654, -0.0664686, 0.0682517, 0.0344746, -0.00901833, -0.0476509, 0.0216932, 0.0113893, 0.0271935, 0.0861464, 0.0628494, 0.044531, 0.0238114, 0.00571248, 0.0816335, -0.0455989, -0.0238136, -0.0519237, -0.0441529, -0.0295062, 0.0355967, 0.0834199, 0.0597679, 0.0614685, 0.0482682, -0.043115, -0.00993291, -0.041368, 0.0380822, 0.00295009, -0.0665982, 0.0240784, 0.0301527, -0.0735169, -0.0212279, 0.0292603, 0.0743772, 0.0295978, 0.092093, -0.0492489, 0.0746103, 0.0462317, 0.0069778, 0.055104, 0.0545034, -0.0545006, -0.0381437, 0.062599, -0.0536333, 0.0206644, 0.0834386, 0.0636283, 0.00740504, -0.0470954, 0.0267257, 0.0317356, -0.0793079, -0.00835289, 0.0196539, 0.0723379, 0.0573778, 0.027413, 0.0684956, -0.069251, -0.0602728, -0.0315039, -0.0798581, 0.0218671, -0.0317288, 0.0784545, 0.0570005, 0.00473517, 0.0260166, -0.050493, -0.0242618, 0.00122984, -0.0811171, -0.0384921, 0.0410687, -0.0517311, 0.010159, 0.0257938, -0.0385089, -0.0650219, 0.0225582, -0.0120463, 0.0332528, -0.0603962, -0.0225976, 0.0809485, 0.0488401, -0.051875, 0.00564986, -0.004489, -0.0122309, 0.0464809, -0.0107709, -0.0658841, -0.00901763, -0.00379542, 0.0138626, -0.0135613, -0.02629, -0.0546998, 0.0498184, 0.0325376, 0.0153007, -0.0307922, -0.024796, -0.0575989, 0.0429309, 0.0440891, -0.0224336, -0.00655418, 0.0800203, -0.0630392, 0.0359693, -0.0765175, -0.0746231, -0.0414137, -0.0206403, -0.0609406, 0.0069254, -0.07719, -2.75746e-05, -0.0771358, 0.0256505, 0.0225106, -0.0469634, 0.0295649, 0.0552815, 0.0682312, -0.0256833, 0.0249477, -0.0585963, 0.0153939, -0.0716309, -0.000469506, 0.010053, -0.0673338, -0.0800742, 0.0594687, -0.0805518, 0.0540154, 0.0376446, 0.0766946, -0.0120522, 0.025916, 0.0571047, 0.0493841, 0.038299, 0.0124283, -0.0231528, -0.0593932, -0.0521714, 0.0235417, -0.0686826, -0.0682211, 0.0741092, 0.0187288, -0.046836, 0.0419738, -0.00906087, -0.0631383, -0.0119711, 0.0285175, 0.0809585, -0.0340547, -0.0194167, -0.0131271, -0.0732648, -0.0680639, -0.0425196, -0.075667, -0.00217219, -0.0722248, 0.0379625, -0.0588174, 0.0670341, 0.027636, -0.0411058, -0.046723, 0.051809, -0.0581114, 0.0701184, 0.0504402, -0.0239415, 0.0442743, 0.0705411, 0.00986179, 0.0224279, 0.00789829, 0.0667883, -0.0326338, 0.0279868, -0.0171513, 0.0713381, 0.0311245, 0.0410683, -0.0357145, 0.0494102, -0.0749565, -0.0404662, 0.0420315, -0.0182944, -0.0692315, -0.0785145, -0.0292355, -0.0304931, 0.0441807, 0.0424054, -0.0277397, 0.0698172, 0.018541, -0.0709841, 0.0720611, 0.0126501, 0.0497188, -0.0173433, -0.0168223, 0.0555747, 0.0097809, 0.0548197, 0.0533585, 0.0345181, 0.0113171, 0.0367642, -0.0204637, -0.0782447, -0.0792412, 0.0328669, 0.0427486, -0.0315063, -0.0586271, 0.0508018, -0.00309133, 0.00817733, -0.0384417, -0.078205, 0.0721055, -0.0358597, -0.00203591, -0.0796441, -0.0796031, 0.0436464, -0.0353922, -0.0787751, 0.0278458, 0.063426, 0.0645603, 0.000896506, -0.0285422, -0.0772007, 0.00509365, -0.0601712, -0.0336319, 0.0187414, 0.0690584, -0.0216974, -0.0554948, 0.0517703, -0.0609828, -0.0705668, -0.0502762, 0.0158834, 0.0307422, -0.0786737, -0.0248135, 0.0623804, 0.0575955, -0.0537608, 0.0131046, 0.00779309, 0.0538878, 0.0587116, 0.0120123, -0.00225555, -0.0520962, -0.00240941, -0.0418833, 0.0569344, 0.0309807, 0.0588419, 0.0464674, 0.0729496, -0.00605863, 0.0264729, 0.0463443}, {0.0116863, -0.0390203, 0.0134552, -0.013926, 0.0351683, -0.0563936, -0.00468574, 0.0356568, -0.0066892, -0.0330087, -0.0376091, -0.0417778, -0.0692447, -0.0793433, -0.00173613, -0.0501768, 0.0339497, 0.0320361, -0.00583532, -0.0320838, 0.0552843, -0.046847, -0.0249146, 0.0194948, 0.0543713, 0.0536977, 0.00270709, 0.0270436, -0.0633777, -0.0177488, 0.0138287, 0.0800029, -0.0494477, 0.0491341, 0.0584892, -0.0671408, 0.0641496, 0.0650492, 0.0611197, 0.0251919, -0.0771893, -0.0450244, 0.0580462, -0.00311698, 0.0554771, 0.0789378, 0.00900091, -0.0815112, -0.0207527, 0.016184, -0.00754865, -0.000445463, -0.0288315, 0.0764704, 0.0306144, -0.081723, 0.0414729, 0.0514116, -0.0409311, 0.0229254, 0.00394049, -0.00360387, -0.0615106, 0.0610505, -0.0223613, 0.0807841, -0.0359769, 0.0510028, -0.0769978, -0.00466103, 0.0156465, 0.0572736, -0.0566796, 0.0242065, 0.054825, 0.00782321, 0.0476703, -0.00157876, -0.0408511, 0.0633553, 0.0740896, 0.037557, -0.0721096, -0.0196368, 0.0420653, 0.00169431, -0.00737261, -0.0181057, -0.00925703, 0.0187105, -0.0425211, 0.0304361, 0.00859758, 0.041302, 0.0601076, 0.0738736, 0.013661, -0.0624308, -0.0724315, 0.0188159, 0.0298315, -0.054032, 0.00439906, 0.0134416, 0.013623, -0.0802258, 0.0664611, 0.0124406, -0.0775489, 0.0795205, -0.0373376, -0.0422728, -0.0178771, -0.0392135, -0.0744795, 0.0404688, -0.0483824, 0.0548087, -0.0514694, -0.0149185, -0.0236287, 0.0799519, -0.0370531, 0.00428913, -0.0438142, 0.0472675, -0.0738189, 0.0303578, 0.00521299, 0.0419994, -0.0267548, -0.0548562, -0.0602195, 0.0091387, 0.027199, 0.0429306, 0.0365862, 0.0142625, -0.0626078, 0.0483968, 0.077391, -0.00461544, -0.0299804, -0.0391918, 0.0444189, -0.0535718, 0.0718084, 0.0667868, 0.0181696, 0.0682252, 0.00606146, 0.0742822, -0.0193441, 0.0648739, -0.0377323, 0.0726552, -0.00508273, -0.0624015, -0.0440119, 0.00962105, 0.0206272, 0.057213, -0.0500032, 0.0690408, 0.0178301, -0.0516395, 0.0487129, 0.053484, -0.00562362, 0.0185294, -0.0618833, -0.0551039, -0.0175472, 0.0601947, 0.0622214, -0.0654361, 0.000371121, 0.0811943, 0.0651786, -0.0632232, 0.0174827, -0.0552403, 0.0256639, 0.0350459, -0.0777361, -0.0771472, -0.00366853, 0.0768012, 0.0154631, 0.0255076, 0.00485802, -0.0328985, 0.0650668, 0.0497768, -0.0608234, 0.0507079, -0.0278471, 0.0361215, 0.0495074, -0.0572781, 0.0266854, -0.0210034, 0.00351964, -0.0575788, -0.0573764, -0.0410927, -0.00916953, -0.0429632, 0.00499842, -0.0160275, -0.0159023, -0.0716541, -0.0700896, 0.010045, 0.0419846, 0.0402604, 0.0283196, 0.00141781, -0.080556, 0.0768196, -0.0596631, -0.0155936, 0.034422, -0.0116052, 0.0241617, 0.01674, 0.0122893, 0.0617831, 0.0601943, 0.0733628, 0.000941388, 0.0393639, -0.0121748, -0.053397, -0.0228706, 0.0352135, 0.0775969, 0.00608261, -0.00211819, -0.0751971, 0.0304826, -0.0673, -0.028247, -0.0708146, -0.076801, -0.0517687, -0.0323111, -0.0585148, 0.012634, -0.0457115, -0.0089474, -0.0286674, 0.0398934, 0.0501805, 0.0459395, 0.0557749, 0.00990594, 0.0200563, -0.0685451, 0.0675795, -0.0255749, -0.0602293, -0.017616, -0.0640476, -0.0308163, 0.0179518, 0.070196, 0.0758097, -0.0436849, -0.0708946, 0.0559508, -0.00538911, -0.0214565, -0.0652272, -0.0794186, -0.00059545, -0.0335161, -0.0368831, -0.00883865, -0.0454844, -0.0218127, 0.0444966, 0.0440928, -0.0754807, -0.0634288, -0.0350029, -0.0677704, 0.0635014, 0.0330279, 0.0799706, -0.041136, 0.0745845, -0.0436516, -0.0350815, 0.0454804, 0.00768314, -0.0112275, 0.0601886, -0.0764621, -0.00786221, -0.0361567, 0.08094, -0.000962839, -0.0381537, 0.0319287, 0.0806678, -0.0774091, -0.080604, 0.0676879, -0.058355, 0.020257, 0.00537974, -0.00686236, -0.0201233, -0.0470445, 0.0277513, -0.0862692, -0.0988639, -0.0352863, -0.0188141, -0.059528, -0.0403076, 0.0303019, -0.0322157, -0.112368, -0.0987479, -0.0103336, -0.074242, -0.0135158, 0.153, -0.112415, -0.0552766, -0.0650891, 0.147666, 0.0728084, 0.00344306, 0.0653609, -0.0704544, 0.0044384, -0.0119599, -0.0780066, 0.0200196, 0.0788358, -0.0203139, -0.0157691, 0.0238886, -0.0121916, 0.100093, -0.0748072, -0.0041779, -0.0249935, 0.0269244, -0.0080484, 0.0851836, 0.0410395, 0.0789911, -0.00567001, -0.0464319, 0.0423521, 0.0404563, 0.0854926, -0.0161407, -0.0787129, -0.0144517, 0.0230432, 0.0899038, -0.00697181, -0.0338883, -0.0562609, 0.00224827, 0.0581158, -0.0456629, -0.0632312, 0.035807, 0.138671, 0.0638217, -0.0520352, 0.0602502, 0.0176578, -0.0112863, -0.0203291, 0.0442009, 0.0966413, 0.00193068, 0.0553378, -0.0191139, 0.0340252, 0.0206627, -0.112053, -0.0812344, -0.0311229, -0.0880377, -0.0710011, -0.062191, -0.0712692, 0.0209814, 0.0509017, -0.0350064, 0.0245356, 0.0461504, 0.0420799, 0.0279021, -0.0258856, -0.109533, 0.0352048, 0.0063351, -0.108499, 0.0444322, 0.083545, -0.000712181, 0.0764524, 0.0926034, -0.00753997, -6.90018e-06, 0.0296808, -0.0433415, 0.0414948, 0.0129043, 0.0163851, -0.00243347, -0.0526227, 0.0532296, -0.0129468, 0.0298726, -0.0799478, -0.145942, 0.0244644, -0.101359, -0.022333, 0.0762701, -0.0933276, -0.0626787, -0.0434234, 0.00934888, 0.130588, 0.0927323, 0.0106655, 0.0561786, -0.128307, 0.00110594, -0.130633, -0.0512931, 0.0855359, -0.0911692, -0.0765636, 0.0136431, -0.0437028, 0.0935708, 0.050702, -0.0866163, -0.0155296, -0.0231903, -0.0245705, 0.00359644, -0.0350305, 0.037223, 0.0458544, -0.0324459, 0.0511884, 0.0468133, 0.0501315, 0.00170527, -0.0264345, 0.0566661, -0.0273612, -0.00298461, 0.04017, 0.0223212, 0.0745545, -0.00913769, 0.0692708, 0.0788999, -0.0979825, -0.0140571, 0.0194623, -0.012581, -0.044423, 0.00192244, 0.0522014, 0.0449901, 0.0441294, 0.0801346, 0.0374524, 0.133567, 0.00856493, 0.0439935, -0.0960034, 0.078349, -0.0990483, 0.0242392, -0.00602653, -0.0179527, 0.0301286, 0.0772705, 0.00818045, 0.00906697, -0.0405756, -0.0447316, 0.0555414, 0.00070025, -0.0112298, -0.0673881, 0.00668799, 0.0295532, -0.0443508, 0.0202486, -0.0969189, 0.0293278, -0.0330845, -0.0593111, 0.117304, 0.105882, 0.0266336, 0.0256164, -0.138657, 0.0637727, -0.0559624, 0.074591, -0.0846421, -0.0296613, -0.0134331, -0.00814625, -0.0465642, 0.0667663, -0.0738342, -0.00404297, 0.0491996, -0.0183706, 0.0484966, 0.115605, -0.0526867, 0.0514653, -0.0885702, 0.0888312, -0.0366901, 0.0595731, 0.00244655, -0.011136, 0.0248974, 0.03948, 0.0545589, -0.101076, 0.0567329, 0.0410754, -0.0544424, -0.0505547, 0.0327669, 0.0343054, -0.0760464, 0.000380661, -0.0154769, -0.0393813, 0.00562377, 0.0485237, 0.0566843, 0.135297, 0.0326413, -0.000246843, -0.0292755, -0.00882091, 0.062837, 0.0600624, -0.0523152, 0.0346446, 0.00133302, 0.00800538, 0.0290085, 0.00698994, -0.0101827, 0.0233427, 0.103717, 0.110549, -0.060124, -0.036524, 0.095184, 0.0530562, -0.00298435, -0.00549467, 0.120703, -0.00211385, 0.0569285, 0.0797566, 0.107181, -0.0430839, 0.0676593, 0.0096699, -0.133865, 0.00816313, -0.0696352, 0.0219295, 0.00769243, -0.101269, -0.00799711, 0.0497266, 0.00520513, 0.00320194, -0.091577, 0.0443943, -0.0962302, -0.0961255, -0.0447027, 0.0417601, 0.13504, 0.0166337, 0.0882971, -0.0825163, -0.027053, -0.0237883, -0.0903243, 0.00553169, 0.0821081, 0.0135822, -0.0114218, -0.08998, -0.10945, 0.0791865, -0.0542842, 0.119335, -0.0031225, 0.0752438, 0.0439172, -0.0429064, -0.0236286, -0.0208716, -0.108751, -0.0993403, -0.0153879, -0.0484115, 0.127314, -0.0255392, -0.023749, 0.0141071, -0.0446031, 0.17743, 0.0162232, 0.0228292, 0.0194816, 0.052893, -0.0715095, 0.0480908, 0.0499025, -0.0133319, -0.0175511, -0.0271136, 0.000184558, 0.00282117, 0.0441127, 0.0539374, 0.045336, 0.0529089, 0.0598403, -0.0251622, -0.020873, 0.111886, 0.0750001, 0.0104419, 0.160762, -0.0409341, 0.0741396, -0.0617614, 0.0817058, 0.0803396, 0.067451, -0.0144158, 0.0447788, 0.114136, 0.0432573, 0.0730271, -0.0655696, -0.0407855, 0.153855, -0.00823666, -0.00825658, -0.0215405, 0.00596617, 0.05944, 0.033508, -0.0355351, 0.0266759, 0.0484388, 0.0541561, -0.000958017, 0.0237195, -0.0483031, 0.00821244, 0.0536559, -0.119169, 0.0816841, -0.042755, -0.0621518, -0.0407439, -0.0264303, 0.0624928, -0.0813729, -0.0233447, -0.0857586, 0.00303103, 0.144367, -0.0265881, 0.0216304, 0.0186544, 0.0937862, 0.0560236, -0.0356747, 0.126991, 0.0245894, -0.0959118, 0.0593293, -0.0881367, -0.0290052, 0.00809417, 0.00310785, -0.0391286, 0.0530281, 0.0103305, -0.0643969, 0.0279813, 0.16563, -0.00878273, -0.00117476, -0.0793709, 0.0477144, 0.0397815, 0.0344886, 0.0245401, -0.132688, 0.0584222, 0.0756363, -0.0485303, -0.00480936, -0.0675199, 0.0456567, -0.0357484, 0.0720812, -0.0434564, 0.121411, -0.0802167, -0.0666481, -0.102937, 0.100939, 0.0360373, -0.0733555, -0.0482807, -0.00543318, 0.0576721, -0.115206, 0.0744819, 0.0789518, 0.0338424, 0.0240592, 0.108653, 0.0390076, -0.0256855, 0.0085413, 0.021696, -0.0135262, 0.0403152, 0.0567852, 0.0289561, 0.0655964, -0.0908717, 0.0238846, 0.0414505, -0.0502947, 0.0065357, 0.0378798, 0.0349863, -0.0449899, -0.0286743, -0.0567623, 0.10462, 0.0265961, -0.0158396, 0.0599602, -0.0920768, 0.0798164, -0.0530302, 0.0851321, 0.0128295, -0.0289985, -0.00768927, -0.0312939, 0.038998, 0.0632122}, {0.0657866, 0.137965, -0.110449, -0.00417149, -0.00427422, 0.0496304, -0.12763, -0.151828, -0.0668318, -0.0477258, 0.0666328, -0.0305765, -0.0156618, 0.0552256, -0.06444, -0.0196509, 0.0610985, 0.0735487, 0.0776549, -0.0137466, 0.0373716, -0.00632463, -0.0811983, 0.149278, 0.0510169, 0.032493, -0.0321564, 8.90772e-05, 0.106392, -0.0111917, -0.0480034, -0.0291157, 0.016319, 0.178973, -0.101195, 0.04997, -0.0156258, -0.0725434, 0.00921242, 0.0259361, -0.00539336, -0.0286274, 0.023907, 0.0922123, 0.0858297, -0.105032, -0.0175732, -0.0104764, -0.168049, 0.123337, 0.0356292, 0.0521762, -0.0274774, 0.0782379, -0.0617465, 0.089487, 0.0398411, -0.0369003, -0.0582629, -0.124032, 0.0237814, -0.10604, -0.074784, 0.111616, -0.0311423, 0.0953013, 0.109912, -0.0931991, 0.0585937, 0.141404, 0.010663, -0.00990894, 0.136748, -0.053217, -0.0519126, -0.0109854, -0.0254265, -0.0271267, 0.025172, -0.0380574, 0.0702813, 0.129563, 0.0162568, -0.0604353, 0.0292897, 0.0129255, 0.102786, 0.104104, -0.0321731, 0.0149575, -0.0776133, 0.0314689, -0.0548435, 0.0177778, 0.0753167, -0.0235155, 0.0685902, -0.0679428, 0.175692, 0.0751231, 0.0293723, 0.128879, -0.0791971, 0.0814875, -0.0816826, 0.0490907, -0.102554, -0.0143086, -0.00987648, 0.014252, -0.00405043, -0.00857723, -0.0801606, 0.077332, -0.160971, 0.00983114, 0.0869904, 0.0760826, 0.125866, 0.096171, 0.0217215, 0.0116515, -0.0517213, -0.0133358, -0.0382507, -0.0423865, -0.00254311, 0.0296058, -0.0403194, 0.0500774, -0.0686936, 0.0023685, -0.0360589, -0.0981983, 0.0954526, -0.0503077, 0.0736313, -0.0714713, -0.0706448, 0.0485919, -0.076362, -0.0248711, -0.13132, 0.0579305, 0.0036391, -0.0526343, 0.0599085, -0.0102408, -0.0586836, -0.0377126, 0.0590023, -0.102564, -0.0550228, -0.00703765, 0.00346896, 0.0842443, -0.033509, 0.0818491, 0.0336285, -0.010966, 0.0445192, 0.0755634, -0.0985486, 0.036635, 0.0478859, 0.0100798, 0.116189, 0.115309, 0.072731, -0.14101, 0.0471467, -0.00853738, -0.0140531, -0.0739953, -0.0160255, 0.118412, 0.116115, -0.0463361, 0.024021, -0.0244112, -0.0469638, -0.0198789, -0.0768543, 0.0519893, -0.0686325, 0.140044, 0.0375643, -0.00962255, -0.0203023, 0.0175209, -0.0367533, -0.00303063, -0.0778488, -0.0641303, -0.0101001, -0.0230383, -0.0348119, 0.0118938, -0.0819008, -0.0481814, 0.0336768, 0.0661224, 0.0499089, 0.1374, -0.11341, -0.0570539, -0.0789927, 0.0872627, -0.0195595, 0.145431, -0.134487, -0.108809, 0.00493614, -0.0817307, -0.074153, 0.129737, -0.0424184, 0.0340417, 0.00787578, 0.0273207, -0.115185, 0.00746546, -0.012843, 0.0631854, -0.0753183, 0.0890292, -0.00709804, 0.0746466, -0.0697125, -0.0412731, -0.091724, 0.0359486, 0.0263427, 0.00890847, -0.00221125, -0.0772722, -0.0554844, -0.00462571, 0.0720456, 0.114344, 0.00456904, -0.00494975, -0.144601, -0.109449, 0.000920346, 0.0198651, 0.124159, -0.013684, 0.0168809, -0.0646019, 0.0143185, -0.0747026, -0.0035409, 0.0121082, -0.0250628, 0.0143112, 0.0261987, 0.121192, 0.0866957, 0.0710866, -0.0394132, -0.000995764, -0.0689215, 0.0609052, 0.150492, 0.0634322, -0.0261834, 0.116302, -0.0096015, -0.0402356, 0.133306, -0.0846734, -0.0390868, 0.0573786, -0.105609, 0.0774299, 0.173909, -0.102423, -0.0104188, -0.0774966, -0.17707, -0.00982042, 0.0247517, -0.115356, 0.020839, 0.046705, -0.0963822, -0.0570115, 0.0351397, -0.073053, -0.00296559, -0.0241532, -0.112994, 0.0628723, -0.00901041, 0.0449565, 0.0492693, -0.016889, -0.0331395, -0.0553795, -0.0237765, 0.103203, -0.0341134, 0.119373, -0.0101261, -0.0848269, -0.0976047, -0.00804059, -0.11535, 0.0624036, -0.149192, -0.06966, 0.209662, 0.0356042, -0.0245838, 0.0229649, -0.0267712, 0.157443, -0.0498931, -0.0431739, -0.00542744, 0.0621686, 0.158929, 0.122105, 0.071788, -0.00762536, 0.101962, 0.0726414, -0.0814074, -0.0341215, -0.0421578, 0.0656848, -0.0791793, -0.00326275, -0.0122038, -0.0970595, -0.0707377, -0.0635513, 0.0284689, 0.0764558, -0.0607497, -0.0758346, -0.159572, -0.0252326, -0.133875, -0.0127224, 0.0813036, 0.060195, 0.00421845, 0.0453318, -0.0154725, -0.203519, -0.0301603, -0.0262031, -0.059693, 0.0519336, 0.0319981, 0.0605422, 0.189324, 0.0317914, 0.0709802, 0.0608701, -0.0735346, 0.0576978, 0.00917009, -0.0291578, 0.118624, 0.153742, 0.0718846, -0.0692554, 0.138884, 0.0472973, 0.0259695, -0.0311794, -0.0528032, 0.126609, 0.176866, -0.193248, 0.0718563, -0.0795624, -0.196439, 0.0962226, -0.074324, -0.0345988, 0.0195266, 0.0988892, -0.0276219, 0.0208402, 0.0630605, -0.0148576, -0.0908373, -0.0125188, -0.0536412, -0.00261626, 0.107574, -0.0472838, 0.118944, -0.10718, -0.0848017, -0.0658088, -0.111987, 0.121673, -0.0661975, 0.0648803, 0.031012, -0.069797, -0.0849265, 0.0465042, -0.000949335, 0.101235, -0.0328069, -0.191055, 0.165825, -0.0624357, 0.107088, 0.0118727, -0.0517866, 0.0716271, 0.00505796, -0.0543608, 0.120342, 0.139419, 0.0818402, 0.136997, -0.00946531, 0.0663127, 0.0839919, 0.0525586, 0.0196277, 0.0334126, -0.10969, 0.0682475, 0.0275036, -0.0667216, 0.099725, -0.0661209, 0.0450077, 0.0486185, 0.128429, -0.000590521, -0.09561, 0.0431654, 0.00216593, -0.0944683, -0.00340042, -0.168032, -0.0129648, -0.0410757, 0.0842224, -0.00602182, -0.0914697, -0.138286, -0.0279995, 0.0859357, -0.117948, -0.0405449, 0.000512564, 0.0986554, 0.125145, 0.131022, -0.0587348, -0.000484466, 0.0290418, -0.00720092, 0.0856647, 0.0332768, 0.131484, 0.186361, 0.0170739, -0.056231, 0.017952, -0.0922711, 0.0345169, 0.00141208, -0.00783862, 0.0906744, 0.222399, -0.123295, 0.0611884, 0.0575706, -0.106906, 0.0700157, -0.089916, -0.115381, -0.000188131, 0.124647, 0.00474872, -0.0240347, 0.125646, 0.00624941, -0.104734, -0.0935797, -0.0606631, -0.0500211, 0.120819, 0.00871228, 0.0398062, -0.112824, 0.00519309, -0.0847495, -0.138218, 0.143923, 0.00591296, 0.042459, 0.0621804, -0.13468, 0.0307675, 0.0962119, -0.0601222, 0.132913, -0.0610381, -0.170778, 0.227158, -0.0866529, -0.0109165, 0.0402327, -0.0270709, 0.142787, 0.059175, -0.0262697, -0.0243311, 0.0385635, 0.107649, 0.163736, -0.0626463, 0.0633542, 0.0225855, 0.148381, -0.000245475, 0.0919341, -0.140468, 0.0422694, 0.0682223, 0.0334592, -0.0508228, 0.0352164, 0.0504747, -0.00357379, -0.0287154, -0.0285135, 0.0277962, -0.0525628, -0.0633821, -0.143141, -0.12185, -0.0915278, -0.019763, -0.0446596, 0.108725, 0.0490083, 0.0110465, -0.181975, 0.0624729, -0.031453, -0.036295, 0.0197043, -0.0177328, -0.0233206, 0.0589679, 0.0295669, 0.0273092, -0.030975, -0.0729974, 0.03137, -0.00765859, 0.0310824, 0.0553602, 0.116505, 0.042859, -0.0568313, 0.0010038, -0.0276382, -0.0661806, -0.0032343, -0.149549, 0.188027, 0.110814, -0.172968, 0.00232842, -0.0479514, -0.132035, 0.0381672, 0.0202692, -0.0718717, 0.0600588, 0.0443809, -0.000789588, 0.0151564, -0.0309308, -0.081389, -0.000245318, 0.0569631, -0.0517709, -0.0517083, 0.0442208, -0.086004, 0.120957, -0.0959992, -0.0942626, 0.0159187, -0.0301439, 0.151801, 0.0118099, 0.0564942, 0.0592573, -0.139846, -0.0299309, -0.028429, -0.011062, 0.150806, -0.0616928, -0.111869, 0.209048, -0.0805839, 0.101615, 0.108829, -0.0541636, 0.103349, -0.0230578, -0.0565965, -0.0475129, 0.132273, 0.128494, 0.136091, -0.0302127, 0.0259334, 0.0298453, 0.0841232, -0.0862254, -0.01662, -0.015908, -0.0323094, -0.0799983, -0.00171186, -0.0740075, -0.0430521, 0.0520972, 0.10791, 0.070853, -0.00649465, -0.0717635, -0.0496982, -0.0145814, -0.0435479, 0.0299502, -0.0783927, 0.108156, 0.0202209, 0.0256278, 0.0962637, -0.0469792, -0.0861022, 0.020675, 0.0515884, -0.0154901, 0.133623, 0.00478128, 0.0672904, 0.113775, 0.0260571, -0.0412343, -0.0298654, -0.107783, 0.0291997, 0.0646394, 0.0632035, 0.119471, 0.0416149, -0.0433293, -0.0112124, -0.00431572, -0.0508984, 0.0473187, 0.0380881, -0.0955175, 0.0880025, 0.138232, -0.138045, -0.0566235, 0.0576414, -0.0431472, 0.0275825, -0.0394477, 0.00573223, -0.0231619, 0.0478689, -0.0757339, 0.0677773, -0.0532659, -0.00251453, -0.001084, 0.018501, -0.0930782, -0.0420241, 0.0821311, -0.0845219, 0.0251054, -0.117708, 0.00321429, 0.0421992, -0.0266927, 0.0576429, -0.0742317, 0.181477, -0.0622192, -0.0736836, -0.0163918, 0.0370251, 0.0140661, 0.0780031, -0.120352, -0.0700885, 0.0684163, 0.0452184, 0.0854466, -0.00165414, -0.0619145, 0.085616, -0.0760596, 0.0191505, -0.0915192, -0.0289137, -0.0362074, 0.0807987, -0.106806, 0.00912189, -0.0123827, 0.15839, -0.138406, 0.020766, -0.0698757, -0.0748495, -0.0630173, 0.0580431, -0.00484602, -0.101837, 0.00747398, 0.155054, 0.0610318, 0.000879272, -0.121255, 0.0181752, -3.6255e-06, -0.122164, -0.0484072, -0.036823, -0.0519047, 0.0475077, 0.0454209, 0.12114, 0.0238411, -0.0813504, 0.0624055, -0.0689973, 0.0767533, 0.121375, 0.0669109, 0.00633787, 0.0744493, -0.070415, -0.028933, 0.074342, 0.013327, 0.0594398, 0.0101219, -0.00561711, 0.113608, -0.0463813, -0.0721315, -0.0411985, 0.10939, 0.0888486, 0.0953479, 0.0649808, -0.0275478, 0.0616404, 0.0445074, -0.0269702, 0.03956, -0.00322861, -0.179762, 0.124682, 0.0710583, -0.126737}, {-0.0390011, 0.107399, 0.00951078, 0.0345076, 0.00645565, 0.057572, -0.00497018, -0.0164925, -0.0226402, 0.0123141, 0.118184, -0.028997, -0.00516054, -0.0012475, -0.00853399, -0.163188, -0.0933568, 0.0814774, -0.0386006, 0.227273, -0.134627, -0.0991473, -0.116039, 0.0265521, 0.00416054, 0.118844, 0.111327, -0.10173, 0.130714, 0.0622095, -0.0455049, 0.0704061, -0.0504238, 0.0970601, 0.0481265, 0.0377777, 0.0318094, 0.0169452, 0.0139091, 0.12545, -0.0936859, 0.0291767, 0.0578367, 0.105073, -0.114955, 0.0331806, -0.0319141, -0.125206, -0.112631, 0.0098183, -0.0445427, -0.141811, -0.0387593, 0.0476045, 0.0595223, 0.0210617, -0.0630873, -0.0591783, -0.0257716, -0.173456, -0.0885408, 0.00718039, -0.0116728, 0.00586397, 0.0527253, 0.113928, -0.0954216, -0.0123939, 0.109284, -0.179025, 0.0366294, 0.026577, 0.0395986, 0.067429, 0.16442, -0.0722501, 0.0635876, 0.0784803, 0.00885062, -0.0915633, -0.0617481, 0.0352429, 0.00858065, -0.130545, -0.0155239, -0.00401223, 0.156966, 0.137936, -0.0485022, 0.0797128, 0.0992053, 0.136239, 0.0703793, -0.016584, -0.0163313, 0.00342535, -0.16691, 0.10845, -0.0110027, -0.0419639, 0.0614023, 0.130777, -0.0403525, -0.0962816, 0.00437606, 0.0241438, 0.114956, -0.0590692, -0.0209357, 0.0393094, 0.0894324, 0.0715203, -0.064377, 0.0428722, 0.0449275, -0.0922744, -0.129137, 0.0526274, -0.0660682, 0.214711, -0.0747837, -0.164498, -0.051373, -0.0419912, 0.0433272, 0.0677477, 0.116589, -0.0699913, 0.213656, -0.010018, -0.115791, -0.131245, -0.0332325, 0.0596508, 0.085716, -0.0289372, 0.0408185, 0.0479341, -0.0631717, 0.0909659, -0.0656089, -0.0052247, 0.0406082, 0.0945749, -0.0620516, 0.0430313, -0.0661075, -0.110256, -0.113011, -0.0340205, 0.0434008, -0.13152, 0.0185774, 0.153022, 0.168434, -0.0120229, -0.113916, 0.00940899, 0.114263, -0.212975, -0.0795838, 0.091185, -0.0586419, -0.0660189, 0.0426998, 0.0559271, -0.11795, -0.0440495, -0.0275988, -0.113871, 0.160848, 0.0821272, 0.136211, 0.058536, 0.0426964, -0.0636572, 0.00949018, 0.0943184, 0.12931, 0.0135516, -0.0669697, -0.0270848, 0.0898319, 0.0155906, 0.024203, 0.0952916, 0.0647962, 0.0213647, -0.076321, 0.0438453, 0.0728848, -0.0150141, 0.124773, -0.00916103, 0.0253768, 0.0439755, -0.156227, 0.168509, -0.0503688, -0.0338144, 0.0123297, 0.223897, 0.0575342, -0.056891, 0.0747186, -0.0330283, 0.106532, -0.112571, -0.0807248, 0.132133, 0.0909732, 0.0109603, -0.126688, -0.00174931, 0.128257, -0.194156, -0.158314, 0.064951, -0.0921862, 0.21774, 0.00474274, -0.14136, -0.154592, -0.0343745, 0.0367959, 0.12897, 0.128648, 0.00803435, 0.208969, -0.0148525, -0.151169, -0.0420082, -0.0299578, 0.155302, 0.0213503, -0.050671, 0.0772733, 0.133373, 0.0573379, 0.0816785, 0.013802, 0.0711764, -0.0169361, 0.153127, -0.115518, 0.101933, -0.0412891, -0.0602047, -0.149643, -0.0520717, 0.0536148, -0.0526208, 4.23118e-05, 0.0615542, 0.141392, -0.0483944, -0.0996036, -0.105129, 0.0836712, -0.12142, 0.0444828, 0.00416217, -0.0648943, 0.0268602, 0.0205762, 0.17146, -0.0297654, -0.0992094, 0.0647945, -0.0444494, 0.0846999, 0.147597, 0.114949, 0.0318955, 0.139061, -0.0741861, 0.0783335, 0.0279859, 0.00315051, -0.109445, 0.0392584, 0.077174, 0.107283, -0.0737115, -0.0765787, -0.0458157, 0.144947, -0.0431296, 0.00518427, 0.0140068, 0.014584, 0.011619, 0.11434, -0.0129749, -0.0180586, 0.0404826, -0.0209525, 0.11232, -0.0629872, 0.00455994, -0.0329468, 0.121238, 0.0429116, -0.00535081, 0.0133338, 0.0757006, 0.0828283, -0.088843, -0.0494278, 0.0685936, 0.0634499, -0.0376419, -0.072448, -0.0334781, 0.0449353, -0.0532761, -0.0432278, 0.0832498, -0.0111538, 0.231327, -0.00925498, -0.11557, -0.0788986, 0.0524517, 0.0890735, 0.116143, 0.0423371, -0.0319439, 0.114244, 0.0843021, -0.120034, -0.0046716, -0.0490233, 0.0365192, -0.049696, -0.0663587, -0.0501859, 0.157125, 0.0417269, 0.0903343, -0.0367881, 0.0159096, 0.151578, 0.0951487, -0.0653676, -0.0157089, -0.11894, -0.0216661, -0.0941401, 0.0357219, 0.113393, -0.0944767, 0.023596, 0.00551753, -0.0113882, -0.0468733, -0.0673628, -0.0170204, -0.0134271, -0.0397325, -0.0218919, 0.0748119, 0.103066, 0.0353454, -0.0747343, 0.0846368, -0.0311871, -0.0616031, -0.016804, -0.0278672, -0.0756867, 0.0488648, -0.0156612, 0.0598682, 0.112706, 0.0248625, 0.00227262, 0.0398346, 0.0277696, -0.0179809, -0.056782, 0.118312, 0.0789706, 0.0430002, 0.0265684, -0.0581906, -0.0213119, -0.0402498, 0.00886169, -0.115362, 0.0586601, 0.0764557, 0.0375378, -0.0828654, -0.0625684, 0.0600039, -0.00974889, 0.0396739, 0.00394693, -0.0711931, 0.00461741, 0.153018, -0.0856502, -0.0908116, 0.0228596, 0.053916, 0.00018558, -0.0265219, -0.0381522, -0.0443567, 0.058934, -0.0402404, 0.0459568, 0.0458465, -0.0129694, -0.0112338, -0.0959027, 0.0501233, -0.0325676, 0.149489, -0.020333, -0.0968896, 0.0363049, 0.0356362, -0.0515864, -0.00863964, -0.071678, -0.0745104, 0.155727, 0.034505, 0.0580393, 0.0751226, 0.0478425, 0.017683, 0.0135111, 0.0520598, -0.0521401, 0.0366547, -0.0759192, 0.0653236, -0.0190271, -0.00972981, 0.0566847, 0.142531, 0.0299871, -0.0163877, -0.15648, -0.107706, -0.0654675, -0.0128019, 0.0284781, 0.019444, 0.0642634, 0.00124088, 0.0179835, -0.0270604, -0.140607, 0.0446498, 0.0640347, 0.0133054, -0.0792538, 0.00954922, -0.025182, 0.0248554, -0.0293404, 0.00535216, 0.00387595, 0.0634232, -0.0430865, -0.00582178, -0.104745, 0.00397248, -0.00228414, 0.0705334, 0.101442, 0.0362527, -0.0731408, -0.0517579, 0.0294736, 0.106169, 0.112194, -0.0133222, 0.16017, 0.0581011, -0.0235691, -0.0152555, 0.06575, -0.0839541, 0.0201633, -0.0742919, -0.100782, -0.0175088, 0.084913, -0.0413, -0.0562368, 0.034009, 0.031709, 0.0444293, -0.0655342, -0.0773541, 0.00554338, 0.0694506, 0.087159, -0.0310231, -0.022409, 0.0421538, -0.0166538, -0.0337148, -0.0197132, -0.0330595, -0.0923253, -0.0694667, -0.0355254, -0.036733, 0.0518155, -0.0203873, 0.0185951, -0.0664026, -0.104802, 0.0821119, 0.0224507, 0.0686622, -0.0955876, -0.00844291, 0.0165842, 0.0768577, -0.0647017, -0.0529571, 0.0851689, 0.0878556, -0.0935406, 0.0887995, -0.0681065, 0.0145618, -0.0647226, 0.0349532, 0.0669641, 0.0133175, 0.0516718, 0.0103059, 0.00345726, -0.037619, 0.0190896, 0.103863, -0.0977478, -0.0426018, -0.00783501, -0.0948411, -0.0372658, 0.0787987, 0.0269433, 0.048238, 0.0638026, -0.0999037, -0.0423562, 0.00664313, -0.101858, 0.0998748, 0.0863376, 0.122945, 0.00995763, 0.108403, 0.00542788, 0.021616, -0.000778172, -0.0184091, -0.128029, 0.0496155, -0.0648514, 0.120791, 0.0312509, 0.0576178, -0.0333305, 0.194435, 0.0238657, -0.080461, -0.0574084, -0.0565478, 0.0329558, 0.0685952, 0.0646986, -0.0767151, 0.0582695, 0.054834, 0.0906986, 0.0267829, -0.00459845, -0.0302412, 0.00751705, -0.0368594, 0.0151317, 0.0252853, 0.00301294, -0.0493793, -0.0812084, -0.0511073, 0.0505689, 0.0233521, 0.0419332, 0.0262872, 0.0203706, 0.140013, -0.0304931, -0.16008, 0.0423064, 0.0222981, -0.101397, 0.0555637, -0.0900437, 0.00400455, -0.0515598, 0.0750312, 0.0164766, 0.0824269, 0.037365, 0.0519356, 0.00490989, -0.0990621, 0.00875037, 0.0693547, -0.0860553, 0.0241887, -0.101531, -0.0578177, 0.0918758, 0.071414, -0.0248611, -0.0426305, -0.0261198, 0.0607062, -0.0809293, -0.0152075, 0.0409748, 0.121194, -0.0828885, 0.00980489, 0.070897, -0.00531279, 0.128844, 0.0860383, -0.0744647, -0.0760233, 0.0362818, 0.141692, -0.117169, 0.0742221, -0.0282075, -0.137154, -0.0714402, 0.0166285, 0.067324, 0.107673, 0.0418468, -0.124209, -0.0842383, 0.0721195, -0.139328, 0.00968329, 0.0352661, 0.113915, -0.0747959, 0.026032, -0.00160106, 0.080169, 0.0792394, 0.0443679, 0.0115675, 0.0783383, 0.0763224, 0.0232591, 0.010575, -0.00648021, -0.0806541, 0.0588085, 0.0288944, -0.014186, 0.0447564, -0.10872, -0.0101339, 0.140086, 0.0685167, -0.0403624, 0.00440155, -0.0591619, 0.151038, 0.0361969, 0.0258281, -0.00928461, 0.0338426, -0.0528563, -0.0392791, -0.120957, 0.0243758, -0.12235, -0.00532224, -0.0214821, 0.0511395, -0.0524018, 0.00557271, -0.0376597, -0.0285445, 0.0476802, -0.0190739, -0.013111, -0.0344998, -0.0186961, -0.126113, -0.0741245, -0.0125334, 0.088896, -0.0972257, -0.0426882, 0.044429, 0.00660267, -0.0385383, 0.0173282, -0.0415998, -0.0716057, 0.0751884, 0.145931, 0.0401751, 0.120831, -0.123146, 0.0548366, 0.107385, 0.0955779, -0.00132364, 0.116955, -0.0541562, 0.0929055, -0.0652057, -0.00719267, 0.0461314, 0.057457, -0.0269916, 0.0431313, -0.049707, -0.0566532, -0.0203226, 0.0431675, 0.0302276, 0.00546007, -0.0496201, 0.11109, -0.126021, -0.0296219, -0.0444767, -0.0558179, 0.022511, 0.0929961, 0.0413606, 0.108111, -0.0427395, 0.0012702, -0.070278, 0.0621089, -0.019595, 0.00564984, 0.0466444, 0.0749906, -0.108213, 0.0695761, 0.0263861, 0.055798, 0.132279, -0.0489556, -0.0145329, 0.0018003, -0.0138564, -0.00469931, -0.0763821, -0.0553468, -0.0256247, 0.0971979, 0.107842, 0.0671323, 0.0412225, -0.0423493, -0.161742, 0.149042, 0.0815311, -0.00238068, 0.0121995, 0.0430077}, {0.0827681, 0.0373858, 0.05237, -0.00212138, 0.0939921, -0.0360031, -0.121462, -0.12555, 0.090158, 0.0112066, -0.147869, 0.0428078, 0.0385593, -0.0527594, -0.029145, -0.031342, 0.0122108, 0.0815319, 0.0843382, -0.0237641, -0.0015096, -0.00848707, 0.00887334, -0.0595469, -0.0110078, -0.0217249, -0.0307087, 0.0221041, -0.00380136, -0.0224526, 0.013052, 0.108037, 0.0764727, -0.00722818, 0.0696978, 0.0186709, -0.0240875, 0.00335302, -0.185047, 0.0345363, 0.0886984, 0.000807167, 0.0187784, 0.101342, 0.050585, 0.0259701, -0.0158807, 0.0655466, -0.0926568, 0.0060555, -0.114725, -0.0420762, -0.0417613, 0.0324509, 0.0663361, 0.0306119, -0.07366, -0.0750849, -0.0378505, -0.0159562, 0.0284423, -0.0230228, -0.115345, -0.0782025, 0.0268515, 0.0794, -0.0129095, 0.0320878, -0.054373, -0.063027, -0.197472, 0.0765029, -0.0938064, 0.157732, 0.0514665, 0.136411, -0.0629501, 0.0136641, -0.0458205, -0.0541174, 0.134643, -0.0374548, 0.0102889, 0.0327188, 0.0638969, 0.117456, -0.0637376, 0.104639, 0.00732965, 0.215673, 0.0884884, -0.0666844, -0.0622659, -0.133705, -0.0335049, 0.0798116, 0.100927, -0.0219529, 0.152531, -0.0905802, 0.0218078, 0.0326087, 0.0596441, -0.0723725, 0.0499571, -0.108942, -0.0872228, -0.132762, 0.060003, -0.134457, -0.121335, 0.0755188, -0.00373653, -0.0706552, -0.0472748, -0.0788442, 0.0607006, 0.048607, 0.0108134, -0.028124, 0.116277, 0.0177835, -0.0487586, 0.0221136, -0.100751, 0.08368, -0.0890474, -0.0199565, 0.0217692, 0.0458971, -0.0725141, 0.157956, -0.063344, 0.0223545, 0.0503384, 0.00295975, -0.0752339, 0.0844836, -0.0831189, -0.116079, 0.14741, 0.0590695, -0.0341069, 0.0780711, 0.0130728, -0.0180575, -0.168149, 0.0825361, 0.00708697, 0.0694909, -0.0661054, -0.00721326, -0.00474612, 0.0223959, 0.00882996, 0.0259001, -0.0116223, -0.110247, 0.00329847, 0.089475, -0.00725384, -0.0309841, -0.0768389, -0.0972622, -0.0988853, 0.0305734, 0.0584837, 0.171279, -0.0594464, -0.126048, -0.092247, 0.091016, -0.0702265, 0.120505, -0.0668662, 0.127798, -0.0435622, -0.0696621, -0.0307845, -0.00795889, 0.0882456, -0.0906705, -0.0482953, 0.0952973, 0.0599391, 0.077648, -0.0916928, -0.00529107, -0.0123853, 0.206312, 0.0634118, -0.0616215, -0.0683487, -0.114288, -0.0288823, 0.236386, -0.0507093, 0.0804652, -0.00846415, -0.0919729, 0.0506175, -0.0203017, -0.0141476, 0.0192695, 0.174845, -0.079307, -0.108423, 0.0151536, 0.11445, -0.0466399, -0.031518, -0.0761262, 0.0413329, -0.0684728, -0.0615, 0.0220245, 0.0574885, 0.0628591, 0.0271042, -0.0851112, 0.0469588, 0.0804113, 0.0116109, 0.0383629, -0.127778, 0.0674257, -0.0723198, 0.0837441, -0.0151425, 0.0457282, 0.0500835, 0.154959, -0.0822095, -0.0566057, -0.0738653, -0.00836285, 0.0393015, 0.0727512, -0.0831268, -0.00572574, 0.108507, -0.0404012, -0.051424, 0.143219, 0.0421547, 0.0736567, -0.134573, 0.0896852, -0.0710977, 0.103589, -0.0483921, -0.0106213, 0.0701665, -0.103014, -0.0235461, -0.066466, -0.0633409, -0.0899617, 0.0278101, 0.00716847, 0.0275871, 0.0598435, -0.136252, -0.0129425, 0.00689276, 0.0226447, 0.086772, 0.179065, 0.00482917, -0.137918, -0.120666, 0.0340965, 0.0117097, 0.100019, 0.0424886, 0.0671025, -0.0614939, -0.0401233, -0.0996911, -0.0343329, 0.0320221, -0.0481953, 0.00301187, 0.100559, 0.0427686, 0.125355, -0.0237331, 0.0876841, -0.036668, 0.233794, 0.0545554, 0.0160278, 0.0565868, -0.161654, 0.0397992, 0.227222, 0.0365573, -0.0331573, 0.110231, 0.00869828, 0.0160923, 0.105393, -0.0617527, -0.00149924, 0.0434042, -0.149685, -0.119675, -0.136231, 0.0409485, -0.0312949, -0.0969895, 0.0373572, 0.0535828, -0.0371225, 0.0203133, 0.000681452, 0.0712819, 0.0479306, -0.0602304, -0.10644, -0.0481387, 0.0637755, -0.120746, 0.0131434, -0.0830711, 0.0205793, -0.0731916, 0.0984205, 0.03626, 0.0330909, 0.0751889, 0.0722894, 0.0328555, 0.00766134, 0.014918, -0.00102459, -0.0193699, 0.0344662, -0.0835403, -0.06657, 0.151854, 0.0762869, 0.0160522, 0.0524119, 0.013746, -0.0640738, -0.0479679, -0.0115915, -0.0899032, 0.0329118, -0.0802121, 0.0214443, -0.0208255, -0.0875506, 0.00392239, -0.0057922, -0.0222152, -0.135513, -0.0347815, 0.0659482, -0.0124154, 0.092153, -0.0349335, -0.137598, -0.0537139, 0.11718, -0.0166411, 0.0507455, -0.0391283, -0.111686, -0.0211166, 0.157727, -0.00365931, 0.170146, 0.0286182, 0.0430566, -0.0854635, 0.0614837, -0.0198423, 0.00236633, 0.0318317, -0.0343815, -0.016633, 0.106328, 0.000922595, 0.0335997, -0.0579484, 0.0665204, -0.0900866, 0.240811, 0.0413776, -0.0623831, -0.0210899, -0.160956, 0.0158672, 0.189802, -0.0251575, -0.0534091, 0.0515367, -0.0766702, 0.149905, 0.103142, 0.0414251, -0.0749807, 0.154309, -0.0996706, -0.0397116, -0.0344272, 0.115668, -0.13466, -0.12784, 0.0431948, 0.081472, 0.0561208, 0.00840212, -0.0917113, -0.0397571, 0.0182437, -0.0407823, -0.133484, -0.0391174, -0.0485183, -0.10215, 0.0387268, -0.0750363, 0.0677911, 0.0111676, 0.0635946, -0.0580998, 0.110171, 0.0293377, 0.148374, 0.0139332, 0.00782729, -0.044606, 0.0392299, -0.0872215, 0.0663898, -0.118035, -0.028795, 0.0852663, 0.0891126, -0.0277057, 0.136809, 0.0534873, 0.0527331, -0.146825, -0.00800975, 0.0175941, 0.127889, -0.0687265, -0.062389, -0.0156996, 0.0245656, 0.117825, -0.0211927, 0.0657787, -0.0911682, -0.00631865, 0.057934, 0.0419068, 0.033418, 0.0494417, -0.0777406, 0.001201, 0.0165819, -0.057998, 0.0641046, -0.0450584, 0.0458585, -0.0142423, -0.00829892, 0.0605133, 0.0325501, -0.0383859, -0.00361121, 0.0384462, -0.00907394, 0.0800811, -0.002962, 0.0593579, -0.0176747, -0.0299938, -0.00102385, 0.00212508, -0.0574539, 0.022067, -0.0522673, 0.0315364, -0.0157372, -0.0624136, -0.0686185, -0.0621697, 0.0613441, -0.018259, 0.0390164, 0.0280341, -0.0770238, 0.0277491, 0.0422955, -0.0166029, 0.0557333, -0.0307641, -0.0282972, 0.0360648, -0.0725515, 0.0393155, -0.0365954, -0.0780332, -0.0141855, -0.0572305, -0.0364994, -0.058889, -0.0179261, 0.0485134, 0.00818336, 0.00646811, -0.0572625, 0.0528615, 0.0575875, 0.0638636, 0.0815819, 0.0538762, -0.0682437, -0.0426427, -0.0774052, -0.0109554, -0.0150704, -0.019172, 0.0284294, 0.0334035, 0.0311875, -0.0337901, -0.0730329, 0.0367665, 0.0757953, 0.0397687, -0.0127151, -0.0801374, -0.0270526, -0.0206277, 0.0242558, -0.0317695, -0.0641655, -0.067081, -0.000261456, -0.0185392, -0.0321263, -0.0247555, -0.059419, -0.0401027, 0.0747298, -0.0764228, 0.073336, 0.0136736, 0.0640953, -0.00878946, 0.0222942, 0.0219535, 0.0716899, -0.00409298, 0.0637275, 0.00110953, -0.000391625, -0.0353103, 0.0370116, 0.0456888, 0.0434916, 0.0749844, 0.00637758, -0.0454699, -0.066044, -0.060563, 0.0157942, 0.0302412, -0.0455575, 0.0447504, -0.0169186, 0.0669348, 0.0225641, -0.0801847, 0.054878, 0.038831, -0.00512773, -0.0162053, -0.0597889, 0.02696, 0.0639457, -0.069402, 0.0584443, 0.0287839, -0.0561944, 0.0433644, -0.0673352, 0.0308252, -0.026803, 0.0539639, -0.00324817, -0.0506857, 0.0449142, -0.00430987, 0.0050557, -0.0278294, 0.0267128, -0.0315, 0.0388152, -0.0498012, -0.054694, -0.0749799, -0.0418944, -0.0261887, 0.00311664, -0.0793426, -0.0334797, -0.0626061, 0.020082, -0.0593205, 0.0820463, -0.0152091, -0.0302188, 0.0704096, -0.0726927, -0.0812766, -0.00959998, 0.0574776, 0.011119, -0.0431209, -0.0453591, -0.0307627, -0.0402627, -0.0417256, 0.0249043, -0.0475981, 0.0123298, 0.0447457, 0.0353289, 0.0822286, -0.0528482, -0.0179576, 0.0489935, 0.0783858, 0.0591382, 0.0656628, 0.0311844, -0.0202083, -0.0559662, -0.0418186, -0.0739601, 0.0189639, 0.0490767, 0.0779328, -0.0299724, -0.0434635, -0.0622404, -0.0682477, 0.00345246, 0.0127257, 0.05627, -0.00301944, 0.0222884, -0.0143588, -0.0684744, -0.0637137, -0.0223406, -0.00808344, 0.00272219, 0.0150701, 0.0804534, 0.0310832, -0.0929533, -0.0333865, 0.0548768, -0.0300593, 0.0308629, 0.079473, 0.0798368, -0.000501798, 0.0902662, -0.0373831, -0.0322309, 0.00785572, 0.0706551, -0.00552221, 0.0641483, 0.101334, -0.0764526, -0.0313186, 0.00456242, -0.00223231, 0.0727905, 0.0287586, 0.0266254, -0.017501, -0.0253658, -0.124692, 0.108293, -0.0566056, -0.0504408, -0.044543, 0.0269355, -0.104571, 0.0842826, -0.0650451, -0.04282, -0.0768562, -0.0253005, -0.0587549, -0.0209043, -0.012944, 0.07453, -0.0547162, -0.0578614, -0.0934047, -0.00760693, -0.0307533, 0.0180058, -0.0230464, 0.0612772, 0.0531343, 0.0167256, -0.125093, 0.030255, 0.0455792, -0.0137375, -0.0114471, 0.0922103, 0.087182, 0.0444281, -0.0413153, -0.00230375, 0.100998, 0.115783, 0.0654642, 0.0997686, -0.0302941, -0.0252606, -0.0298175, 0.0368299, 0.0323435, 0.138202, -0.0913959, -0.0484104, -0.0255984, -0.039743, -0.0440662, -0.0614301, 0.0458487, -0.075431, 0.0132632, -0.0118211, 0.0388995, -0.100241, 0.00878399, -0.0116902, 0.0155634, -0.042071, -0.000182754, 0.0504761, 0.0715941, 0.0939175, -0.052724, -0.0404262, -0.0817988, -0.0561044, -0.0864913, 0.106227, -0.0823875, 0.0489465, -0.0524824, -0.102132, -0.0933874, -0.0123195, -0.0752925, -0.0109026, 0.0344641, -0.111966, 0.00556555, 0.19202, -0.0508157, -0.0579798, -0.0502381, 0.228673, 0.0581485, 0.0180625}, {0.0738786, -0.0395651, -0.0157461, 0.0624116, -0.0653149, -0.0169635, 0.0786349, -0.0833278, 0.0578393, 0.0188997, -0.175046, 0.185995, -0.059299, -0.117438, -0.0614625, -0.0308075, -0.0500601, -0.000329107, 0.0148134, 0.0747102, -0.0722519, -0.097608, 0.0409859, 0.0486369, 0.0914502, 0.0165032, -0.0407477, -0.0275223, -0.0169117, 0.0370213, -0.0658083, 0.00919067, 0.00624939, -0.0388261, 0.165661, 0.1678, -0.0827971, 0.0383816, 0.0928509, 0.0121479, 0.0636443, -0.00753374, 0.0522719, -0.0463481, 0.0820138, -0.00921489, -0.00515767, 0.128459, -0.00942444, 0.0052571, -0.0982264, 0.00479948, -0.0421864, -0.126763, -0.00317324, -0.102331, -0.0902729, -0.04106, 0.0318519, -0.0475363, -0.13067, -0.0112387, -0.0862963, -0.0508787, 0.043434, 0.0039349, 0.0644862, -0.0785078, 0.00565856, -0.133824, -0.0405182, 0.0756491, 0.104264, -0.068355, 0.119205, 0.127694, 0.0955211, 0.00995306, 0.00270112, -0.0226719, -0.0213149, 0.0819908, -0.0320653, 0.0323929, -0.0391232, -0.0365862, -0.156317, -0.00267841, 0.0290377, -0.0829729, 0.0110452, -0.0888206, 0.128441, 0.216256, -0.069876, 0.06514, -0.225974, 0.125011, 0.121314, 0.0036759, -0.0169186, -0.0910986, -0.028327, 0.187389, -0.141514, 0.0480553, 0.0982521, 0.0440431, 0.0246539, -0.100571, -0.135949, 0.103022, 0.0696321, -0.0684211, -0.0134991, -0.0713825, -0.123574, 0.0946099, 0.0653155, 0.0643973, -0.047377, -0.122781, 0.0523699, -0.0846733, 0.0904662, 0.0273745, -0.0282247, -0.100322, 0.0301032, 0.0136518, -0.0784334, 0.143534, -0.0135815, -0.0560399, 0.121457, 0.0632656, -0.177903, -0.0443189, 0.0844088, 0.0147648, -0.00103669, -0.0149925, 0.0491731, -0.0913697, 0.00750549, 0.0660169, 0.058161, 0.182007, 0.0773246, 0.018662, -0.0403265, 0.00493083, -0.093978, 0.0133448, 0.00524575, -0.0810651, -0.10913, 0.0282563, -0.0429915, -0.0841474, -0.0396838, 0.0654994, -0.0505317, -0.125462, 0.0741062, -0.00829024, 0.104793, -0.0764678, 0.0278492, -0.096168, -0.0815038, -0.00496548, -0.00394825, 0.0432143, 0.0620848, 0.0350751, 0.094212, -0.0349315, -0.111851, -0.0452674, -0.0262426, 0.0892155, 0.00533079, -0.0799986, 0.0289078, -0.017574, -0.122191, -0.0973391, -0.00259659, -0.121872, 0.0216214, -0.130211, 0.0845278, 0.0747072, -0.0168629, -0.00823237, -0.14234, 0.260173, 0.00390139, 0.110489, 0.127709, -0.0627387, -0.0967352, 0.169512, -0.0697887, -0.0873733, -0.00291586, -0.024266, -0.0124592, 0.014675, -0.125841, 0.180557, 0.0269338, -0.041442, 0.0361864, 0.0506987, -0.121027, 0.162602, 0.145162, 0.0516105, 0.102668, -0.0666385, 0.0635659, 0.063907, -0.00290752, -0.044205, 0.0113773, -0.0884642, 0.0334262, 0.0318001, 0.00813094, 0.181329, -0.0940132, 0.0785227, 0.132382, 0.188099, -0.0512098, -0.0343465, 0.157441, 0.0682276, -0.024168, 0.0298649, 0.06892, 0.021694, 0.0350063, -0.0563344, 0.0695581, 0.115486, 0.125593, 0.17235, -0.0955588, -0.0221726, -0.0331821, -0.133205, -0.0388653, -0.201213, -0.130377, 0.000735499, 0.0263694, 0.0125461, -0.0213581, 0.191974, -0.175139, -0.0995924, -0.01465, 0.12591, 0.019851, -0.0952243, 0.0860162, -0.124435, -0.0965195, 0.115947, 0.0594863, -0.0811181, 0.0435039, 0.141292, 0.0129272, -0.0426291, -0.156624, -0.0753572, -0.0611059, 0.138364, -0.0339297, -0.0413189, -0.0791012, 0.0663742, -0.00417033, 0.0308409, -0.0357731, -0.139343, -0.0601758, 0.0814283, 0.124996, -0.0678029, -0.126197, 0.0563575, -0.121257, 0.173178, 0.0643574, 0.108805, 0.0507958, 0.0643765, -0.047275, 0.11914, 0.0155689, -0.0249511, 0.0917518, -0.0470262, 0.0111037, 0.0231343, -0.0682451, 0.0467171, -0.0262761, 0.00177662, -0.0403223, 0.0405364, -0.0780965, 0.189837, 0.0541612, 0.00134049, 0.174848, 0.0202607, 0.0232066, -0.0660823, 0.0294767, 0.0416091, -0.0623052, -0.0115971, 0.0902917, 0.149855, 0.0770807, 0.128217, 0.0392968, 0.0272104, 0.191851, 0.0424498, -0.0790616, -0.0592369, -0.0350331, 0.0300153, -0.0495984, -0.0227331, -0.00434811, 0.0801904, 0.0475359, 0.0680789, 0.0956772, 0.0430598, -0.00910824, 0.0853223, -0.0306345, -0.0409321, -0.1431, -0.0318964, -0.0699198, -0.10636, -0.105049, 0.0678628, 0.0459555, 0.00259102, -0.090571, 0.137842, -0.160586, -0.132138, -0.0547182, 0.0974565, 0.142724, 0.0986374, 0.0196228, -0.0817529, -0.207704, -0.00673939, 0.0221713, 0.0466122, 0.0362837, 0.0936107, 0.0300307, -0.0364116, -0.101899, -0.0398497, -0.059355, 0.184278, -0.045211, 0.0551849, -0.0607895, 0.0899434, -0.0384488, -0.0300566, 0.0286756, -0.0751247, -0.0442628, 0.0738391, -0.0458976, -0.00998242, -0.0667403, 0.0244728, -0.108615, 0.0878934, -0.0463139, 0.0434023, 0.036148, 0.0206093, -0.0884172, 0.167903, -0.02731, -0.0362556, -0.0664323, -0.152678, 0.0667769, -0.0653398, -0.0693327, 0.13649, -0.0513334, 0.0805906, -0.0251102, -0.000873618, -0.0122802, 0.135896, 0.0298907, 0.0379222, 0.00613382, -0.0117328, 0.0152671, -0.108892, -0.0138303, -0.00888827, 0.0431806, -0.027864, 0.00244701, 0.180889, 0.0243772, 0.102577, 0.0326288, 0.00449124, 0.193625, 0.0273849, -0.0294532, 0.0574305, -0.00906346, 0.023523, 0.0574253, 0.147827, 0.054963, 0.00713224, 0.101353, 0.00141883, 0.154837, 0.0396837, 0.0617709, 0.0724958, -0.121679, -0.0298, -0.0865906, 0.0653123, -0.146475, -0.0472343, 0.101729, 0.0770589, 0.0247549, 0.00595703, -0.122812, 0.12237, -0.138635, -0.0211882, 0.0988839, 0.111553, 0.0290366, 0.0266589, 0.168154, 0.0504759, -0.115075, 0.00277314, -0.0935116, 0.0391867, -0.0761401, 0.162985, 0.0548384, 0.0323921, -0.0732809, -0.0951518, 0.016075, 0.149708, -0.0847328, -0.0314865, -0.0489422, 0.083699, -0.0604152, 0.0811793, -0.00624028, -0.0832203, 0.0739557, -0.14121, -0.029485, -0.210697, 0.0335931, -0.000519224, 0.0367632, 0.0364444, -0.0624673, 0.071901, 0.0375256, -0.0147345, 0.00422177, 0.167681, -0.0929565, 0.133588, -0.0775274, -0.0394533, 0.041186, 0.00632346, -0.0785478, -0.00244755, -0.0372266, -0.0288082, 0.0151138, -0.0859995, -0.0416507, 0.013561, 0.138523, -0.0330708, 0.0579072, 0.0297595, 0.0398478, 0.0825518, 0.019916, 0.0603812, 0.0457454, 0.0221242, -0.0256954, -0.0221209, 0.0581595, -0.0759215, -0.0750003, -0.105155, 0.0539759, -0.089043, -0.0235794, 0.0416577, -0.165676, 0.0291571, 0.0148967, 0.084364, 0.0577955, 0.0112613, -0.0260218, 0.0520269, 0.0660988, 0.0694187, 0.0476194, 0.0715095, -0.076059, 0.0848157, 0.024033, 0.176514, 0.0258067, -0.0026327, 0.0630074, 0.0112275, 0.0202382, 0.0702333, -0.0426499, 0.0573146, -0.215043, 0.00480222, -0.0424896, 0.024122, -0.0587824, -0.016584, 0.13205, 0.119879, 0.0264435, 0.0476862, 0.00512402, -0.049177, 0.0541276, 0.134983, -0.070331, 0.0181896, -0.0130314, -0.00598907, -0.00996656, -0.0481695, 0.0288935, -0.0437128, -0.0249264, -0.0586893, 0.0711559, 0.0509051, 0.0329008, -0.0636346, -0.00662076, -0.139134, -0.0806631, -0.139651, 0.0588477, 0.08031, -0.0225338, -0.120942, -0.161201, -0.13645, -0.019854, 0.062165, 0.0322572, 0.00233317, -0.0207786, 0.224614, 0.0180421, -0.00164311, -0.0447137, 0.040177, -0.113004, 0.086067, -0.116808, -0.0536631, 0.0926995, -0.0606448, 0.0766081, -0.164825, 0.236048, 0.0877596, 0.00714633, 0.0683603, -0.0731525, 0.214741, 0.137934, -0.114353, -0.00949088, 0.0239363, -0.153507, 0.0153452, -0.0601233, 0.00541321, 0.0478815, -0.0862875, -0.11303, -0.0930449, -0.0656282, -0.0608496, -0.141943, -0.099787, 0.00982886, -0.00645173, 0.038068, 0.00782468, 0.0100621, -0.0169082, 0.113563, 0.118373, 0.0178487, 0.0944276, -0.0855459, 0.11711, 0.00957807, 0.0460134, 0.138408, 0.0210133, 0.0565319, 0.0500577, -0.0187574, -0.0100555, 0.114975, -0.0690711, -0.0662258, 0.0842145, 0.0102058, 0.122207, -0.0845985, -0.118305, -0.0145118, 0.178201, 0.049687, 0.0439591, 0.0687918, -0.0418257, -0.02948, 0.135387, -0.0571236, 0.054772, -0.0145239, 0.0110331, -0.0176418, 0.0438413, 0.0911803, -0.0018311, 0.0184694, 0.0713973, -0.198598, -0.075271, -0.010322, -0.148175, -0.129008, -0.190121, -0.00353752, -0.0911277, 0.139603, -0.0692842, 0.0896291, -0.195518, -0.15295, 0.049874, 0.0494477, 0.0217245, -0.0617838, -0.0141707, -0.00477743, 0.125851, 0.11426, 0.0595878, -0.0336439, 0.118156, -0.0702715, -0.177896, -0.0428412, -0.0152236, 0.0448145, -0.00706108, -0.0708617, -0.0943469, 0.153684, -0.023564, 0.108717, -0.0349264, -0.0716975, 0.161937, 0.0840412, -0.0874139, -0.103243, 0.0615077, -0.0657805, 0.0464343, 0.0498194, -0.207251, 0.0154221, -0.0474709, -0.173397, -0.199353, -0.102139, -0.00779777, -0.181347, 0.0488525, 0.086978, -0.0177977, 0.158073, 0.0477385, -0.128992, -0.00600939, 0.0225143, 0.0189669, 0.00169083, 0.27998, -0.118296, 0.244277, 0.125071, -0.0656575, 0.0248228, 0.0739709, 0.0447859, -0.0621629, -0.106125, -0.229236, 0.291261, -0.0636773, -0.027971, 0.14509, -0.0476243, 0.175981, -0.136313, -0.0715071, 0.0864614, 0.274853, 0.105489, 0.213729, 0.0589573, -0.0142801, 0.172153, 0.264878, -0.0536964, 0.0147309, 0.0152973, 0.0860016, 0.00538698, -0.0636401, 0.106372, 0.0325266}, {0.0980923, 0.167015, -0.0556213, -0.117707, -0.0330507, -0.196229, -0.0790503, -0.21073, 0.0170915, -0.0116897, -0.00178979, -0.0181361, 0.0953302, -0.13789, -0.0474545, 0.0580691, 0.0843885, 0.0159146, 0.0637578, 0.00266923, 0.101891, -0.0273897, 0.0983176, 0.0612596, 0.0497326, 0.0134524, 0.00461653, -0.129875, -0.102733, 0.0444205, 0.133538, -0.00427229, 0.0446662, 0.0354809, 0.244635, 0.0776652, 0.125303, 0.102351, -0.064067, 0.214545, 0.0644197, -0.0917193, -0.0332485, 0.0404564, 0.057925, 0.121337, -0.0354778, -0.188677, 0.0858569, -0.0703108, -0.213565, -0.289475, -0.0317428, -0.0138325, -0.173586, -0.0204904, 0.0114323, -0.0525044, 0.196469, 0.0301401, -0.0286382, -0.107365, 0.0258783, 0.0374122, 0.0642483, 0.271299, -0.0105446, 0.175032, 0.163439, -0.0824234, 0.0501693, 0.0236367, 0.0252623, -0.0957478, -0.217304, -0.13525, 0.340415, 0.143128, 0.063794, 0.0495698, -0.08194, 0.183119, -0.00528175, -0.15906, 0.0186001, 0.155558, 0.221603, 0.268935, 0.0482031, -0.0150117, 0.175968, 0.192759, -0.137498, 0.0305167, -0.0426609, 0.0966643, -0.0152389, -0.0567201, 0.123136, -0.127165, -0.0379951, 0.204019, -0.116875, -0.123565, -0.0397638, -0.0804593, -0.0805019, -0.187661, 0.111773, -0.0380233, -0.0151326, -0.0439367, 0.242909, -0.115703, -0.062857, 0.0217981, -0.0611698, 0.0336858, -0.133437, 0.0957817, 0.04291, 0.0304274, 0.159214, 0.0537711, 0.0339417, 0.0289301, -0.0420646, 0.0100221, -0.0422393, 0.111306, 0.0596136, 0.0119756, -0.00856243, 0.00315902, 0.113281, -0.027081, 0.132995, -0.0544917, -0.0172421, 0.266368, 0.0932393, -0.11383, -0.00444662, -0.014882, -0.0663788, 0.138892, 0.0366043, -0.281645, 0.0768438, -0.0666251, -0.118763, -0.208119, -0.0943635, 0.0142705, -0.149526, 0.012336, -0.0532833, -0.0811871, 0.188224, -0.0472968, -0.0945541, -0.010766, -0.0618635, 0.0291165, -0.0508697, 0.0871261, -0.0703949, 0.17028, 0.202735, -0.157754, -0.0633952, 0.0112684, -0.0169333, 0.0492965, -0.245053, -0.239383, 0.311556, 0.0751374, 0.0731053, -0.0498558, 0.0204184, 0.0570165, -0.10511, -0.118583, 0.0825699, 0.140039, 0.0799717, 0.204397, 0.027767, 0.160838, 0.100405, 0.164424, 0.0932497, 0.0394911, -0.156189, 0.0648491, -0.167608, 0.0529172, -0.107245, 0.000808656, -0.0213234, 0.231398, 0.00619627, 0.0437351, 0.00859384, -0.125456, -0.101079, -0.156351, 0.0415356, -0.141097, -0.0267673, -0.0540816, 0.0465242, 0.0977079, -0.0834145, -0.0647453, 0.015237, -0.147457, -0.168525, 0.197758, -0.0938376, 0.140813, 0.0118898, 0.0740613, 0.0674824, -0.142742, 0.00056251, 0.0467671, 0.00237501, 0.2532, 0.193238, 0.0871989, -0.0645117, 0.0602831, 0.184398, 0.06148, -0.10345, 0.0392525, -0.130815, 0.17916, 0.177106, -0.0551023, 0.0886372, 0.00854483, -0.257233, 0.259815, 0.0262604, -0.0569499, 0.147113, -0.102442, 0.0380021, -0.00945848, -0.0870221, -0.070553, -0.165414, -0.134962, -0.00574975, 0.0502649, -0.0127943, 0.0787884, 0.191009, -0.0531777, 0.12896, -0.0682336, -0.0028489, 0.0882073, -0.0179457, 0.0679251, 0.0140203, -0.038155, 0.0236611, -0.0573938, -0.0327479, 0.125746, 0.0199136, -0.161156, 0.154811, 0.0455538, -0.0509992, 0.187872, 0.0738338, 0.245124, 0.121014, -0.0869396, -0.0261915, 0.116144, 0.117765, 0.100473, -0.0598211, 0.0307559, 0.0102604, 0.0595154, -0.0451457, 0.0345706, -0.310288, -0.0889018, -0.237803, 0.127934, -0.106137, -0.142556, -0.0762502, 0.181346, 0.128936, -0.00147774, -0.0279776, -0.117755, -0.0168813, -0.0846211, 0.147553, 0.0740412, -0.0671505, 0.0785212, 0.0297507, 0.113557, -0.220157, -0.0314557, -0.0449187, -0.212759, -0.153862, 0.196126, 0.0605953, 0.0689985, -0.0171128, -0.00322594, 0.0635959, -0.172109, 0.0651029, 0.0518867, 0.129261, 0.179633, 0.165208, -0.00168224, 0.00278335, 0.103734, 0.229088, 0.0131655, -0.0307821, 0.0351849, -0.143705, 0.0329211, 0.192006, 0.165788, 0.0509519, 0.0371094, -0.186892, 0.253756, 0.0868182, 0.0706467, 0.164785, -0.109028, 0.0491963, -0.0352814, -0.0801535, 0.0743667, -0.191078, -0.116271, -0.111618, 0.0446895, 0.092734, 0.0745588, 0.0787457, -0.0955509, 0.16033, -0.127444, -0.196909, 0.047241, -0.0634363, 0.124602, -0.0185618, -0.0466393, -0.0769342, -0.000829087, -0.053001, 0.0231788, 0.0299825, -0.062947, 0.0538832, 0.0889503, -0.248457, 0.0193137, 0.106605, 0.261352, 0.145152, -0.102151, -0.0116656, 0.108447, -0.00748145, 0.0986234, -0.106467, 0.0393102, 0.0875021, 0.25704, 0.0406718, 0.0822425, -0.178496, -0.186827, -0.255465, 0.00935761, -0.155728, -0.130227, -0.0635939, 0.221274, 0.101587, 0.00167986, -0.0939265, -0.123611, 0.097569, -0.0984926, 0.0201803, 0.0398882, -0.154536, 0.0551637, -0.00982494, 0.0592078, -0.0878678, -0.0194836, -0.023768, -0.162594, -0.0353959, 0.155191, -0.028724, 0.0109892, 0.135621, -0.0335646, 0.0741771, -0.209675, -0.026988, 0.0947185, 0.0489777, 0.110908, 0.149895, -0.0962404, 0.0934101, 0.258299, 0.289148, -0.00608098, 0.0976282, 0.00157131, -0.0212198, -0.0203114, 0.20462, 0.159594, -0.123632, -0.0525622, -0.0706917, 0.286374, 0.178426, 0.0240773, 0.204107, -0.0771947, 0.112144, -0.0228161, -0.167233, 0.0743542, -0.217099, -0.267614, -0.162257, 0.0491184, 0.0338719, 0.0509125, 0.0567556, 0.0756099, 0.118107, -0.0474171, -0.135638, 0.0260108, 0.00257468, 0.155596, -0.0906938, -0.00421217, -0.0617869, -0.0458821, -0.0198099, 0.0430732, 0.051618, -0.0658435, 0.162287, 0.0470163, -0.212355, -0.0241119, 0.158302, 0.283722, 0.129877, -0.0666764, 0.063264, 0.148232, -0.00783481, 0.0947365, -0.0200578, 0.0146384, 0.0477791, 0.13053, -0.158246, -0.0451137, -0.26827, -0.165737, -0.24964, 0.0247508, -0.147439, -0.00541183, -0.104947, 0.15067, 0.0222723, -0.0693066, -0.105706, -0.0209989, 0.10892, 0.0149823, -0.0216817, 0.036027, -0.120759, 0.0578294, 0.119435, 0.187398, -0.109016, 0.0924601, 0.0969684, -0.123083, 0.00260123, 0.191223, 0.111007, 0.112008, 0.149132, -0.114777, -0.00516357, -0.122169, -0.00287812, -0.0300222, -0.0405439, 0.127272, 0.146901, -0.171289, 0.0632111, 0.275378, 0.171201, -0.0470732, 0.127145, -0.0711091, 0.0144482, -0.0477098, 0.146669, -0.0579131, -0.109455, -0.00332242, -0.111969, 0.193324, 0.0916686, -0.0689602, 0.0261341, 0.0133007, 0.0658944, -0.165312, -0.038046, -0.0392172, -0.166937, -0.123746, -0.0797251, 0.0995245, 0.101036, -0.0325318, 0.0606481, 0.0602769, 0.228417, -0.0403317, -0.0687957, 0.060245, 0.0145038, 0.266064, 0.0222605, -0.0259958, -0.145916, -0.00354245, -0.00661436, 0.0845127, 0.122757, -0.0253451, 0.147537, 0.0868844, -0.175069, -0.0160826, 0.125079, 0.205227, 0.00251473, -0.108762, 0.118965, 0.0878542, 0.0717918, -0.00862153, -0.0611434, -0.0866311, 0.137238, 0.241026, -0.238211, -0.0145321, -0.102271, -0.0751165, -0.177714, 0.145862, 0.0748923, -0.0921996, -0.0298371, 0.120387, 0.131696, -0.0255402, -0.152592, 0.11519, 0.102343, -0.0833181, -0.022624, -0.000606263, -0.05793, 0.0652407, 0.225065, 0.195999, -0.0328821, 0.0906523, 0.08297, 0.0305348, 0.110068, 0.142296, 0.00889836, 0.0900039, 0.143759, -0.0139481, -0.0657706, -0.10651, 0.0247771, 0.0256531, -0.00857304, 0.121959, 0.176136, -0.0722128, 0.119283, 0.210024, 0.133994, 0.00918604, 0.0247973, -0.0461831, 0.0945485, -0.0781834, 0.215436, -0.055922, -0.0485919, 0.068065, -0.121226, 0.182347, -0.0253855, -0.149881, -0.0875194, 0.145646, 0.071979, -0.107437, 0.084574, -0.05526, 0.0381005, -0.127198, -0.00896476, 0.16386, 0.178171, 0.0726573, -0.0913201, 0.104592, 0.119415, -0.0347049, -0.0821942, 0.0236547, -0.0979775, 0.284277, -0.0386555, -0.0998027, -0.0353159, -0.0983667, 0.132576, -0.00503502, 0.156843, 0.0320448, 0.0635004, 0.0588029, -0.219731, -0.0914288, -0.00810396, 0.180398, -0.067458, -0.00245085, 0.159564, 0.111363, 0.0336501, -0.00416523, -0.120772, -0.0358985, 0.0375987, 0.127332, -0.243755, 0.0787581, -0.145809, -0.110217, -0.191158, 0.109692, 0.0258148, -0.0867634, -0.0172054, 0.0846022, 0.037824, -0.0189205, -0.105608, 0.021497, 0.0787997, -0.0115396, -0.0919844, 0.108798, -0.0290422, -0.0744471, 0.112496, 0.127654, -0.0293056, 0.00293964, 0.0391087, 0.0320073, 0.0455425, 0.0869285, 0.069216, 0.114166, 0.162637, -0.101586, 0.0608229, -0.0506762, 0.0441424, 0.000934885, -0.111505, 0.069955, 0.0945821, -0.0532561, 0.0289052, 0.165142, 0.107599, -0.015006, 0.106526, -0.0817944, 0.0475095, -0.0472973, 0.169042, 0.00496253, 0.0646925, -0.0864816, -0.0161986, 0.165306, 0.00104481, -0.174451, -0.0230193, 0.168433, 0.00646174, -0.151584, -0.0408343, 0.0377311, -0.112734, -0.0518752, -0.0303335, 0.0692746, 0.238959, 0.045902, -0.0663584, 0.088825, 0.109221, -0.0148615, -0.123905, -0.0597092, -0.0184927, 0.241075, 0.0591685, -0.003828, -0.0867333, -0.049617, 0.22344, 0.0652774, 0.295897, -0.0310925, 0.0354979, 0.0411793, -0.138472, -0.101189, 0.0216945, 0.201504, -0.0237116, -0.076427}, {0.176697, 0.0703985, -0.0943816, -0.0284975, -0.0255076, -0.0490028, 0.0417731, 0.0474536, -0.186254, -0.0608127, -0.203491, -0.0791553, -0.150575, 0.118468, 0.126493, -0.0905504, -0.0840607, -0.0548528, 0.0148234, -0.0674339, 0.0281726, 0.151903, 0.182905, -0.0474316, -0.0996428, 0.00375056, -0.0832628, -0.0317293, 0.0440677, 0.12815, -0.0580602, -0.0604772, 0.053503, -0.0282496, -0.000594775, 0.0990554, 0.0465225, 0.0763776, 0.0854982, -0.123769, 0.0552413, -0.0980899, -0.0121982, 0.011411, -0.152277, 0.102115, 0.191738, -0.149334, 0.0793863, 0.0169678, 0.00312283, 0.0214996, 0.185735, -0.0332007, 0.0741344, 0.0237262, 0.057997, -0.088549, 0.0176092, -0.0107536, -0.0924583, 0.133314, 0.0687445, -0.171429, -0.0681873, 0.244279, 0.0746378, -0.0843165, -0.0036416, -0.0745307, -0.116451, -0.14288, -0.163329, 0.159291, 0.138945, 0.107963, -0.0573876, 0.0974688, -0.00118202, -0.0443708, -0.204703, -0.0111906, -0.14226, 0.311939, 0.0547142, 0.13599, -0.106515, -0.14223, 0.0952697, 0.0432716, 0.242384, 0.038257, 0.0166366, 0.071126, -0.132077, -0.0971341, -0.146998, 0.152978, -0.135495, -0.0564112, 0.100576, -0.0224273, 0.105978, 0.158925, -0.0554273, -0.0995976, 0.0917381, 0.0826915, -0.157913, 0.0755461, -0.16702, -0.0477691, -0.18579, 0.0982132, 0.123777, 0.0151038, -0.0551899, 0.0483913, -0.0965631, 0.0175851, -0.121281, 0.0491142, 0.165492, -0.0016293, -0.0773386, 0.0603064, -0.131094, 0.0517405, 0.138574, 0.097576, -0.061185, 0.0234362, 0.0192419, 0.0111874, 0.123574, 0.0369459, -0.0547344, 0.194889, 0.0252803, -0.0606422, -0.0487326, -0.0810784, 0.133204, 0.0729459, -0.122156, -0.0194756, 0.181672, -0.00478641, 0.0701494, 0.00011963, 0.0670125, 0.0253998, 0.127306, 0.00526312, 0.02834, -0.0426896, 0.129477, -0.0295071, -0.00259973, 0.0785033, 0.0647903, 0.214416, -0.0535116, -0.186435, 0.0404996, 0.107713, -0.0223448, -0.113559, 0.00415763, -0.0424832, -0.0962418, -0.145698, -0.135088, -0.00152716, 0.0972538, 0.0329529, -0.0774203, 0.0241695, -0.087799, 0.0988981, -0.123035, -0.0575019, 0.0115595, 0.207671, 0.0511994, 0.0442482, -0.0656742, 0.00742515, 0.178136, 0.0511407, 0.150224, 0.0770299, 0.0999538, -0.0960465, -0.0970268, -0.144736, 0.0010743, 0.0937489, -0.0261403, -0.102437, 0.0454222, 0.0191084, 0.0185369, -0.00625261, -0.00791177, -0.0959139, -0.0158785, 0.0504317, -0.206114, 0.0557743, -0.0478923, -0.100568, -0.113705, 0.0428184, 0.038812, 0.0265598, -0.0555046, -0.00598759, -0.0848322, -0.0101906, 0.0790527, 0.000306665, 0.0894713, 0.0765193, -0.00208717, -0.0689516, -0.096017, 0.079007, 0.179261, -0.0290825, 0.0868305, 0.0938374, 0.0339153, -0.0446595, 0.00952565, 0.092105, -0.0570214, 0.184256, 0.177318, -0.0144213, 0.00387807, -0.0547268, -0.0450595, -0.013111, 0.0621881, 0.104382, 0.0844354, -0.0572552, 0.0130933, 0.101077, 0.0627537, -0.116591, 0.0374167, 0.0298561, -0.0910126, 0.0991858, 0.0804452, 0.0419952, 0.0153026, 0.0804182, 0.00900767, 0.139817, -0.0697894, -0.0668676, 0.0159106, 0.301003, 0.0331504, -0.13685, -0.0442199, -0.00828668, -0.0853465, -0.116039, -0.108075, 0.0770704, 0.107617, 0.0193015, -0.124872, -0.0654929, -0.0815704, 0.0749455, -0.0435823, 0.0210601, 0.0555438, 0.125338, 0.0364153, 0.0761081, -0.0758351, -0.0256492, 0.0058341, 0.10561, 0.176715, 0.0428728, 0.02357, 0.0720786, -0.0352366, 0.0956029, 0.0706694, 0.114509, -0.00886114, -0.0314011, 0.0808799, 0.0538901, 0.00796051, 0.0502048, 0.0186588, -0.113408, 0.0775034, 0.136482, -0.194463, 0.139937, -0.11485, -0.0857301, -0.015207, -0.022134, 0.0513156, 0.0402601, 0.0681105, 0.0364191, -0.156238, -0.0413204, 0.0454425, -0.0587165, 0.10649, -0.0258728, -0.101023, 0.0782193, 0.0505073, -0.0456834, 0.0659019, -0.113246, 0.0745441, 0.137219, 0.112081, -0.0541481, 0.0277167, -0.0538059, -0.0448508, 0.108188, 0.112061, 0.115846, 0.0326015, -0.110377, -0.0422799, 0.044145, 0.103655, 0.174098, 0.133958, -0.0324679, -0.0552201, -0.0453897, 0.111658, -0.106061, 0.0550978, 0.138081, -0.048361, 0.0714017, 0.159452, -0.0339377, 0.0610083, -0.0230015, -0.00165238, 0.184101, -0.0413962, -0.150129, 0.142869, 0.290813, 0.0748398, -0.128548, 0.0185768, -0.010837, -0.156819, -0.203449, -0.165533, 0.0604909, 0.0869301, 0.108753, -0.0835416, -0.000643123, 0.0658114, 0.0685821, -0.0152209, -0.0540114, 0.00524574, 0.247753, -0.0763583, -0.0560433, 0.0451452, -0.0116863, 0.112004, 0.0194035, 0.0322387, -0.0498756, 0.0882173, 0.0406527, -0.0868058, 0.201239, 0.0187337, 0.0896293, -0.00557378, 0.00948015, -0.0764731, -0.0777375, 0.0836298, -0.0297476, 0.0240639, 0.00406181, 0.0705946, 0.117538, -0.132762, 0.0945949, -0.135506, -0.0834427, 0.106856, 0.0454515, -0.00703425, -0.0316243, 0.00112027, 0.0797551, -0.170932, -0.046394, 0.0918375, 0.0506535, 0.0980591, 0.0143511, -0.0734004, 0.0162041, -0.00260095, -0.0600723, 0.197453, -0.0204987, 0.0812573, -0.030146, 0.138619, 0.000676662, 0.0375297, 0.0423821, -0.124146, 0.183066, 0.19526, 0.092401, -0.031122, -0.0300149, -0.136827, 0.0227153, 0.0746948, 0.121965, 0.119539, -0.0657853, -0.0173216, -0.0231582, 0.00590703, -0.0344862, 0.0617303, 0.033099, -0.0356968, 0.0225516, 0.135221, -0.117883, 0.0339419, 0.0363265, 0.152283, 0.0857335, 0.0330509, -0.173647, 0.192695, 0.368584, 0.0874459, -0.0822508, 0.141584, 0.0316554, -0.121072, -0.206014, -0.0890624, -0.0288348, -0.0191808, 0.0788928, -0.0811376, -0.0988663, -0.0313382, 0.0807121, 0.0928724, -0.00646725, 0.00215879, 0.139962, -0.060047, -0.0144101, -0.0948212, -0.0134879, 0.0910745, -0.00565905, 0.115826, 0.0744443, -0.070358, 0.171776, -0.0972535, 0.206295, -0.0270821, 0.106552, -0.160164, -0.0335654, -0.0290646, 0.0438528, 0.135241, 0.065737, 0.0267999, 0.0176158, 0.0153331, 0.162245, -0.0331693, 0.0901803, 0.0181276, -0.112135, 0.0290769, 0.0446568, 0.107481, 0.0374937, -0.0400923, 0.0798991, -0.0808157, 0.0517995, -0.0671784, 0.0895642, -0.0229193, 0.0369818, -0.0756687, 0.0538393, 0.0397796, 0.0381656, 0.128113, -0.0109873, 0.0648021, 0.136818, 0.130995, 0.037515, -0.0671206, 0.019876, -0.022374, 0.17235, 0.105122, -0.0296998, -0.0291646, -0.0491078, -0.173322, 0.212379, 0.14589, 0.0490813, 0.149191, -0.0296909, 0.144054, -0.0394458, -0.0572012, 0.0387706, 0.0671452, -0.0387929, -0.0557746, 0.0445893, 0.182445, -0.0749441, -0.000801582, -0.00702656, 0.105852, 0.0283083, -0.0438874, -0.078892, 0.0765925, 0.279124, 0.0643857, -0.16635, 0.00431308, -0.0279502, -0.143007, -0.167428, -0.0264496, 0.0902856, 0.0831204, 0.0129222, -0.00600203, -0.00384148, 0.0967513, 0.132967, 0.0997171, 0.000183998, -0.000961095, 0.0862228, 0.0274176, 0.0568314, -0.137522, -0.0178768, 0.130913, 0.0995858, 0.0433351, 0.00079371, -0.0191506, 0.163162, -0.0178539, 0.251742, -0.0265436, 0.0570975, -0.12374, 0.00159796, 0.0740857, -0.0991641, -0.00234156, -0.0626656, 0.012244, -0.0952965, 0.00287962, 0.114798, -0.0766891, 0.0267848, -0.0857618, -0.0569331, -0.0164615, 0.0962057, -0.00390562, 0.17674, -0.0366936, 0.0396237, -0.105315, 0.123884, -0.0806094, 0.109838, 0.0302578, 0.188642, -0.0765145, 0.0594278, -0.104208, 0.0618424, 0.0642566, -0.0194596, -0.0808074, 0.15204, -0.0232055, 0.0694523, -0.0794796, 0.066654, -0.0255101, 0.148978, 0.0940812, -0.0339262, 0.0236062, -0.133095, -0.152594, 0.193086, 0.0827605, 0.0781217, 0.0734653, -0.0418774, 0.0210078, -0.0237833, -0.0491003, -0.0857214, 0.108433, -0.118056, -0.15783, 0.00689907, 0.168996, -0.0866154, -0.131294, -0.0533365, 0.120287, 0.0567461, -0.00471494, -0.0558645, 0.0383634, 0.122123, -0.0612542, -0.122005, 0.0158087, -0.02394, -0.0162711, -0.106176, -0.0797532, 0.0761284, -0.0352871, 0.0551859, -0.0936531, 0.0179608, 0.0351493, 0.117576, 0.0817354, -0.0304494, 0.0127964, 0.0475248, -0.101151, 0.152915, -0.13123, -0.00966071, 0.137462, -0.050194, 0.0053989, 0.0119646, 0.0499884, 0.00969526, -0.0649805, 0.134769, -0.0815843, 0.164985, -0.162979, -0.0178136, 0.051213, -0.048257, 0.130439, -0.02519, -0.0426592, -0.0484678, -0.0538608, 0.0652203, -0.0662184, 0.0937338, -0.0900301, -0.131015, -0.0851796, 0.0696244, 0.120734, 0.0944944, 0.068517, 0.00975926, -0.0307567, 0.0744158, -0.0969906, 0.0995151, 0.0212048, 0.196714, -0.0144018, 0.0304974, 0.0027913, -0.077983, 0.0560143, -0.0367806, -0.0441102, 0.0516394, -0.0305669, 0.0343911, -0.100499, -0.048266, -0.122698, 0.146544, 0.0450646, -0.080893, -0.012327, -0.0251917, -0.123518, 0.129768, 0.0464933, -0.0599756, 0.0133323, -0.0727992, 0.0684477, 0.0977279, 0.00909172, 0.0246647, 0.0698516, -0.0315319, -0.0408341, -0.0148494, 0.0360189, -0.181361, -0.045117, -0.0669359, 0.124969, 0.0201075, 0.0113865, -0.0593725, 0.042455, 0.0269788, 0.00528222, -0.0867021, -0.0345505, -0.0741068, -0.0178245, -0.0110106, -0.0869815, -0.00947055, 0.0552715, 0.0190981, 0.021207, 0.0273888, -0.0338253, 0.144016, 0.0678679, -0.0828445, -0.0509018, 0.0413222}, {0.0222032, 0.023048, -0.0361819, -0.0113005, 0.12117, -0.0245324, 0.0803466, 0.0508205, -0.0524554, -0.0472522, -0.0294447, 0.0677887, -0.0521343, 0.165166, -0.0313784, 0.00256373, 0.0831392, 0.0100858, 0.00553872, 0.050188, 0.0263809, -0.0352397, 0.0130766, 0.0441708, -0.0690603, 0.0330751, -0.0339601, -0.106693, 0.0280159, 0.0733451, 0.12919, 0.0815526, -0.0325779, 0.0141988, -0.163021, 0.0537133, -0.0980487, 0.0356798, -0.0762459, 0.152979, -0.106001, 0.0223175, -0.0735599, -0.00728699, 0.17455, 0.0589012, -0.0461174, 0.094235, -0.0694812, 0.0690909, -0.00355324, -0.00288264, -0.0228338, 0.212169, 0.0458028, 0.0410735, 0.0502744, -0.0741466, -0.0166387, 0.126322, 0.0950699, -0.00959199, 0.0808069, -0.0460594, 0.16799, 1.95737e-05, -0.0720135, 0.0148203, 0.0695927, -0.0856885, -0.0567778, 0.0584663, 0.0968296, -0.113399, -0.137563, 0.062264, 0.065248, 0.0390164, 0.0569544, -0.0779395, 0.0476068, 0.104188, -0.0565712, -0.0510377, -0.0339117, 0.0548185, -0.0676761, -0.0747358, -0.0738126, 0.0878726, -0.0626641, 0.0803625, -0.0924516, 0.0376134, -0.0707076, 0.04816, -0.0135429, -0.0318288, -0.0203936, 0.128222, -0.0759635, 0.106379, -0.0126821, -0.020354, 0.0190847, 0.0232206, 0.0426503, -0.0532269, 0.0495196, 0.0438904, -0.143486, 0.162958, 0.0155836, 0.0763644, -0.167672, -0.0392375, -0.00312893, -0.0820762, 0.0977375, -0.0431692, 0.0188076, -0.106754, -0.00342676, 0.0893817, -0.0214398, -0.037457, 0.0768711, 0.0216211, 0.00124587, 0.046354, 0.0492896, -0.0187322, -0.0652994, 0.138009, -0.0174456, -0.0372213, 0.03504, -0.0262803, -0.00108347, 0.0365499, 0.0356202, -0.0864287, 0.143164, -0.0159616, 0.0165859, 0.11623, 0.00500553, -0.0964989, -0.108054, 0.0498847, -0.0247184, -0.0291186, -0.0456182, -0.00504282, 0.083899, 0.00776313, 0.0654331, -0.0544512, -0.0350334, 0.051164, 0.0348408, 0.059024, 0.0482008, 0.0168073, 0.0990401, 0.00376859, 0.103246, 0.0764836, 0.0218658, -0.0119016, 0.00702375, 0.0952813, 0.00619468, -0.0602478, 0.0128977, -0.0558654, -0.0985101, 0.0585895, -0.0115852, -0.061127, 0.0153424, 0.039957, -0.0751659, -0.0531449, 0.045242, -0.033938, 0.0132791, -0.049245, -0.0410946, -0.0498007, 0.0095881, 0.0604704, -0.080325, -0.128697, 0.075876, -0.00329804, -0.0727088, 0.0858972, 0.0103466, 0.0284457, -0.0175276, 0.0319802, 0.042349, -0.0251276, -0.151061, 0.132698, -0.0765655, -0.177925, 0.0516454, -0.017768, -0.031439, 0.025161, 0.0214429, 0.0944678, 0.069501, 0.0915292, 0.00195217, -0.0222586, 0.0649577, 0.0282408, -0.0761656, -0.0174187, 0.0453666, 0.0154748, 0.0425361, -0.0398998, -0.0280215, -0.0361508, 0.0633966, -0.0307382, 0.00645259, 0.0654113, -0.00962614, -0.0734255, -0.0259388, -0.0121916, -0.00974497, 0.0225469, 0.0484285, 0.0265013, -0.00476232, -0.0629204, -0.0562815, 0.00479719, 0.0822466, -0.0192707, -0.00743996, -0.0134935, -0.0316066, -0.0178206, 0.00536864, -0.0411014, 0.0272391, 0.0765333, 0.0289226, 0.0220969, 0.0806188, 0.0125201, -0.0210687, -0.0419666, 0.0694359, -0.046552, 0.0704458, -0.0166418, 0.0182782, -0.0621927, 0.017384, 0.0622422, -0.0739539, -0.0480344, 0.0455174, -0.0772962, 0.0329625, -0.0389616, 0.0315359, -0.00746986, -0.000745639, 0.0816888, -0.0694586, 0.0399792, -0.0269017, 0.0270672, -0.00543863, -0.0396497, -0.0638481, -0.0299902, -0.0115533, 0.06918, 0.0343599, -0.00386542, 0.0774793, -0.0700235, -0.015152, 0.00978817, -0.00715332, -0.0508479, 0.0544132, -0.0500749, 0.0108531, -0.0484347, 0.0723192, -0.0586094, -0.00027778, -0.0535877, 0.057692, 0.0284673, 0.0560112, -0.0545453, 0.0108019, -0.00985375, 0.0807524, -0.0126096, -0.0124355, 0.0524237, -0.0773469, 0.00620025, -0.0729366, 0.0794553, -0.0163469, -0.0431913, 0.0317806, -0.0300378, -0.0205388, 0.0755732, -0.044935, -0.09393, 0.0133586, -0.0454525, -0.0528562, 0.0137758, 0.0159229, -0.0154746, 0.0160915, -0.10766, -0.117339, -0.0772561, 0.0344969, 0.0336235, 0.0747293, 0.0884386, -0.00593408, 0.033022, 0.0241665, -0.0469291, -0.00263537, 0.141017, -0.00451584, 0.130072, 0.105146, 0.0374712, -0.0852855, 0.021012, -0.128562, 0.0298898, 0.068235, -0.00657779, 0.0599923, 0.0280701, -0.0713256, 0.00769328, -0.0355884, -0.0876417, -0.0407441, 0.0727698, -0.118045, 0.099621, -0.0315223, 0.0734371, -0.0144299, -0.0606726, -0.0521861, 0.0355763, 0.100096, 0.0246903, 0.0284306, 0.0340772, 0.0244837, 0.0554148, 0.0739512, -0.0141089, -0.0497955, 0.0286302, 0.114061, -0.0268884, 0.00199881, -0.0809223, 0.067209, 0.00832702, -0.0321317, -0.0273804, 0.117657, -0.0984935, 0.0658468, 0.042083, 0.104784, 0.0654039, 0.0135332, -0.0170894, -0.023968, -0.00279172, -0.0410392, 0.00866846, -0.0632404, 0.020785, -0.0837763, 0.0219091, -0.0198337, 0.000997418, -0.105194, -0.00592141, 0.0500535, 0.0790572, 0.099273, 0.0228212, 0.112004, -0.0418577, 0.0396514, -0.12457, 0.0381909, 0.0825523, 0.109423, 0.0612182, 0.0483402, 0.0190284, -0.0393051, -0.133496, -0.0450647, 0.0593146, -0.0628811, 0.106408, -0.135201, -0.0595448, 0.0506741, -0.0585496, -0.115242, -0.0280758, 0.040219, -0.146169, 0.0557632, -0.0671226, -0.00515263, 0.0831207, -0.0822774, 0.0446187, -0.159637, 0.201437, 0.0923829, 0.0498385, 0.037847, -0.0233089, -0.140797, 0.105928, -0.00899918, 0.0251031, 0.0195758, -0.120838, -0.0391826, -0.0275578, -0.0273728, 0.206701, -0.043348, -0.0771356, 0.0901797, -0.0498549, -0.124364, 0.119041, 0.0308708, 0.116539, -0.120575, -0.0278848, -0.026407, 0.0405289, 0.0565875, -0.0664628, -0.02499, 0.0348216, 0.0160777, -0.0272748, -0.044092, 0.0577863, -0.0273276, 0.00755937, 0.0862053, 0.0483343, -0.100428, 0.0599165, 0.0410573, 0.0153833, -0.104987, 0.109917, 0.0560586, 0.028573, 0.086246, -0.059092, 0.144969, 0.0844306, 0.00294343, 0.0158781, -0.0981647, -0.0409929, 0.0301021, -0.116147, 0.013064, -0.0891458, -0.112407, -0.039764, -0.00423443, -0.00167181, 0.016812, 0.0333351, 0.0291592, -0.00949417, -0.0228062, 0.0927645, 0.0778108, -0.0541025, 0.0913243, -0.074688, -0.181999, 0.00401218, 0.0170587, 0.0369065, 0.00613402, 0.0107378, 0.0749566, -0.119218, -0.013862, 0.00284375, -0.047408, 0.0742075, -0.0679153, -0.0634866, -0.0165822, -0.0102425, -0.0150057, -0.0245905, -0.056866, -0.0659601, 0.0387235, -0.0726653, 0.0680972, 0.0960048, 0.0300457, 0.0597273, -0.219752, 0.17524, 0.0288607, 0.000341217, 0.0744071, 0.0704311, -0.17147, 0.201966, -0.116055, -0.0184714, 0.0450302, 0.0323775, -0.05611, -0.128108, -0.096935, 0.117255, -0.0794819, -0.0436942, 0.0855676, -0.0822658, -0.0681508, 0.0868187, 0.00653174, 0.0831102, 0.0304441, -0.0835251, -0.0820293, -0.080642, 0.0800614, 0.0522566, -0.0124575, -0.0109092, 0.0808308, 0.142427, 0.0664239, 0.0463288, -0.0368592, 0.075376, 0.158452, 0.0431617, -0.119853, 0.0474839, 0.0535578, -0.0126393, -0.0798755, 0.0486293, 0.0158601, -0.102667, -0.00610288, 0.0612339, 0.101114, 0.104005, 0.108661, 0.072858, -0.0652175, -0.058121, -0.0762015, -0.0453359, -0.0897829, -0.0341461, 0.00491482, 0.0424478, 0.066507, 0.0193386, -0.0339226, 0.0847273, -0.0367157, -0.0299235, -0.0528469, 0.0561924, 0.152434, 0.00350589, 0.081987, -0.147802, -0.190732, 0.0601818, 0.116659, -0.00941235, 0.11689, 0.126359, 0.346879, 0.27132, -0.238753, 0.320544, -0.230817, -0.249886, 0.40532, 0.470251, -0.393563, -0.168341, 0.217921, 0.350191, 0.0763716, 0.112484, -0.204395, 0.108776, 0.0730429, -0.147215, -0.410764, 0.00543576, 0.342727, 0.472577, -0.443947, -0.356086, 0.129347, -0.189154, 0.151767, 0.243422, 0.2705, -0.243565, -0.184606, -0.0155459, -0.00972064, -0.0521178, 0.0754291, 0.147248, -0.22949, 0.200692, 0.219872, 0.216489, -0.104697, 0.246544, 0.0332085, 0.371586, -0.0396352, 0.0728075, 0.0189141, 0.148101, -0.312809, -0.00534433, -0.0920012, 0.574537, 0.293517, 0.553365, -0.273836, 0.332536, 0.092112, -0.333797, 0.0383121, -0.112893, -0.483424, 0.0219329, -0.615107, 0.0816134, 0.581994, -0.379188, 0.0497334, -0.0524244, -0.658925, -0.0595791, -0.119206, -0.27019, -0.591878, 0.515677, 0.114067, 0.316202, -0.818724, -0.167969, -0.45779, -0.299123, -0.0506711, 0.247525, 0.418565, 0.274552, -0.000258913, -0.200748, -0.0243857, -0.291803, 0.151478, 0.218469, -0.193635, -0.55658, -0.0109944, 0.269287, 0.523853, -0.245165, -0.397476, 0.261035, -0.216573, 0.207358, 0.0440108, 0.280938, -0.481038, 0.162978, -0.00601353, -0.319053, 0.231346, 0.366871, -0.428494, 0.040228, 0.103205, 0.218094, -0.0461519, 0.374972, -0.326304, 0.0188744, -0.241031, -0.228327, -0.19411, 0.0508116, 0.345521, 0.487688, -0.133883, -0.0147202, 0.0139948, -0.242591, 0.0283479, 0.00396216, 0.0469749, -0.0740849, -0.318621, -0.0484094, 0.0305827, -0.0410502, -0.0126728, 0.068959, -0.243231, 0.0436429, 0.283638, 0.381009, -0.169356, 0.376376, -0.1983, -0.0109867, -0.0271977, -0.0931539, 0.152699, -0.351284, -0.0390425, -0.315582, -0.11629, 0.512478, 0.143089, 0.285824, -0.329171, 0.00339632, -0.0727485, 0.0152361, 0.394617, -0.0255792}, {-0.022065, -0.0430748, -0.417444, 0.0501724, 0.0524939, -0.391965, 0.143813, -0.439893, -0.765253, -0.20262, -0.492144, 0.212158, -0.083038, 0.542617, 0.277733, -0.0529046, -0.520636, -0.202843, -0.120121, 0.0336466, -0.173142, 0.683041, -0.0832079, -0.083638, -0.23928, 0.0544015, -0.0493709, 0.278889, 0.261095, 0.320692, -0.133449, -0.503495, -0.225839, 0.316481, 0.174209, 0.338801, 0.0209755, 0.19561, -0.189556, 0.0488548, -0.120142, -0.112024, -0.147123, 0.271764, -0.0995635, -0.3299, 0.265787, 0.403497, -0.436953, -0.167654, -0.211185, 0.138103, 0.00827931, 0.184593, -0.5814, 0.0677622, -0.112778, 0.247107, -0.0440881, -0.0770132, 0.232553, 0.0578549, 0.269118, 0.370343, -0.289706, -0.27307, -0.231421, -0.273092, -0.444528, -0.00980535, 0.111828, -0.355432, 0.073339, 0.112475, 0.113648, -0.0478082, -0.0399513, -0.335325, -0.122003, 0.17264, -0.303528, 0.256465, 0.000621462, 0.0887093, 0.138731, -0.0759767, -0.0942478, -0.191625, -0.120272, -0.453706, -0.103285, 0.462418, 0.232439, 0.255965, -0.20335, 0.0264037, -0.208398, -0.200311, 0.279772, 0.137332, 0.108918, 0.0806785, -0.270997, -0.0278085, 0.0255528, -0.246086, -0.0309364, -0.0599263, -0.414361, -0.282018, -0.313263, 0.109564, 0.1349, 0.129284, 0.205628, -0.450914, -0.244499, -0.0969466, 0.0601253, 0.385336, 0.0615817, 0.522621, -0.349218, -0.0631917, 0.105183, -0.0599721, -0.0712462, -0.0734441, 0.224881, 0.101295, -0.114053, -0.0154733, -0.128594, -0.014682, 0.0939641, 0.261247, 0.313449, 0.0705805, 0.0643231, 0.0331624, -0.22876, -0.150168, 0.251767, 0.0859538, -0.209557, -0.106699, 0.167009, 0.0873938, -0.267147, -0.100622, 0.152609, 0.264869, 0.0548839, -0.270246, -0.427253, -0.119975, 0.453381, -0.0650774, -0.211979, -0.0299558, 0.293304, -0.0310381, 0.0331267, 0.207783, -0.536667, -0.0297533, -0.144547, 0.139252, -0.381028, 0.13887, -0.103264, -0.509825, -0.0729479, 0.210658, 0.266054, 0.0324353, 0.304501, -0.0170949, -0.28326, 0.123466, -0.471751, -0.0230049, -0.0206855, 0.122254, 0.276993, -0.273542, -0.410696, 0.129322, -0.0775531, -0.356244, -0.43896, 0.487317, 0.160672, 0.151449, 0.0666198, 0.144928, -0.389135, -0.3132, 0.0598491, -0.165642, -0.0279558, 0.0512153, -0.164211, -0.109539, 0.0830348, 0.01249, 0.231201, -0.152051, 0.270464, 0.211968, -0.168382, 0.0285682, 0.0648855, 0.0108043, -0.00563832, -0.466059, -0.0678051, -0.241391, 0.218546, 0.572284, 0.131086, 0.281372, -0.0271554, 0.116445, 0.233229, 0.228907, -0.281094, -0.34122, 0.0172942, 0.000979629, -0.155116, -0.0178569, 0.0108577, 0.00272274, 0.065532, -0.169429, -0.0736354, 0.156384, 0.064507, 0.60996, 0.0255725, -0.0225932, -0.143952, 0.322818, -0.304843, -0.011994, 0.294022, 0.00716274, -0.0946784, -0.173604, 0.369872, 0.331919, -0.0140913, -0.194748, -0.574339, 0.0874385, 0.270547, -0.292345, -0.193592, -0.01228, 0.397374, -0.0846387, 0.0854406, 0.00836139, -0.0556534, -0.0242609, -0.114993, -0.105967, 0.123331, 0.135992, -0.0701486, -0.159649, 0.0053089, 0.112505, -0.143185, 0.231972, 0.35678, 0.150011, -0.190328, -0.0178457, -0.277726, 0.369697, -0.236608, 0.0812424, 0.176442, -0.16808, -0.31399, 0.225876, -0.152465, -0.137629, -0.238861, 0.245907, 0.367937, 0.252589, 0.0651276, 0.220901, -0.290245, -0.274524, 0.192334, 0.0151141, -0.0665106, -0.0476591, -0.0911801, 0.0803771, -0.210178, 0.0612683, -0.187055, -0.191152, 0.295361, 0.0120883, -0.3445, -0.504743, 0.0588628, 0.161703, -0.194368, -0.216779, -0.407841, -0.0675567, 0.350028, 0.327459, 0.116283, 0.352977, 0.341159, 0.281628, 0.20108, 0.116938, -0.175022, -0.235284, -0.140773, -0.209746, -0.0387566, -0.20975, 0.173669, 0.244144, 0.0903884, 0.117712, -0.263927, 0.0584171, -0.0895158, 0.874238, 0.0611372, 0.0771606, 0.112679, 0.219748, -0.441903, -0.11998, 0.0893959, 0.14205, 0.0738403, -0.124182, -0.117631, 0.115178, -0.399152, 0.200058, -0.624748, 0.0283654, -0.108103, -0.180804, -0.0812855, -0.0166613, 0.387667, -0.446347, 0.248709, 0.154178, -0.0153032, -0.177879, 0.111527, -0.256292, 0.172623, 0.0304971, -0.33749, 0.00253998, 0.0223283, 0.266384, -0.10191, 0.0743059, 0.108703, -0.233171, -0.278083, 0.151461, -0.243964, 0.181727, -0.495662, 0.176423, -0.0724676, -0.130789, -0.385785, -0.143938, 0.200125, 0.182621, 0.0199248, 0.0237667, 0.217226, 0.0685022, -0.0679243, 0.151613, -0.242071, 0.161653, 0.369101, -0.296762, -0.000349774, -0.0705702, 0.0583046, -0.0118726, -0.150388, -0.0779348, -0.277237, -0.163214, 0.440194, -0.189329, -0.378038, -0.249958, 0.117653, 0.0521599, -0.0284398, -0.444562, -0.178562, 0.0896723, 0.0787884, 0.397397, 0.147931, 0.199849, 0.348462, 0.0822668, -0.119118, 0.251546, -0.128958, -0.360437, -0.0166419, 0.159129, -0.0801451, -0.321248, -0.0472074, 0.341063, -0.0502078, -0.108989, -0.198663, -0.0462465, 0.126726, 0.234243, 0.444902, 0.230411, -0.083281, 0.0591539, -0.649738, -0.0217363, 0.133121, -0.246515, -0.0221438, 0.124767, 0.0266765, 0.0492056, -0.178684, 0.0433696, -0.694035, -0.132429, -0.0964364, -0.0490236, -0.124018, -0.0106004, 0.270395, -0.703009, 0.236052, 0.130763, -0.0734722, -0.142595, 0.0591847, -0.311586, 0.213959, -0.00160512, -0.349531, 0.153587, -0.0169392, 0.324867, 0.200718, 0.062508, 0.141618, 0.00807765, -0.435845, 0.0180161, -0.230923, 0.294852, -0.283782, -0.300826, 0.0866746, 0.130467, -0.593182, 0.120021, 0.0570841, 0.150672, 0.546336, -0.073261, 0.206339, 0.127645, -0.0275039, 0.261961, -0.418308, 0.318964, 0.153983, -0.0412198, -0.0546957, -0.026041, -0.118499, 0.111982, -0.175861, 0.190748, -0.339765, -0.316966, 0.211496, -0.150078, -0.510127, -0.504918, 0.0841414, 0.104647, -0.150079, -0.332717, 0.211952, -0.0162931, 0.0392988, 0.36783, 0.251214, 0.0867511, -0.13586, 0.0718556, -0.343761, 0.307777, -0.0865839, -0.173469, 0.0153841, 0.243548, -0.106382, 0.164953, -0.0428476, 0.196199, 0.042467, -0.186685, -0.0673687, -0.133358, 0.101227, -0.136221, 0.202667, -0.107998, 0.0197742, 0.0405852, -0.741452, -0.136557, 0.0218327, -0.363548, -0.333519, 0.30741, 0.000216825, -0.00912168, 0.0190453, -0.132683, -0.746289, 0.0766255, -0.115937, 0.125521, -0.0681188, -0.0367282, 0.205536, -0.793912, 0.125676, 0.031831, 0.273088, -0.0537662, 0.0314641, -0.0763315, 0.195971, 0.109113, -0.315073, 0.385931, -0.0421804, 0.115508, 0.155193, 0.0268497, 0.183164, -0.00571668, -0.371725, 0.114776, 0.074589, 0.141767, -0.266921, -0.406433, 0.175589, 0.032439, -0.925698, -0.11883, 0.182873, 0.0749916, 0.531774, 0.053604, 0.0482842, 0.0297156, -0.191114, 0.282565, -0.401597, 0.170457, 0.225163, 0.0609641, 0.283999, 0.0650666, 0.00615171, 0.0721127, -0.00549685, 0.278643, -0.33153, -0.360474, 0.102892, 0.122026, -0.496926, -0.277502, 0.189153, 0.203542, -0.08047, -0.663166, 0.396281, 0.00288508, -0.0123285, 0.450897, 0.153716, 0.267956, -0.241582, 0.0566512, -0.19401, 0.18989, -0.184256, -0.443178, 0.0703614, 0.101842, -0.0298152, -0.084063, 0.0219482, 0.394383, 0.203265, -0.318396, -0.125876, -0.0436335, -0.187026, -0.263143, 0.189761, -0.112393, 0.039406, 0.0112223, -0.531306, -0.0987245, 0.28789, -0.233409, -0.39331, 0.149605, 0.0351095, -0.0321635, 0.127589, 0.120307, -1.18782, 0.282528, 0.0201767, 0.0413724, 0.0208841, 0.0592938, 0.475763, -0.648334, -0.040742, -0.162987, 0.116578, -0.087559, 0.0872645, 0.0534605, 0.415313, 0.0343208, -0.241591, 0.191492, -0.0713386, -0.129908, -0.132638, 0.00878725, 0.0414208, -0.0794429, -0.242341, 0.0980127, 0.172071, 0.0673007, -0.188849, -0.153193, 0.123975, -0.105103, -1.0964, 0.0842678, 0.0326398, 0.15132, 0.0392288, -0.04924, 0.107766, -0.11852, 0.0365469, 0.190695, -0.15191, 0.228994, -0.0497728, 0.0608632, 0.113425, 0.0212282, -0.0962017, -0.0342818, 0.0686855, 0.0308914, -0.164528, -0.507551, -0.150198, 0.0818482, -0.684594, -0.000957682, 0.134489, 0.38999, -0.221283, -0.339504, 0.423765, 0.0656963, 0.0297755, 0.538008, 0.341933, 0.445648, 0.140306, 0.0894524, -0.129879, 0.0357114, 0.0056971, -0.288754, 0.146572, -0.307838, -0.0808008, -0.076262, 0.0362471, 0.539709, 0.231725, -0.0845962, 0.00807196, 0.00316186, -0.0846815, -0.0961846, 0.185967, -0.304184, 0.0230274, 0.230533, -0.261207, 0.196539, 0.43041, -0.180425, -0.257817, -0.143916, -0.0900589, -0.0377753, -0.0633635, 0.265337, -0.618769, -0.0282899, 0.134413, -0.00587627, -0.215261, -0.0899265, 0.375871, -0.436672, 0.0205125, -0.240648, 0.0748884, 0.0222083, 0.280609, -0.0239133, 0.453315, -0.0282274, -0.165901, -0.0845788, -0.0511246, 0.0862947, 0.293872, 0.0905244, 0.13286, -0.0630862, -0.180109, 0.211799, 0.172309, -0.0504013, -0.273146, -0.0837923}, {0.0706056, 0.180668, -0.391953, -0.148193, 0.236449, 0.219023, -0.022967, -0.0662242, 0.119207, -0.114681, 0.0439005, -0.0681189, -0.294503, 0.309545, 0.0850757, 0.0802026, 0.0538747, -0.0880419, 0.106108, 0.0893769, -0.0629969, -0.154472, 0.369296, -0.140821, -0.139078, 0.101333, -0.440966, 0.224429, 0.259143, 0.339011, -0.363324, -0.126765, 0.305511, 0.0723217, -0.169859, 0.612996, 0.225231, 0.01827, 0.183744, 0.036235, -0.223516, -0.102653, 0.184707, -0.147177, 0.0634945, -0.618936, -0.0201212, -0.144462, -0.0356111, 0.376049, 0.131246, -0.0609918, 0.262157, 0.162554, 0.155126, -0.122265, 0.176833, -0.32436, 0.250538, 0.137671, 0.011267, 0.152206, 0.282737, -0.372805, -0.347703, 0.0967247, 0.0110664, 0.101277, -0.0546092, 0.00636405, -0.252265, 0.0290108, 0.0740524, 0.071677, -0.0476488, 0.0414884, 0.460037, -0.129732, 0.0326437, -0.0165298, 0.0421993, 0.165154, 0.30775, -0.109666, 0.298067, 0.195711, -0.0716174, 0.225247, -0.088575, -0.120395, 0.246864, 0.253802, -0.090901, 0.166104, 0.192014, 0.155799, 0.00690007, 0.083174, 0.0826464, -0.123485, 0.422246, 0.255243, -0.338329, 0.0496667, 0.295947, 0.015545, 0.000534492, -0.0645127, 0.158298, -0.353448, 0.28704, -0.783238, -0.130298, 0.384798, -0.0602257, 0.0757085, -0.102856, -0.0155304, 0.154685, 0.0361694, -0.26849, 0.0336661, 0.400674, -0.0628729, -0.324364, 0.20156, -0.583681, -0.0493439, 0.223669, 0.13154, -0.752873, -0.218584, 0.39589, 0.140322, -0.199415, 0.545928, 0.232901, 0.0132795, 0.102598, 0.0764844, -0.213542, -0.115293, 0.122795, -0.00406276, -0.00191631, -0.927585, 0.130407, -0.122209, -0.11388, 0.198394, -0.301459, 0.212286, 0.310561, 0.148664, 0.105028, -0.315185, 0.214648, -0.165785, 0.0854085, 0.126416, 0.0504665, 0.0505983, 0.305408, -0.00589548, -0.350507, 0.102642, 0.141944, 0.235724, -0.362638, -0.0660886, -0.0734565, -0.0819952, 0.245097, 0.230278, -0.154493, 0.0463401, 0.492582, -0.0520145, 0.0375184, -0.109231, -0.266939, 0.0884688, 0.457283, -0.235499, 0.0879809, -0.0754138, -0.00543817, 0.212361, 0.042994, -0.114031, -0.0348314, 0.167711, -0.284534, 0.301282, 0.108731, 0.0797483, -0.0279927, 0.0444321, -0.0514446, -0.0823206, 0.330753, -0.047124, 0.00505632, -0.0312299, 0.0547337, -0.102984, 0.171506, -0.268988, 0.0834844, -0.563504, 0.0509839, -1.00358, -0.0169966, 0.401017, -0.143094, 0.220859, 0.116204, -0.0718203, 0.109368, 0.136176, -0.110489, 0.0657902, 0.260564, -0.0720482, -0.180693, 0.406686, -0.339731, 0.0342774, 0.107894, -0.298057, -0.753509, -0.0596639, 0.100266, 0.130788, -0.0689667, 0.393133, 0.514187, 0.156977, -0.0313342, 0.15346, -0.100134, -0.0793562, 0.0522806, 0.11421, -0.127513, -0.49885, 0.121798, 0.0073647, 0.0476656, 0.127767, -0.711716, -0.0524768, -0.0741272, -0.0276095, 0.0138378, -0.189411, 0.181683, 0.0132926, 0.119522, 0.115307, 0.3995, 0.162869, 0.371824, 0.175785, -0.156339, -0.0117515, 0.0326271, 0.303862, -0.164035, -0.0818509, -0.0106868, 0.00582587, 0.132859, 0.109696, -0.219368, -0.0618034, 0.384669, 0.201113, 0.031708, 0.258803, -0.188671, -0.0193551, 0.413627, -0.0193557, 0.148025, -0.0914135, 0.0125244, 0.397127, 0.0544279, -0.0158198, -0.0764207, -0.017613, -0.179516, 0.0907996, -0.00972122, 0.0144577, 0.10481, -0.197636, 0.0690795, -0.0657205, 0.367079, 0.129918, 0.171119, -0.17031, -0.355606, -0.17905, 0.19474, -0.218547, 0.0649748, -0.169443, -0.229745, -0.700388, -0.182547, 0.295869, -0.0813761, 0.00135592, -0.00609552, 0.0583991, 0.215648, -0.226291, -0.0632109, 0.0408269, 0.211065, -0.071737, -0.10536, 0.181405, -0.345519, 0.0622019, -0.00353414, -0.180277, -0.849969, 0.399392, 0.0931226, 0.0671454, -0.124437, 0.295979, 0.643823, 0.155924, -0.0712517, 0.130815, -0.0800629, -0.150072, -0.0734643, -0.0168449, -0.229128, -0.532689, -0.180698, 0.00800549, 0.0246439, -0.0799419, -0.771579, -0.127428, -0.205233, 0.107598, -0.184377, 0.00825493, 0.209838, -0.24988, 0.191441, 0.0396389, 0.516393, 0.125939, 0.25972, 0.249493, 0.149666, 0.12497, -0.00688706, 0.339959, -0.018049, 0.0724544, -0.0936818, 0.0706983, 0.147425, -0.0792774, -0.217284, 0.0404432, 0.232256, 0.312443, 0.0639769, 0.0644924, 0.0358438, 0.153259, 0.297524, 0.172649, 0.118124, 0.128958, 0.0340923, 0.263084, -0.0200412, -0.0173983, 0.0133686, 0.0842081, 0.0843535, 0.128022, 0.213178, 0.153605, -0.0749556, -0.164758, -0.0435659, 0.0748455, 0.290622, 0.150604, 0.0776988, -0.114311, -0.358902, -0.135208, 0.11034, -0.0740568, -0.0348269, 0.188303, -0.301903, -0.306014, -0.38171, 0.304519, -0.129407, 0.019, 0.0631627, -0.00902599, -0.220514, -0.0192522, -0.0832091, -0.164197, 0.153551, 0.023572, 0.193015, -0.149471, -0.303014, 0.122665, -0.561233, 0.0263442, -0.667482, 0.350892, 0.0148436, 0.0795347, 0.0460569, 0.183035, 0.363861, -0.0538464, 0.316413, -0.100975, -0.0550559, 0.0305276, -0.16022, -0.0583875, -0.222966, 0.00203891, -0.125122, -0.0649289, 0.0335114, 0.131639, -1.06124, -0.0267601, 0.164484, 0.139079, -0.276525, 0.0877136, 0.30357, -0.272949, 0.283621, 0.0503709, 0.613349, -0.00649982, 0.38723, 0.140654, -0.00264446, -0.0413152, 0.0448663, 0.0114355, -0.241084, -0.0159229, 0.127647, 0.04238, -0.232007, -0.113718, -0.0485724, 0.0431895, -0.225197, 0.252503, -0.0323461, -0.107992, 0.26732, 0.103599, 0.274285, 0.160035, -0.0614294, 0.0158066, -0.0230313, 0.262093, -0.0734123, -0.0578969, 0.126782, 0.0217975, 0.0882404, 0.258985, 0.164828, 0.100713, -0.0410295, 0.030393, -0.141202, -0.00378031, 0.24709, 0.0440369, 0.262026, -0.0516051, -0.251399, -0.224941, -0.0630031, -0.0208337, 0.208793, 0.202421, 0.0431023, 0.0569275, -0.423485, 0.346183, 0.0578708, -0.0178881, 0.0135206, 0.0443287, -0.39764, 0.0104632, 0.0248483, -0.0928946, 0.164283, 0.0105813, 0.00105583, 0.209484, -0.520703, 0.0427868, -1.08706, 0.203839, -0.845028, 0.339346, -0.349272, 0.258261, 0.127657, 0.139071, 0.645346, 0.1472, 0.0466671, 0.0257078, 0.00299645, 0.00502087, 0.0337805, 0.0163371, -0.256597, 0.215304, -0.19986, 0.00502932, 0.023771, 0.131782, -0.930048, 0.0666991, 0.0958406, 0.116815, -0.00191937, 0.0484662, 0.145869, -0.434251, 0.183881, -0.0461804, 0.545441, 0.00329494, 0.111481, 0.189471, 0.173747, 0.0604149, -0.0245452, 0.0486923, -0.0277296, 0.0748167, 0.282445, 0.185332, -0.405064, -0.170621, 0.255367, -0.0865212, -0.620749, 0.155058, 0.04525, -0.218195, 0.0888364, 0.103613, 0.0435066, 0.124572, -0.21816, 0.0872384, 0.0602958, 0.200745, 0.0234455, 0.0308705, -0.034219, -0.133789, 0.0717276, 0.0878058, -0.0666871, 0.324381, 0.171167, 0.0657476, -0.15362, -0.182947, 0.360652, 0.0605712, 0.439741, -0.329431, -0.0946954, -0.0789511, -0.126567, -0.0269025, 0.050585, 0.0420061, -0.0162927, 0.268408, -0.242746, 0.0518671, 0.162793, -0.054196, 0.0871277, -0.0360091, -0.249721, 0.13836, -0.0929789, -0.0299473, 0.309915, 0.114959, 0.119192, 0.388231, -0.347983, 0.0423752, -0.607345, 0.220837, -0.551943, 0.249379, -0.33831, 0.461224, 0.0280415, 0.128806, 0.434256, 0.015465, 0.0243048, -0.0282282, -0.188478, 0.124163, -0.251997, -0.00592152, 0.0199792, -0.0390481, -0.0870213, -0.200172, -0.075492, 0.0295861, -0.788602, 0.151871, 0.229901, -0.0262387, -0.00433296, 0.220664, 0.0244143, -0.630826, -0.478928, 0.143222, 0.205778, -0.0286111, -0.100951, 0.329096, 0.15764, 0.255243, -0.0616096, 0.0165913, -0.0616672, -0.085948, 0.262028, -0.0343512, -0.612705, -0.167333, 0.0009051, -0.0541246, -0.605621, 0.0619807, 0.17387, -0.10251, 0.198824, -0.16658, 0.258891, -0.0765903, -0.701232, 0.14183, 0.197154, -0.0655368, -0.0172568, 0.193832, 0.138761, -0.244071, 0.0029775, 0.126112, -0.159272, 0.223078, 0.124066, 0.00441088, 0.0415035, -0.231042, 0.548508, 0.310168, 0.191865, -0.236651, -0.0328042, -0.119617, -0.103075, -0.0324314, 0.132027, 0.0707181, 0.163958, 0.254364, -0.131226, -0.0352205, -0.311306, 0.00440628, 0.123274, 0.050118, -0.39178, -0.0186881, -0.0582341, -0.330956, 0.222681, -0.168977, -0.0792359, 0.184023, 0.0221856, 0.0941022, -0.0963062, 0.208192, -0.530389, -0.0605257, -0.266815, 0.635209, -0.0463429, 0.215236, 0.263447, 0.0113755, 0.0494063, 0.122684, -0.0548271, -0.354044, -0.0869145, -0.0981316, -0.247837, -0.269128, -0.390766, -0.28111, 0.0297999, -0.0652188, -0.967969, 0.130873, 0.326703, -0.0548656, -0.166122, 0.132832, -0.000977607, -0.397452, -0.298862, -0.0500478, 0.13052, -0.124215, -0.298584, 0.363615, 0.340832, 0.167168, -0.0458443, -0.0368272, -0.0737868, -0.089725, 0.142447, 0.161848, -0.274453, 0.102059, 0.0388112, 0.0337905, -0.415067, -0.0789068, 0.364819, -0.128135, 0.270842, 0.145577, 0.102155, -0.0948112}, {-0.772838, 0.189368, 0.0903844, -0.0452911, -0.056591, 0.0257296, -0.0511782, -0.33378, -0.587893, 0.000468209, 0.0172432, 0.331778, 0.0957884, 0.0369048, 0.0875929, -0.0280932, 0.403574, 0.0915407, 0.00995944, -0.220114, 0.297007, -0.147901, 0.204837, -0.185829, 0.00542923, 0.284581, 0.160502, 0.193933, -0.267349, -0.375736, -0.223668, 0.0520322, -0.0807659, 0.0412641, -0.778714, -0.0332473, 0.0726042, -0.404465, -0.0160373, -0.00411773, -0.0326146, -0.0661841, -0.184702, -0.108075, -0.10106, 0.181194, -0.558096, -0.0173287, -0.362862, 0.333585, 0.210918, 0.164522, 0.537587, 0.017987, 0.277681, 0.240576, -0.0212245, -0.122406, 0.13499, -0.157206, -0.554813, -0.105926, -0.193448, -0.313571, 0.131529, 0.360807, -0.946044, 0.147252, 0.122139, -0.0628431, -0.501016, 0.0389855, 0.08335, -0.535856, -0.260327, -0.0986313, -0.102105, 0.0322444, -0.0264817, 0.099322, 0.234126, 0.0833483, -0.0740768, 0.0445716, -0.0662519, -0.0783068, -0.255762, 0.00203618, 0.0278686, 0.134908, -0.44376, 0.0684025, -0.532297, 0.179945, 0.515794, 0.064789, 0.310591, 0.233705, -0.223822, -0.0760069, -0.620161, -0.130137, -0.0155858, -0.138229, 0.035273, -0.144613, -0.0841654, -0.254501, -0.321479, 0.170458, 0.015404, 0.345074, 0.310082, 0.241223, 0.0672141, 0.366608, 0.362367, 0.0863452, -0.28872, -0.203809, 0.0894851, -0.151502, -0.103752, 0.0716117, -0.0844145, 0.326793, 0.106442, 0.172075, -0.502055, -0.463594, -0.21716, -0.19404, -0.0775816, -0.0598001, -0.520592, -0.0612122, 0.202355, -0.304829, -0.404565, -0.0354274, 0.164579, -0.401902, -0.323247, -0.456727, -0.0569736, 0.214159, -0.697707, -0.0234553, -0.475018, 0.299414, -0.113394, -0.0235007, 0.0689611, -0.139117, 0.190742, 0.0525464, -0.201206, 0.0686928, 0.258735, -0.0709099, -0.299275, 0.119536, 0.0166812, -0.303915, -0.108699, 0.500078, -0.694526, 0.13513, -0.00326736, 0.129605, -0.291787, 0.0717191, 0.374368, -0.23908, -0.506594, 0.00650989, -0.392368, -0.17343, 0.599591, 0.148874, 0.0139098, 0.126907, -0.133616, 0.127185, -0.132738, -0.117919, -0.209256, 0.229268, -0.452206, 0.204139, -0.645981, -0.0335695, -0.111602, 0.170428, 0.314964, 0.115951, -0.150669, -0.0601534, -0.415427, 0.226458, -0.630515, -0.00360164, -0.151095, -0.486727, -0.00461358, -0.264113, -0.170795, -0.461967, -0.0105088, -0.0247622, 0.0512225, 0.147573, 0.0837247, 0.707124, 0.192922, 0.381702, -0.0584244, -0.0868083, -0.266401, -0.0601192, -0.355035, 0.114762, -0.226305, 0.0182448, -0.197932, 0.606569, -0.166067, 0.228718, -0.374063, -0.672095, -0.375915, -0.774327, -0.194328, -0.0764253, -0.695881, 0.0305765, 0.121611, -0.121104, -0.705307, 0.556466, 0.347277, -0.34955, -0.288023, -0.150206, -0.0763658, 0.598149, -0.647926, -0.140309, -1.16306, 0.458114, -0.521482, -0.49151, -0.144522, 0.0122978, 0.0505297, 0.0775256, 0.332255, -0.12043, -0.0579309, -0.355912, -0.087419, 0.16121, 0.0439511, -0.492394, 0.0521821, 0.256458, -0.511329, 0.342979, -0.181768, -0.227458, -0.320523, 0.288097, -0.14867, 0.0517827, -0.0105308, -0.0731164, 0.0220545, -0.00868109, 0.0705713, 0.183899, -0.0112575, 0.110075, -0.0878892, 0.108429, -0.0582742, 0.149153, -0.0518185, 0.0873788, -0.0278975, -0.0439107, 0.0141799, -0.061939, 0.155449, -0.0181516, 0.0270719, 0.0644137, 0.0296397, 0.0761054, -0.099996, 0.0236961, -0.063781, 0.165284, 0.163727, 0.0357469, 0.0238344, -0.122026, -0.16257, 0.123596, 0.0819321, 0.114703, 0.0543175, 0.0439936, 0.0157595, -0.0385766, 0.0395317, -0.121427, 0.0443172, -0.0841833, -0.163605, 0.00522509, 0.124064, -0.109387, -0.0539554, -0.0664948, 0.120408, 0.0655829, -0.0239206, -0.214366, -0.0307888, 0.224064, 0.061341, -0.0785124, 0.0931239, -0.0641255, -0.0748085, -0.101498, -0.0128618, -0.0507016, -0.0416339, 0.0150972, -0.0561698, -0.0396849, 0.0333106, 0.0914241, -0.0278099, 0.0217182, 0.0337767, 0.187579, -0.0301952, -0.00179381, -0.0502852, -0.120475, 0.148117, 0.12164, 0.0216522, -0.0385846, 0.0102485, 0.0580769, -0.140222, 0.140229, -0.0997646, 0.17978, -0.112775, -0.0893248, 0.0482353, -0.108482, 0.133701, -0.0104454, -0.0720178, -0.0604259, -0.041239, 0.124303, -0.0679197, -0.0214871, -0.0449148, -0.0342283, 0.0683381, 0.0496829, 0.0995355, 0.0646482, 0.0214386, 0.0281691, -0.114591, 0.126667, -0.0604279, 0.0592011, 0.00644495, 0.146489, 0.0276798, 0.05489, -0.101722, -0.0252984, 0.066495, -0.0257599, -0.109488, 0.101952, 0.0386557, 0.0449966, -0.0211362, -0.0518631, -0.0117406, 0.0864453, 0.119362, 0.0514831, 0.0681523, -0.0411534, 0.00443399, 0.161816, 0.0898161, -0.047747, 0.0826504, 0.00873659, 0.167082, 0.0775077, -0.0191642, 0.0390895, 0.0244151, -0.0833863, -0.152045, -0.0694953, 0.120232, -0.0697215, -0.0207305, 0.0227626, 0.0954942, 0.0436214, 0.0843042, -0.09048, 0.00376745, 0.0832494, 0.0303295, -0.0332098, -0.0331608, 0.0210544, -0.0984543, 0.0100156, -0.0939391, 0.0121525, 0.037474, 0.0801881, -0.0549132, 0.0438472, 0.0130199, 0.0848304, -0.0691324, -0.0461335, 0.0173513, 0.150149, -0.0813998, 0.00362732, -0.0781692, -0.00455762, 0.0215617, 0.0125436, 0.0150637, -0.000258273, -0.0675819, 0.0164067, -0.0739847, 0.123749, 0.05087, 0.162154, -0.0426476, -0.102017, 0.0845237, 0.0446379, 0.125284, -0.0481819, -0.081667, -0.0872262, -0.03631, 0.152939, -0.0969116, -0.00682516, -0.0188523, -0.0334102, -0.00791436, 0.0333467, 0.1249, 0.0372732, -0.0671964, 0.0652589, -0.0550283, -0.029634, -0.110168, 0.114149, -0.0255715, 0.143051, 0.00482099, 0.00400409, -0.0396639, 0.0562184, 0.0671755, -0.0306458, 0.000462061, 0.0709463, 0.0330936, 0.130051, -0.180849, 0.0395072, -0.0851106, 0.126114, 0.0747646, -0.00150383, -0.0586373, -0.110655, -0.0842591, 0.15372, -0.0414164, 0.0459225, 0.0057965, -0.00242551, 0.0490176, 0.0546081, 0.0805413, -0.121782, -0.00655408, -0.0831057, -0.111668, 0.0846096, 0.171075, -0.107086, -0.123449, 0.0784628, 0.0282866, 0.0827823, -0.0334692, -0.0495998, -0.0328305, -0.0227153, 0.00778411, -0.0895956, 0.0235203, 0.00301144, -0.0666645, -0.022132, -0.107694, -0.0504157, 0.0210975, 0.0597721, -0.0705095, -0.0483647, -0.0266452, 0.0209829, -0.0619617, 0.0773648, -0.0546812, 0.203679, -0.0100402, -0.0469332, -0.128362, -0.0460874, -0.0789281, 0.150127, -0.0928206, -0.0259329, -0.0465531, 0.02982, -0.147461, 0.119539, -0.0507365, 0.206013, -0.0703525, 0.00702633, 0.0257455, -0.0286687, 0.0619683, 0.00839299, -0.0521462, 0.024557, 0.0595674, 0.102375, -0.0952012, -0.00688291, 0.105372, 0.0216893, -0.0428654, 0.00250704, 0.123461, 0.0438961, 0.0415466, 0.0444399, 0.0434544, 0.0772828, -0.035539, 0.0657381, -0.0309964, -0.0145259, 0.0207117, 0.0261447, 0.0550833, -0.0262269, 0.0438439, 0.0242224, -0.0358143, -0.0114595, -0.0603983, 0.00484528, 0.0282866, -0.0277267, -0.0519281, 0.110469, 0.0672995, 0.0424681, -0.0162167, -0.10456, -0.0946088, 0.118564, 0.0467662, -0.014121, -0.0321591, 0.143753, 0.10513, -0.0109435, 0.0749151, -0.0182055, -0.0736034, -0.030242, -0.0542818, 0.0934855, 0.0838649, -0.085414, 0.0526936, 0.0408731, -0.0112666, -0.0211964, 0.0644653, -0.0185112, -0.00459226, 0.0447705, -0.060406, 0.076465, -0.0489905, -0.0656734, -0.0320455, -0.0770387, -0.00956601, -0.000642212, 0.0749271, 0.00331886, -0.079305, -0.0675837, -0.0726025, -0.0184431, -0.0568169, 0.10065, -0.0665326, 0.0612572, -0.0374697, -0.0971373, 0.0292238, 0.00597943, -0.0502375, 0.0764545, -0.0435425, -0.0715808, 0.0530142, 0.0694429, -0.0181435, 0.144448, -0.0371354, 0.0482588, -0.0317, -0.0379888, 0.0917765, -0.0678219, 0.0573412, 0.0625304, 0.0222985, 0.0644083, 0.0256701, 0.0495092, 0.0460449, 0.0136736, -0.0805749, -0.00159381, -0.000964038, -0.000797234, 0.0374611, 0.0729597, 0.00810544, 0.0232898, -0.0575513, -0.0369483, 0.00241496, -0.0262719, 0.0185811, 0.0659547, -0.0754985, 0.0783277, 0.0674571, 0.0344982, -0.0791119, 0.032287, 0.0241123, -0.0066158, 0.00501901, -0.0224575, -0.00948361, -0.0736873, 0.0542432, -0.0671343, -0.0705174, 0.0381984, 0.0591414, -0.0248042, 0.0331346, -0.0808133, 0.0145674, 0.063114, 0.0407011, 0.0501828, -0.0292937, -0.00522794, 0.0312083, -0.0249185, 0.00835038, -0.000771798, -0.0329083, 0.0553837, -0.00132475, 0.0198837, 0.00810617, 0.0116993, 0.0305598, 0.0197563, 0.0764866, -0.0816792, 0.0784173, 0.0256753, -0.00665076, 0.00582719, -0.0672591, -0.0243386, 0.0479674, -0.0230468, -0.0349888, 0.0718336, -0.0469966, 0.0679762, 0.0588011, 0.00396252, 0.000415668, 0.0764696, -0.019727, -0.0560391, 0.0431855, 0.0582417, 0.0156707, -0.0202001, -0.0455001, -0.0315343, -0.0320983, -0.0278271, 0.00891431, 0.0382557, -0.049067, 0.0702235, -0.0678177, -0.0404747, 0.0171334, -0.0241867, 0.0375597, -0.00515487, 0.0723848, -0.0425172, -0.0516431, 0.0342921, 0.027456, -0.031591, 0.0381426, -0.0147115, 0.0071891, 0.0250974, 0.0540894, -0.0738659, -0.0654071, -0.0134991, 0.0136945, -0.0155233, -0.00169156, 0.0388747, -0.0307713, -0.0066921}, {-0.0268265, -0.0590853, 0.070493, 0.0158668, 0.0449425, 0.0434908, 0.0361813, 0.0548387, 0.0367231, 0.112184, 0.0798196, 0.135263, 0.107297, -0.0662232, -0.0670411, -0.0367364, -0.109512, 0.0653149, -0.0484851, 0.0117218, -0.0341978, -0.0539027, -0.0210698, 0.0939619, -0.0025847, -0.0295762, -0.0735297, 0.0262587, -0.0366675, -0.0177077, -0.0214323, -0.0462636, -0.122158, -0.0372142, 0.0549766, 0.0679647, 0.0500983, -0.0181465, -0.0736705, -0.0656315, -0.00661025, 0.0662138, -0.0209808, 0.127701, -0.0983502, 0.00522646, 0.0393384, 0.0181705, -0.127823, 0.0681977, 0.091891, 0.0186574, 0.0533294, 0.050557, 0.0678241, 0.0385739, 0.105734, -0.0172287, 0.0515045, 0.0966367, 0.00284309, 0.0857932, -0.0831494, -0.0152076, 0.0603751, -0.0399618, 0.0514841, 0.0598139, -0.0463191, -0.0380077, 0.0181105, 0.00157107, -0.018537, 0.0657978, 0.0628091, -0.0454613, -0.0442368, -0.0308469, -0.0269945, -0.0470029, 0.0536447, -0.00120372, 0.0127503, 0.10153, 0.115904, 0.00205024, 0.10196, -0.00837509, 0.0203599, -0.11521, -0.0351749, 0.0789517, -0.00670301, 0.00830726, -0.00150933, 0.0624311, -0.0425337, 0.0506181, -0.135962, -0.0765079, -0.0235866, 0.00298514, -0.026857, -0.0384514, 0.123693, 0.0946163, 0.0353147, 0.00550519, -0.233062, 0.146468, 0.12142, 0.0868718, 0.0461441, 0.0896021, -0.0661128, 0.129638, -0.014062, 0.00620855, -0.0350464, 0.00151709, -0.0556571, -0.0852749, -0.0788156, 0.15406, 0.0332349, -0.0522928, -0.0201179, 0.00655861, -0.102068, 0.0592719, -0.0360227, 0.0355231, -0.0968666, 0.0133543, 0.0451891, -0.00401197, -0.0641914, -0.0269263, -0.0847126, 0.0122096, 0.0675892, 0.108572, 0.0760742, 0.0934677, -0.0346066, 0.0770914, 0.128343, 0.172614, -0.0178985, 0.0297083, 0.0607639, -0.0108193, -0.0653197, 0.0977001, 0.0773692, -0.0791103, 0.0693426, -0.0646725, 0.000836182, 0.0897275, 0.0592786, 0.147701, -0.151983, -0.100736, 0.000395567, -0.0300983, -0.00779898, -0.134178, -0.0995298, 0.0582346, 0.0686176, -0.111266, -0.139063, 0.0748498, -0.0510241, -0.100178, -0.00191169, 0.109704, 0.0880762, 0.0239594, 0.0401976, -0.0532622, -0.226247, 0.160287, 0.0533613, -0.00858856, 0.152301, 0.123317, -0.0146471, -0.222754, -0.187306, 0.00690673, -0.0230312, 0.116837, -0.102809, 0.149621, 0.0714501, -0.148121, 0.0169665, 0.124735, -0.031934, 0.0581445, 0.0626687, 0.0768152, 0.20808, 0.0555065, -0.203278, -0.0408266, -0.148714, 0.235954, 0.0697355, 0.0722566, 0.174491, 0.0181134, -0.0164628, 0.293933, -0.119331, 0.095403, 0.0235274, -0.125414, 0.035702, 0.017971, -0.103334, 0.246865, 0.0724626, -0.0755079, -0.00590884, -0.0784571, -0.0338126, 0.212982, 0.0403935, 0.021732, 0.0372419, -0.0982126, 0.0874662, -0.105118, 0.00554602, 0.202023, -0.121654, -0.0566065, 0.118566, 0.161086, 0.0313705, 0.105786, -0.0270757, 0.117251, 0.181572, 0.0996706, -0.0290926, -0.053893, 0.0432004, 0.0466988, -0.0213986, 0.0452383, 0.120554, -0.129761, -0.00917952, 0.0321675, 0.18945, 0.153711, 0.038433, 0.150813, -0.136039, -0.102285, -0.124882, 0.134601, -0.285134, -0.134855, 0.0618103, 0.0398991, 0.111907, 0.132732, -0.0741466, 0.21723, -0.101652, 0.00957992, -0.0709374, 0.127068, 0.134744, 0.0251331, 0.20179, -0.112557, -0.0823402, -0.0166164, 0.116045, -0.0624812, 0.0905734, -0.0168367, 0.254814, -0.23212, -0.172661, -0.211239, -0.54019, 0.163458, 0.322207, 0.115971, -0.347997, -0.282738, 0.00869245, 0.139954, 0.0717509, -0.0414078, -0.737879, 0.254393, 0.0236954, -0.235261, -0.0407798, 0.0851661, -0.0456963, 0.753246, -0.298163, 0.0549494, 0.143852, -0.097611, -0.20699, -0.00634295, 0.0578173, 0.209323, 0.0354996, 0.0319367, -0.0913516, 0.0269101, 0.248599, 0.361441, -0.277266, 0.0015992, 0.36294, 0.21229, -0.0192783, 0.202345, 0.10305, 0.277465, 0.127678, -0.414499, -0.44977, -0.297026, -0.342939, -0.568405, -0.209759, 0.43286, 0.382292, 0.534115, -0.260518, 0.0776978, -0.00468322, -0.184457, 0.162275, -0.158118, -0.559281, -0.0341467, -0.353482, 0.199296, 0.382641, -0.103746, -0.30024, 0.196754, -0.417075, -0.0884372, 0.142069, -0.0255011, -0.408211, 0.432242, 0.128518, 0.208451, -0.355216, -0.16302, -0.370185, -0.0220925, -0.428215, 0.0131796, 0.222842, 0.130508, 0.198765, -0.231838, 0.178418, -0.136839, -0.0556007, -0.0096573, 0.00271647, -0.52257, -0.249703, -0.0980931, 0.458115, -0.104907, -0.328623, 0.169519, -9.7343e-05, 0.0806686, 0.232993, 0.176814, -0.404344, -0.367165, -0.421957, 0.102641, 0.0875478, -0.0498744, -0.307523, -0.114736, -0.19873, -0.100682, 0.0834786, 0.0956722, -0.6384, 0.0426303, -0.00311007, -0.158844, -0.0567673, -0.0677082, 0.112355, 0.29352, -0.0120276, 0.329968, -0.0327046, 0.053713, -0.0126011, -0.0396308, 0.0668883, -0.0501238, -0.067416, -0.166876, -0.0828429, 0.160649, 0.0148065, 0.0478518, -0.120936, 0.145085, 0.227619, 0.171593, -0.224734, 0.154752, 0.257883, 0.0687349, -0.0137525, -0.181972, -0.20226, -0.268885, -0.00403956, -0.254673, -0.463602, 0.390008, 0.338733, 0.228383, -0.217122, 0.0899812, -0.175429, -0.101137, 0.0277564, 0.151816, -0.325936, -0.0215182, -0.233999, 0.366853, -0.0290151, -0.403565, -0.518115, -0.134562, -0.572778, 0.0888592, -0.10818, 0.280959, -0.0886814, 0.215631, 0.197302, -0.223346, -0.178058, 0.124558, -0.250188, 0.429273, -0.320077, 0.140983, -0.20396, 0.008472, 0.0617448, 0.0763855, 0.222031, 0.207578, -0.0104617, -0.0471647, 0.113716, -0.219144, -0.211158, -0.0864133, 0.234994, 0.0712048, 0.094944, 0.0807762, 0.0202055, -0.114696, -0.0497856, 0.0434255, -0.136665, -0.386881, -0.0814801, 0.187634, 0.0426754, -0.0340863, -0.341871, 0.011938, -0.298771, -0.0913669, 0.370915, -0.0138439, -0.418446, -0.0256778, 0.160468, -0.20773, 0.0332791, 0.0659476, 0.147674, 0.197218, -0.00798055, 0.346696, -0.152634, -0.0611761, -0.0416654, 0.204352, -0.210931, 0.137692, -0.278962, -0.493105, -3.34921e-05, 0.202126, 0.106018, 0.0179338, 0.057354, 0.00637723, 0.0209905, 0.241503, -0.30578, -0.300538, 0.233794, -0.249368, 0.0670845, -0.041926, -0.454122, -0.0120489, 0.0629182, -0.163858, -0.317951, 0.468457, 0.141221, 0.174322, -0.197874, 0.0318749, -0.00375909, -0.0521436, 0.0932815, 0.0492411, -0.154109, 0.0693228, -0.0435413, 0.158524, 0.0683067, -0.53473, -0.397361, -0.0176803, -0.0623858, 0.0258979, 0.100641, 0.0923381, 0.134158, 0.114076, 0.00856853, -0.516773, -0.327378, -0.0939054, -0.0189615, 0.556295, -0.344334, -0.090654, -0.0176516, 0.172784, 0.091777, -0.0350407, -0.0353887, 0.109872, 0.073704, 0.0929584, -0.130542, -0.0459339, -0.0235112, -0.0164746, -0.0688571, -0.0701208, 0.29653, 0.291139, -0.0302978, 0.0877617, -0.115759, 0.0105497, 0.197841, 0.0138094, -0.36098, 0.40798, 0.112708, -0.0301895, -0.322017, -0.072756, -0.110423, 0.157924, 0.142426, -0.387376, -0.179507, -0.0690563, 0.149423, -0.140443, -0.299955, -0.0400857, 0.369141, 0.143853, 0.00548863, 0.230426, -0.0952943, 0.160887, 0.139379, 0.18913, -0.217406, 0.0189319, -0.00998309, -0.58736, -0.0535874, 0.0427917, -0.027858, -0.119666, 0.165877, -0.0575604, -0.0533582, 0.211722, -0.268846, -0.0601127, -0.118103, -0.0491313, 0.192719, -0.0156913, -0.575842, 0.073102, -0.230417, 0.122169, -0.791605, 0.388887, 0.182729, 0.266162, -0.059661, 0.0570046, -0.279414, 0.018338, 0.035519, -0.0883135, -0.105947, -0.0595286, -0.180681, -0.194853, -0.263211, -0.010789, -0.218296, -0.165377, 0.211611, 0.0478565, 0.0637105, -0.163572, 0.0464884, 0.139452, -0.199817, -0.683254, -0.137491, -0.565367, 0.21329, 0.356595, -0.0303478, 0.0451558, -0.0352197, -0.0332326, 0.206634, -0.028336, 0.222101, 0.0911702, -0.013789, 0.0435326, -0.0601882, 0.00554988, -0.0998979, 0.215628, 0.133123, -0.063501, 0.160716, 0.328598, 0.0786196, 0.136753, -0.0432397, 0.000655457, -0.00615372, 0.363189, -0.444365, 0.133832, 0.0435737, 0.109804, -0.0429356, -0.286603, -0.179647, 0.0996241, -0.0426048, -0.0162876, -0.487233, 0.0749459, -0.0571353, -0.0240522, -0.250598, 0.0297316, 0.39594, 0.214597, 0.316203, 0.212303, -0.12486, -0.0909685, -0.0659868, 0.151454, -0.188038, -0.0217457, 0.192138, -0.223058, 0.0505892, 0.196386, -0.144246, 0.172698, 0.1915, -0.176322, -0.0888489, 0.193539, -0.202927, 0.156396, -0.0698092, 0.0535046, -0.0736878, -0.058452, -0.536482, 0.039503, -0.244658, 0.126387, -0.686413, 0.133684, 0.195287, 0.236061, -0.000697149, 0.255517, -0.153956, -0.103984, 0.200669, -0.101214, -0.113081, -0.0360059, -0.0488687, -0.139164, -0.386481, 0.0817721, -0.610796, -0.0213883, 0.220094, 0.189492, 0.0415067, -0.241774, 0.0889005, 0.166142, -0.0998023, -0.384014, 0.0549187, -0.122247, 0.31016, 0.450701, -0.015048, 0.104237, 0.241227, -0.0543457, 0.158173, 0.0454933, 0.138405, -0.0677325, -0.195257, -0.298472, -0.0844788, 0.177558, -0.210152, 0.173166, -0.0594352, 0.0481849}, {-0.149702, 0.199495, 0.233077, 0.339201, 0.100256, 0.10024, 0.166355, 0.0811111, -0.472907, 0.158174, -0.123645, -0.0444397, -0.148573, -0.0895447, -0.253807, 0.121646, -0.169092, 0.0639056, -0.563662, -0.391405, 0.0227595, -0.0042042, -0.0656947, -0.0160036, 0.363775, -0.26113, 0.200267, 0.213889, -0.0931578, 0.0112777, 0.0660567, -0.0326094, 0.00605626, -0.135369, 0.0496074, -0.25075, -0.0590465, 0.285777, -0.167882, -0.0291572, 0.00045977, -0.196374, -0.436523, 0.162635, -0.0971984, 0.0560606, -0.183603, -0.0484166, 0.0939748, 0.0405096, -0.791586, -0.109687, 0.0184836, 0.1849, -0.280921, 0.0407019, 0.134784, 0.223306, 0.00179534, 0.260092, -0.365298, 0.0511644, 0.19022, -0.203207, -0.149259, 0.0115823, -0.125733, 0.0889028, -0.101442, -0.0873805, -0.343473, 0.106107, 0.162546, -0.0197016, -0.121786, 0.0182095, -0.0504213, 0.195061, -0.00317607, -0.0244578, 0.214996, -0.117501, 0.148828, 0.580735, -0.14211, 0.0943806, 0.151925, -0.14185, -0.126954, -0.027963, -0.0668542, -0.297885, -0.0546018, -0.25489, 0.22815, 0.0403445, 0.126017, 0.283834, 0.137923, -0.159913, -0.0931327, 0.139961, 0.260717, 0.145165, 0.263966, 0.0352763, 0.103751, -0.082591, -0.438246, 0.103386, 0.105905, -0.208696, -0.231265, 0.140417, 0.0187784, 0.022343, -0.141293, -0.000389968, -0.956376, -0.357769, 0.0231799, -0.0240709, 0.192772, 0.003658, 0.250058, -0.65429, -0.0244874, 0.303751, -0.230532, 0.199727, 0.023372, -0.0313195, 0.0504206, -0.0542726, -0.0178723, -0.193877, 0.0121993, 0.315581, 0.094544, -0.114862, 0.150384, -0.133566, -0.451241, 0.145098, -0.0201667, 0.283383, -0.0597614, -0.164498, 0.105307, 0.201009, -0.811373, 0.19364, 0.0553186, 0.134548, 0.266245, -0.137655, 0.191184, 0.0788742, 0.104246, 0.223334, -0.33615, 0.0479692, -0.0311646, -0.0591792, -0.170425, 0.06311, -0.00521878, -0.0822921, 0.134953, 0.0705909, -0.45653, -0.0542084, 0.20041, -0.0955611, -0.301445, -0.0099964, -0.0354879, 0.270283, -0.172251, -0.0873372, 0.232318, -0.067629, -0.0359009, 0.525628, -0.0515683, 0.173493, -0.0591436, -0.176623, 0.00355328, -0.113136, -0.005047, -0.0819705, 0.0489188, 0.324611, 0.219632, 0.120156, 0.0946447, 0.32991, -0.0271391, -0.054059, -0.132758, -0.0385846, 0.167182, 0.241428, 0.0468538, 0.00223046, 0.143261, 0.231098, -0.351803, -0.0417773, 0.0487613, -0.240515, -0.262424, 0.0236657, -0.06694, 0.244382, -0.160041, -0.0603364, -0.809295, 0.0174895, 0.23713, -0.0945096, 0.014426, 0.0589673, 0.19718, -0.7535, 0.116645, -0.158836, -0.0590973, -0.0942316, 0.199056, -0.00480103, 0.151637, 0.101449, -0.216626, -0.0238127, -0.0591863, 0.111163, 0.00155706, -0.0157295, 0.294718, -0.125145, -0.321452, 0.396291, -0.111464, 0.0907134, -0.0846718, -0.288156, 0.0817139, 0.000407013, -0.854302, 0.0142335, -0.0540342, 0.188156, 0.255313, 0.0380733, -0.0186685, 0.0860999, -0.026607, 0.268752, -0.397307, 0.118246, 0.0301021, 0.182916, 0.125066, -0.0773125, -0.126348, -0.130909, 0.24802, -0.0285858, -0.509978, -0.202516, 0.171574, -0.0204404, -0.148815, -0.0237094, 0.0620189, 0.33772, 0.0387362, -0.253384, 0.276857, 0.0302896, -0.0569104, 0.480514, -0.100146, 0.406299, 0.0988034, -0.147345, 0.0847189, 0.200097, 0.0778452, -0.303408, -0.145705, -0.118376, 0.098624, -8.66693e-05, 0.169667, 0.366374, 0.261377, -0.186421, -0.201954, 0.216609, -0.132322, -0.0236984, 0.153597, -0.13188, 0.0764673, -0.0366278, -0.0787099, 0.148598, 0.0519283, -0.0822013, -0.413344, 0.0372491, -0.213098, 0.0233472, 0.0183001, 0.0740907, -0.680369, -0.0670035, 0.125944, 0.0518684, -0.184243, 0.00834658, 0.307085, -0.827441, 0.124847, -0.00804309, -0.1203, -0.15689, 0.106047, 0.0631482, 0.228449, -0.0320794, -0.139178, 0.0790209, -0.02133, 0.0809649, -0.0249475, -0.163367, 0.0135154, 0.0113696, -0.175519, 0.355949, -0.0197868, 0.174633, 0.026584, -0.223362, 0.105337, 0.0680506, -0.550408, -0.000360178, -0.166575, 0.0717037, 0.109065, -0.163453, 0.0148428, 0.0846782, -0.0500154, 0.200814, -0.323342, 0.155633, 0.0448581, 0.0617978, 0.235556, -0.0305255, -0.294624, 0.119949, 0.0982024, -0.0169168, -0.0221815, 0.0241765, 0.0456316, -0.0801881, -0.352123, 0.223849, 0.225392, 0.229429, -0.357315, 0.0520608, 0.394839, 0.219503, -0.0844822, 0.522792, -0.224512, 0.285809, -0.0606025, -0.237927, 0.0967808, 0.0460208, -0.0536347, -0.131549, 0.0155816, -0.129699, 0.0684877, -0.00042563, -0.10944, 0.313013, 0.0906107, -0.0319188, -0.115134, 0.177251, -0.109948, 0.00794178, 0.117706, -0.102669, 0.114851, -0.0297922, -0.0539138, 0.175615, 0.193695, -0.141749, -0.48919, -0.0509133, -0.0578133, -0.0585013, 0.00753924, -0.0204512, -0.55302, -0.0650817, 0.0848312, -0.0245195, -0.298189, -0.00482922, 0.434702, -0.689241, -0.0354875, 0.0215909, -0.329411, 0.000296021, 0.27826, 0.0968056, 0.403095, -0.0581463, -0.281839, 0.0542287, 0.034475, 0.300686, -0.063111, -0.11244, 0.0165279, -0.00520224, -0.128205, 0.197792, 0.0810148, 0.0460155, 0.102502, -0.159875, 0.194361, 0.10274, -0.340378, 0.0981279, -0.104931, -0.125656, 0.00610564, -0.0709376, 0.145416, 0.0488206, 0.0308546, -0.122935, -0.228213, 0.273416, 0.0271061, 0.0547939, 0.24391, -0.0791649, -0.212066, 0.0562728, -0.0574436, 0.101045, 0.0716031, -0.0287193, -0.287289, -0.00343516, -0.311672, -0.0189578, 0.210911, 0.140307, -0.728758, -0.0153866, 0.403867, 0.173386, -0.0441261, 0.580869, -0.00826002, 0.21583, 0.116221, -0.0376615, -0.0911684, 0.00499793, 0.00758284, -0.165554, 0.15939, -0.242184, 0.0134842, 0.00283612, -0.122113, 0.0906929, -0.00339998, -0.0975417, -0.141172, 0.134668, -0.0301209, 0.0883558, 0.184563, -0.205988, 0.137541, 0.0511652, 0.00562475, 0.0082934, 0.167181, -0.150211, -0.623182, 0.0280696, -0.111844, 0.0577247, -0.0482639, -0.00497416, 0.0107431, -0.08908, 0.0554966, 0.113026, -0.0251588, 0.0629473, 0.417147, -0.332951, 0.0796368, 0.12221, -0.392809, 0.0706626, 0.296257, 0.0520263, 0.523818, 0.0074546, -0.196184, 0.173262, -0.0362802, 0.164726, -0.0463343, 0.10816, 0.0245321, 0.0678678, 0.145102, 0.116613, 0.0288146, 0.112172, 0.23935, -0.067725, 0.151157, 0.105769, -0.0395634, 0.0812729, -0.17574, -0.0778004, -0.0773442, -0.146738, 0.177509, -0.013026, 0.136823, -0.689559, -0.147915, 0.153752, -0.0773146, 0.0296988, 0.0701116, -0.057291, -0.108916, 0.0449889, 0.0110436, 0.218742, 0.21509, -0.0248424, -0.332204, 0.0782152, -0.331635, 0.0971911, 0.392384, -0.0206834, -0.757521, -0.171843, 0.292178, 0.23044, -0.168769, 0.608831, -0.0235683, 0.292477, 0.0175142, 0.0268636, -0.145003, -0.0894417, -0.00575101, -0.195028, -0.075927, -0.677748, -0.12267, 0.0283834, -0.0615516, 0.106147, -0.090863, 0.0344201, 0.0510334, -0.0272023, 0.0246649, 0.0501706, 0.200964, -0.448405, 0.239896, -0.000163449, 0.169556, -0.0235318, 0.0868968, -0.0821334, -0.415908, -0.0388188, -0.15565, 0.0136196, 0.0429698, 0.115442, 0.0110227, -0.184473, -0.0255544, 0.0777616, -0.11206, -0.0447755, 0.172581, 0.216405, -0.0350472, 0.0519533, -0.580613, 0.137825, 0.410873, -0.00157824, 0.353116, -0.071309, -0.0157101, 0.0692911, 0.00862568, 0.260504, -0.0580477, 0.0782955, -0.109406, 0.182381, 0.199381, 0.163365, -0.0413401, 0.00683404, 0.160521, -0.0325095, 0.346759, -0.060922, 0.0694566, 0.0907584, -0.123792, -0.0627605, -0.038773, -0.140919, 0.0333123, -0.183629, -0.0272953, -0.792338, -0.16832, 0.265215, 0.0344294, -0.0730128, -0.0571546, -0.0454708, 0.0799885, 0.0286572, 0.0408688, -0.0197932, 0.322218, 0.0387137, -0.233086, 0.133002, -0.207584, 0.157544, 0.418086, -0.033656, -0.761988, 0.0284038, 0.148048, -0.0785789, -0.245171, 0.530029, 0.168148, 0.246371, 0.0122508, 0.0563518, -0.00323521, 0.061038, -0.195799, -0.103876, -0.0669496, -0.698327, -0.128926, -0.191559, -0.093561, 0.140477, -0.113571, -0.0401409, 0.0153156, 0.0943107, 0.0552723, -0.0638718, 0.137614, -0.109673, 0.199206, 0.105028, 0.406683, 0.110623, 0.182451, -0.116278, -0.26141, 0.0165393, 0.0291812, 0.123862, 0.0255518, -0.0345759, 0.0797573, -0.0256152, 0.0683566, -0.112916, -0.0506727, 0.0179783, 0.060067, 0.271578, -0.198638, -0.234365, -0.245566, 0.0357535, 0.424965, -0.0466235, 0.377011, -0.0435179, 0.0200797, 0.307683, -0.0668841, 0.102917, -0.136274, -0.014472, -0.00241643, -0.122816, 0.0851149, 0.306379, 0.0251333, -0.173457, 0.106502, -0.0765692, 0.408079, 0.101678, 0.212251, -0.0685344, -0.296846, -0.0609154, 0.110617, -0.129766, 0.0216101, -0.0349305, -0.112577, -0.643972, -0.192212, 0.490721, -0.0734815, 0.0680823, 0.0328064, 0.0650351, 0.25004, -0.0180236, 0.0689258, -0.210919, 0.135613, 0.0132486, -0.0572219, 0.16788, -0.0967441, 0.188682, -0.161369, -0.0211149, -0.609717, 0.48865, -0.0211814, -0.203647, -0.0489224, 0.22926}, {0.407598, 0.202941, 0.179827, 0.253874, 0.081333, 0.0964099, -0.112157, -0.0749061, -0.0098813, -0.296894, -0.103767, -0.0921082, -0.00868481, 0.138939, -0.28177, -0.114935, -0.0133346, 0.0731516, -0.224386, -0.0673418, 0.244644, -0.00147567, 0.0982628, -0.0549162, 0.602109, 0.288908, 0.164519, 0.265871, -0.0905964, -0.0190828, -0.0980045, -0.0357198, 0.157939, 0.104269, 0.174119, -0.121954, 0.000183195, -0.215612, 0.0187397, -0.0637115, -0.146952, 0.16685, -0.0412663, -0.199182, 0.201646, 0.141675, 0.517282, -0.0554376, 0.0922454, -0.0250227, 0.18869, 0.218527, 0.0385473, 0.241543, 0.0617211, 0.0378276, 0.000647914, -0.0325606, -0.0546191, 0.275751, -0.0162913, -0.187536, 0.0853454, -0.0693591, 0.182842, 0.237536, 0.198867, -0.110939, -0.346333, -0.234957, 0.146443, -0.234138, 0.0321059, 0.11575, -0.220376, -0.0862303, -0.331653, 0.449002, -0.113588, 0.00888527, -0.176768, 0.0245298, 0.0449444, 0.0633686, -0.0140332, -0.400752, 0.108658, 0.139976, -0.0126101, 0.157443, -0.132944, 0.363898, -0.768407, 0.0102698, -0.689482, 0.461497, -0.183393, -0.136728, -0.170057, 0.0433196, 0.523814, 0.0468131, 0.239987, -0.107527, 0.0122486, 0.0243126, -0.205075, -0.0383683, -0.125166, -0.0627467, -0.207423, -0.0994945, -0.114029, 0.00976559, -0.548677, 0.10352, 0.189457, 0.113921, -0.0830803, 0.0760226, 0.14179, -0.293005, 0.205566, -0.0295104, 0.504254, 0.260214, 0.0717224, 0.0233615, -0.0614087, -0.197309, 0.02954, -0.221384, 0.016242, 0.0513329, 0.293305, -0.101557, -0.251673, -0.161331, 0.120465, -0.0660461, -0.378243, 0.212574, 0.0755821, -0.0120431, 0.20274, 0.0566495, 0.336748, 0.15339, -0.108881, -0.137294, 0.0291814, 0.294075, 0.0478189, 0.0141145, 0.080235, 0.00606277, 0.0918612, -0.0419157, 0.223658, 0.117953, -0.260728, 0.221282, -0.12042, -0.136492, 0.131342, 0.0229721, 0.279512, -0.179038, -0.206943, -0.190223, 0.0267871, -0.162361, 0.239163, 0.0100168, -0.0148242, 0.314873, -0.378839, 0.343983, 0.166546, 0.0416726, -0.058953, -0.0155978, -0.204844, 0.0616397, -0.0587576, -0.398571, -0.0238901, 0.142004, -0.0933335, 0.184708, -0.289454, 0.135434, -1.08948, 0.0813774, -0.816159, 0.0143361, -0.407815, 0.20636, 0.156912, 0.0337151, 0.722025, 0.0513103, 0.281239, -0.0566087, -0.0443705, 0.163879, -0.0262419, 0.0237442, -0.172499, 0.015593, -0.136809, -0.0934557, -0.0561408, -0.0919065, -0.948014, -0.0394078, 0.14777, 0.0598788, 0.0389947, -0.0905858, 0.211228, -0.591324, 0.244589, 0.131683, 0.418729, 0.0428401, 0.0267497, 0.205218, 0.114538, -0.224393, 0.0189019, 0.0304765, 0.0319976, -0.0379861, 0.338412, -0.105653, -0.377046, -0.0465869, 0.00117953, -0.0877306, -0.654938, -0.0299099, -0.0263711, -0.0887264, 0.323155, 0.259149, 0.252941, -0.0325874, -0.410358, -0.102837, 0.100782, 0.179075, 0.0258462, 0.170513, 0.0880118, -0.115377, 0.00527361, -0.0208483, -0.0182213, 0.182113, 0.110006, 0.0462686, -0.225567, -0.103589, 0.0386465, -0.11319, 0.297346, -0.198026, -0.267385, -0.0207526, -0.159776, -0.0893498, 0.257645, -0.0349339, 0.114011, 0.436617, -0.194341, 0.136695, 0.0684535, 0.0286205, -0.014938, 0.016273, -0.353979, 0.0423622, -0.0100114, -0.178539, -0.0307947, 0.106803, -0.0254378, 0.187153, -0.223584, -0.102329, -0.670411, 0.0876946, -1.03207, -0.0391157, -0.393883, 0.195056, -0.00914477, -0.0447995, 0.530637, 0.119171, 0.0115839, -0.14553, 0.0577074, 0.078133, -0.17526, -0.113699, 0.00921003, -0.231502, -0.0250903, -0.0858038, -0.189916, -0.0237099, -1.36511, 0.0469003, 0.183257, 0.142827, 0.206961, 0.142645, 0.109389, -0.320326, -0.139828, 0.153676, 0.223784, -0.00323497, -0.0592841, 0.197549, 0.356073, 0.0137036, 0.085945, 0.269868, -0.00886811, -0.230525, 0.189677, -0.0993269, -0.450493, -0.350388, 0.0058641, -0.0697413, -0.604709, -0.106534, 0.165156, -0.0813502, 0.462517, 0.270819, 0.317598, -0.15194, -0.223963, -0.150047, 0.0956611, 0.174284, -0.0646751, 0.220889, 0.0548581, -0.011155, 0.145715, -0.0468805, -0.115144, 0.145687, 0.0414582, -0.102446, -0.183268, -0.0809314, 0.0685825, 0.157327, 0.179498, -0.265877, -0.166469, -0.12607, 0.0270223, -0.0463111, 0.146421, 0.0930908, 0.140223, 0.281339, -0.255219, -0.0545479, -0.401646, 0.0570088, -0.0529546, 0.0758087, -0.493202, -0.116867, -0.183542, -0.331461, -0.0156662, -0.0377084, -0.111053, 0.265526, -0.0911601, -0.268785, -0.391155, 0.279903, -0.535926, -0.0241599, -0.567569, 0.076028, -0.0656967, -0.037649, 0.379833, -0.139116, 0.0420537, -0.0565177, -0.0733476, -0.123831, 0.11208, -0.0910301, -0.149123, -0.225311, -0.132027, -0.157751, 0.0421496, -0.0621943, -1.06423, 0.181657, -0.0838909, -0.019117, 0.000737728, 0.136055, 0.0785903, -0.439701, -0.258672, -0.00232564, 0.168205, -0.0732517, -0.153247, 0.408435, 0.202396, -0.112379, 0.0202656, -0.0385481, -0.0494804, -0.201025, 0.199124, -0.318706, -0.357016, -0.267709, 0.0490542, -0.0229842, -0.750195, 0.0694834, 0.196718, -0.169486, 0.0590639, 0.12617, 0.0938945, -0.0800297, -0.637849, -0.157844, 0.0624524, -0.246555, 0.0559527, 0.170971, 0.214503, -0.399746, -0.172834, -0.202419, 0.0506395, 0.0632503, 0.126669, -0.00722667, 0.165015, 0.0828841, 0.0426249, -0.0149094, 0.079144, 0.0321476, -0.0479702, -0.00131915, 0.109379, -0.23236, -0.182693, 0.249332, 0.34648, 0.263961, -0.250207, -0.0335838, -0.392728, -0.0338271, 0.0376751, -0.0795572, -0.436659, -0.20014, -0.0925021, -0.231932, -0.178834, 0.165397, -0.118252, 0.13028, 0.130517, -0.364608, -0.0656501, 0.0524459, -0.759687, -0.119484, -0.239963, -0.101014, -0.0118771, 0.0210905, 0.59212, -0.189246, 0.173762, 0.0512956, -0.135472, -0.19451, 0.214172, -0.18771, -0.170336, 0.15865, -0.144811, -0.196853, 0.00372285, 0.0848886, -0.841843, -0.0271063, 0.157677, -0.0110288, -0.165762, 0.112365, 0.105165, -0.287024, -0.176275, -0.2158, 0.0863401, -0.353778, -0.125631, 0.233779, -0.0347759, -0.0734081, -0.0891042, -0.106514, -0.0830207, -0.0736215, 0.280186, -0.152966, -0.39573, -0.0530816, 0.123773, -0.0857245, -0.753636, -0.023224, 0.277325, -0.0579913, 0.0746457, 0.19933, -0.0262188, -0.0199375, -0.823167, -0.16103, 0.226925, -0.107339, -0.0725722, -0.000312226, 0.0154109, -0.2993, -0.0567687, -0.177296, -0.0825835, 0.468166, 0.0832061, 0.184992, 0.359223, 0.377323, 0.0749743, -0.0573831, -0.171619, -0.106413, -0.00591768, 0.145419, 0.152675, -0.17036, 0.0394437, 0.34887, 0.158104, 0.0907779, -0.317712, -0.395871, -0.23166, -0.0975785, -0.0953532, -0.0657835, -0.265079, 0.0356545, -0.0589433, -0.478758, -0.479865, 0.0135986, 0.026354, -0.0376138, 0.0689336, -0.293248, 0.0305047, 0.0304538, -0.756197, 0.017568, -0.3214, 0.0251967, 0.00380564, 0.135263, 0.200312, -0.0837223, 0.0128745, -0.0385844, -0.218201, -0.132798, 0.191605, 0.0574919, 0.0870197, 0.0277708, -0.187197, 0.0871188, -0.00953439, 0.113405, -0.756611, 0.121847, 0.115751, 0.144121, 0.0143972, -0.00406541, -0.00452451, -0.105181, -0.435539, 0.0129528, 0.111955, -0.796995, 0.0346417, -0.0286447, -0.22256, 0.0167383, 0.0500494, -0.0739334, 0.0433136, -0.283801, -0.146487, 0.00273979, -0.231274, 0.11586, -0.0349383, -0.0845581, -0.555578, -0.0171493, 0.326234, 0.0657633, -0.00386719, 0.0924082, -0.0866087, 0.0422488, -0.942113, -0.0975036, 0.224959, -0.194605, -0.0423709, -0.376209, -0.0546714, -0.233305, 0.226466, -0.144176, -0.0508451, 0.678492, 0.105337, 0.486532, 0.152563, 0.264263, 0.0150776, 0.0179084, -0.0115422, -0.104945, -0.0862634, 0.15028, 0.10687, 0.00308008, -0.506749, 0.265957, 0.0279884, 0.161168, -0.175282, -0.489788, -0.155627, -0.375775, 0.0887843, -0.0194968, -0.0780213, 0.0287812, -0.358068, -0.43339, -0.475188, 0.306277, 0.175544, -0.140187, 0.151817, -0.156005, -0.203679, 0.350133, -0.51029, 0.0296954, -0.809869, 0.247365, -0.495645, -0.137609, 0.0147166, 0.13831, 0.127571, -0.0774166, 0.0946652, -0.402751, 0.318081, -0.286335, 0.0159849, 0.124887, 0.0711029, -0.0764663, 0.263054, 0.0778659, -0.39834, 0.220341, 0.139773, -0.18714, 0.00151764, -0.240971, -0.0975774, 0.00256606, -0.0982678, -0.0318489, 0.0602706, 0.0765183, 0.000804267, 0.0673758, 0.0966141, 0.125141, -0.17462, -0.0585889, 0.0272456, 0.0669518, 0.0890846, 0.0219145, -0.0266284, -0.0504036, -0.0837528, -0.0784502, 0.218995, -0.05348, -0.027156, 0.0434504, 0.027986, -0.00185593, 0.0800878, 0.0441196, -0.0397694, 0.200311, 0.138763, 0.00606905, 0.0691384, -0.112426, -0.184436, 0.126091, 0.0527089, 0.122556, 0.040836, -0.0881138, 0.0889238, 0.00521056, 0.000892993, 0.0178852, 0.120216, -0.0189909, -0.0490431, -0.0740383, 0.237198, -0.125751, 0.000973163, -0.0448853, 0.072179, 0.126553, -0.0638214, -0.142074, 0.106225, 0.251735, 0.07451, -0.0724073, 0.0505207, 0.0104799, -0.141836, -0.0623764}, {-0.125881, -0.0366722, -0.0580468, 0.0701711, -0.0628238, 0.0440586, -0.0572729, 0.0792434, 0.0551521, 0.0621355, 0.054904, 0.156887, -0.104771, 0.0430136, -0.0590069, -0.0977548, 0.0610352, -0.0134746, -0.0217315, -0.0594928, 0.0561158, 0.140313, -0.0467268, 0.201318, -0.100991, 0.13983, -0.0161767, 0.00401284, 0.0603489, -0.0557794, 0.00196195, 0.0388418, -0.0292007, -0.097011, -0.0284149, 0.120392, -0.0394149, -0.0169504, -0.120189, -0.0557248, -0.030921, 0.0349073, 0.0784731, -0.0120447, -0.0551584, 0.0556216, -0.0330578, 0.0446916, -0.0128036, 0.0675971, -0.0364092, 0.11881, -0.103336, 0.0117902, 0.0109957, -0.0525537, 0.098669, 0.108709, -0.0875304, 0.0171499, -0.00324865, 0.102965, -0.0441301, 0.0301709, -0.014062, 0.0678154, 0.050214, -0.0749447, -0.0278297, -0.135399, -0.0579312, 0.154181, -0.0436582, 0.0318854, 0.0507222, -0.074601, 0.0811748, -0.0245297, -0.0810509, -0.0403113, 0.0934865, -0.0593523, -0.116159, -0.0768902, 0.189828, -0.133408, -0.0979301, -0.0647575, -0.0294394, 0.014573, -0.0354135, -0.0568277, -0.0452706, 0.0699344, -0.00289733, -0.117421, -0.0464399, -0.0658086, -0.101875, 0.0516188, 0.0312269, 0.0464896, 0.0168148, -0.00695495, 0.0169544, 0.025132, -0.000561745, 0.0622349, -0.0189719, -0.0126848, -0.0728021, 0.105493, 0.0210214, 0.00202935, 0.0140257, -0.109865, -0.0511744, -0.0247023, 0.0237358, -0.00610142, -0.0405914, -0.0283435, -0.0877134, 0.0907588, 0.0551142, 0.129017, -0.112897, 0.0240902, 0.0521946, -0.0650935, -0.0231798, -0.00678388, -0.064594, 0.010224, -0.0105416, 0.147073, 0.0174406, 0.0398647, -0.0294728, 0.0596596, 0.054964, 0.0446008, 0.115065, 0.072853, -0.0575552, -0.0293397, -0.0697743, 0.0725035, -0.0897085, 0.0346247, -0.0647084, 0.0613961, 0.0241706, 0.00376284, -0.0487091, -0.00149834, 0.00868761, 0.0486223, -0.076363, 0.0760232, -0.12049, 0.0568146, -0.00801368, 0.0805683, 0.0173148, 0.159178, -0.000997222, -0.0198377, -0.0482306, -0.00992553, 0.00450571, 0.0924262, -0.0427234, 0.0200956, 0.0490903, 0.0606529, 0.0877758, -0.0945715, 0.109333, 0.0390197, 0.0732925, -0.036225, -0.0583196, 0.00661079, 0.0222807, -0.134194, -0.0477941, -0.0683069, -0.00873271, -0.029116, 0.0425712, -0.0027831, -0.0334945, 0.050235, -0.0430476, -0.094291, 0.0615489, 0.0682496, -0.121945, -0.0161606, 0.0256026, -0.0204544, 0.0492422, -0.030302, 0.0234015, 0.0267895, -0.0575992, 0.13275, 0.000520892, 0.0693714, 0.0590476, 0.0879387, -0.0749041, 0.0635688, -0.0120715, 0.0771654, 0.00468428, 0.127715, -0.120466, -0.11769, -0.028597, -0.0581227, -0.0475678, 0.169448, 0.0446397, 0.0772474, -0.0533589, 0.0349545, 0.124627, -0.0223395, 0.0857472, -0.0144098, -0.0115308, -0.0328486, 0.0566803, 0.00863695, 0.0180137, -0.0207321, 0.0776763, 0.0809321, 0.0331149, -0.0276151, 0.0660357, 0.0708605, 0.0611491, 0.0644531, -0.0718323, 0.00120053, -0.0354724, 0.0677092, -0.00891804, -0.0512918, -0.0809757, -0.0104478, 0.141206, 0.0650335, 0.047413, -0.031583, 0.0367181, -0.127973, -0.053674, 0.0244691, -0.0212076, 0.0684014, -0.0360248, 0.0468191, 0.0524441, 0.0128247, -0.078237, 0.0439409, -0.00210906, -0.00539288, -0.0320895, 0.0780969, -0.0256853, 0.0637648, 0.0616105, -0.00880599, 0.0724281, -0.0118225, 0.0579806, -0.0172035, -0.108467, 0.0654879, 0.084152, -0.171252, -0.0388267, 0.0332638, 0.0190932, 0.0458274, -0.00538484, -0.146832, 0.0700486, 0.0138284, -0.0692438, 0.0747976, 0.0468644, -0.0608199, -0.058684, 0.0135802, -0.0336778, -0.0136148, 0.0219017, 0.0445495, -0.0315891, -0.0445314, -0.0389225, -0.0687862, -0.0223515, 0.0344408, 0.0172459, 0.0922515, 0.0198936, -0.110544, 0.0314199, 0.11802, -0.0348189, 0.120229, 0.00936379, -0.093316, 0.121979, -0.0116924, -0.044125, 0.129886, 0.0686486, 0.0313189, 0.0448475, 0.0126859, 0.0486341, -0.0466698, 0.0217184, 0.136897, -0.0578685, -0.0718505, 0.0952011, 0.0385188, -0.0413844, -0.0529903, -0.0419922, 0.077799, -0.0540011, -0.0497135, -0.0716485, -0.0502264, -0.0556912, 0.0821752, 0.00297318, -0.0545203, -0.0372808, -0.00823349, -0.0206403, -0.0664282, -0.0530829, 0.0467294, -0.0084533, -0.0719126, 0.077231, 0.0345649, 0.0690288, 0.082152, 0.050312, -0.0629271, -0.0672745, 0.0227145, -0.0725577, -0.038753, -0.047897, -0.0432507, -0.0526858, 0.0504019, -0.0402748, 0.042031, 0.0672633, -0.0615332, -0.0760515, -0.0720365, -0.00974456, -0.0511858, -0.0149547, 0.0321699, -0.0497246, 0.066859, 0.048177, -0.0587384, -0.00458565, 0.0681232, -0.0419424, 0.0274009, 0.0272639, -0.0520552, -0.00303584, 0.00409357, -0.0255598, -0.0776288, -0.0374409, 0.0744362, 0.0445768, 0.0619885, 0.0120962, -0.0638184, 0.0797466, -0.0525252, 0.00354616, 0.00880194, 0.0048087, -0.0742305, -0.0535485, -0.0601542, -0.0230368, -0.0183659, -0.00774377, 0.0627652, 0.0394718, -0.00314269, 0.0665707, 0.0678866, -0.0510865, 0.0675901, 0.00272496, -0.0510164, -0.0530726, 0.0152381, 0.0420115, -0.040669, 0.0355516, -0.0483313, 0.0451281, -0.0153103, -0.0195672, -0.0550611, -0.0472613, 0.0756322, 0.0493148, -0.0483002, 0.0117876, 0.0555275, 0.0994331, -0.0778782, -0.0422419, -0.0359026, -0.0707515, 0.00715216, -0.0345481, 0.0633232, 0.0114751, -0.0424917, -0.0639404, 0.0351012, -0.0318258, -0.0315845, 0.0396646, 0.0697565, 0.0569207, 0.0742158, -0.0198274, -0.0271399, -0.00650853, 0.165699, 0.00221792, 0.059243, 0.0441988, 0.0495313, -0.0633526, 0.0600952, -0.0768033, 0.1404, 0.00850121, 0.001702, 0.0469757, 0.0370146, -0.0896303, 0.0600438, 0.0581504, -0.0354148, 0.0433309, -0.0503502, -0.123995, 0.0731412, -0.0342686, -0.0434696, -0.123014, -0.0608322, -0.0567512, -0.0525946, -0.0112407, 0.0811937, -0.0870628, -0.0603641, -0.0609607, 0.0526314, -0.0159073, 0.096532, -0.00420701, 0.0327617, 0.05641, 0.060539, -0.0270556, 0.0174557, 0.0399758, -0.049427, 0.0622876, 0.0398817, 0.0526747, -0.0251923, 0.00578203, -0.00805558, -0.0323682, -0.00411272, -0.0161108, 0.0115344, -0.0612321, -0.108393, 0.0117925, 0.041826, -0.0118942, 0.0326587, 0.0330474, -0.0197407, 0.0635632, 0.0738432, -0.0265898, -0.0761061, -0.0077011, -0.0275304, 0.0935067, 0.0322865, 0.0683748, 0.0496633, 0.0199143, 0.0103758, -0.05097, 0.0730614, 0.0652654, 0.0378238, 0.0209131, 0.0741452, 0.105189, -0.078494, -0.00129858, -0.0792803, -0.0832873, 0.0325222, -0.100052, -0.0302812, 0.0142964, -0.112008, -0.121095, -0.107562, 0.149737, -0.0593932, 0.0467823, 0.00771091, 0.0304711, 0.0228433, 0.0438507, -0.0146436, -0.20638, 0.154557, 0.045685, 0.0671645, 0.1155, 0.045152, -0.0346794, 0.0433629, -0.139798, 0.071445, 0.0467259, -0.037831, -0.0745665, 0.018347, -0.102035, 0.201626, 0.0362065, -0.0894815, 0.00890332, -0.0660236, -0.161566, 0.10605, 0.023915, 0.115205, -0.179213, -0.138566, -0.000816055, -0.0656555, -0.0731609, -0.00985519, -0.110987, -0.0806718, 0.0343722, 0.0815108, -0.0588335, 0.0603121, -0.113778, 0.19665, 0.14522, 0.0998084, -0.0229028, -0.0796143, 0.207123, 0.0758123, -0.0793279, 0.0128269, 0.0681121, 0.0260805, 0.0222597, 0.0394255, 0.092665, 0.183939, 0.0601547, 0.137259, -0.000778074, -0.0102962, 0.0943617, 0.0522135, -0.0114788, -0.00546407, -0.0169119, 0.0503556, 0.050048, -0.125838, -0.0565956, 0.0900107, -0.0404481, -0.00643163, 0.0758217, 0.0225108, 0.0571979, 0.028048, -0.00731733, -0.047112, -0.122663, 0.0346247, 0.104035, 0.0538511, 0.184852, 0.0995668, -0.0251181, -0.268163, -0.168518, 0.032938, -0.0208496, 0.0889501, -0.00576793, 0.0290862, 0.0675982, -0.0615827, 0.0788617, 0.180987, -0.123546, -0.0610863, 0.0820515, 0.0866174, 0.192596, -0.0717401, -0.203916, 0.081898, -0.0774873, 0.273228, 0.0437939, 0.0412783, 0.243404, 0.131403, -0.0453225, 0.255293, -0.0244032, 0.159259, -0.0549307, -0.0732406, 0.0137368, -0.0863865, -0.0856033, 0.311604, 0.107241, -0.119225, -0.00584222, 0.0286554, -0.0533813, 0.107902, -0.0953773, -0.00509059, 0.0525132, -0.169612, -0.0592318, -0.126405, -0.0252529, 0.111167, -0.0518402, -0.00126558, 0.0727282, 0.0525083, 0.0205603, 0.177371, -0.129347, 0.236222, 0.136134, -0.0664923, -0.0108738, -0.0184712, 0.0918752, -0.106582, -0.0259465, 0.114234, 0.0734788, -0.00320495, 0.133549, 0.139886, 0.0679918, 0.225691, -0.0377299, 0.134623, -0.107119, -0.0928527, -0.105062, 0.0794895, -0.305798, -0.151299, 0.0536964, -0.00161386, 0.036956, 0.142872, -0.1633, 0.105011, -0.188124, -0.0525419, 0.0522386, 0.0741389, -0.0129143, -0.0553649, 0.060196, -0.0463967, 0.0759752, 0.0125865, 0.247779, -0.0783529, 0.04569, 0.122481, -0.0438699, -0.48333, -0.623926, -0.429748, -0.286463, 0.224411, 0.254498, 0.214023, -0.538856, -0.145621, -0.0992373, 0.362342, -0.239343, 0.0156913, -0.435673, 0.270214, 0.220973, 0.0190193, 0.117629, 0.0184464, -0.096646, 0.596891, -0.216071, -0.0696238, -0.211393, -0.00213565, 0.170156, 0.111296, -0.270875, 0.256019, -0.0333244, -0.14362, 0.0108745, -0.146573, -0.0996151, 0.109308, 0.0464159, 0.175766, 0.0638407, 0.218833, -0.0523839, 0.184483, -0.0269227, 0.366632, -0.0839449, -0.500268, -0.743851, -0.441983}, {-0.0659857, -0.793588, -0.468375, 0.212253, 0.414889, 0.40929, -0.172102, -0.0356381, -0.0385513, -0.0543862, 0.0592381, 0.176766, -0.183307, -0.0372243, 0.00620731, 0.278251, 0.0950796, -0.136327, -0.428133, 0.0803382, 0.110612, 0.223804, 0.161315, 0.319912, -0.0172342, 0.280952, -0.137341, 0.0391797, -0.242707, 0.238893, -0.0900161, 0.445352, 0.0839769, 0.0149674, -0.240489, 0.37714, 0.249666, -0.0241575, -0.0951608, -0.191073, 0.0141936, -0.038961, -0.00693169, -0.65021, 0.144657, -0.0098087, 0.323494, -0.0749656, -0.0678598, -0.0123324, -0.142445, -0.135957, -0.0412308, -0.0958097, -0.474285, -0.40987, -0.427727, 0.0902583, 0.222887, 0.171376, -0.271431, -0.178683, -0.0344005, 0.12645, 0.132494, 0.0403637, -0.621372, 0.303219, 0.179278, 0.100768, -0.0259784, 0.00624313, 0.0773775, 0.40874, 0.0205945, -0.0337891, -0.154285, 0.00382719, 0.0477782, -0.0451417, -0.0622816, 0.0261249, -0.153624, -0.321242, 0.0109602, 0.0742071, -0.0194082, 0.0779421, 0.00295514, 0.0698319, 0.264472, 0.213977, 0.0211969, 0.126438, 0.0770456, -0.0561217, -0.10884, -0.160193, -0.731386, -0.23952, -0.0597324, -0.55441, -0.617732, 0.342428, 0.103234, 0.205155, -0.16591, 0.0310718, -0.11438, -0.159322, -0.0279771, 0.118845, -0.274062, -0.0328633, 0.103134, 0.298446, -0.208465, -0.0213113, -0.555695, -0.010631, -0.5314, 0.164687, 0.050054, 0.276823, 0.0714455, 0.0598791, -0.18329, -0.220452, -0.0414578, 0.139088, 0.0118943, 0.406123, -0.393699, 0.197808, -0.251192, 0.193729, 0.221198, -0.0657688, 0.143126, 0.189537, -0.207127, -0.058077, -0.0950443, -0.0893738, 0.0223009, 0.0174207, 0.237278, -0.00411062, 0.149476, 0.106255, -0.112372, -0.158685, -0.118007, -0.0215863, -0.220845, -0.185541, -0.284561, 0.299062, 0.0383046, 0.0524565, -0.339094, -0.0924636, -0.0887045, 0.223802, 0.322612, -0.0784514, -0.167395, 0.0538629, -0.137505, 0.0734572, -0.101797, 0.00574182, 0.295269, 0.419317, -0.0421699, 0.0273059, 0.0691341, -0.0954701, -0.0755862, 0.131481, -0.0652332, 0.0334098, -0.0348995, -0.269159, -0.0619418, 0.150483, 0.0391134, 0.0499586, 4.52832e-05, -0.063189, 0.156132, 0.0946605, -0.277878, -0.195732, 0.181516, -0.240712, 0.160983, -0.101967, -0.479241, 0.107064, -0.203242, -0.0667833, -0.5793, 0.459481, 0.0981093, 0.348927, -0.0900011, -0.0885235, 0.161764, 0.12107, 0.305274, -0.0307389, -0.127485, 0.0574578, 0.00200992, 0.231145, -0.121671, -0.272536, -0.44284, -0.138539, -0.156991, 0.0799346, 0.165949, -0.152004, -0.108144, 0.118917, 0.12713, -0.401463, -0.0213706, -0.12856, -0.0302011, 0.233547, -0.48085, 0.149608, -0.1613, 0.15238, -0.0444382, 0.0367167, -0.158884, 0.0223265, 0.161039, -0.0912799, 0.0434841, 0.0498815, 0.0670293, 0.198362, 0.010981, -0.0226293, -0.0461201, 0.290107, -0.116058, -0.0999707, -0.0903114, 0.1674, -0.196133, 0.134387, -0.720064, 0.284607, -0.0147574, 0.286146, -0.0720763, -0.146851, -0.193943, 0.0254183, 0.0395282, 0.0510113, 0.0059013, 0.0488944, 0.116763, 0.169297, -0.217297, -0.0249763, 0.334628, 0.383877, 0.268901, 0.276149, -0.159887, -0.0600234, 0.276439, -0.0333163, 0.0324641, 0.179954, 0.119551, -0.247225, -0.0575268, 0.111281, -0.148753, -0.0288703, 0.0741453, 0.0761445, -0.0519167, 0.171149, -0.285297, -0.0397086, -0.148683, -0.13302, 0.0746857, 0.0721799, -0.814161, 0.161367, -0.286573, 0.00594491, -0.73913, 0.254221, 0.16613, 0.162, -0.043119, -0.139457, -0.269688, -0.0611757, 0.0872279, -0.161546, -0.150885, -0.0730107, 0.183658, -0.0682533, -0.438912, -0.145246, -0.428074, -0.120169, 0.206807, 0.16744, 0.144179, -0.212769, -0.0445298, 0.0948907, -0.0404511, -0.320169, -0.0658334, -0.181267, -0.00682103, 0.241149, -0.234784, 0.200767, -0.0630943, 0.0985322, 0.162616, -0.100756, 0.207235, -0.116732, 0.0308155, 0.0792646, 0.0197204, -0.122392, -0.0364403, 0.108933, -0.00829938, -0.113737, 0.00532976, 0.189421, -0.0436642, -0.188803, 0.111416, -0.082812, 0.014477, 0.125366, -0.424356, 0.0652075, -0.0215423, 0.130477, -0.171632, 0.119991, -0.147218, -0.0362709, 0.0749987, 0.0847455, -0.317215, 0.00749864, -0.153267, 0.0901937, 0.0768916, -0.0799038, 0.228925, 0.322939, 0.305446, 0.353753, -0.136237, -0.274433, -0.0400216, -0.0127689, -0.116176, -0.000231, 0.2216, -0.164342, 0.062266, 0.244478, -0.33936, 0.0438502, 0.126088, -0.0237909, -0.0453984, 0.0327772, -0.103228, 0.14017, -0.230801, 0.0190983, 0.167739, 0.0181039, -0.933281, -0.134655, -0.282535, 0.0720419, -0.711352, 0.176651, 0.0725445, -0.00205408, 0.19185, 0.136585, -0.226838, -0.119797, 0.148961, -0.147418, -0.0133817, -0.0839703, 0.214368, -0.0590171, -0.316837, -0.136648, -0.48825, -0.0297664, 0.336903, 0.0163757, 0.281877, -0.293245, -0.0574847, 0.0188956, 0.148014, -0.243054, 0.0330844, 0.037312, 0.210402, 0.271535, -0.313119, 0.322891, 0.0689361, -0.0570614, 0.172923, 0.0122242, 0.170442, -0.126001, -0.217572, -0.0309302, -0.0881924, 0.174242, -0.0629105, 0.283634, 0.00493551, -0.0611033, -0.138869, 0.181057, 0.0560209, -0.041069, -0.0408488, -0.0761337, -0.0207427, 0.207661, -0.278343, 0.249962, 0.214696, 0.137777, -0.136363, -0.0631907, 0.108742, 0.0479363, -0.116538, 0.0546535, -0.724918, -0.0884136, -0.140736, -0.103077, 0.0367512, 0.0413529, 0.263337, -0.0312879, 0.084075, -0.077288, 0.152593, -0.0293939, -0.276071, 0.000603675, -0.058207, 0.011316, -0.0733579, -0.413404, -0.0398551, 0.177089, -0.260553, 0.282139, 0.19432, 0.115821, -0.189517, 0.153925, -0.181247, 0.0615161, -0.0368978, 0.00690884, -0.00960651, 0.057703, -0.997483, -0.0295611, -0.229181, 0.157241, -0.293984, 0.0848821, 0.00519448, 0.0794188, 0.232229, 0.352219, -0.136999, -0.0238122, 0.110579, -0.00536012, 0.0103124, -0.0323472, -0.0232377, -0.0456067, -0.0463724, -0.140329, -0.180056, -0.0226054, 0.286834, 0.0496675, 0.186454, -0.245209, -0.0404537, 0.329818, -0.0382916, -0.281725, 0.21444, -0.0882069, 0.190142, 0.454932, -0.188203, 0.240607, 0.209747, 0.0367022, 0.00131638, -0.0813366, 0.0963372, -0.137992, -0.0868557, -0.296962, -0.00241226, 0.0383222, -0.0964566, 0.310756, -0.00260973, -0.17573, -0.0569786, 0.128906, 0.169298, 0.193433, 0.138939, -0.128934, 0.218113, 0.112431, -0.0705124, 0.136195, 0.0379074, -0.0412381, -0.168696, 0.0472417, 0.0366664, 0.121271, -0.134113, 0.0716662, -0.983492, 0.146835, -0.134216, -0.0673993, 0.0118678, -9.9192e-05, 0.184153, -0.444863, -0.0316136, 0.0182982, 0.0459099, 0.0469673, -0.0286025, -0.229484, 0.00658696, 0.0856897, -0.0397581, -0.396024, -0.0159533, 0.221154, -0.0382028, 0.0343365, 0.0787513, -0.0260621, -0.154049, 0.0893116, -0.248028, 0.111086, -0.063009, -0.107616, -0.0255503, 0.0926772, -0.557928, -0.0404163, -0.0645804, 0.0368184, 0.303109, 0.171358, -0.0433654, 0.00356717, 0.0738067, 0.536646, -0.0124656, -0.0601988, 0.0472331, 0.0410831, 0.143542, -0.0824927, -0.0337103, -0.0569934, -0.0325502, -0.147162, 0.0623904, -0.0916418, 0.304713, 0.0122634, -0.00284605, -0.222355, 0.0152858, 0.265072, -0.242543, -0.111748, 0.324181, 0.0305209, 0.129072, 0.544918, -0.168986, 0.262296, -0.235082, -0.20259, -0.167155, -0.136708, -0.0524352, -0.0265622, -0.126752, -0.149422, 0.00440921, 0.141878, -0.195103, 0.373322, -0.0375214, -0.196468, -0.0260268, 0.107443, 0.00588121, 0.242926, -0.00415219, -0.246197, 0.161696, 0.206518, 0.123509, 0.210249, 0.0199501, -0.0834344, -0.175026, 0.127445, -0.162933, 0.165353, -0.186793, -0.118995, -0.376007, 0.0971754, -0.174447, 0.1297, 0.0628355, -0.0364333, 0.359442, -0.62834, 0.0336518, -0.106123, 0.0331026, -0.0959924, 0.187532, -0.0980281, 0.219051, 0.101788, -0.0126794, 0.138538, -0.0323115, -0.00337716, -0.040614, -0.189333, 0.0158344, -0.0425855, -0.138268, 0.28443, -0.175341, 0.114916, 0.0409651, -0.0396994, 0.135409, -0.00884662, -0.112926, -0.0361939, -0.0231094, -0.0203046, 0.370075, -0.0585494, -0.0406404, 0.0680347, 0.0172661, 0.603854, -0.313935, 0.238531, -0.00456245, -0.0844038, 0.302566, 0.0162081, -0.0782978, 0.181068, 0.147497, -0.0435041, 0.0645606, 0.0250971, 0.140597, -0.0189335, 0.00971887, -0.198741, 0.0396185, -0.0574524, -0.187336, -0.157501, 0.350457, 0.154645, -0.0405408, 0.612045, -0.102151, 0.332746, -0.167089, -0.118365, -0.000602089, -0.178155, -0.13264, -0.214094, -0.42429, -0.267794, -0.188267, -0.0444305, 0.0329705, 0.188176, 0.0965221, -0.280846, 0.08885, 0.107028, -0.159883, 0.189664, 0.145555, -0.164598, 0.00415449, -0.00576201, 0.0196283, 0.134104, -0.0771486, -0.0674872, -0.401014, 0.0390177, -0.130302, -0.0614693, 0.0232726, -0.0860281, -0.451972, -0.00612259, -0.0311663, -0.144445, -0.0723399, -0.0162035, 0.35994, -0.855178, -0.0993838, -0.0772462, -0.292236, -0.192938, 0.00811045, -0.0421629, 0.356958, 0.0882338, -0.0182192, -0.0467905}, {0.0494585, -0.0459471, 0.196395, -0.220781, 0.00766203, 0.102429, -0.332539, 0.313948, -0.218099, -0.129989, 0.156429, -0.0190083, 0.148854, 0.130215, -0.195782, 0.0179082, -0.321395, -0.0517488, 0.0965336, -0.211945, 0.0490446, 0.336762, -0.247955, 0.0900563, -0.294707, 0.184253, -0.0102249, -0.121803, 0.130074, -0.0842048, -0.122408, 0.123992, 0.0297163, 0.0484113, 0.270334, 0.0390822, -0.0998349, -0.0885928, -0.145454, -0.0596207, 0.278143, -0.0770853, -0.455501, -0.205599, 0.381892, 0.209352, -0.114497, 0.683253, -0.298592, 0.448951, -0.184117, -0.00705144, 0.124119, -0.122395, -0.265323, 0.0141116, -0.0475563, -0.395126, -0.0515638, -0.0149699, 0.0321507, 0.17586, 0.218744, -0.101322, 0.0583873, 0.190227, -0.193099, -0.0203142, 0.0673256, -0.135703, 0.157012, 0.165452, -0.0156146, 0.251061, 0.0695671, -0.101211, -0.431707, 0.0270903, 0.0168566, 0.0955183, 0.0585203, -0.148137, -0.270618, -0.037898, -0.0246222, 0.0380156, -0.225477, 0.0559013, 0.168964, -0.568008, -0.140737, -0.00919325, -0.417135, 0.0947714, 0.0798829, 0.0831758, 0.296954, 0.148406, -0.0867373, 0.128369, -0.0113507, -0.0660913, 0.0313823, -0.206444, 0.210673, 0.0998699, -0.202973, 0.236604, -0.126479, 0.00669608, 0.258863, -0.12335, 0.174188, 0.0773009, -0.00238278, -0.132979, -0.245205, -0.0332211, 0.154011, -0.21755, 0.104443, 0.120776, -0.201032, -0.0159145, -0.203424, 0.0928271, -0.0722539, -0.121102, 0.198261, 0.0491374, -0.203668, 0.148985, 0.0910193, 0.260845, 0.210162, -0.106231, -0.0670241, 0.0292145, -0.189751, 0.0206363, 0.392349, -0.135258, -0.460294, -0.431033, 0.252926, 0.123763, -0.202751, 0.391916, -0.228988, 0.570762, -0.0146041, -0.140754, 0.00648935, 0.0383521, 0.00142935, -0.0814507, -0.0968412, -0.425063, -0.0570636, -0.275899, 0.00842213, 0.231634, 0.191964, -0.274596, -0.0475766, 0.0458089, -0.00919889, -0.00125825, 0.0161609, -0.292527, 0.234441, -0.0239425, 0.0475691, -0.0385052, 0.148301, 0.00340901, -0.391689, 0.100557, -0.100723, 0.0315646, -0.0799221, -0.021615, -0.0231114, 0.0257301, 0.0348132, -0.179289, -0.191062, 0.0472934, 0.120435, -0.181249, -0.0522617, 0.140174, -0.419898, 0.111352, 0.22188, 0.0702529, 0.352441, 0.0756479, -0.0787422, 0.125814, -0.0850003, -0.0149934, -0.160426, -0.131205, -0.102763, -0.0474592, 0.128597, 0.250768, -0.205879, 0.134796, 0.202582, -0.0702119, 0.15699, -0.0312509, -0.015424, -0.0886187, -0.188678, 0.041212, 0.110257, -0.180737, -0.0214082, 0.287185, 0.142412, -0.699847, -0.324579, 0.309522, -0.112372, -0.17972, 0.261658, 0.00157086, -0.19748, 0.00149524, 0.23477, 0.30002, 0.160357, -0.111422, -0.252152, -0.00737577, -0.131722, 0.0369176, 0.418849, -0.122028, -0.70628, -0.100018, 0.0594981, 0.0108455, -0.393825, 0.272847, -0.144058, 0.588886, -0.083238, -0.21938, -0.00893681, -0.0282521, 0.121243, 0.0521549, -0.143929, -0.719994, 0.0221453, -0.0681982, -0.122784, 0.0486226, 0.288337, 0.112062, -0.0381577, -0.0267469, -0.054865, 0.0509698, 0.0238507, -0.162143, 0.106789, -0.144989, -0.060911, -0.0648962, 0.174639, -0.229934, -0.0565788, -0.0318152, -0.0074461, 0.00178885, -0.0678065, -0.107912, 0.0500597, 0.114987, -0.15876, -0.158798, -0.101296, 0.0171025, 0.0921425, 0.237743, 0.0264949, -0.0985918, -0.224348, 0.178039, 0.407992, -0.00904694, 0.240799, 0.130097, -0.124659, 0.296325, -0.000547286, -0.0196262, -0.000279947, -0.0608335, -0.0737756, 0.1868, 0.220129, 0.296846, -0.108191, -0.180161, 0.150347, 0.0506076, 0.249637, -0.0256722, 0.109109, -0.0622274, -0.0745711, -0.00116159, 0.0660519, -0.300917, -0.0837026, 0.032494, -0.0374688, -0.817256, -0.281618, 0.40526, -0.0691839, -0.314233, 0.0178054, -0.0664611, -0.220173, 0.112362, 0.187705, 0.227229, 0.114011, -0.136005, -0.226525, -0.0383954, 0.0542759, 0.0914137, 0.353407, -0.0517649, -0.594251, 0.0275738, -0.0778881, -0.123974, -0.101319, 0.341936, -0.0908992, 0.392832, 0.0137372, 0.0250995, -0.00221998, -0.0600696, 0.0767829, 0.00504705, -0.0577371, -0.844592, 0.0285999, 0.02555, 0.0850927, 0.0389954, 0.0248903, -0.00117255, 0.00879391, 0.0578417, -0.0265651, -0.172921, 0.066393, 0.15312, -0.0001857, 0.028447, 0.0955361, 0.0730324, 0.327451, -0.124061, -0.0612763, -0.0243633, 0.0656764, 0.0121556, -0.0569337, -0.147993, -0.00658995, 0.120335, -0.026615, 0.0793737, 0.0367402, 0.0203763, -0.185739, 0.251409, -0.0688548, -0.138564, -0.141577, 0.223384, 0.146917, 0.114052, 0.13465, -0.0907444, -0.072943, 0.233144, -0.0991577, -0.0147634, -0.0508153, -0.0050925, 0.0249848, -0.0661609, 0.35044, 0.201268, 0.12584, -0.0420939, 0.0342176, -0.0524575, 0.236187, 0.11212, 0.0966471, 0.148802, -0.283529, 0.0818859, 0.250033, -0.22851, -0.0770523, -0.0869143, -0.0255075, -0.617079, -0.31801, 0.511085, -0.100501, 0.044367, 0.172209, 0.0411421, -0.0249742, 0.0610426, 0.12186, -0.0138117, 0.204164, 0.0298157, 0.02236, 0.014983, 0.313228, 0.295575, -0.166104, -0.0626982, -0.54674, 0.247986, 0.01002, -0.112859, 0.0289495, -0.105105, 0.0879592, 0.316601, 0.193638, 0.0726369, 0.0281145, -0.0579634, 0.05307, -0.122611, -0.245638, -0.28248, 0.10937, -0.044284, 0.0293272, -0.0344608, 0.076508, -0.174824, 0.0524852, 0.0887179, -0.369867, -0.222483, 0.0799759, 0.197968, 0.0542327, 0.0294897, 0.266358, 0.233641, 0.302663, -0.0373683, -0.0393367, 0.0879089, -0.0585888, -0.120874, 0.126586, 0.0934112, 0.105643, -0.0627826, -0.0558373, -0.0801872, -0.0725401, -0.00544068, -0.141126, 0.245841, -0.157653, -0.137386, 0.0511539, 0.120632, 0.34892, -0.0644003, -0.0294249, -0.0174217, 0.110333, 0.300337, -0.0741349, -0.0495206, 0.181156, 0.067627, 0.0134264, -0.159839, 0.184038, 0.357306, 0.108573, -0.0247099, -0.140997, -0.00426266, 0.368931, 0.246191, 0.0391617, 0.0244547, -0.435262, -0.0469009, 0.0393361, -0.303109, 0.124418, -0.168328, 0.00851126, 0.0185957, -0.16473, 0.340501, -0.00645088, -0.120008, 0.114105, -0.0441857, 0.0693104, 0.0394328, 0.0040716, -0.151081, 0.144423, 0.0747301, -0.0155409, -0.0930549, 0.00708048, 0.176529, -0.738245, 0.102586, -0.806698, 0.439894, -0.0918763, -0.266082, -0.0184904, -0.145638, 0.19397, 0.107436, 0.1015, 0.0288587, -0.160415, 0.0891399, -0.112613, 0.0736501, -0.105986, -0.0213541, -0.0396727, -0.295863, 0.038881, 0.0464702, -0.201816, 0.0654657, 0.203819, -0.00926434, -0.0780596, -0.0188121, 0.0523315, -0.17906, -0.0990275, 0.255634, 0.585292, 0.315968, 0.0665377, -0.142012, -0.131646, 0.030857, 0.142502, -0.166761, 0.0235295, -0.000699522, 0.172239, 0.047401, -0.0301839, -0.352728, -0.269152, 0.0467391, -0.0888797, 0.0856249, -0.134394, 0.0625911, 0.123937, -0.00647046, 0.304181, 0.0123673, -0.0817247, -0.0803617, 0.10475, 0.269834, 0.0550756, -0.127296, 0.105657, -0.0899864, -0.112011, 0.0225664, 0.174646, 0.379898, 0.10983, 0.0989933, -0.258886, 0.0226015, 0.176675, -0.00211834, -0.0601589, -0.0497654, -0.31728, -0.151033, 0.241901, -0.241708, 0.322127, -0.0947991, 0.114057, 0.309827, -0.376553, 0.322942, -0.105163, 0.0404506, 0.123608, 0.039882, 0.0525624, 0.00473092, -0.0651231, -0.20686, 0.102683, 0.189044, 0.0424687, 0.0363909, -0.109026, -0.101894, -1.03136, 0.125508, -0.886983, 0.08774, 0.106176, -0.0437022, 0.277677, -0.218919, 0.341806, 0.122795, -0.0987084, -0.0325835, -0.0760172, 0.154295, -0.221739, 0.0441934, -0.0308358, 0.151588, -0.0377959, -0.19286, 0.0943954, -0.0872862, -0.7722, -0.288527, 0.266412, -0.151722, -0.0767351, 0.0861125, 0.035366, -0.242735, 0.131364, 0.00425194, 0.271324, 0.147686, 0.0428119, -0.0237602, 0.101398, 0.0834594, 0.0929428, 0.0695205, -0.0427302, 0.0150239, 0.405592, -0.0258991, -0.0581789, -0.205112, -0.162267, 0.00597666, -0.313148, -0.0296933, -0.00573309, 0.150015, 0.210022, 0.183273, 0.142958, -0.0813638, -0.104819, -0.0539202, 0.255729, 0.167723, -0.024586, -0.0751897, -0.0367624, -0.0371888, -0.146398, -0.180991, 0.0523527, 0.333255, 0.0548021, 0.0299597, 0.0483878, -0.0152244, 0.0732282, 0.114625, 0.0934194, -0.0912983, -0.317516, -0.106101, 0.251759, -0.311041, 0.427034, -0.0492406, 0.0447033, 0.308325, -0.454508, 0.049103, -0.00879595, 0.110936, 0.0745406, 0.00846807, -0.00276566, 0.0672812, 0.0594441, -0.143578, -0.0695519, 0.197891, 0.0234886, 0.156421, -0.225527, -0.285537, -0.505447, -0.0517583, -0.801064, -0.114477, 0.0330096, 0.223685, 0.11539, -0.104957, 0.368914, 0.0138602, -0.0418657, 0.114716, -0.142377, 0.036644, -0.153338, -0.0912147, -0.193062, -0.0174812, -0.067515, 0.0790509, 0.0856604, -0.0927197, -1.44201, -0.171021, 0.0707497, -0.0709143, -0.0360986, 0.0605452, -0.0606698, -0.152616, 0.0942903, 0.0918607, -0.108327, 0.139491, -0.105595, 0.147293, 0.214182, 0.0670637, -0.0306127, 0.15645, -0.205844, -0.0374662, 0.17317, -0.121798}, {-0.108773, -0.096085, -0.0792629, 0.0692006, -0.287887, -0.077143, 0.00556641, -0.112503, 0.0293904, 0.292772, 0.0979243, -0.0449132, -0.373411, -0.117568, 0.149066, 0.166454, 0.0331609, -0.169372, 0.0222175, 0.0277188, 0.0590431, -0.299064, 0.0679106, 0.27691, 0.058099, -0.201827, -0.0495019, 0.0611281, -0.0413671, 0.0286756, 0.304069, -0.278876, -0.20159, 0.161603, 0.131272, -0.148581, 0.0768833, -0.0252003, 0.0601249, 0.065277, -0.296678, -0.131967, -0.0620419, 0.10324, 0.0753927, -0.0294278, -0.258511, 0.0934448, 0.0482044, -0.0312112, -0.094932, 0.444742, 0.0567538, 0.0376723, 0.000579595, -0.205698, -0.144383, 0.0597227, -0.921256, -0.0708342, -0.0330513, 0.321654, 0.026418, -0.105387, 0.450322, -0.0924684, -0.127463, 0.0145064, -0.178158, 0.01291, -0.0310731, -0.0189739, -0.17001, 0.122448, 0.102587, 0.0768166, 0.00175105, -0.208211, -1.42595, -0.0318179, 0.0523367, 0.000941871, -0.144047, -0.00638023, -0.103382, -0.188732, 0.0697181, 0.137736, 0.073599, -0.119093, -0.069364, 0.068309, -0.12572, -0.111294, 0.0328907, 0.159504, -0.136381, 0.00364881, 0.126445, -0.0833257, -0.12479, -0.14218, 0.0663186, -0.0565587, -0.612349, -0.0768963, 0.160726, -0.0354965, 0.0932442, 0.378204, -0.0116044, -0.0473909, -0.602093, -0.0707595, 0.102085, 0.0970131, 0.0135981, -0.137517, 0.122647, -0.0652037, -0.0451855, -0.13866, 0.230125, 0.312152, -0.0129978, 0.146142, 0.150723, 0.222101, 0.0990506, 0.0507369, 0.170169, -0.0805448, -0.42855, 0.145721, 0.209673, -0.0890016, -0.0669585, 0.0651287, 0.350788, -0.0672059, -0.23146, 0.163992, -0.177126, -0.0204857, 0.13613, -0.0566152, -0.0959912, 0.162169, -0.00603082, -0.254017, -0.123252, 0.309387, -0.134521, 0.0975636, 0.123961, -0.354322, -0.0889311, 0.0536137, -0.623895, -0.262104, -0.141009, 0.103686, -0.093644, -0.0847308, 0.44014, -0.0634279, -0.12966, -0.136781, -0.197507, -0.113857, 0.114468, -0.119459, -4.22043e-06, 0.104633, 0.0614299, 0.00142937, -0.00310058, -0.19837, -1.21879, 0.0318583, -0.0509907, -0.0764178, -0.112398, 0.238388, 0.465611, -0.106358, 0.097779, -0.0959688, 0.25388, -0.293077, 0.0441179, 0.0751975, -0.308614, 0.0139196, 0.153913, -0.029097, 0.0336952, 0.114923, 0.208755, -0.11778, -0.331423, -0.296402, 0.0671147, 0.0335463, -0.536464, -0.35098, 0.0610183, -0.048297, 0.025305, 0.38702, -0.0672336, 0.0245418, -0.814566, -0.191169, 0.142399, 0.172381, 0.0481846, -0.0502439, 0.0711989, -0.268228, 0.0338906, -0.0466888, 0.126319, 0.33481, 0.0383946, 0.135174, 0.395731, 0.357183, 0.0531527, -0.0180863, 0.0902018, -0.0601246, -0.0100121, 0.123339, 0.343746, -0.216302, 0.0938349, 0.0811669, 0.454801, 0.0176343, -0.149399, -0.123893, -0.046437, -0.0673154, -0.222806, -0.00300173, -0.376164, 0.0819361, 0.104296, -0.389302, -0.416466, -0.0468848, -0.120242, 0.165511, 0.119499, -0.154082, 0.143299, 0.104616, -0.69451, -0.26043, -0.18673, -0.110554, -0.0627606, 0.0569325, 0.352394, -0.0378409, -0.00967389, -0.0953145, -0.316428, -0.20168, 0.308272, 0.0118729, 0.086527, 0.0331367, 0.0415319, 0.306075, -0.0141432, -0.0164175, -0.730113, 0.082324, 0.0498583, -0.00416475, -0.168086, 0.0110599, 0.0794185, 0.137786, -0.132343, -0.27238, 0.356583, -0.749666, 0.0321789, -0.0813707, -0.356959, 0.0532156, 0.0618852, -0.128833, 0.0802957, -0.00415271, -0.213033, 0.0330187, -0.214207, -0.112462, 0.178348, -7.11157e-05, -0.217965, -0.345256, -0.0737799, 0.0849397, 0.0522708, 0.382104, -0.0421568, 0.221317, -1.0527, -0.238856, 0.132822, 0.0175129, 0.0529997, -0.191749, 0.0396135, -0.290423, -0.144362, 0.0869511, 0.0788913, 0.447231, 0.240616, 0.279419, -0.0112426, 0.441235, 0.104154, -0.132555, 0.19556, -0.147235, -0.0740406, 0.164495, 0.358768, -0.0456723, -0.177243, -0.0595576, -0.0425154, -0.0938075, 0.00625862, -0.231331, -0.193243, -0.405296, 0.154054, 0.0185789, -0.148427, 0.0712557, -0.205133, -0.41138, -0.401879, -0.0407214, -0.14897, 0.121901, 0.359485, 0.155889, 0.201409, 0.00318117, -0.805925, -0.0860678, -0.197778, 0.235068, -0.205943, -0.0429344, 0.215447, 0.105629, 0.104448, -0.22072, 0.00914045, -0.282747, 0.110938, -0.18365, -0.302456, -0.210423, 0.109431, 0.163358, -0.00135883, -0.0628302, -0.38443, 0.00589164, 0.130522, -0.341061, 0.19713, -0.169438, -0.154426, 0.0485496, -0.00680715, -0.135245, -0.0222966, -0.0343582, 0.0773775, -0.103898, -0.0108104, 0.238577, 0.00328989, -0.195229, 0.0173759, -0.0625267, 0.143006, -0.178989, -0.0265742, -0.0621967, 0.0213366, -0.00360065, -0.012961, 0.0369103, -0.00383091, -0.10837, 0.228937, -0.181539, 0.131548, -0.0141342, 0.115062, -0.046033, 0.239307, -0.0216042, 0.0762349, 0.018185, -0.0534985, -0.207135, -0.0753241, 0.0114241, 0.00346712, 0.0592415, -0.106614, 0.0955272, 0.10986, -0.0508198, -0.0950158, 0.151697, 0.106658, 0.204613, 0.149221, 0.0676392, 0.000385128, 0.0555678, -0.0908438, 0.0492736, 0.0756706, -0.0347762, 0.116507, 0.257861, 0.043916, -0.0847397, 0.115511, -0.0252222, -0.0792774, -0.00577287, -0.152557, -0.0510644, 0.0153628, 0.121095, -0.0334207, -0.0851964, -0.088384, -0.0483216, -0.0617061, 0.0578135, 0.0589256, 0.180377, -0.0220156, -0.0566583, 0.0830654, 0.00634041, 0.0236911, 0.0405062, 0.132764, -0.146539, 0.150301, 0.0703399, -0.0884586, 0.0474629, -0.0991374, -0.0537975, 0.0144136, -0.028479, 0.0411, -0.00364316, 0.0354013, 0.142507, 0.00909504, -0.0311516, 0.076904, 0.0269316, 0.0431002, -0.00900144, -0.00432912, 0.000876505, -0.0411262, 0.000545749, 0.0359037, 0.0634241, -0.0660696, 0.0758607, 0.0812162, 0.064036, -0.0108413, -0.0333269, -0.00709859, 0.0168786, 0.0307246, 0.0173052, -0.0410871, -0.0548874, -0.050386, 0.0752322, -0.00470637, -0.101223, -0.0891337, -0.0221557, -0.079623, 0.0311389, -0.0727222, -0.0675067, 0.0202655, 0.0522266, -0.0765933, -0.0471413, -0.0288926, 0.0584746, -0.0437339, -0.0186029, 0.071459, 0.0827768, -0.0284081, 0.0593509, 0.0886922, 0.00402392, 0.0293349, -0.0276686, 0.0397556, 0.0383513, -0.00165481, -0.11808, 0.0734168, -0.0093785, -0.0410506, 0.0489809, -0.0429261, -0.0784655, 0.0341371, 0.0730112, 0.000658422, -0.0166609, -0.0827857, -0.0521878, -0.0534602, 0.0226202, 0.00968236, 0.0131281, -0.0620584, -0.0642488, 0.023262, 0.0419243, -0.00648121, -0.0829495, 0.0441342, -0.0152631, -0.0582124, -0.0157835, -0.0366779, -0.0568184, 0.0164857, -0.000889381, -0.0547745, 0.0312831, -0.0290278, -0.0796516, 0.0404836, -0.00729972, -0.03496, 0.046583, -0.075195, 0.106843, 0.0548163, 0.0465655, -0.0238458, 0.0372181, -0.0707446, 0.0860133, 0.00622541, -0.0339611, -0.0237511, 0.0020435, 0.0419306, -0.0689304, 0.0653601, -0.00332461, -0.0642049, -0.0124755, 0.00663978, -0.060626, -0.0331392, 0.0120459, -0.0274674, -0.0187649, 0.0894594, -0.0198521, -0.0107024, 0.0185064, 0.0498394, 0.00620247, 0.107507, 0.00493602, 0.0392536, 0.063786, -0.0008812, -0.0899534, -0.0829924, -0.0303147, 0.0209171, 0.0372461, 0.0454517, 0.025595, -0.0454676, 0.0207354, 0.068782, 0.029971, -0.0423206, 0.0794857, -0.0717762, -0.0168973, -0.0408282, 0.0965479, -0.0637787, -0.0749705, 0.090275, 0.01495, 0.0783318, -0.0798565, -0.0502099, 0.104362, 0.0769528, -0.126313, -0.0239073, 0.0650925, -0.0770687, -0.0418487, 0.088216, -0.0319983, 0.0760275, -0.068813, 0.0149528, -0.0387327, -0.0053581, -0.0168795, 0.0752958, 0.00729191, -0.0890511, -0.077407, -0.0154114, 0.0647922, 0.00464721, -0.0027226, 0.0605214, -0.0472671, 0.0368658, 0.00599457, 0.0141397, 0.114598, 0.0686383, -0.0936819, 0.0699695, -0.0548812, 0.0179965, -0.0154568, 0.0316948, -0.0992625, 0.0188254, 0.0815226, 0.0823975, 0.0696104, 0.0360731, 0.0234235, -0.0455632, -0.0175613, 0.0235347, 0.077403, 0.0715454, -0.0469322, -0.0343066, -0.0362272, -0.0199506, 0.0325406, 0.0349872, -0.0130642, 0.00214974, 0.0813044, -0.0569487, 0.0265204, 0.00763187, 0.037991, -0.00784001, -0.044855, 0.0490412, 0.0838166, -0.0182893, -0.0120429, 0.0307221, -0.106107, -0.0181947, -0.0822882, 0.0558308, 0.0773259, 0.0694624, -0.0807479, -0.0100443, -0.0679373, -0.0406533, 0.0610727, 0.056272, -0.0633409, -0.0101696, -0.0485404, 0.0752668, 0.0080149, -0.0294051, 0.0733639, -0.0168198, 0.0663287, -0.0230742, 0.0711821, -0.0379055, 0.0982196, 0.0719433, -0.0810371, -0.00424576, 0.0657246, 0.0858256, -0.00150744, -0.0612765, -0.0294079, -0.00678071, -0.110644, 0.00370897, 0.0124801, 0.0367872, -0.0431644, 0.0418398, 0.0319337, -0.0309476, -0.0508247, 0.0277458, -0.0308733, 0.00861391, 0.0496469, 0.0534586, -0.0619314, 0.00471567, 0.0170382, -0.0845058, 0.0804255, -0.02751, -0.0627848, 0.0258095, 0.060866, 0.0751176, 0.111641, 0.00505201, 0.111217, -0.0748049, -0.119199, 0.0510403, 0.116269, -0.0625895, 0.0913908, -0.0397112, 0.0180429, 0.0561425, 0.0703976, -0.0497829, 0.0285074, 0.0113371, 0.0622764, 0.0171697, -0.0484696, 0.0811073, -0.0104809, -0.0498983, -0.00130308, -0.0733185, -0.0798397, 0.0789551, 0.112175}, {0.0399467, 0.0591493, 0.00091552, 0.0602494, 0.0319023, 0.0215872, -0.0139216, 0.0138818, 0.0622478, 0.0684122, 0.0440321, 0.0379544, 0.0731426, 0.0530353, -0.00495077, 0.0740327, -0.00829904, 0.0588062, 0.0654569, -9.61497e-05, 0.0779522, 0.0054988, -0.0191988, 0.0497744, -0.00228792, 0.0337336, -0.0361871, -0.0421059, -0.0656141, 0.0281504, 0.0588375, 0.00841761, -0.0328994, 0.07976, 0.0307718, -0.0400178, 0.0755334, -0.0813383, 0.066477, -0.0482305, 0.0292592, 0.0423116, -0.0311256, 0.0119912, -0.0159432, 0.0113283, -0.0017283, 0.0329505, -0.0101679, -0.0287781, -0.0356461, -0.0203724, 0.0271076, -0.0135754, -0.0102944, 0.0771821, -0.0513697, -0.0285884, -0.0681266, 0.0776514, 0.0771889, -0.0736486, 0.0715023, -0.0562929, 0.063072, -0.0123843, -0.00447845, -0.0567958, -0.0620055, 0.00237553, -0.0231009, 0.0397957, -0.0531371, 0.0585334, 0.0415733, -0.0184052, 0.0812682, -0.0448814, -0.0634405, -0.0617737, -0.0251176, -0.0414767, 0.0462041, -0.0554576, 0.06475, -0.0210129, -0.0288503, 0.0780711, -0.0186086, -0.0632552, -0.0405167, -0.00327879, 0.0451923, 0.0263028, -0.0193117, 0.0586129, -0.00137314, 0.0796505, 0.0734541, 0.0243733, 0.0638671, 0.0329227, 0.0116047, 0.0630763, -0.0472058, -0.0669573, -0.0351991, 0.0333524, 0.0449219, 0.024997, -0.113002, 0.0115916, -0.0101445, 0.0373148, 0.0431497, 0.0433157, 0.0134264, 0.0616996, 0.0606, -0.033938, -0.0201864, 0.0536413, -0.0161363, 0.102847, 0.0640726, 0.100372, -0.0860533, -0.00188039, -0.143079, 0.136715, 0.0250187, -0.100055, -0.0566169, 0.0493277, -0.15919, 0.182184, 0.0607747, -0.0326973, 0.0111488, 0.0210787, -0.0868543, 0.0531124, -0.0535659, 0.0745813, -0.0967866, -0.130821, 0.0418697, -0.00318062, 0.0595687, 0.0177809, -0.0804614, -0.00227064, -0.00345362, 0.0856704, 0.0119708, 0.080969, 0.00566942, 0.0741929, 0.101084, 0.012101, -0.122098, 0.0108323, 0.0563102, -0.0381653, -0.0469919, 0.0671082, 0.0280076, 0.0444632, 0.0379716, -0.016121, -0.0226157, 0.0309264, 0.0289579, 0.113606, 0.0447579, -0.132685, -0.0299893, -0.0428281, -0.0701726, 0.121808, -0.0142688, 0.0767304, 0.00539014, -0.0790124, 0.0405926, -0.0573802, 0.0896482, -0.0290352, 0.0802588, 0.102155, 0.030294, 0.0371149, 0.0451732, -0.0569593, -0.0381887, 0.0776895, 0.131522, -0.0999995, 0.0675122, 0.0371547, 0.00769273, -0.0366957, 0.0602001, 0.032319, -0.0668455, 0.00407424, -0.0546412, -0.0427946, 0.0206948, -0.0904685, -0.154432, -0.0511183, 0.168598, -0.0431637, 0.0599857, 0.157866, 0.0529539, 0.156124, -0.025435, 0.0603272, -0.110253, 0.198178, 0.000605764, 0.120833, 0.134787, 0.16251, -0.0166013, 0.0703138, -0.088436, 0.132168, 0.036892, -0.00788758, 0.0297915, 0.0300201, -0.134271, 0.181271, -0.0380342, -0.154342, -0.0654298, -0.000812694, -0.242856, 0.00581614, -0.0923343, 0.112242, -0.085717, -0.142035, -0.0686613, 0.0344202, 0.0636454, 0.0632224, -0.115449, -0.0886621, 0.0903484, 0.0114534, 0.0758072, -0.0154345, -0.0704147, 0.135443, 0.115866, 0.139989, -0.150046, 0.0246343, 0.133772, -0.00877249, -0.0135333, 0.116782, 0.0224446, -0.0832618, -0.0143478, -0.0900484, -0.0107275, 0.200191, 0.0814824, 0.0573348, -0.106658, -0.0193547, 0.025848, -0.0938944, 0.0634616, -0.0464863, -0.138784, 0.00334113, -0.0416854, -0.117955, -0.0162504, 0.054229, 0.00368721, -0.0885178, 0.0414564, -0.00233633, 0.0328251, -0.0796699, 0.0687223, -0.0414035, -0.0817598, 0.12228, 0.263173, 0.0653868, 0.21547, 0.0666979, 0.0327031, -0.237602, -0.103657, 0.119044, -0.0676949, 0.00204282, -0.073354, -0.0529053, -0.014237, -0.119079, 0.0332994, 0.119836, 0.0204499, 0.023231, -0.0422488, 0.052248, 0.247021, -0.131535, -0.051969, -0.0101182, -0.0543517, 0.191709, 0.037076, -0.0155773, 0.242513, 0.116085, -0.0887995, 0.158712, 0.00566186, 0.240999, 0.0498214, -0.0304999, -0.0444391, -0.109508, -0.148729, 0.360417, 0.223006, -0.126817, -0.0256042, 0.00722363, -0.112709, 0.0521205, -0.111842, 0.0795988, -0.169131, 0.0499109, 0.0763698, 0.00115687, 0.120322, 0.0770009, 0.00547904, -0.0260918, 0.0238285, 0.163408, 0.0186141, 0.14472, -0.117638, 0.285983, 0.114294, -0.0375131, -0.0867878, 0.0606544, 0.0103239, -0.189311, -0.0779303, 0.0398052, 0.10938, -0.124419, 0.0500307, -0.00790565, 0.126907, 0.12334, 0.105621, 0.189571, -0.162587, -0.074254, -0.0990031, -0.0509814, -0.194098, -0.0186347, -0.05032, 0.0736825, 0.00695583, -0.075457, -0.111691, 0.140683, -0.102229, -0.000806574, -0.0309053, 0.0881218, 0.0666609, -0.0379354, 0.034717, -0.0344218, 0.0200277, -0.0197271, 0.127571, 0.071807, 0.130031, -0.029876, -0.0990632, -0.230093, -0.277495, -0.422309, -0.344942, 0.0939768, 0.276789, -0.104996, -0.349429, -0.0119477, -0.160222, -0.028241, -0.296469, 0.0630279, -0.590664, 0.052045, 0.119006, 0.212025, 0.279973, -0.0697235, 0.0309842, 0.431393, -0.0128378, -0.0341335, -0.23361, -0.166697, 0.228537, -0.0399209, -0.394694, 0.114348, 0.132891, -0.292829, -0.0364356, 0.0430802, -0.138443, -0.0582508, 0.00645048, -0.0187462, 0.0791031, 0.0297356, -0.357338, 0.54474, 0.134137, -0.0385148, 0.0419286, -0.225873, -0.942697, -0.169913, -0.18598, -0.455815, -0.18967, 0.0739154, 0.36214, 0.35893, -0.0888424, 0.111649, 0.00616408, -0.237267, -0.440543, 0.123968, 0.141942, -0.0656881, 0.0488149, 0.0441732, 0.150122, -0.289818, 0.123098, 0.126977, -0.359198, -0.0292925, -0.0172294, 0.112301, 0.174748, 0.162724, -0.211346, -0.136626, -0.172346, -0.139022, 0.130461, 0.214104, 0.2502, 0.0593927, -0.271918, 0.351432, 0.0287717, 0.0821123, 0.206036, -0.126805, 0.259174, -0.101708, -0.461954, -0.116648, -0.0198529, 0.00714733, 0.252408, -0.132477, -0.120139, 0.151168, -0.0751119, 0.0246466, -0.0692681, -0.263347, -0.0576677, -0.368451, -0.577597, 0.169547, 0.289254, 0.108021, -0.267904, -0.0819005, -0.00399364, 0.287313, 0.32844, 0.169942, -0.56329, 0.0370759, 0.109062, 0.0349174, -0.163689, -0.0167734, -0.023368, 0.169152, -0.149012, -0.140434, -0.295209, 0.128199, -0.024612, -0.114162, -0.092768, -0.347245, 0.178352, -0.097356, -0.044962, 0.111822, 0.00795722, -0.0268646, 0.170614, -0.261738, 0.0290952, 0.0350721, -0.366557, -0.0791467, -0.0186957, 0.0828686, 0.149549, -0.139035, -0.652343, 0.0590004, -0.261623, -0.0837244, -0.376439, 0.293057, 0.196287, 0.248392, -0.147286, -0.109978, 0.0489585, -0.0602534, -0.253841, 0.128217, 0.0949561, 0.0541902, -0.0474455, 0.118607, -0.134742, -0.197212, -0.283064, 0.12459, -0.48807, 0.00528961, 0.150694, -0.0868258, 0.0899208, 0.178589, -0.180313, -0.318523, 0.266006, 0.0206557, 0.0918295, 0.453599, -0.0790311, 0.192501, -0.367556, 0.107709, 0.120407, 0.121521, -0.0106592, 0.12615, -0.139438, -0.193477, -0.159246, -0.0153709, 0.0619864, 0.0423449, 0.156484, -0.0229475, 0.112567, 0.364271, 0.0414708, 0.0246836, -0.0148235, 0.152728, -0.28689, -0.17267, -0.597877, 0.0392326, 0.125054, -0.079495, -0.373044, 0.111365, -0.0999581, 0.11187, 0.38621, -0.209084, -0.391643, 0.05316, -0.164523, 0.110685, -0.0355036, -0.0419569, 0.104438, 0.577255, -0.0838735, 0.0454034, 0.0117291, 0.00459943, 0.12182, 0.0312429, -0.126587, -0.140369, 0.113711, -0.0802497, 0.0642973, 0.154361, 0.0583479, 0.0648432, 0.0352706, 0.0844546, 0.142874, 0.123638, -0.272084, -0.161798, 0.05393, -0.20202, 0.0880276, 0.0890717, -0.69391, 0.149892, -0.106284, -0.188959, -0.532736, 0.313674, 0.137767, 0.35966, 0.135318, -0.0412394, 0.100265, 0.107864, 0.00872304, 0.181889, -0.081244, 0.0548489, 0.149728, 0.157058, -0.189379, -0.281692, -0.339513, -0.124763, -0.0681028, -0.0769555, 0.233062, -0.0906682, -0.121095, 0.280731, 0.149341, -0.272878, -0.0909629, 0.155495, 0.105556, 0.306066, -0.519091, 0.166073, -0.218153, 0.201194, 0.122461, 0.0933466, 0.140923, 0.14287, 0.00190186, -0.200296, 0.00104445, -0.0280359, 0.11204, 0.201444, -0.0711893, 0.18012, -0.00183348, 0.0991408, -0.0121809, -0.0738876, -0.0420527, 0.317678, -0.219159, -0.0340449, -0.569518, 0.226037, 0.167569, 0.259819, -0.231634, 0.116971, 0.0321979, 0.0229242, 0.115247, 0.0571674, -0.308132, -0.0577013, -0.0716162, -0.00898605, -0.0245124, -0.0681406, 0.373437, 0.354949, -0.0596233, 0.275474, -0.0334776, 0.0279126, 0.0543734, 0.0538423, -0.0787554, -0.0572976, 0.32861, -0.111367, -0.0310467, -0.0318057, -0.247712, -0.0788103, -0.0702401, 0.169237, 0.129029, 0.00855544, 0.1352, 0.0716373, -0.00547306, -0.0265339, 0.368243, 0.383734, -0.873714, 0.203493, -0.135976, -0.227502, -0.7325, 0.173645, 0.295155, -0.0260558, 0.144133, -0.0992686, -0.115015, 0.0801206, -0.095053, 0.0243475, 0.00707017, 0.0403193, 0.133743, 0.198328, -0.20594, -0.124569, -0.457315, -0.275125, -0.0188164, -0.130465, 0.215621, -0.114041, -0.00520814, 0.198223, -0.0619501, -0.0075422, 0.140003, -0.048515, 0.0487429, 0.416574, -0.413522, 0.125203, -0.399604, 0.115664}, {0.0441228, -0.15628, 0.412796, -0.00301864, -0.0129976, -0.180438, -0.0767477, 0.0597726, -0.184576, 0.3242, -0.20803, -0.146694, -0.187635, 0.0708153, 0.188385, -0.136951, 0.0989389, -0.0277132, -0.0158232, 0.222506, -0.0697104, 0.177469, -0.0391964, 0.496042, -0.099189, 0.011374, 0.0621126, 0.00930369, -0.116461, -0.019108, -0.316388, -0.147349, -0.013987, -0.130387, 0.00442234, 0.061488, 0.406474, 0.432119, -0.128136, 0.202065, 0.0294345, -0.0393482, -0.142413, 0.0304098, 0.00902741, -0.15744, 0.186752, -0.0948241, 0.000333039, 0.100188, -0.102903, 0.0276949, 0.118568, 0.0308547, 0.135537, -0.112743, 0.141787, 0.0792258, -0.219648, -0.0631704, 0.250045, 0.099724, -0.806097, -0.12882, -0.192935, -0.017046, -0.44093, 0.100596, 0.0352255, -0.0480773, 0.123887, 0.254177, 0.116832, 0.128999, 0.189061, 0.0580882, 0.172037, -0.0698815, 0.0698084, -0.0675897, -0.207022, -0.0792198, -0.417738, -0.358869, 0.148687, -0.145655, 0.199419, -0.297, -0.0284003, -0.0689326, 0.0916626, -0.202148, 0.322633, -0.0264445, 0.213882, 0.367671, -0.132299, 0.245082, -0.108153, 0.0501824, 0.184621, 0.050514, 0.246959, 0.0466935, 0.0302193, 0.0429479, -0.172424, 0.0836342, -0.101438, 0.485668, -0.0408121, -0.23525, -0.0170399, 0.220749, -0.152449, 0.109533, 0.0280242, 0.077055, 0.173614, 0.129981, 0.0661056, 0.106403, 0.162804, 0.222469, -0.0260067, -0.0807778, 0.0758488, 0.347938, 0.0837294, 0.200709, -0.527249, 0.258138, -0.0867524, -0.172334, -0.15866, -0.0979541, 0.348162, 0.105674, 0.0208913, -0.0196435, 0.152926, 0.118586, -0.119691, 0.0711424, -0.0362318, -0.012977, -0.0972278, -0.238536, -0.0625863, 0.100207, -0.0904089, 0.281654, 0.0306311, -0.0590216, 0.077163, 0.0262548, -0.0387638, 0.0779243, -0.0849521, -0.0478738, 0.0464463, 0.232557, -0.699823, -0.115584, -0.36905, 0.173911, -0.224831, 0.125162, 0.0369577, 0.186269, 0.151602, 0.343435, -0.0795841, -0.0330428, 0.096312, 0.182547, 0.255477, -0.0212611, -0.0119184, -0.10825, -0.281307, -0.0862405, -0.0608925, -0.275238, 0.412973, 0.0115256, 0.31037, -0.420007, 0.122495, 0.00894861, 0.142527, -0.344877, 0.286177, -0.0150244, 0.331613, 0.452623, -0.0896015, 0.302019, -0.220155, 0.252701, -0.015746, 0.0171228, 0.083207, 0.00629862, 0.0974148, -0.154353, 0.0013844, 0.173421, -0.0414723, 0.461468, 0.171209, -0.172623, -0.151319, 0.0558423, -0.0339304, 0.284667, 0.016275, 0.0807789, 0.0712878, -0.0239966, 0.134241, 0.176405, -0.03398, 0.227758, -0.0594375, 0.149933, -0.0963021, 0.22458, -0.065323, 0.0668665, -0.495801, 0.0677768, -0.323979, -0.0938013, -0.158306, -0.0617988, 0.400597, -0.378504, 0.119882, -0.0791026, -0.0423642, 0.116163, 0.106274, 0.0591705, 0.134451, -0.0514446, -0.0594813, -0.0454565, -0.0445187, 0.0331158, 0.0124833, 0.219671, -0.137875, -0.154627, -0.0470513, -0.00617515, -0.254826, 0.215185, 0.0580518, -0.116684, 0.0289317, -0.0527773, -0.516178, -0.0684752, -0.157241, 0.00423698, 0.136194, 0.0976768, -0.101419, 0.19245, 0.0291921, 0.319153, -0.105328, -0.00666633, 0.122821, -0.0209476, 0.388519, 0.0632222, -0.106896, 0.0982422, -0.126912, 0.130654, 0.233357, -0.0518431, 0.278884, -0.0592023, 0.247778, -0.295944, -0.0416763, 0.0416933, -0.0283152, -0.407141, 0.286411, 0.231541, 0.400765, 0.186014, -0.177071, 0.207667, -0.349105, 0.174675, 0.094207, -0.110845, -0.0674718, -0.201787, -0.13527, -0.276017, 0.160571, 0.0133813, 0.0469033, 0.400452, 0.218398, -0.0863425, -0.106733, 0.0818297, -0.111129, 0.201896, -0.116233, -0.0299664, 0.075823, 0.124573, 0.255432, 0.193573, 0.130007, 0.0485162, -0.12492, 0.0274794, -0.0640139, 0.189663, -0.116367, -0.126954, -0.498742, 0.145655, -0.128359, -0.0214293, -0.0962972, 0.0648785, 0.299019, -0.718355, -0.0493832, -0.0789012, -0.30298, 0.0838592, -0.00141163, 0.0571454, 0.168858, 0.15488, -0.0276293, 0.0802397, -0.023885, -0.14255, -0.0264882, -0.00228998, -0.0249419, 0.173718, -0.380542, 0.0886725, -0.17853, 0.0773875, 0.172581, -0.0160913, 0.132101, -0.134109, -0.311856, 0.175192, -0.00191668, -0.0661089, 0.223068, -0.0015721, -0.153751, 0.311345, 0.000715168, 0.372532, -0.346514, 0.10152, 0.107357, -0.00119711, 0.226377, -0.028343, -0.114258, 0.0637624, 0.0386446, 0.0104191, 0.220504, -0.112762, 0.181306, 0.132213, 0.0161079, -0.133727, 0.169371, -0.0794332, -0.142112, -0.441625, 0.343332, 0.134812, 0.150641, 0.350404, -0.0988424, 0.383065, -0.126628, 0.137343, 0.107593, -0.0116529, -0.287371, -0.152791, -0.21038, -0.313192, -0.0731195, -0.121132, 0.0688029, 0.354044, 0.196245, -0.165772, -0.0383369, 0.152989, -0.107036, 0.033148, 0.0446226, -0.0314893, 0.216843, 0.0591366, 0.138306, 0.122287, 0.113197, 0.125219, -0.220678, 0.0254868, -0.0180816, 0.108281, 0.00223796, -0.127201, -0.304766, 0.140243, -0.0833713, -0.0773007, -0.0752313, 0.0251218, 0.0827036, -1.05436, -0.049635, 0.0620573, -0.445318, 0.104538, 0.14928, -0.101555, -0.151583, -0.0307856, -0.03568, -0.117612, -0.00448576, 0.0762319, -0.0670723, -0.176467, -0.00633078, 0.0991959, -0.554452, 0.237735, -0.101176, -0.223125, 0.27808, 0.0184545, 0.359848, 0.0216787, -0.053194, 0.113857, -0.274567, 0.112604, 0.140665, -0.0195005, 0.0608922, 0.414727, -0.218837, 0.286971, -0.308533, 0.0507761, 0.122962, 0.0532107, 0.301868, -0.0314634, -0.102378, 0.0685242, 0.143413, 0.3111, 0.126161, -0.218843, -0.25297, -0.00158546, 0.0643514, 0.0211262, 0.323313, -0.0159147, -0.171803, -0.424219, 0.249904, 0.308882, 0.0482963, 0.229576, -0.194222, 0.503626, -0.20384, 0.284001, 0.0714219, -0.138008, -0.113144, -0.0876234, 0.0135401, -0.394553, -0.0568458, 0.0449236, 0.0398657, 0.34992, 0.26978, -0.275246, -0.0843098, 0.00067907, -0.157847, 0.0364951, -0.161031, -0.11455, 0.180039, 0.0311568, 0.217358, 0.111186, 0.10612, -0.0374825, -0.219802, 0.0229937, 0.0979128, 0.219938, 0.0171587, 0.0286625, -0.199539, 0.0484121, -0.105928, -0.0915819, -0.0504426, -0.0961727, -0.052111, -0.595914, -0.0588741, 0.00313417, -0.379724, 0.0700283, 0.0878224, -0.185181, -0.169255, 0.0319265, -0.192755, 0.0261245, 0.054527, 0.146725, -0.196933, -0.26888, 0.0754955, -0.027935, -0.336265, 0.196617, -0.00173306, -0.188813, 0.187911, -0.0621222, 0.522667, 0.00385291, 0.0196064, 0.237224, -0.212667, 0.0431636, 0.066814, -0.0328683, 0.043833, 0.3017, -0.0263005, -0.124901, -0.174107, 0.232846, 0.101184, -0.157795, 0.203512, 0.0469732, -0.174387, 0.0978201, 0.0917366, 0.311438, 0.137893, -0.165986, -0.201032, 0.0253859, 0.0082042, -0.0392261, 0.477301, 0.0479592, -0.319062, -0.323614, -0.0199877, 0.281539, -0.291618, 0.195495, -0.194579, 0.54898, -0.0528835, 0.172254, 0.0434085, 0.00529446, -0.0736036, 0.0140094, 0.0836835, -0.463671, -0.0293154, 0.0998561, 0.0493765, 0.323246, 0.340472, -0.0605198, -0.100255, 0.0151929, -0.0742904, 0.219095, -0.142467, 0.14822, 0.121598, -0.212042, -0.154871, 0.133608, 0.139413, 0.121734, -0.0738924, -0.00371012, 0.0274721, 0.119379, -0.00799428, 0.081361, -0.0801106, 0.143404, -0.203876, -0.0534906, -0.185551, 0.00638137, 0.042546, -0.214719, 0.151166, -0.157248, -0.108826, 0.0881018, 0.264189, 0.0325374, 0.0630936, 0.147595, -0.215741, 0.247527, 0.0507534, -0.0379861, -0.0793338, -0.165828, -0.0428269, -0.109449, -0.184006, 0.346755, -0.106927, -0.0365036, 0.251311, 0.0545147, 0.525877, -0.0783833, -0.161154, -0.082178, -0.0487745, 0.0724301, 0.192853, -0.055118, 0.051984, 0.255296, -0.0380474, -0.919596, -0.292701, 0.1774, -0.0245597, -0.388827, 0.185099, 0.00840804, -0.260702, 0.05836, 0.0457036, 0.0959022, 0.0596769, -0.159073, -0.172596, -0.0408345, 0.154462, 0.0276011, 0.436317, 0.0913365, -0.621957, -0.326836, -0.233263, 0.0394009, -0.634902, 0.0390993, -0.243013, 0.467807, -0.0390885, 0.235156, 0.0517444, -0.0622543, -0.137679, 0.0401281, -0.181187, -0.981225, 0.185047, 0.109774, 0.156254, 0.0343813, 0.374059, 0.0808075, -0.0905317, 0.103962, -0.0396374, 0.0149314, -0.0430097, 0.0462565, -0.0157578, -0.111827, -0.166536, 0.266502, 0.100001, -0.125293, 0.0237999, 0.120267, 0.0617653, 0.0141672, -0.0022805, -0.133699, -0.0945671, 0.212404, -0.107774, -0.161758, -0.102365, -0.0290825, -0.139686, 0.158519, -0.0329846, -0.118977, 0.0925129, 0.175606, 0.19552, 0.048904, -0.0199858, -0.0525792, -0.107756, 0.335691, -0.057147, -0.0706498, -0.154604, -0.0681095, -0.117098, 0.18331, 0.0987162, 0.247027, 0.117045, -0.0147435, 0.0182805, -0.00334156, 0.436642, 0.0957788, -0.129735, 0.0281239, -0.126314, 0.00669518, 0.148602, -0.247945, -0.0206968, 0.121402, 0.0497555, -1.21297, -0.305983, 0.187082, -0.189065, -0.207199, 0.0813906, 0.0689876, 0.0417192, -0.0381069, 0.159414, -0.00184164, 0.0555903, -0.242902}, {-0.371293, -0.112369, 0.0880449, 0.0262199, 0.207433, 0.132186, -0.662152, 0.13182, -0.157668, -0.100138, -0.390338, 0.0887908, -0.294195, 0.457716, -0.0786899, 0.286702, -0.0600604, -0.0584263, 0.020847, 0.0580137, -0.186473, -0.887662, 0.0831703, 0.211047, 0.0361554, -0.227366, 0.250189, -0.292186, -0.206838, 0.178508, -0.0723676, 0.0722773, 0.133517, 0.250397, 0.0810815, -0.0181342, -0.163383, 0.539818, 0.0761752, -0.125296, 0.047046, -0.0528176, -0.148609, -0.159153, 0.00611451, 0.00507056, 0.0176218, 0.0968702, -0.0148358, -0.002608, -0.148687, -0.0164036, -0.202066, 0.107306, -0.0218775, -0.0965, 0.237451, 0.222874, 0.282188, 0.0882225, -0.0428617, -0.109824, -0.0860519, 0.184916, -0.0100207, 0.0192788, -0.0548569, -0.135109, 0.0290714, 0.0157082, 0.260528, 0.165708, 0.117623, 0.163448, -0.283594, -0.105696, 0.377854, 0.0848271, -0.0945142, -0.0036823, -0.280309, 0.168093, 0.227854, -0.316043, 0.148817, -0.0863125, -0.0762573, -0.592802, -0.367505, 0.279983, -0.219918, -0.0694178, 0.444857, -0.0211934, 0.056989, -0.0105971, 0.14657, 0.0395623, 0.265983, 0.29216, -0.182198, -0.265958, 0.182912, 0.0108633, -0.448375, 0.166949, -0.635866, 0.362422, 0.0564783, -0.282084, -0.132873, -0.1383, -0.329955, 0.245866, 0.0194314, 0.265768, -0.0977345, -0.19163, 0.0817703, -0.111474, -0.275038, -0.313398, 0.0345869, 0.141953, 0.209124, -0.172108, 0.138927, -0.218056, -0.167018, 0.0690418, -0.0826761, -0.131325, 0.0778983, 0.221699, 0.0234977, 0.168233, 0.165461, 0.387117, 0.251311, -0.0739352, -0.0328224, 0.182065, -0.0428539, -0.00680684, 0.0638234, -0.0541098, 0.0943905, 0.191148, -0.122003, 0.147342, -0.074277, 0.00866405, 0.00826376, 0.178182, -0.000690402, -0.0166431, 0.302328, 0.302156, 0.285303, 0.0220067, 0.150999, -0.0399175, -0.0885095, 0.356099, -0.0234447, 0.0594551, 0.0549961, 0.11031, -0.0163566, -0.368419, 0.129653, 0.259871, -0.0347669, 0.202651, -0.299867, 0.0374712, 0.114764, 0.033625, -0.0937341, -0.212982, -0.371167, -0.147128, 0.247956, -0.218864, 0.244072, -0.109594, 0.0687831, 0.0645882, -0.374031, 0.286451, -0.073988, -0.0880912, 0.340638, -0.0394332, 0.0198546, 0.035446, 0.289853, 0.0937198, 0.0468023, 0.433166, 0.0447555, -0.132013, -0.0130309, -0.1035, -1.24956, 0.153588, -0.619298, 0.299861, -0.022117, -0.386075, -0.0314491, -0.0734056, -0.0361431, 0.172745, 0.152731, 0.0952018, 0.0810662, -0.064877, -0.112714, -0.0992301, -0.0461837, -0.02788, 0.0941264, -0.22308, 0.258631, -0.274395, 0.0698897, -0.234859, -0.0224794, -0.0140034, -0.09967, -0.173339, -0.00359734, -0.0110573, -0.0391919, 0.144665, 0.0933685, 0.281484, 0.172726, 0.050293, -0.236426, 0.0909722, 0.153298, -0.0619963, 0.0156666, -0.0148429, 0.216121, -0.0068991, -0.000568984, -0.230191, -0.203635, -0.056987, 0.00864222, 0.0937125, -0.230469, 0.0171016, 0.244672, 0.271505, 0.312628, -0.0398314, 0.231514, 0.122231, 0.102003, 0.317865, -0.0434338, -0.0419677, 0.236459, -0.06529, 0.00883743, 0.00930898, 0.127653, 0.337887, 0.0400104, 0.0286882, -0.0239439, 0.246915, -0.0634854, 0.0366228, -0.133233, -0.176384, -0.335086, -0.030685, 0.319309, -0.311596, 0.220615, -0.0127318, 0.179534, 0.582986, -0.594369, 0.540557, -0.227487, -0.212815, 0.107263, 0.0108735, 0.150741, 0.0463919, -0.0522018, -0.0375174, 0.0825323, 0.239079, 0.129468, 0.0693872, 0.0949313, -0.0472244, -0.69391, 0.113216, -0.834564, 0.22645, -0.126689, -0.320718, 0.0360342, 0.00718077, 0.30523, 0.167203, 0.069518, 0.2484, -0.0915178, 0.131587, -0.162153, -0.0632465, -0.0757291, 0.0594632, 0.0413358, 0.0875048, 0.362912, -0.247126, -0.341831, -0.0820225, 0.372843, -0.00474498, -0.0172169, -0.0856618, 0.00726736, -0.0505428, 0.104496, 0.14688, -0.0808469, 0.308121, 0.145215, 0.158348, 0.23856, -0.0164454, -0.0429264, 0.234954, -0.186661, -0.0984469, 0.158013, -0.0186819, 0.0996504, -0.246878, -0.0297546, -0.0595802, -0.0301647, 0.106259, -0.182196, 0.0695876, 0.135114, 0.122068, 0.184651, -0.027775, 0.240517, 0.189164, 0.182257, 0.0929046, -0.0489752, -0.209573, 0.0255376, 0.00400969, 0.0719563, 0.0979374, 0.168362, 0.382371, 0.191357, 0.00606572, 0.214849, 0.16249, -0.186478, 0.0341956, -0.148947, -0.0509657, -0.249866, -0.233838, 0.0828674, -0.214566, -0.0157032, 0.259561, -0.0140082, 0.429593, -0.639187, 0.419215, -0.183619, -0.11688, 0.0928456, -0.0683372, 0.151965, 0.166373, -0.0366206, 0.0802166, -0.0108229, 0.283687, 0.211874, 0.0852448, 0.11962, 0.0556724, -0.0286233, -0.0960104, -0.937497, 0.0933525, -0.00890026, -0.0788067, -0.0493136, -0.0506068, 0.328562, 0.185937, 0.0951672, 0.0926894, -0.107304, 0.12835, -0.172695, 0.0233797, -0.0520559, 0.195551, 0.0955346, 0.101596, 0.248568, -0.308985, -1.16994, -0.0956555, 0.343237, -0.00679678, 0.032019, -0.0802131, 0.0305654, 0.104804, 0.0229592, 0.029915, 0.0554542, -0.124735, -0.0296676, 0.129998, -0.0333326, 0.196453, -0.114125, 0.121763, 0.0192032, -0.0232332, 0.212983, -0.191003, -0.0958287, -0.0310983, 0.0766109, -0.00475921, -0.367367, -0.225682, -0.206671, -0.151515, 0.111648, 0.033833, 0.024194, 0.144727, -0.0232684, -0.0682694, 0.455745, -0.0460944, -0.0582364, -0.374319, -0.139228, 0.148396, -0.00672869, 0.0884748, 0.126428, 0.540447, 0.142314, 0.202183, 0.224103, 0.0735475, -0.0602615, 0.0780517, 0.190781, 0.018811, -0.108869, -0.193193, 0.0907529, -0.223384, -0.0701339, 0.156298, 0.240814, 0.0363097, -0.632664, 0.10862, -0.094232, 0.0239053, 0.226049, 0.0661958, 0.256758, 0.126404, 0.0734548, -0.0703972, 0.00833589, 0.458334, 0.0631522, -0.0302754, 0.1336, -0.198725, 0.0271855, -0.262248, -0.787773, -0.050626, 0.0408163, 0.0143037, 0.0453889, -0.0792112, 0.336265, 0.160024, 0.141426, -0.0233348, -0.116625, -0.000200222, 0.174323, 0.0922733, -0.15922, 0.267584, 0.241338, 0.00988591, 0.231636, -0.180235, -1.6517, 0.0443796, -0.0190471, -0.0955492, 0.0643806, 0.0487745, 0.0964088, 0.111422, 0.0677454, 0.282523, 0.146885, -0.261674, -0.0678761, 0.0759223, -0.205381, 0.134617, -0.123102, 0.18989, 0.0226574, -0.09562, 0.188489, 0.00507518, -0.159273, -0.0835158, 0.260168, 0.00018831, -0.580723, -0.0633104, -0.221728, -0.270347, 0.226495, 0.306801, 0.298438, -0.0141306, -0.282951, -0.0308442, 0.333631, 0.136133, 0.0400636, -0.221362, 0.219547, 0.231561, 0.413477, -0.0559205, 0.226406, 0.11256, 0.140064, 0.0892585, 0.069324, 0.081195, -0.0648061, 0.296139, 0.0123984, -0.101598, -0.28657, -0.0525311, 0.185179, -0.166364, 0.140603, 0.200391, 0.246721, -0.0505697, -0.330209, 0.287832, -0.0398365, -0.05585, -0.0250386, -0.0222445, 0.0823335, 0.108556, -0.00703384, -0.329673, -0.266529, 0.098942, 0.0175931, 0.168949, 0.334531, -0.21501, 0.109768, 0.0131721, -0.454099, -0.216036, 0.0514603, -0.139367, 0.0454072, 0.085488, 0.420017, 0.107571, 0.0109559, 0.0534757, -0.0742296, -0.224176, 0.283925, 0.120273, -0.204428, 0.101632, 0.385765, 0.13089, 0.229999, -0.278103, -1.32556, 0.037513, -0.0836951, 0.00953513, 0.0509373, 0.139173, 0.221346, -0.255039, -0.0508721, -0.0105618, 0.334187, -0.33159, -0.0826066, 0.101367, -0.234784, 0.0956261, 0.119711, 0.167648, -0.106689, -0.0885064, 0.202088, -0.0366367, -0.436907, -0.213171, 0.20939, -0.0496061, -0.679179, -0.1466, -0.0520821, -0.12164, 0.297242, 0.531462, 0.195451, 0.0481687, -0.509041, -0.271297, 0.22559, 0.247121, -0.0777262, -0.00915226, 0.0709137, 0.119415, -0.022935, 0.13425, 0.0273493, -0.0398422, -0.0628994, 0.225083, 0.200753, 0.198217, 0.0131791, 0.123801, 0.204326, -0.164088, -0.0603933, 0.136615, 0.0972682, -0.317017, 0.19652, -0.0650373, 0.316717, 0.0570615, -0.242746, 0.0137787, -0.0906287, 0.0374583, 0.00271063, 0.00637601, -0.0937704, 0.00348996, -0.204962, -0.567212, -0.632216, 0.00092022, -0.304021, 0.0292333, 0.297037, 0.0352526, 0.13874, 0.0440083, -0.839964, -0.324764, -0.219293, 0.0353992, 0.0382734, 0.0176301, 0.486046, 0.0906386, 0.111975, -0.000688356, 0.0404594, -0.0736566, 0.280395, -0.0753994, -0.0781869, -0.100428, 0.305763, 0.110952, 0.282676, -0.208028, -0.816433, -0.0481166, -0.0765602, -0.0337511, -0.0138388, -0.0469825, -0.198122, 0.0103763, -0.078827, 0.0881249, 0.0739415, -0.539883, 0.278039, 0.0103185, -0.297921, -0.049542, 0.319965, 0.272688, -0.248757, -0.0327769, 0.0257134, 0.136874, -0.266095, -0.121109, 0.293566, -0.0449107, -0.482213, -0.271239, -0.0696988, -0.0698399, 0.105688, 0.732231, -0.00153177, 0.133427, -0.460956, 0.00958679, -0.043688, 0.230821, -0.08018, 0.00953511, -0.0857256, 0.125068, -0.335805, 0.0811711, 0.318401, -0.0165852, -0.0403155, 0.328914, 0.159722, 0.367085, -0.0975045, -0.0749718, 0.112584, -0.216814, 0.00242654, 0.171883, 0.285443, -0.132781}, {-0.0760289, 0.00336525, -0.00250132, -0.00850368, -0.238701, -0.252986, -0.24635, -0.0622765, 0.257156, 0.034039, -0.229451, 0.0808338, -0.288793, -0.642252, -0.751747, -0.182487, -0.180063, -0.0556092, 0.277804, -0.0554749, 0.307081, 0.388189, -1.13879, -0.544716, -0.417441, 0.224081, 0.0133111, 0.174855, 0.0464093, 0.188058, 0.236248, -0.396586, -0.155398, -0.105603, 0.418643, -0.0745679, -0.20234, 0.0705897, 0.394591, -0.0648459, 0.254248, -0.111726, -0.454399, -0.0887424, 0.173471, -0.525221, 0.405931, -0.181407, -0.110968, -0.0156111, 0.064121, -0.212658, -0.158297, 0.0485518, -0.0203763, -0.0554275, 0.0246784, 0.10649, 0.098088, -0.187905, 0.0415436, -0.091383, 0.16216, -0.21558, -0.0740343, -0.0455118, -0.193687, 0.0764302, -0.0729953, 0.0450689, -0.0471847, -0.0618224, 0.186219, -0.170615, 0.241756, 0.00999479, 0.0906179, 0.0184288, 0.184552, -0.0198955, -0.0297305, 0.0350199, 0.0659853, -0.183332, 0.0794939, 0.0591382, 0.0964209, 0.0459462, -0.168999, 0.165776, 0.174936, 0.0490568, 0.0238907, 0.118974, 0.110863, 0.151192, 0.0820959, 0.0693861, 0.0145755, 0.0515312, -0.160411, 0.0955127, 0.0525933, 0.0280816, 0.0850228, 0.167656, 0.0615475, -0.0569806, -0.00258481, 0.0488855, -0.0595186, -0.113266, -0.133929, 0.0291223, 0.113707, 0.174047, -0.0528881, 0.0175582, -0.0113923, -0.0661221, 0.00242694, -0.0805154, -0.00409868, 0.170508, -0.0346161, -0.0803413, -0.0685107, -0.0435598, -0.0131684, -0.0152619, 0.175317, -0.0205674, 0.126839, 0.0393436, -0.128456, -0.0623164, -0.0481711, -0.0183498, 0.0474109, 0.0101141, 0.0553173, 0.0169095, 0.0432871, 0.098946, 0.0236779, -0.077503, -0.0342113, -0.0151697, -0.0728586, 0.0348288, 0.0287692, -0.0793234, 0.0120749, 0.0857847, 0.0379171, 0.0432274, 0.0299786, -0.0624849, -0.0479644, -0.0360785, 0.0286474, 0.0822197, -0.0708505, -0.0191149, 0.0196315, 0.0602439, -0.0605787, -0.0715457, 0.0280727, -0.0268234, -0.0812139, 0.0631146, 0.0457588, 0.0438712, 0.0106139, 0.0413878, 0.0806898, 0.0129535, 0.0819117, -0.0557928, 0.041555, 0.0311031, 0.00511784, -0.0380619, 0.0742129, -0.0563686, -0.0440032, -0.0172263, 0.0273078, -0.0061272, 0.0823907, -0.0185584, -0.0764787, -0.036332, -0.00475126, -0.0395091, -0.0184415, 0.0307031, -0.0495886, 0.0580342, -0.0290926, 0.0556538, -0.048274, 0.0536202, 0.0339764, 0.0185033, 0.00345169, 0.0518186, 0.0361785, -0.0714957, 0.0161199, 0.00139697, 0.0718487, 0.0115877, 0.0730921, 0.00386295, -0.0245442, 0.0340141, 0.0786541, -0.0654573, 0.0655701, -0.0248559, 0.0638832, -0.0572636, 0.00455686, -0.0450654, 0.0766116, 0.0416406, -0.0620062, -0.053415, -0.00438157, -0.0265799, 0.0511471, 0.040625, -0.0690533, 0.0333917, 0.016594, 0.035209, -0.0579306, -0.0500168, -0.0531516, 0.0319619, 0.0717925, 0.032603, -0.0169324, -0.0749367, -0.0381312, 0.0787835, 0.0499654, -0.075064, -0.0488166, -0.0671776, 0.0712616, -0.0580147, -0.000627548, -0.0307926, -0.00917048, -0.0550111, 0.035229, -0.0306247, 0.0416393, -0.0498038, -0.0128482, -0.0141481, 0.0234003, -0.0690097, 0.00980163, -0.0148297, -0.0709766, -0.00979923, 0.0177995, 0.0780972, -0.0320171, -0.0196528, -0.0330571, -0.00406071, 0.000543967, 0.0409532, -0.0801354, -0.0463579, -0.0286249, 0.0685319, -0.0190681, 0.0745042, 0.00217301, 0.055074, 0.0614999, 0.0392926, 0.0510374, -0.0330976, -0.0758979, -0.0284741, 0.0296816, 0.0446803, -0.00961543, 0.0352796, -0.0785593, 0.0412613, 0.0251612, -0.0644314, -0.0732684, -0.0649073, 0.0665019, 0.0609965, 0.0357504, -0.0722796, 0.0617597, -0.00335459, -0.0639258, -0.0285342, 0.0216653, -0.0356959, -0.00499882, -0.00642152, 0.0260902, 0.0271393, 0.0416303, 0.00965802, -0.0574195, -0.00041493, -0.0154246, -0.0752654, -0.0321504, 0.0534311, -0.0577709, 0.0211997, 0.0678799, -0.0562214, 0.0291478, 0.0103096, 0.0624871, 0.0333857, -0.00852756, -0.0783141, -0.0222759, -0.0132089, -0.0406854, -0.0471254, -0.0197301, -0.0298218, 0.0551633, 0.0154388, -0.035842, -0.00530826, -0.0246276, 0.0527319, -0.0571565, 0.0571813, 0.0284965, 0.0525438, -0.0318088, -0.0457318, -0.024291, 0.0519962, 0.0422404, -0.0407648, 0.0711102, -0.0531991, -0.0732611, 0.0297467, 0.081497, -0.0765025, -0.0806718, -0.00785711, -0.0573345, 0.0760282, 0.0169742, 0.00488888, -0.0765734, 0.0631812, 0.0246424, -0.0408625, 0.0698993, -0.0241132, -0.0342565, 0.00293929, 0.0559025, 0.0459291, 0.0363606, -0.0139047, -0.059329, 0.030773, 0.0124871, 0.0476424, -0.0403737, 0.0316706, 0.0137688, 0.0798375, -0.0537017, -0.0585244, -0.0325728, -0.0315725, -0.00960282, -0.0749114, -0.0326302, -0.0696469, 0.0389538, 0.0734852, -0.03319, -0.0222163, 0.019769, 0.0101097, 0.00467258, 0.0596596, -0.0753009, -0.0805289, -0.0494743, -0.0200226, -0.0665023, 0.0781819, 0.011925, -0.0133264, -0.0583172, -0.0613667, 0.0408794, -0.0249491, -0.0686438, -0.0607885, -0.0507511, 0.000595853, -0.0565305, -0.0682417, -0.016179, 0.0581224, -0.0623414, -0.0592525, 0.0391162, -0.00327136, -0.0417052, 0.0167525, 0.001887, -0.0501242, -0.0101723, -0.0318144, 0.0285685, -0.0601101, -0.0124776, -0.0303843, -0.00221884, -0.0665478, -0.00241961, 0.014769, -0.0279795, -0.0359326, 0.0676281, 0.00953379, 0.0198823, -0.0163337, 0.0551823, 0.0769041, -0.0572543, -0.0677593, -0.0656438, -0.0223247, 0.0567448, -0.0437216, 0.00260092, 0.0737256, -0.0579902, 0.0329623, 0.0256304, -0.0582693, 0.0688258, 0.017681, 0.0541667, -0.0297449, -0.0252802, 0.0516065, 0.0276225, -0.0573092, 0.025522, 0.0098226, -0.0551908, -0.0202818, -0.0340209, 0.0416268, 0.0208603, -0.0348792, -0.0238489, -0.0408443, -0.0744026, -0.00889205, -0.0579506, 0.0137857, -0.0797103, -0.0198769, -0.0674822, 0.0694581, 0.0288866, 0.0295435, 0.0625346, 0.0682492, -0.0105259, -0.0629875, -0.0451475, -0.0482331, 0.00338427, -0.0267534, -0.0713965, 0.0618065, -0.0363962, -0.00136971, -0.0474903, 0.0408894, 0.00930941, -0.0321819, 0.0778269, -0.0101875, 0.0597099, -0.00886658, -0.0309595, 0.0623325, -0.00865801, -0.0114558, -0.00338806, -0.0746631, -0.0708276, 0.0614614, 0.0409518, 0.0404076, 0.0263211, 0.0113263, 0.0788743, -0.0418386, -0.058476, 0.0719048, 0.0393446, 0.0126161, -0.0336551, 0.066257, -0.0466601, -0.0363172, -0.056664, -0.0483091, -0.050164, 0.0597146, 0.0240749, 0.0114544, -0.0528699, 0.0600739, 0.042091, -0.0245811, -0.0258426, -0.0346213, 0.0635759, 0.0628958, 0.0739286, -0.0744989, -0.0109098, -0.0269336, 0.042983, 0.0525349, -0.0143793, 0.0081214, 0.0238694, 0.0298813, 0.0438755, 0.0563057, 0.000975764, 0.00163941, -0.014329, 0.00502496, -0.0948776, -0.0219983, -0.0638057, 0.0936684, -0.0981602, -0.0706098, -0.0666669, -0.0189393, 0.00278872, 0.0521227, 0.0426383, -0.0243113, -0.0115899, 0.0360065, -0.0186245, 0.0013339, -0.0340412, 0.0494574, 0.0415468, 0.0620697, -0.016053, 0.0700594, 0.0459253, 0.0111776, -0.0300047, -0.0106807, -0.0333468, 0.0253403, 0.0881854, -0.0173002, 0.038369, 0.0322551, 0.00492755, -0.0753505, 0.0721686, -0.0235206, 0.00739698, 0.0348818, -0.0533658, -0.007753, -0.0096735, 0.00342031, 0.0259356, -0.062654, 0.0683073, 0.0368552, 0.0496986, 0.0645281, 0.081075, 0.0593932, 0.0403475, -0.0693188, -0.0718186, -0.0533515, 0.100172, 0.0870128, 0.074077, -0.000761396, 0.0729214, 0.0636252, -0.0294426, -0.0536525, -0.0411284, -0.0930854, -0.0704588, 0.010874, 0.0309673, 0.0673118, 0.0299417, -0.0565894, -0.0418519, 0.0586602, 0.0946406, -0.0168476, 0.00537891, 0.0162853, 0.104248, 0.03283, -0.0760598, 0.0254248, -0.0517078, 0.0106796, -0.0460838, 0.041345, -0.0249912, 0.0536004, 0.0766685, -0.013064, -0.075825, 0.0510529, -0.108371, 0.0739316, 0.00267756, -0.0211139, -0.0399614, 0.0378666, -0.212065, -0.0569976, 0.196378, -0.0501688, -0.0714393, 0.147611, 0.0770956, 0.16495, 0.0202155, -0.0698482, -0.0748518, 0.228056, 0.00262548, 0.126506, 0.107247, 0.0427064, -0.0819312, 0.177222, -0.0316936, 0.0924993, 0.0207863, -0.0929258, -0.0465818, 0.0259768, -0.0879141, 0.240415, -0.0169955, -0.169665, -0.0240092, 0.0491049, -0.201988, 0.110246, -0.00105259, 0.109962, -0.0867746, -0.0820479, -0.0743187, 0.0354609, 0.0974124, -0.0517368, -0.0884694, -0.127529, 0.00106244, 0.0205351, -0.0630205, 0.102091, -0.084926, 0.157183, 0.130844, 0.04329, -0.14183, -0.0690912, 0.208973, 0.0417766, -0.133104, -0.0199587, 0.0348628, -0.0933456, 0.0140773, -0.010606, 0.067953, 0.192645, 0.0201431, 0.0463449, 0.000419435, -0.00756193, 0.0341863, -0.0828705, 0.0600874, 0.0812791, -0.0484855, 0.042646, 0.070924, -0.092887, -2.21675e-05, 0.0729522, 0.0485811, -0.00205353, 0.0661146, 0.000713561, 0.0731239, 0.0208117, 0.0577898, -0.0738829, -0.140457, 0.13128, 0.118804, 0.0332973, 0.0976603, 0.022694, -0.0606709, -0.200919, 0.00696897, 0.0871402, -0.11299, 0.0702363, -0.0479222, 0.0156001, -0.0397634, -0.0389743, 0.019353, 0.173816, -0.0883072, -0.106449, -0.0111854, 0.0179693, 0.154282, -0.102453, -0.00975383, -0.0509292, 0.0055609, 0.159444, -0.0812525, -0.0490681, 0.290577, -0.00474095, -0.147308, 0.182364, 0.129911, 0.234754, 0.010799, 0.0708197, 0.00986373, 0.0601883, -0.215155, 0.354444}, {0.0783085, -0.117109, -0.0268367, 0.0680229, -0.136503, 0.0379092, -0.0187756, 0.00709634, -0.135748, 0.0242747, -0.00968491, 0.214004, 0.0240518, 0.195004, 0.0643025, -0.11406, -0.0687747, 0.0317223, 0.0451382, 0.0295511, -0.131034, 0.241562, 0.118851, -0.139982, -0.0855322, 0.0280597, 0.0697782, -0.0136355, -0.0528787, 0.0935231, -0.035887, -0.0318691, -0.0258636, 0.0137195, 0.0879051, 0.157812, 0.0731856, 0.293005, -0.144515, -0.145543, 0.0256074, -0.0260038, -0.144694, -0.0706887, -0.00794197, -0.0179741, 0.0633569, 0.0229077, -0.0727384, 0.0370555, -0.159883, 0.00966875, -0.0247621, 0.0138396, -0.0481591, -0.0734393, 0.0262144, -0.00736717, 0.0443594, 0.0365842, 0.126802, 0.0601514, 0.175519, -0.0174661, 0.151405, -0.0485238, 0.000172798, -0.306984, -0.414179, 0.0973993, 0.247721, -0.119908, -0.174245, 0.121988, -0.175022, 0.141109, -0.0557625, 0.169215, -0.894691, 0.185397, 0.113934, 0.232094, 0.112, 0.0593229, 0.126998, 0.651725, 0.0237932, -0.0760943, 0.100959, 0.226337, 0.0932887, 0.145421, -0.219902, -0.0142369, 0.0371012, -0.115441, -0.0623712, 0.169185, -0.187946, -0.164182, -0.276341, 0.192904, 0.0940475, 0.0633908, -0.52761, 0.311851, 0.0147285, -0.246865, 0.0794375, -0.0256774, -0.96744, 0.190738, -0.203935, -0.069722, -0.158799, 0.158885, 0.355309, 0.572827, -0.135233, 0.247912, 0.0500503, -0.372072, -0.553493, 0.298284, 0.284253, -0.0747145, -0.139572, 0.105405, 0.0409781, -0.381707, -0.145055, -0.0669109, -0.450324, -0.0909348, 0.262303, -0.14358, 0.12224, 0.239984, 0.121959, -0.553701, -0.101163, -0.149766, -0.0910466, 0.174752, 0.249944, -0.250833, -0.289119, -0.106795, 0.0102534, 0.0782438, 0.205057, -0.0626182, 0.161316, -0.281397, -0.277739, -0.102944, -0.188389, 0.0912149, 0.00694824, -0.00900776, 0.117959, 0.144582, 0.126166, 0.191845, 0.0502689, -0.0493585, 0.193967, -0.276529, -0.727887, 0.0642719, 0.199473, -0.0143486, -0.215936, -0.0279253, -0.0842179, 0.499287, 0.236854, 0.115353, -0.798518, 0.113574, -0.024717, 0.088366, -0.0310143, -0.0544129, -0.0405537, 0.393679, -0.138819, 0.0217802, -0.302464, 0.360417, -0.0358622, -0.0556605, -0.23588, -0.0949753, 0.0916673, -0.187417, -0.0141762, 0.239287, -0.313223, -0.0338576, -0.04228, -0.0447996, 0.00219429, 0.0852568, -0.436663, 0.0226728, 0.0889368, 0.0502348, 0.200996, -0.0519863, -0.826958, -0.123262, -0.276269, 0.00410494, -0.267621, 0.295794, 0.263372, 0.399407, -0.0643723, 0.167923, 0.179905, -0.054785, -0.236271, 0.143078, 0.0231367, 0.0020305, -0.0378614, 0.151338, -0.193445, -0.207329, -0.247456, -0.0269543, -0.264353, -0.2099, 0.3169, 0.0985966, 0.116078, 0.0637442, 0.0605826, -0.550574, 0.216279, 0.137313, 0.0618122, 0.319666, 0.0112869, 0.020506, -0.362546, 0.0643781, -0.018046, 0.0156272, -0.0326438, -0.0116343, -0.403798, -0.552868, 0.00132041, 0.03869, -0.0648429, 0.205129, -0.0141589, -0.0269455, 0.114992, 0.255106, 0.053601, 0.0274071, -0.000846533, 0.155565, -0.0652745, -0.111888, -0.672062, -0.121639, 0.131624, -0.176021, -0.258642, 0.0632687, 0.0579228, 0.318165, 0.202022, -0.090495, -0.490679, 0.0582578, -0.238482, -0.0600154, -0.0901936, -0.0516334, 0.202053, 0.42323, -0.0074736, 0.0620904, -0.301792, 0.34241, -0.077041, -0.025546, 0.0204534, -0.0812055, 0.130181, 0.01445, -0.0186562, 0.239726, 0.04799, -0.0275115, 0.0874114, 0.0358341, 0.136381, 0.00636141, -0.104443, -0.13456, -0.0358074, 0.0322215, 0.0554715, -0.0638009, -0.812087, 0.146302, -0.182508, -0.232606, -0.244497, 0.271379, 0.0453193, 0.20784, -0.0269808, 0.147621, 0.110811, 0.190189, 0.223962, 0.255846, 0.0883559, -0.04041, 0.111729, 0.143826, -0.18761, -0.162277, -0.242633, -0.0862963, -0.0312571, -0.108266, 0.0870629, 0.046431, -0.0277447, -0.17472, 0.0985268, -0.355992, 0.0380013, 0.0223109, -0.154999, 0.114538, 0.020933, 0.116286, -0.0549278, 0.0551266, -0.0572128, 0.129697, 0.135367, 0.036043, -0.0678647, -0.436623, 0.00882867, 0.0603437, 0.00346218, 0.326069, 0.00306932, 0.0123955, 0.0141631, -0.091341, 0.073139, 0.244829, -0.0778902, 0.13299, -0.0395972, 0.0469616, -0.338698, 0.063721, 0.124731, 0.210606, -0.151434, 0.0782941, -0.0570001, -0.0366027, 0.242515, 0.106146, -0.462287, 0.105981, -0.139465, 0.0172743, -0.0431566, 0.00104558, 0.409085, 0.44476, -0.00424744, 0.325297, -0.133478, 0.0828476, 0.0404255, 0.0306249, -0.13928, -0.0587072, 0.23355, 0.268898, 0.0192549, 0.224394, -0.123509, 0.0638127, 0.131705, -0.0104301, 0.254651, 0.0239047, 0.175214, -0.0484905, 0.0186364, 0.011824, 0.151211, -0.173725, -1.13661, 0.0147172, -0.11821, -0.393198, -0.438496, 0.186057, 0.0799884, -0.00559358, 0.0557019, 0.149938, -0.148746, 0.119321, -0.00863876, 0.0722763, 0.161903, 0.0542112, 0.290444, 0.0346604, -0.0790234, -0.145108, -0.287634, -0.436138, 0.126163, -0.0123912, 0.113055, -0.0971506, 0.119078, -0.0386488, 0.0943877, -0.234315, 0.108057, -0.222114, 0.0400617, 0.117907, 0.113153, 0.0576575, -0.408248, 0.275988, -0.0382029, 0.0964898, 0.0196727, -0.063849, 0.027982, -0.335833, -0.0927965, 0.273589, -0.00805751, 0.234927, -0.0421147, -0.101992, -0.125482, 0.0833793, 0.0596327, 0.301731, -0.112498, 0.246112, 0.134698, 0.0994743, 0.0363752, -0.0762748, 0.251911, 0.476983, -0.216098, 0.136716, 0.174116, 0.157733, -0.00958557, 0.116019, -0.505057, 0.0455307, -0.261111, 0.00399881, -0.0424702, 0.0537986, 0.394567, 0.27489, 0.00350826, 0.0565268, -0.0774098, 0.268609, -0.104168, 0.131119, 0.0189092, -0.0451308, 0.150122, 0.168287, 0.0185893, 0.150597, -0.0400092, 0.118563, 0.215605, -0.0887616, 0.363498, -0.020723, 0.111999, 0.104417, -0.0898174, -0.0618301, -0.104013, -0.174184, -0.98971, -0.0714989, -0.230316, -0.205347, -0.619032, 0.040232, -0.17549, 0.110452, 0.0721074, 0.34544, -0.0476614, 0.122644, 0.0235811, -0.0710317, 0.296968, -0.0241802, 0.0198728, 0.174972, -0.290384, -0.123021, -0.359847, -0.383756, 0.366647, -0.00853107, 0.280999, -0.231331, 0.225509, 0.0220186, 0.0158668, -0.427476, 0.171765, -0.0642987, 0.224131, -0.0570531, 0.0653458, 0.0176029, -0.21353, 0.148519, 0.0637133, 0.226655, 0.217961, -0.013819, -0.146475, -0.0707995, 0.0495935, -0.0513142, 0.105792, 0.403708, 0.111416, -0.239413, -0.0464832, 0.0253369, -0.0498729, 0.335403, 0.116413, 0.377843, 0.229471, 0.150722, 0.220304, -0.0649569, 0.0844493, 0.52762, -0.0151133, -0.0765573, 0.083642, 0.212266, 0.00280719, -0.0436244, -0.298868, 0.0924992, -0.213386, -0.118539, -0.0120527, 0.0508904, 0.355849, -0.0809101, 0.157515, 0.0177864, 0.067071, 0.277435, 0.0287353, -0.0853305, 0.0742214, -0.128416, -0.133036, 0.0312117, -0.0747517, 0.115624, -0.139491, -0.00190408, 0.180409, -0.143345, 0.308382, -0.0290443, 0.00865995, 0.23369, -0.102291, -0.153978, 0.320308, 0.0688226, -0.646194, 0.0377166, -0.34946, 0.0560827, -0.256756, -0.0291609, 0.00580806, 0.140727, 0.0555845, 0.300253, -0.0512941, -0.061659, -0.0575044, -0.0659643, 0.564499, 0.0485377, -0.19326, 0.127806, -0.0951724, -0.179034, -0.036727, -0.323366, 0.296255, -0.057443, 0.281525, -0.255026, 0.138755, -0.166742, 0.118802, -0.474339, 0.266361, 0.243477, 0.215871, 0.195949, -0.204052, 0.0376644, -0.204987, 0.118772, 0.0402892, 0.142502, 0.163526, -0.0353531, -0.0696758, -0.238905, -0.0457167, 0.167052, 0.0416106, 0.420146, 0.106264, 0.123399, -0.0408766, 0.135707, -0.0146638, 0.552235, -0.118133, 0.12756, 0.0793916, 0.171429, 0.226625, 0.131898, -0.00972259, 0.40523, -0.236987, 0.0594983, -0.0637292, 0.132598, -0.115125, 0.0151836, -0.387607, 0.0327063, -0.37631, 0.0658709, -0.122751, -0.0846687, 0.324798, -0.438113, 0.187124, -0.0490253, -0.125017, 0.132795, 0.0983991, -0.0677004, 0.107506, -0.0625372, -0.182304, 0.0559928, 0.00302827, 0.0585183, -0.0470361, -0.0323393, -0.0818622, -0.123209, -0.170888, 0.00743154, -0.0379849, 0.226271, 0.186311, -0.169626, 0.0730926, -0.0255297, -0.444115, 0.136086, -0.145142, -0.0982522, -0.139828, -0.111428, -0.114669, 0.258485, -0.00854396, 0.296486, -0.0853765, -0.0807965, -0.0870598, 0.047532, 0.44249, -0.0561342, -0.0312779, 0.0637764, -0.148202, -0.0249448, 0.197569, -0.23723, 0.117594, -0.097121, 0.269201, -0.267006, 0.0238788, 0.120816, -0.0061836, -0.325017, 0.162325, 0.0392069, 0.3048, -0.0526302, -0.124757, -0.014943, -0.285602, 0.202006, 0.201091, -0.0784401, 0.10015, -0.0819651, -0.0594275, -0.215974, 0.0107357, 0.0312415, 0.0433864, 0.376299, 0.155622, 0.269767, 0.0494381, 0.000357749, 0.110342, 0.43453, -0.0674044, -0.141837, -0.0197083, 0.329516, 0.209902, 0.079787, 0.0152663, 0.460223, -0.362267, -0.0294796, -0.0702618, 0.248239, -0.25474, -0.0246109, -0.569164, 0.0692694, -0.21792, -0.0478154, -0.114199, -0.0433904}, {0.0223067, -0.478495, 0.0505315, -0.24475, -0.457223, 0.124627, 0.117389, 0.095779, 0.0720996, 0.049396, 0.0409143, -0.000136225, -0.0903079, 0.141811, -0.198048, -0.0569895, -0.0757045, 0.0993248, -0.559567, 0.0209521, -0.113191, -0.0844447, 0.141579, -0.0239859, 0.356615, -0.0141687, -0.0419679, 0.0383035, -0.18173, 0.0160005, 0.0877505, -0.196081, -0.0912885, 0.344107, -0.0540727, 0.449809, -0.161898, 0.00604633, 0.0867791, 0.0412237, 0.501225, -0.0133629, -0.157945, 0.170903, -0.227289, 0.0554283, 0.234807, -0.163367, 0.13184, -0.161176, 0.407384, -0.163831, 0.284014, -0.0281678, 0.102854, -0.513742, 0.0579104, 0.0464928, 0.225144, -0.194545, -0.0233268, 0.140834, -0.334352, 0.143506, 0.00305333, 0.11543, -0.177591, -0.0496597, -0.0102004, -0.193958, -0.0897301, 0.180203, 0.0156362, 0.320056, 0.142387, 0.119566, -0.0239668, 0.0507078, -0.0842297, 0.170036, -0.0487316, 0.0626395, 0.0621281, -0.0104038, 0.364141, 0.072498, -0.0538375, 0.228087, -0.185111, 0.0970743, -0.108179, 0.204923, 0.0467529, 0.209084, -0.301984, 0.153071, -0.0410797, -0.111712, -0.045159, -0.0730075, -0.0386654, -0.741991, -0.023268, -0.0599555, -0.261069, 0.196537, 0.0439408, -0.127939, -0.117325, -0.00699946, 0.154962, -0.0210018, 0.0331086, 0.186919, -0.0790406, -0.218436, 0.0129458, 0.0486227, -0.626638, -0.0861242, -0.15996, -0.230159, 0.207664, 0.0897269, 0.596896, 0.0832163, 0.0271554, -0.172921, -0.0435014, -0.00604345, 0.0473066, 0.122234, -0.0258598, 0.351208, -0.213196, 0.357176, -0.432667, 0.132283, 0.163826, 0.130816, 0.640093, -0.0888178, -0.0506744, 0.0157766, -0.303337, 0.307047, 0.281906, -0.100086, -0.212694, -0.320041, 0.249802, -0.229893, 0.463453, 0.136749, 0.157943, -0.245784, 0.0264781, -0.0479493, -0.112127, -0.4855, -0.0894212, -0.0188713, -0.0823077, 0.0897543, 0.10224, 0.0398244, -0.107183, 0.0166548, 0.0519958, -0.30304, -0.0585293, 0.162133, 0.13617, 0.191154, 0.283172, -0.158722, 0.087541, 0.266156, 0.0799257, -0.0521471, -0.221776, -0.00945018, -0.0786966, -0.00666656, 0.343262, 0.1421, -0.213575, 0.0772043, -0.206544, 0.109058, -0.0928144, 0.259307, 0.107262, -0.0695271, -0.0867157, 0.107203, -0.195411, -0.030659, -0.0265577, 0.034201, -0.219565, -0.364651, 0.0675519, -0.0322907, -0.0861175, -0.00437113, 0.0849787, -0.122122, -0.0852434, 0.104652, -0.066887, 0.0198492, 0.0162986, -0.0427262, -0.0744128, -0.194282, -0.00538579, -0.0338147, -0.615263, -0.0889304, 0.0104131, -0.217447, 0.124137, -0.0928838, 0.625458, 0.146923, 0.157938, -0.0721593, -0.250954, 0.00286421, 0.218452, 0.116043, -0.0102347, 0.221063, -0.161121, -0.0782882, -0.401551, -0.0927851, 0.0069106, -0.101149, 0.422163, 0.0129658, -0.0653755, -0.114568, -0.0628372, 0.073829, 0.350256, -0.046875, -0.225863, -0.130025, 0.222004, -0.105926, 0.497274, 0.201437, 0.15911, -0.267799, -0.267768, -0.147195, -0.465096, -0.525451, -0.270165, -0.0674769, -0.0814379, 0.0416476, 0.106072, -0.0776767, -0.102042, 0.0770391, -0.025344, -0.600424, 0.0660492, 0.21441, -0.0946211, -0.134466, 0.400541, 0.0755677, 0.0725432, 0.232947, 0.0606421, 0.221633, -0.0264577, 0.000702297, -0.0652917, -0.0730807, 0.0298234, 0.346105, -0.0256575, 0.217638, -0.0802333, 0.0294396, 0.00407619, 0.316272, 0.107328, 0.154892, 0.0768722, 0.103692, -0.214736, -0.103562, -0.157023, -0.0605033, -0.0261779, -0.235464, 0.0623386, -0.146497, 0.146333, 0.18995, -0.0106592, 0.0101862, 0.026889, 0.165702, -0.0711902, 0.131473, -0.105142, -0.0242934, -0.318079, -0.0214468, -0.168207, -0.0340076, -0.430346, -0.0933372, 0.166779, -0.0350242, -0.0106954, -0.00443671, 0.584385, 0.14743, 0.085196, -0.069834, -0.0934638, 0.0164511, 0.111853, 0.167705, 0.268748, 0.064396, -0.0407362, -1.10413, -0.388358, -0.209668, -0.171347, -0.121266, 0.395114, -0.0332835, 0.0227312, -0.0940843, 0.0611698, -0.106398, 0.162234, -0.30532, -0.252488, -0.0197537, 0.0701696, 0.246612, 0.40822, 0.0965354, -0.164679, -0.46197, -0.17318, -0.127014, -0.593206, -0.536407, -0.237576, -0.347521, -0.165565, 0.287403, 0.097119, 0.0306465, -0.17743, -0.0481327, -0.46509, -0.875548, 0.0706845, 0.348758, -0.0392516, -0.207509, 0.373817, -0.115171, -0.212755, 0.160893, -0.0356015, 0.120137, -0.133202, 0.0649359, 0.166364, -0.279714, -0.0259038, 0.572804, 0.00745354, 0.0341552, 0.0373603, 0.132618, -0.0360954, 0.086302, 0.13432, -0.00736163, 0.00168762, 0.321345, -0.313614, -0.135072, -0.0561371, -0.102724, 0.0371193, 0.0394923, -0.00236424, -0.0612335, -0.0299266, 0.0416696, -0.075589, 0.0208159, -0.254363, 0.237712, -0.038898, 0.23237, -0.000538711, 0.0704522, -0.463484, 0.0986165, 0.00524978, 0.102234, -0.156869, -0.0859209, 0.331525, -0.223007, -0.329643, 0.0864457, 0.418795, 0.121755, -0.115625, -0.0795443, -0.0638048, 0.0178451, 0.293045, 0.1078, 0.107416, -0.0111762, -0.0759943, -1.12692, -0.638409, -0.0673115, -0.0558241, -0.00812498, 0.345901, 0.00409281, -0.00381443, -0.0817815, 0.341504, -0.218866, 0.243459, -0.187034, -0.205691, -0.162896, 0.151429, 0.0536843, 0.0451803, -0.00103154, -0.414277, -0.125777, 0.0623508, 0.0155032, -0.272699, 0.0208951, -0.353736, -0.0385535, -0.137511, 0.09768, 0.0377825, -0.187323, -0.173212, -0.205074, -0.428537, -0.994973, 0.0788617, 0.548999, 0.0999388, -0.482342, 0.415618, -0.164031, -0.518565, 0.218144, 0.0413067, -0.121151, -0.191466, 0.087357, 0.133816, -0.328014, -0.21353, 0.72458, 0.243564, 0.0468601, -0.0556792, 0.00148107, -0.126404, 0.120995, -0.0492751, -0.0788551, -0.00570077, 0.304324, -0.0360168, 0.0544142, 0.109958, -0.0668078, -0.0613521, 0.145138, -0.0876996, 0.0486584, 0.0478741, -0.107455, -0.0913343, 0.0291443, -0.037352, 0.128878, -0.146585, -0.0913219, 0.0422851, -0.0671169, -0.373208, 0.122035, -0.0910143, -0.00910417, 0.111169, -0.229095, 0.365786, 0.0279777, -0.314796, -0.0875231, 0.0071166, -0.0363618, -0.168532, -0.0291513, -0.129682, 0.0675129, 0.298079, -0.212187, 0.071094, 0.0227696, -0.191525, -0.320521, -0.503519, 0.273971, -0.0746956, -0.115033, 0.144259, 0.0291815, -0.10456, 0.0662569, 0.454669, 0.268187, -0.111342, 0.474724, -0.15568, -0.307335, 0.243391, 0.0750735, -0.746529, 0.138189, -0.628426, 0.419441, -0.099666, 0.0131023, -0.102031, 0.123011, -0.306506, 0.0387256, 0.206293, 0.0578754, 0.14266, -0.238779, -0.352114, -0.183162, -0.138764, -0.591425, 0.163284, 0.449746, 0.121963, -0.459143, 0.182878, -0.00636691, -0.528021, 0.194549, 0.0809465, -0.00788754, 0.113444, 0.194181, 0.0883112, -0.278563, -0.265756, 0.557366, 0.475394, 0.0441641, -0.138117, 0.143159, -0.224237, 0.117461, 0.123237, 0.0570331, 0.233009, 0.155712, -0.0861114, 0.0720612, -0.0226413, -0.0929624, 0.109243, 0.0981219, -0.229284, -0.0358307, 0.17345, -0.0448113, 0.265123, 0.0876893, 0.335159, 0.0334178, 0.0521256, 0.130224, -0.0231896, -0.1852, -0.105987, 0.0567592, -0.0500262, -0.342094, 0.195348, -0.298525, 0.166308, 0.0806577, -0.119163, -0.0336117, -0.0520307, 0.186439, -0.408872, -0.152699, -0.243829, -0.0462136, 0.255709, -0.117888, 0.16313, 0.121448, -0.0239753, 0.261246, -0.652453, 0.232694, -0.248136, -0.0887947, 0.232507, -0.0299337, 0.189272, 0.0763682, 0.578411, 0.192577, -0.277693, 0.702864, 0.141956, -0.136451, 0.27945, -0.0525392, -1.09923, 0.183541, -0.789045, 0.314143, -0.107235, -0.0254002, 0.0732772, 0.20291, -0.100342, -0.0767993, 0.176704, 0.148042, 0.0342674, -0.117231, -0.237913, -0.171944, -0.0382499, -0.0758213, 0.222741, 0.0784172, 0.208191, -0.439098, -0.0220184, -0.0820442, -0.367395, 0.238159, -0.039489, 0.0187515, 0.0212858, 0.27599, 0.0402613, -0.0172759, -0.0556134, 0.178362, 0.339106, -0.115199, -0.208537, 0.0872409, -0.0611705, 0.105852, 0.081245, 0.120593, 0.147307, 0.134503, -0.0658409, -0.0789288, -0.0328749, -0.013422, 0.0395077, -0.00904547, -0.0967295, -0.247574, 0.0511132, 0.140479, 0.247284, 0.233069, 0.299414, 0.172409, 0.288451, 0.0896325, -0.0252145, -0.276715, 0.0303914, 0.0861341, 0.101805, 0.0627973, 0.135257, -0.297732, -0.00287332, -0.0425953, 0.18106, 0.156973, -0.182344, 0.264261, -0.378339, -0.190602, -0.379503, -0.113986, -0.0605005, -0.218591, 0.159524, -0.162624, 0.129398, 0.451488, -0.75852, 0.485287, -0.212352, -0.0754464, 0.325208, -0.0600849, 0.212717, 0.145578, 0.358411, 0.202719, -0.11717, 0.363536, 0.0875414, -0.124007, 0.285366, -0.126019, -0.323655, -0.0386585, -0.504339, 0.119743, 0.00846367, -0.148892, 0.139887, 0.0513306, -0.0150926, 0.0928395, 0.217916, 0.308542, 0.00373323, 0.0949918, -0.364528, -0.0902708, -0.0744683, 0.0988769, 0.395941, 0.246062, 0.2805, -0.299678, -0.171685, -0.020429, -0.120363, 0.131904, -0.0356008, -0.166393, 0.0363739, 0.225337, 0.034156, 0.0595596}, {0.106228, 0.0783489, 0.0266884, 0.0781974, -0.0880511, -0.191914, -0.15043, -0.0320267, 0.0853568, 0.0953238, 0.30616, -0.0568309, -0.100066, -0.127311, 0.0774179, 0.0129809, -0.114989, -0.0861959, -0.0524406, -0.0580897, 0.21924, 0.0527911, 0.13648, 0.0837476, 0.191057, -0.0551254, 0.342318, -0.081069, -0.075302, -0.193443, 0.184786, -0.0295365, -0.00455549, 0.354315, 0.0795275, -0.529115, 0.206119, 0.0296573, 0.0727002, 0.101158, -0.264894, 0.158169, -0.108263, -0.119301, -0.159879, -0.0198122, -0.0688309, -0.15111, 0.0909975, -0.10589, 0.242787, 0.232015, -0.562872, 0.720659, -0.242728, -0.0695513, 0.134565, 0.0165935, 0.259899, 0.244802, 0.250698, 0.0794229, 0.217342, 0.169855, 0.172566, -0.278035, 0.313701, -0.095159, 0.0565872, -0.170561, -0.738641, 0.15166, 0.136531, -0.125523, -0.0433483, -0.109693, 0.0391338, -0.00445226, 0.0748965, 0.260709, -0.10943, -0.0523931, -0.0349851, 0.0701781, -0.090458, 0.248113, 0.307061, 0.169542, 0.187634, -0.2461, -0.607664, 0.166876, 0.213629, 0.134512, -0.157098, -0.131492, 0.149443, 0.0774883, -0.00985674, 0.119163, 0.0524511, -0.43508, 0.205349, 0.112172, -0.0616579, -0.0954217, -0.274216, 0.00573893, -0.021907, -0.0156302, 0.189533, -0.131088, -0.0901327, -0.121227, 0.0266469, -0.0770435, -0.17133, 0.0168353, -0.0490402, -0.0812962, 0.239077, -0.00947406, 0.150931, 0.0698773, 0.00668009, -0.0566452, 0.397731, -0.184763, -0.0224399, -0.0351355, 0.217392, 0.0896165, 0.204174, 0.30587, 0.22536, -0.291659, 0.0343764, 0.171715, 0.133172, 0.154814, -0.351272, -0.137641, -0.128276, 0.0731684, -0.134018, -0.0517926, -0.0648602, -0.287559, 0.0281201, 0.15921, 0.213428, 0.108729, -0.455282, 0.391864, -0.0828412, -0.0872908, 0.146633, 0.0237852, 0.221633, 0.155727, 0.373807, -0.0426788, -0.0248793, 0.16546, 0.0236898, -0.140391, 0.506752, -0.00319115, 0.157672, -0.274368, -0.53935, 0.0847296, 0.0300079, -0.212777, -0.0749273, -0.170332, 0.15075, 0.160601, -0.0771117, 0.143252, 0.00570011, 0.0301606, 0.158193, 0.0026997, 0.0321507, 0.149892, 0.385593, -0.0884273, 0.198285, -0.270067, -1.18945, 0.0475723, 0.0535051, -0.0291026, -0.00882954, -0.0175344, 0.228148, -0.0466812, 0.191291, 0.0476256, 0.305487, -0.476911, 0.116088, 0.142133, -0.269137, -0.123279, -0.14686, 0.0696721, 0.0997293, -0.137139, 0.191979, 0.0160196, -0.29023, -0.161442, 0.108263, -0.0601739, -0.361265, -0.0155223, -0.00608392, -0.195548, 0.451285, 0.275272, 0.365422, 0.0818399, -0.0636868, -0.318975, 0.304668, 0.0506616, 0.0433654, -0.100645, 0.269806, 0.0384133, 0.0164098, -0.0954253, 0.0987515, -0.380492, 0.16384, -0.0424626, 0.134995, 0.188744, -0.20065, -0.0237758, 0.11539, 0.0591621, -0.220156, 0.0337867, 0.125506, -0.411931, 0.127044, 0.21377, 0.279625, 0.141396, -0.290387, 0.3233, 0.160796, 0.0822911, 0.198651, -0.0211558, 0.00648465, -0.116035, 0.161201, -0.315931, -0.458266, 0.096787, 0.0296235, 0.0315981, 0.482945, -0.19107, 0.171579, -0.0198533, -0.694679, -0.0756212, -0.0749095, -0.477745, -0.164855, -0.018781, 0.459294, -0.100174, 0.0132599, 0.11289, -0.0370448, 0.11403, 0.14149, -0.0613515, -0.130114, 0.0169196, 0.360202, -0.126686, 0.157749, -0.158878, -0.923254, -0.116676, -0.0839202, -0.330571, 0.179163, -0.035661, 0.126527, -0.092803, 0.255846, -0.0706928, 0.238706, -0.3074, 0.110449, 0.0779279, -0.198761, -0.0695021, -0.0169589, 0.0924133, -0.0688577, -0.0779862, 0.136993, 0.0325743, -0.176087, -0.108891, 0.0930566, 0.045106, -0.513104, -0.108395, -0.098078, -0.0408314, 0.408529, 0.321084, 0.363504, -0.0364622, -0.410695, -0.238509, 0.461608, 0.160242, -0.0761577, 0.0239169, 0.284341, 0.222348, -0.203271, -0.0330857, 0.0363384, -0.617783, 0.0595815, 0.104009, 0.238751, 0.161461, 0.0471715, 0.00720896, 0.0507102, -0.185404, -0.197831, 0.211248, 0.197675, -0.186024, 0.274778, -0.0224699, 0.0473367, 0.282691, -0.40648, 0.0305323, 0.016877, -0.142536, -0.0820371, -0.0277592, -0.151387, 0.286842, -0.133986, -0.462732, -0.636447, 0.0728473, 0.0146836, 0.0847432, 0.393744, 0.0129399, 0.291461, 0.0326279, -1.01267, -0.409298, -0.18529, -0.209581, -0.0687, -0.116882, 0.598766, 0.00432624, 0.0153415, -0.0933092, 0.0294605, -0.0856998, 0.14466, -0.0181009, -0.0551553, -0.0757602, 0.376359, -0.092105, 0.219286, -0.153261, -0.65096, -0.0500806, -0.239568, -0.435606, -0.0380773, -0.0785754, 0.000479117, 0.186631, -0.0298776, -0.0426709, -0.0265988, -0.273386, 0.111777, -0.0838393, -0.05312, -0.174917, 0.0676386, 0.30082, -0.151601, 0.106563, 0.342491, -0.0368085, -0.0993033, -0.00614346, 0.20513, -0.0533839, -0.745947, -0.222543, -0.155648, -0.0189709, 0.207195, 0.599533, -0.0249364, 0.15537, -0.359481, -0.148591, 0.373197, -0.169472, 0.0596552, 0.189621, 0.0695457, 0.464376, -0.26048, -0.0388054, -0.00777882, -0.63587, 0.243413, 0.195224, 0.245992, 0.460392, -0.363334, 0.235109, 0.0248368, -0.143888, -0.122985, 0.121124, 0.131884, -0.421677, 0.213081, -0.048978, -0.0662981, 0.077159, -0.425332, -0.136375, -0.258874, -0.0855508, 0.185019, 0.0343102, -0.251024, 0.0408662, -0.076963, -0.939761, -0.393506, 0.0682762, -0.212111, 0.091375, 0.214266, -0.145631, 0.134762, 0.293902, -1.02951, -0.463808, -0.609863, 0.0176058, 0.144982, -0.125917, 0.606399, 0.154963, 0.218054, -0.150898, -0.0668025, -0.245749, 0.438938, 0.0474114, 0.0787208, 0.14089, 0.539561, 0.0944855, 0.106003, -0.247501, -0.850703, -0.027484, 0.188744, -0.556431, 0.260488, 0.100893, -0.102187, 0.0652266, -0.0530284, -0.0592192, -0.194899, 0.00563411, -0.0375979, -0.0238458, 0.03417, 0.206393, 0.0865611, -0.0651526, 0.0254215, -0.0607744, 0.205715, -0.0976619, -0.0899626, -0.021927, -0.159355, 0.0470674, 0.00684065, -0.000117611, 0.0496235, 0.0935823, 0.199903, -0.192236, 0.233556, 0.0439257, 0.0661198, -0.037225, 0.101252, -0.0761964, -0.0411658, 0.0617262, 0.0898041, -0.162734, -0.0374347, -0.0639115, 0.0422137, -0.00878786, -0.106721, 0.112103, 0.0676824, 0.031201, -0.0204709, 0.17504, 0.144924, 0.0779569, 0.0785571, 0.0595144, -0.0342123, 0.00147246, -0.106409, 0.112795, -0.00807928, 0.0395167, 0.143934, 0.190205, 0.0376234, -0.166338, 0.0795435, 0.0322158, -0.0582759, -0.0286662, -0.126662, -0.0291046, 0.0282258, 0.0551304, 0.0494178, 0.0486255, 0.0337688, -0.20053, -0.107614, -0.0147769, 0.0238361, 0.123211, -0.0674866, -0.0397505, 0.0465113, 0.0191078, -0.0279066, -0.0515832, 0.110796, -0.00172641, 0.122779, -0.0401669, -0.0535992, -0.0512884, -0.0128355, -0.0870605, 0.0547826, -0.0818571, 0.126043, -0.0110227, -0.0366337, 0.0149989, -0.0372861, 0.0652104, -0.00762276, -0.0205568, 0.0316321, -0.0194013, -0.0044834, -0.0445022, -0.067683, 0.0351842, -0.0560417, 0.0372428, -0.0332195, -0.0283974, 0.0172348, -0.0562934, -0.0614047, -0.0463125, 0.0748064, -0.0579784, 0.0342823, -0.00125796, -0.0225826, 0.00970435, -0.076774, -0.0273902, 0.026127, 0.0613562, 0.0610499, -0.0215178, -0.0221368, 0.0212263, -0.035672, -0.0498391, -0.0254565, -0.00164395, -0.0068439, -0.065408, 0.0611235, -0.0206502, -0.00251836, 0.0462653, 0.0266971, 0.0747625, 0.0197937, -0.0418868, 0.0296677, 0.0498549, -0.0281584, 0.0116278, -0.000439046, -0.0235977, 0.0107671, 0.0697557, 0.0117734, -0.0613823, 0.0654296, 0.007876, 0.00296129, -0.0282109, 0.0658105, -0.0740173, -0.030634, -0.0269175, -0.0521414, 0.0740558, -0.0189515, -0.0510656, 0.0435114, 0.04525, -0.0823205, 0.046068, -0.0498974, -0.0438497, -0.0167841, -0.0722696, -0.0758175, -0.0774343, 0.0102278, 0.0223604, -0.0451963, -0.0187346, -0.0280464, 0.0457861, -0.0652473, -0.0170273, 0.0354331, 0.0438309, -0.00835784, 0.0268001, -0.0496824, -0.0133471, 0.0432181, 0.054949, 0.0793102, 0.0644628, 0.0770307, 0.0413358, 0.034026, -0.0600782, 0.0499074, 0.0551336, -0.0502823, 0.0417936, 0.0286551, 0.0686193, 0.0204799, 0.0588617, 0.0516437, 0.0356938, 0.0317645, -0.0454114, -0.0773483, -0.0288175, 0.0514881, 0.0311751, 0.0373352, 0.0754472, 0.0417206, -0.0484494, -0.0100939, 0.023451, 0.0578131, 0.0628097, 0.00437278, -0.0762603, -0.0364193, -0.0728384, -0.0230054, 0.00777201, -0.0551509, 0.0638988, -0.0815448, -0.0562305, 0.0690872, 0.0717397, 0.0139686, -0.0138745, -0.0319408, -3.88604e-05, 0.0344767, -0.0415303, 0.0453481, 0.0247033, -0.0567496, -0.051773, 0.0261704, 0.0196623, 0.0205157, -0.0247812, -0.0544679, -0.028377, 0.0433471, -0.00281045, -0.0370607, 0.00538541, -0.043714, 0.0408239, -0.0711456, -0.0633004, 0.019739, 0.055718, -0.061287, -0.0425627, 0.0292396, -0.0756729, 0.00970749, -0.0417561, 0.014265, 0.0611766, 0.0811706, -0.0613711, -0.0402846, -0.0779509, 0.0816195, 0.0809503, 0.00787995, 0.0358824, 0.0214607, -0.0444484, -0.0561718, 0.0343452, -0.0183889, 0.0216392, 0.0122597, -0.0330169, -0.0793481, 0.0149399, 0.0559038, 0.0772916, -0.0715435, 0.00913159}, {0.0688562, 0.00519381, 0.0452299, 0.0172116, 0.0440391, 0.00348625, -0.0100488, -0.0687728, -0.0425062, 0.0673371, 0.0765072, -0.0414634, -0.00331896, 0.0274454, 0.0160977, 0.057025, 0.059171, 0.0811036, -0.0740875, 0.0474222, -0.00447991, 0.0283125, -0.0200669, 0.0564087, -0.0650948, 0.0337162, -0.045976, -0.0738564, 0.0147309, -0.0151635, 0.00953154, -0.0359997, -0.054605, -0.0143271, 0.0278187, -0.0121926, -0.0234082, 0.0587457, -0.000471391, 0.00385281, -0.0621695, 0.0265547, -0.0814582, 0.0572222, 0.0237959, -0.0618939, 0.0457196, -0.0791222, -0.027333, 0.0203922, 0.0229027, -0.0593854, 0.0472042, -0.0324131, -0.0293764, -0.00837035, -0.0486536, -0.0456363, -0.0387316, -0.0662781, 0.0472379, -0.0666359, -0.0524254, 0.00547321, 0.0278148, -0.0281987, 0.0509355, 0.0322822, -0.0695822, 0.0780975, 0.0129934, -0.0699667, 0.0518378, 0.057456, 0.0544721, 0.0139068, -0.0453229, 0.0320583, -0.0659085, -0.01896, -0.0575521, 0.0568375, -0.0612552, 0.0580056, 0.0647983, 0.0467467, 0.00313044, -0.0609863, 0.0796147, 0.0317063, 0.0301597, 0.0593748, 0.00892798, -0.00474358, 0.0484435, -0.0752748, -0.0368581, -0.0336355, -0.0123344, 0.0691037, 0.0567775, 0.0475532, 0.0110805, 0.0660029, 0.0795991, 0.0173841, 0.0157752, -0.0705982, -0.0580972, 0.00275515, -0.0813531, -0.00209847, 0.029734, -0.0808274, -0.0233868, 0.0532267, -0.0398337, 0.00856996, -0.0535785, 0.0632483, 0.0325174, -0.079892, 0.0724498, 0.0434156, -0.0589782, 0.0646692, 0.0785469, 0.0651546, 0.0756008, -0.0369482, 0.079261, -0.0316378, -0.0397821, -0.0664815, -0.0713122, -0.0815149, 0.0369504, 0.0309361, -0.0711362, 0.016442, -0.066231, 0.0103765, -0.0503103, -0.0196158, -0.0314453, -0.0736933, 0.0500839, 0.0495247, -0.0160433, 0.012135, -0.0318366, 0.0247343, -0.0586796, -0.0791689, 0.0106919, 0.0133124, -0.0594835, -0.081543, 0.0245614, -0.0316692, -0.0374838, -0.000338927, -0.0556435, 0.0119441, -0.0792761, 0.0476488, -0.0586372, -0.0260746, -0.0480716, -0.0799996, 0.0724571, 0.0744247, 0.0484247, 0.0142458, 0.0258083, -0.017503, -0.0493595, -0.0621898, -0.066893, -0.0150613, -0.0439402, -0.0391866, 0.0290893, 0.0309786, 0.0680639, 0.0245234, 0.0451974, 0.0759465, -0.0129352, 0.0747771, 0.0777778, -0.0238157, 0.0538951, 0.054531, -0.0521115, 0.0225482, -0.0262055, -0.00730145, 0.051451, -0.0821683, 0.0177617, -0.0792962, -0.0547936, 0.0523012, 0.0256393, -0.0233562, 0.0773626, -0.0298054, 0.0716357, -0.0638024, 0.0341725, -0.0687673, -0.0294533, 0.0357646, -0.0522063, -0.0501866, 0.0515789, -0.0914757, 0.0274805, -0.0420126, -0.0542943, 0.0425956, -0.0669988, -0.0576291, -0.0621375, 0.00426897, -0.0430185, 0.0486532, 0.0530738, -0.0264454, -0.0378986, 0.0612783, 0.0676239, -0.0425594, -0.00755219, -8.41312e-05, -0.0520412, -0.0630627, -0.0359756, -0.0736924, -0.00906721, 0.0321712, -0.0171744, -0.0550204, 0.0739103, 0.0403296, -0.045856, -0.0234004, 0.0321001, -0.102762, -0.0193531, -0.0806168, 0.0192554, -0.0616239, 0.055123, -0.0248056, -0.0126465, -0.0387301, -0.0483521, -0.0455788, 0.0750612, 0.0733936, 0.00358158, 0.0200632, 0.00244221, 0.0166086, 0.0286301, -0.00181356, -0.0085813, -0.000111784, 0.0217321, 0.0267503, -0.00272095, 0.0351902, 0.000383976, 0.074079, -0.00420327, 0.0260825, 0.019423, 0.0041048, -0.0201616, 0.10038, -0.0401037, 0.101862, 0.018521, 0.00226108, -0.00749256, 0.0306981, 0.0532129, 0.0120642, -0.00545772, -0.0544602, -0.0983469, 0.00921935, -0.0261096, -0.0888445, -0.0370228, 0.0212568, 0.0186713, -0.0312372, -0.055879, 0.0241056, 0.09821, -0.0282552, 0.0123204, 0.0655538, 0.0475607, 0.0807089, -0.000892608, 0.0132423, 0.0881375, 0.0149489, -0.0541359, 0.0251274, -0.0323102, -0.0647636, 0.0236787, 0.0851905, -0.0919926, -0.0512472, -0.0222562, -0.0160785, -0.179393, -0.0987289, 0.0388862, -0.181658, -0.0195746, -0.0682853, 0.154324, 0.058156, 0.106598, -0.0588053, -0.0616785, 0.133357, -0.0252694, 0.0440131, 0.195884, -0.000365252, -0.0873708, 0.137082, -0.0310968, 0.135489, 0.0132775, -0.0734563, -0.079516, 0.0178029, -0.101465, 0.116939, 0.0214054, -0.181108, -0.0757837, -0.135835, -0.113887, -0.00228155, -0.0463486, 0.127704, -0.0137494, -0.0772217, 0.0368818, 0.0929664, 0.0903488, 0.0620084, 0.0310103, 0.0218983, 0.0754895, -0.0598056, -0.0613288, -0.0082727, -0.0926897, 0.0797924, 0.0924856, 0.0346584, -0.035924, 0.0636576, 0.129607, 0.0189064, 0.0690258, 0.0820872, -0.00463654, -0.1114, 0.042848, -0.0335403, -0.0522452, 0.240356, 0.0531339, 0.194241, -0.118369, 0.00481883, 0.0929418, 0.0784902, 0.167211, 0.0904801, -0.00419117, -0.014103, 0.0453694, -0.0433359, -0.0524516, 0.0415577, -0.109334, 0.0835629, -0.019824, 0.0413249, -0.0810069, -0.180194, 0.0702942, 0.0633845, 0.0307907, 0.0601998, 0.200343, -0.105625, 0.153482, -0.0218919, -0.00088458, -0.0917724, 0.00633991, -0.0436505, -0.117569, 0.113962, 0.0037583, 0.0863448, 0.0389763, -0.110945, -0.00556126, 0.0887889, 0.0116291, -0.173025, 0.00309758, -0.0254314, 0.19778, -0.103993, -0.00770905, 0.0520641, 0.0518232, 0.14193, -0.0529933, -0.114306, 0.243773, 0.0134534, -0.13454, 0.111411, 0.00563397, 0.255686, -0.00610499, 0.0486981, 0.0412893, 0.0317419, -0.177677, 0.242851, 0.185172, -0.170406, 0.0531101, -0.0915159, -0.20437, -0.0513013, 0.105213, 0.137917, 0.00853831, -0.110343, -0.00926666, 0.15385, 0.105197, 0.179168, 0.0165245, -0.11869, -0.126879, 0.0123564, -0.0309906, 0.100847, -0.190677, 0.252184, 0.0574611, -0.0879441, -0.0983899, -0.00318549, 0.0487236, -0.0749757, 0.0275774, 0.0873552, 0.0267292, -0.0633608, -0.0435143, 0.0126048, 0.0700412, 0.318575, -0.0217064, 0.15708, -0.0645394, -0.0422823, 0.146177, 0.0557916, 0.0755574, -0.0643768, -0.077025, -0.00122175, 0.0281641, -0.00541661, 0.0927989, 0.027671, -0.190268, -0.00490927, -0.0341603, -0.0373209, 0.0357815, -0.160614, 0.0963296, 0.03671, 0.168934, 0.00483323, 0.132673, -0.0196009, 0.107491, 0.0383384, 0.17936, -0.0925687, -0.316035, -0.113083, -0.504205, 0.0371819, 0.369303, -0.150053, -0.130131, 0.275814, 0.0172666, 0.181962, 0.121958, 0.136845, -0.626226, 0.284002, -0.0251899, 0.0568471, 0.0765812, 0.0262849, 0.474268, 0.319451, 0.069361, -0.39697, -0.0208846, 0.276164, 0.234869, 0.0792926, 0.205113, 0.141525, -0.080992, 0.139076, -0.00791732, 0.112209, -0.0597345, -0.000435038, -0.178805, 0.456828, -0.126883, 0.31466, -0.482958, 0.0269587, 0.148671, -0.0750621, -0.0451045, -0.227241, -1.23433, -0.0124284, -0.297223, -0.202369, -0.443926, 0.23671, 0.164495, 0.474629, -0.428129, 0.0592223, 0.215419, -0.214091, -0.125087, 0.0562464, 0.187661, -0.0227058, 0.160295, 0.218651, 0.0526475, -0.308313, -0.643697, -0.0450336, -0.391119, 0.0733667, 0.261148, -0.0592682, -0.196503, 0.447848, 0.209606, -0.582024, -0.111866, -0.192462, -0.252218, 0.0454584, 0.698784, -0.38065, -0.193296, 0.171663, -0.0823217, 0.0848999, 0.275949, -0.249707, -0.0934999, -0.481919, -0.0782228, 0.00969401, -0.15561, 0.192178, -0.0550206, 0.0888409, 0.102892, 0.159747, 0.0290457, -0.0525865, -0.0190244, -0.220261, -0.0858741, -0.155183, -0.729068, -0.0411141, 0.193639, 0.00618291, 0.00383848, 0.0880445, 0.111262, 0.444026, 0.00710108, 0.204816, -0.3711, 0.228552, 0.0506328, -0.10593, 0.157756, -0.078207, 0.348949, 0.291976, 0.0881419, 0.0242584, -0.426693, 0.121902, 0.100618, -0.0245362, 0.0281911, 0.187542, -0.0328126, -0.154745, 0.0496397, 0.1882, -0.247709, 0.0742853, 0.153782, -0.12291, 0.0202414, 0.196379, -0.426986, -0.0340325, 0.279865, 0.0443546, 0.022447, -0.204583, -1.11515, -0.0428406, 0.0195449, 0.0576801, -0.438367, 0.358284, 0.217283, 0.300943, 0.0601738, -0.0817778, 0.124012, -0.172084, -0.119366, 0.231511, 0.163006, 0.0269343, 0.112929, 0.0458643, -0.113699, -0.155703, -0.237678, 0.0661106, -0.328903, -0.197735, 0.34129, 0.176442, -0.205016, 0.00981658, 0.0914852, -0.603354, 0.0474704, 0.0425557, -0.0244808, 0.0317086, 0.298102, -0.576902, -0.288521, -0.141751, -0.0142218, 0.192413, 0.284791, -0.121428, -0.0978219, -0.446898, -0.103331, 0.0980413, -0.144006, 0.209575, 0.0261356, 0.0221322, 0.114308, 0.0218913, -0.138801, 0.0763199, -0.0371897, 0.0875823, -0.143354, -0.355969, -0.531603, -0.00766149, 0.256021, -0.086776, -0.280844, -0.107563, -0.0204844, 0.381555, 0.090141, 0.0997491, -0.428074, 0.206449, -0.200715, -0.0335111, -0.145554, -0.0664254, 0.504367, 0.573514, -0.00591666, 0.0661665, -0.425195, 0.29041, -0.191071, 0.0870074, -0.00871458, -0.0718195, 0.0354209, -0.000847749, 0.0621982, 0.254533, 0.0509816, -0.0224427, 0.191257, -0.123156, 0.276803, 0.0498967, 0.126522, 0.0186068, 0.156298, 0.0146927, 0.0319949, -0.267902, -1.13234, 0.210474, -0.154068, -0.135519, -0.331532, 0.345099, 0.139213, 0.247897, 0.117251, 0.0620684, 0.121303, -0.163534, 0.00285366, 0.331072, 0.157545, -0.0772951, -0.050471, 0.00823999, 0.0113291, 0.0152603, -0.108158, 0.107834, -0.139168, -0.10757, -0.0168018, -0.0617371}, {-0.0950404, 0.126134, 0.127527, -0.181885, 0.121184, -0.177723, 0.0226325, -0.235439, 0.316594, -0.180701, -0.37613, -0.212085, -0.0675553, 0.430078, 0.220084, -0.141345, -0.00669867, -0.392287, 0.00154248, 0.294685, -0.169181, 0.310095, -0.0119369, 0.112429, -0.148898, 0.0784634, -0.0798688, 0.178744, -0.00554646, 0.168843, -0.0497573, -0.176232, -0.316085, 0.0787189, 0.114786, 0.141804, -0.0505409, -0.0587801, -0.0764822, 0.0524986, 0.272636, -0.0650728, -0.230982, 0.41365, -0.0184202, -0.00977706, 0.00194932, -0.00422911, 0.406838, 0.565644, 0.0516623, 0.187666, -0.176108, 0.276025, -0.00699144, -0.0033469, -0.0369856, -0.00698879, 0.014019, -0.013497, 0.0355315, 0.267941, 0.035841, -0.0719945, 0.149236, -0.0148469, 0.239033, -0.0503646, 0.295201, 0.0794482, -0.129105, -0.0313669, 0.158035, -0.390376, -0.865969, -0.175109, -0.174014, -0.250736, -0.219325, 0.243431, 0.0185289, 0.104402, 0.0993127, 0.125895, -0.292551, -0.086826, -0.160893, 0.230763, 0.359785, 0.0649435, 0.201782, -0.00157055, 0.0843762, -0.117248, -0.0452795, -0.277015, 0.0425119, -0.216345, 0.112444, 0.051192, 0.144339, 0.0798691, 0.341722, -0.32628, 0.269929, -0.138051, 0.11574, -0.24503, 0.360328, -0.479377, -0.293739, 0.172823, -0.307747, 0.302889, 0.203004, -0.18314, -0.107055, -0.227943, -0.0170366, 0.0518226, -0.0960243, 0.251959, 0.0896538, -0.140631, 0.0122933, 0.00308818, -0.150597, 0.228908, 0.0865887, 0.460314, 0.164338, -0.0167616, -0.136622, -0.077554, 0.137101, 0.297217, 0.0545921, -0.150714, 0.116329, 0.0335935, 0.218095, 0.0608174, -0.341924, 0.303415, -0.242061, -0.0596974, 0.256769, -0.0862801, 0.229473, 0.416696, 0.0736076, 0.0932537, -0.191965, 0.170744, 0.07913, 0.0263013, -0.212999, -0.103138, 0.0226906, 0.0162384, -0.0567953, 0.317739, -0.0866445, 0.0867686, 0.275274, -0.268961, 0.299482, 0.0142019, 0.0389984, 0.193096, -0.0163444, 0.00122739, 0.197734, -0.137915, -0.667429, -0.23646, -0.299123, -0.145568, -0.303401, 0.00489044, 0.0146228, 0.00807239, -0.0583806, 0.10158, -0.14019, -0.133176, -0.14261, 0.129901, 0.432664, 0.00983529, -0.0383404, -0.0862603, 0.0469718, -0.154819, 0.159757, -0.208626, 0.183422, -0.0468752, 0.303765, -0.00453191, 0.106597, -0.163637, 0.237917, -0.531383, 0.238341, 0.127422, 0.270952, -0.274367, 0.131075, -0.633646, -0.31614, 0.202209, -0.0466138, 0.331763, 0.152781, -0.135445, -0.190727, -0.0624177, 0.0595724, -0.0442407, 0.164702, 0.455575, 0.0340667, -0.266365, -0.036732, -0.0736918, -0.0872629, 0.35949, 0.0823265, 0.221037, 0.122928, 0.14611, 0.223183, -0.118695, 0.12324, 0.421978, -0.117487, -0.168707, -0.0158014, 0.12133, 0.0553078, 0.00290092, -0.42699, 0.0246609, -0.201666, 0.0718778, -0.0536398, 0.0488882, 0.309532, 0.0714042, 0.155632, -0.0045503, 0.0310095, 0.278463, 0.1767, -0.186369, 0.0146147, 0.0349734, -0.0414112, 0.0269855, -0.00353384, 0.232004, -0.220932, 0.035287, 0.180611, -0.0764173, 0.0866895, -0.195279, -0.062341, 0.264978, 0.0705757, -0.157264, 0.488519, 0.17025, -0.796598, -0.0662176, -0.395412, -0.125381, -0.526269, -0.239178, 0.0666343, -0.0595685, 0.0317997, 0.337572, -0.319138, 0.00770281, -0.268795, -8.15926e-05, 0.455055, -0.0130392, -0.156439, 0.14759, 0.0723117, -0.176166, 0.15157, -0.366799, 0.260771, -0.208768, 0.235455, -0.231519, 0.107921, -0.140957, 0.230084, -0.452198, 0.235144, 0.289965, 0.162, -0.345092, -0.199445, -0.530854, -0.183674, 0.125516, -0.0410144, 0.185981, 0.0556326, 0.0477961, -0.0737129, -0.315481, -0.133801, 0.027296, 0.061506, 0.394405, 0.0494549, 0.178575, -0.0329401, -0.194742, 0.0749173, 0.394529, -0.0323948, 0.0627524, 0.0821222, 0.169881, 0.27806, 0.165093, 0.0962543, 0.523604, -0.219872, -0.139977, -0.0188231, 0.101734, 0.0986565, -0.0264262, -0.391152, -0.0421694, -0.153868, -0.118452, -0.212073, -0.0203003, 0.060774, -0.461309, 0.130788, 0.0431829, -0.169058, 0.0471406, 0.119436, -0.0446648, 0.0124423, -0.265212, 0.0228362, 0.0585251, -0.0921109, 0.281643, -0.108817, -0.0207184, 0.119648, -0.297488, 0.0423472, -0.213088, -0.0353204, 0.192623, 0.0370996, -0.0924802, 0.425999, 0.157217, -0.381874, 0.0428259, -0.150426, -0.0963596, -0.306694, -0.355902, 0.0995589, 0.077119, 0.00811345, 0.427741, -0.00537762, -0.0855621, -0.124799, -0.0131329, 0.475533, -0.0869165, -0.162396, 0.169012, -0.273085, -0.0171244, 0.0340849, -0.2229, 0.186412, -0.278793, 0.343809, -0.280071, 0.0314347, -0.159262, 0.231083, -0.222538, 0.220673, 0.0263625, 0.41254, -0.548908, 0.118593, -0.470461, -0.131455, 0.0907448, 0.00776394, 0.0903811, 0.0740341, 0.0562559, -0.140812, -0.0699085, -0.155313, 0.0160085, 0.0524729, 0.415347, 0.0423318, -0.0228151, -0.0372144, -0.275014, -0.0810238, 0.234398, -0.0646139, 0.0257616, 0.0691493, 0.281784, 0.0698997, 0.140687, 0.135974, 0.428832, -0.274534, -0.307197, -0.133555, 0.0731877, 0.0928406, -0.0962493, -0.479205, -0.0326138, -0.185397, 0.0521307, -0.0673012, 0.000844311, 0.0169644, -0.683716, 0.0355262, 0.0447224, -0.269392, 0.0481026, 0.0776958, 0.05345, 0.136994, -0.113838, 0.023542, 0.211274, -0.0774637, 0.308765, -0.0695689, 0.0129659, 0.129322, 0.0774665, -0.304179, -0.26281, -0.0585938, 0.0021061, 0.227526, 0.0580936, 0.413328, 0.204537, -0.121612, -0.154815, -0.00168764, 0.0467504, 0.0160625, -0.238529, 0.0847801, 0.0811111, 0.085835, 0.556953, -0.144971, 0.00185424, 0.0634342, 0.147242, 0.444005, -0.0771213, -0.07384, 0.176165, -0.142237, -0.102807, 0.292798, -0.153127, 0.0792507, -0.242261, 0.264429, -0.219824, 0.105132, -0.081774, 0.376428, -0.268954, 0.214894, 0.135516, 0.234294, -0.442096, 0.017513, -0.597195, -0.231122, -0.127942, 0.0373044, -0.0287532, -0.137977, 0.0235221, 0.0360772, -0.0487997, -0.126626, 0.114503, -0.00472394, 0.171103, 0.207376, -0.0979161, -0.0511685, -0.157563, -0.0299579, 0.11892, -0.11849, 0.120032, -0.137088, 0.135362, 0.259588, 0.098154, 0.0234626, 0.345462, -0.180046, -0.170262, 0.214364, 0.228964, 0.00555969, -0.136337, -0.389216, -0.00660186, -0.0478523, -0.0129213, -0.0788501, 0.0255274, -0.0676675, -0.510205, -0.0204439, -0.18732, -0.183304, -0.13493, 0.03329, -0.105376, 0.128678, -0.12497, 0.0308464, 0.0899093, 0.0194073, 0.343078, -0.122541, -0.150787, 0.24161, -0.0500948, -0.603731, -0.255593, -0.0842732, -0.108702, 0.148387, 0.106139, 0.54758, -0.0485654, 0.120943, -0.204471, -0.228234, 0.109296, 0.256564, -0.149894, -0.201553, 0.0217396, 0.0940517, 0.33833, -0.221367, -0.0609717, 0.230666, 0.159689, 0.497744, -0.0077148, -0.0342352, -0.0233379, -0.390779, -0.034673, 0.294765, -0.1278, -0.266448, -0.317373, 0.39005, -0.238691, 0.302343, 0.25157, 0.331361, -0.222422, 0.014761, 0.0242787, -0.0910793, -0.65609, -0.113196, -0.505286, -0.205403, -0.132851, 0.267388, -0.135642, -0.199307, -0.0582752, -0.140985, -0.295935, -0.0751105, -0.0623948, 0.0746082, 0.1412, 0.121863, -0.0103501, 0.0934801, -0.116556, -0.104722, 0.196623, 0.0238827, 0.103426, -0.326638, 0.12133, 0.125441, 0.235287, 0.000609111, 0.527411, -0.0637199, -0.190327, 0.0344628, 0.329241, 0.0585358, 0.0907008, -0.0940819, 0.0996372, -0.1563, -0.00709438, -0.021369, 0.0297092, -0.276342, -0.296211, -0.0113647, -0.2809, -0.0226318, -0.0726905, 0.0301277, -0.143084, 0.18164, -0.000143459, -0.0925372, 0.0901483, -0.0319612, 0.314511, -0.100604, -0.116967, -0.0163682, 0.0382622, -0.396727, -0.240635, -0.0174807, -0.205994, -0.0317948, 0.133038, 0.356464, 0.136993, 0.147916, -0.059593, -0.0596526, 0.026738, 0.313149, 0.0223538, 0.188905, 0.200925, -0.178111, -0.190909, 0.0864177, -0.188885, 0.000442122, -0.0238351, 0.343688, -0.0880923, -0.00787728, 0.0233319, -0.350457, -0.0502534, 0.43953, -0.228775, -0.389846, -0.022801, 0.411501, 0.00832334, 0.481752, 0.296611, 0.479416, -0.254936, -0.218339, -0.057918, -0.351797, -0.640881, -0.307276, -0.638643, -0.0648247, -0.111452, 0.169608, -0.0156885, -0.259821, -0.0545056, -0.342289, -0.470983, -0.0385368, -0.00292452, -0.0299456, -0.256356, 0.347884, -0.00600626, -0.311961, 0.0771402, -0.174167, 0.139689, 0.00790411, 0.17944, -0.0435667, -0.0376352, -0.0897613, 0.460257, -0.079012, 0.327571, 0.00188064, -0.362788, 0.0626865, 0.408771, -0.177138, 0.0305588, 0.0587564, 0.0252892, -0.214348, -0.0415935, -0.116597, -0.0607156, -0.125325, 0.00503847, 0.0920175, -0.22336, -0.00164888, 0.142562, -0.113057, -0.0210365, -0.0688352, 0.089074, 0.0399128, -0.161002, -0.0834381, 0.255268, -0.207274, 0.0859248, -0.102527, -0.0436987, -0.325024, -0.190343, 0.132937, -0.150113, -0.143969, 0.0896477, -0.0701932, 0.122452, 0.164886, 0.189958, 0.0857168, 0.109438, 0.19987, 0.0832197, 0.223246, 0.202677, -0.183413, -0.924426}, {0.0135304, -0.28544, -0.13839, 0.116192, 0.236812, -0.064376, -0.0603157, -0.00705863, -0.151377, -0.274161, 0.373371, -0.355332, -0.031144, -0.0670114, 0.293211, 0.324635, 0.338658, -0.0325117, 0.0611762, -0.409444, -0.144799, 0.0517689, -0.233386, -0.290873, -0.137831, -0.660872, -0.035244, -0.00189328, 0.30362, -0.060477, -0.241108, -0.0165443, -0.644118, -0.902542, -0.0777974, 0.0331202, -0.00720059, -0.655963, 0.187638, -0.0493411, -0.368579, -0.114093, -0.0305066, -0.00808313, -0.00852196, 0.337958, 0.23661, -0.512828, 0.0138958, 0.702375, -0.114606, 0.0848948, -0.226814, -0.322419, 0.0395989, 0.316431, 0.00901299, 0.13615, 0.127579, 0.0672302, -0.199782, -0.128198, -0.000901942, -0.0903787, 0.16735, 0.200874, -0.00640963, -0.200735, -0.00856302, 0.08905, -0.0947071, 0.0594446, -0.0203287, 0.261021, -0.0368233, -0.236803, 0.0426698, 0.308998, -0.284523, -0.0358263, -0.157229, 0.0344104, -0.254343, -0.519556, 0.227955, -0.202833, -0.459885, 0.10211, -0.494431, 0.173265, -0.0176339, 0.0565918, 0.0015593, -0.228672, 0.305763, 0.0114627, 0.119745, 0.0890535, -0.275149, -0.801168, -0.344298, -0.0791274, -0.0652894, -0.0659145, 0.175417, -0.0389368, -0.0359291, -0.00939228, 0.0658447, -0.032661, 0.16836, -0.00397373, 0.195974, -0.106904, 0.2377, 0.0948492, -0.491104, -0.150189, -0.0376999, -0.208579, 0.0217218, 0.130892, -0.216989, -0.192287, -0.0840254, -0.407897, -0.0801651, -0.106143, 0.0958073, -0.110262, -0.253682, -0.128827, -0.517183, -1.45482, -0.00369776, 0.338911, 0.0532084, -0.830843, 0.345305, 0.0934153, -0.568332, 0.204762, 0.10663, -0.160262, 0.082079, 0.204425, 0.0461627, -0.334449, -0.218173, 0.51429, 0.134714, 0.0978643, -0.153533, -0.426908, -0.140593, 0.187854, 0.0234735, 0.137935, 0.375525, 0.240187, 0.0403056, -0.0108309, -0.0235843, -0.00506761, -0.0114832, 0.317288, -0.149433, -0.0328931, 0.0587224, -0.120132, -0.0999909, -0.09658, 0.18301, 0.266299, -0.319875, -0.320261, -0.0889347, 0.104702, -0.317219, -0.0767331, -0.225353, -0.194783, 0.00832647, -0.857357, 0.147099, 0.0465066, -0.365097, -0.076218, -0.609023, 0.148685, 0.177543, -0.069149, -0.269705, 0.116838, 0.0156504, 0.059285, 0.0886608, 0.104343, 0.000530204, -0.238836, -0.222166, -0.0301814, 0.0368943, 0.0815158, 0.137359, 0.0277633, 0.129611, -0.0829891, 0.248064, 0.243307, -0.0860085, 0.491048, 0.190951, -0.204193, 0.333034, -0.160851, -1.30543, -0.176491, -0.334489, 0.043124, -0.256882, 0.0095359, 0.0322534, -0.112501, -0.277728, -0.240325, -0.00751204, -0.196596, 0.0533742, 0.0916789, -0.43538, -0.157449, -0.221832, -0.660559, -0.0113529, 0.320267, 0.00461156, -0.569401, 0.4132, 0.182739, -0.78578, 0.269292, 0.327239, 0.113034, 0.304439, 0.388569, -0.0442363, -0.453698, -0.229822, -0.0300051, 0.381322, 0.0259289, -0.285617, -0.407128, -0.155397, 0.121766, 0.138068, 0.141539, 0.315219, 0.236584, -0.0152305, -0.172591, -0.0911746, -0.0379355, 0.0055896, 0.224086, -0.135548, -0.0559488, 0.0509767, 0.115022, 0.129084, -0.03852, 0.133512, 0.274836, -0.0241874, -0.202702, -0.026902, -0.201081, -0.286026, -0.310475, -0.112941, -0.18862, -0.0685032, -0.746687, 0.0704913, 0.0736235, 0.00995766, -0.0656237, -0.484377, 0.162824, -0.175184, -0.0477987, -0.549127, 0.00812745, 0.00207023, -0.0109993, 0.156675, 0.0892076, -0.0635562, 0.461398, -0.154769, 0.241, -0.088184, 0.228866, 0.397585, -0.0687116, 0.284225, 0.104337, 0.416466, 0.0889431, -0.250119, 0.641838, 0.138297, -0.117281, 0.275384, -0.179454, -0.965951, -0.0176307, -0.790377, 0.348354, -0.0260806, 0.211697, 0.244486, 0.0612749, -0.225389, -0.109898, 0.230657, -0.162096, 0.0291302, 0.0528224, -0.314312, 0.0998497, -0.238401, -0.0388091, 0.266193, 0.292299, 0.0316422, -0.408532, 0.22458, 0.00611873, -0.510075, 0.324716, 0.0812997, 0.108823, 0.374623, 0.542559, 0.153336, -0.431547, -0.0205351, -0.440171, 0.264233, -0.176551, -0.156991, -0.340116, -0.227933, 0.0138657, 0.264259, -0.0117084, 0.180163, 0.235954, -0.0353709, -0.157563, -0.118446, -0.0500058, 0.0535875, -0.0213241, -0.00915019, -0.242776, 0.146845, 0.040104, 0.272903, 0.103446, -0.0148354, 0.128712, 0.382172, -0.140572, -0.0210075, -0.162435, -0.0891723, -0.0510442, 0.324251, 0.158772, -0.0633613, -0.772623, -0.0407115, 0.00755208, 0.154955, 0.178282, -0.233814, 0.0877458, -0.40864, -0.0890205, -0.327491, 0.148866, -0.148008, -0.0147299, 0.129703, -0.0788279, 0.171246, 0.302407, -0.459126, 0.671682, -0.0239205, 0.0835601, 0.177106, 0.056296, 0.355931, 0.0541756, 0.394553, 0.14005, -0.441846, 0.311948, -0.063628, 0.0322748, 0.477928, -0.235982, -0.0551354, -0.0197477, -0.309831, 0.246964, -0.0288562, 0.269757, -0.111581, 0.023192, -0.206219, -0.137398, 0.293111, 0.0881044, 0.111268, 0.0325661, -0.19314, -0.0687169, 0.0266895, 0.132346, 0.548101, 0.209517, 0.143429, -0.311906, 0.121327, -0.0517588, -0.28787, 0.182991, -0.0422335, -0.046346, 0.451411, 0.407775, 0.14702, -0.0900927, 0.215662, -0.373748, 0.155749, -0.0651068, -0.2861, -0.456851, -0.0284435, -0.0668171, 0.259491, 0.0449437, 0.336904, 0.0613576, -0.272359, -0.238299, -0.185961, -0.0839568, 0.0169446, -0.0582082, -0.0321444, -0.251043, 0.161862, 0.182612, 0.232478, 0.272363, 0.0519756, -0.0852499, 0.482905, -0.224168, -0.034506, -0.278078, 0.213675, -0.257257, 0.147656, 0.137209, -0.10122, -1.10142, -0.104614, -0.232374, 0.168688, 0.211852, -0.336107, 0.205372, -0.153024, -0.0265104, -0.501452, 0.140357, -0.0614014, 0.0125829, -0.0283836, -0.20119, 0.324977, -0.0423359, -0.320918, 0.825955, -0.00138964, 0.0456561, 0.205192, -0.00426599, 0.139397, 0.0563681, 0.398469, -0.0692406, -0.114997, 0.222583, -0.00765501, -0.0516495, 0.24422, -0.0955392, 0.217175, -0.109629, -0.389832, -0.0789357, 0.206466, -0.078518, -0.234517, -0.201317, -0.0600351, 0.0869276, 0.0900106, 0.140025, -0.143598, 0.0869611, -0.15917, 0.0490118, -0.0348859, 0.0602455, 0.445615, 0.0437422, -0.0816682, -0.0974229, -0.236796, -0.158454, -0.136735, -0.0309757, -0.106858, -0.172129, 0.24653, 0.404689, 0.116296, 0.0036402, 0.1833, -0.405652, 0.130657, 0.111556, -0.109915, -0.431858, -0.136869, -0.143475, 0.247299, -0.107221, 0.222346, -0.0514494, -0.133858, -0.0605282, -0.198418, -0.0919509, -0.0765727, -0.123082, 0.00593169, -0.0355052, 0.379482, 0.131856, 0.436035, 0.296877, 0.106773, 0.0890813, 0.447135, -0.101246, -0.0252786, -0.130688, 0.217864, -0.189311, 0.106032, -0.0268792, 0.129185, -0.950443, 0.0545237, -0.132908, 0.120334, 0.308804, -0.32347, 0.120806, -0.206241, -0.115792, -0.535964, 0.0211744, 0.0836761, -0.0665251, 0.171099, 0.0210218, 0.287595, -0.0928161, -0.189203, 0.483106, -0.0285292, -0.133013, 0.214147, 0.0104488, 0.0520191, 0.0847026, 0.395698, -0.242097, -0.0464788, 0.280227, -0.0272221, -0.140711, 0.353493, 0.0914016, 0.398692, -0.350586, -0.403856, -0.0627961, 0.156891, -0.316061, -0.249289, -0.217921, 0.0190847, -0.141113, -0.107266, 0.252913, -0.205599, 0.107758, -0.124417, -0.0456366, -0.1028, -0.0777598, 0.592445, -0.278838, 0.00687032, -0.116677, -0.677565, -0.0135177, -0.0663322, -0.618973, -0.116652, -0.229579, 0.197954, 0.235783, 0.446082, 0.166991, 0.355124, -0.723392, 0.170283, -0.0206838, -0.126384, -0.38578, -0.130292, -0.150596, 0.120539, -0.0290105, 0.201701, -0.0172127, -0.00244183, 0.0383703, 0.10037, 0.000964414, -0.250526, -0.187061, -0.0371024, -0.244115, 0.319206, 0.213908, 0.353584, 0.243965, -0.0133708, -0.0503338, 0.487103, -0.0313945, -0.0227414, -0.110385, 0.210416, 0.0484261, -0.265593, -0.171355, 0.0295072, -0.768868, 0.208088, -0.159941, 0.338351, 0.160823, -0.28753, -0.00564214, -0.148686, -0.0513911, -0.264631, -0.0501488, 0.172734, -0.257635, 0.0974284, -0.0588989, 0.166344, -0.0489412, 0.0597032, 0.431516, -0.0138772, 0.0603193, 0.22102, -0.0381095, -0.120829, -0.0670817, 0.282319, -0.37549, -0.100598, 0.147849, -0.0233144, -0.00817436, 0.269992, -0.0703672, 0.214054, -0.205854, -0.899363, -0.105265, -0.106983, -0.302937, 0.108696, -0.101101, 0.138987, -0.0221807, -0.139975, 0.350286, -0.0129588, 0.0236174, -0.20219, -0.0568651, -0.0756288, 0.119856, 0.449318, -0.296031, 0.0668425, -0.227418, -0.970408, -0.0442971, -0.0614331, -0.845923, 0.0498964, -0.146989, 0.0861558, -0.00783946, 0.556457, 0.0647353, 0.244157, -0.132222, 0.202587, -0.131947, -0.00288452, -0.341511, -0.250123, -0.119713, 0.0146757, 0.00822055, 0.128809, 0.144597, 0.0992997, -0.043869, 0.215465, 5.32583e-05, -0.32416, -0.388313, -0.0708496, -0.000787507, 0.420656, 0.305326, 0.337282, 0.337298, -0.237359, -0.0972504, 0.521713, -0.0360763, -0.0412576, -0.0659748, 0.220752, 0.495783, -0.21435, -0.0248276, -0.081488, -1.14949}, {0.127724, 0.0136463, 0.355326, 0.17015, -0.427619, 0.15492, -0.1523, -0.265541, -0.146347, 0.0281723, 0.0174425, -0.318414, 0.378424, -0.256108, 0.0660319, 0.105068, -0.240976, 0.46808, -0.0826548, -0.218495, 0.163532, -0.0720109, 0.0528238, 0.23935, 0.190229, -0.786045, -0.375466, 0.0928639, 0.0064937, 0.0559111, 0.147552, 0.00268267, 0.349842, -0.0715999, -0.778947, -0.420616, -0.0395723, 0.020215, 0.071746, -0.319077, 0.622907, 0.123996, 0.0843572, 0.175808, 0.0832399, -0.0840615, 0.163688, -0.0427443, -0.0229034, -0.0604931, 0.528925, -0.69847, -0.0907361, -0.462597, -1.10821, -0.0694225, 0.0579453, -0.822638, -0.0567915, -0.186671, 0.0148056, 0.475206, 0.254454, 0.205541, 0.22317, -0.0889597, -0.172374, -0.138251, 0.282141, -0.311488, -0.0262861, 0.0709417, -0.0114856, 0.458998, 0.324116, 0.177761, -0.0280065, 0.11006, 0.139199, -0.0446152, -0.274392, -0.333857, -0.148058, -0.0557762, 0.38335, 0.202393, 0.110518, 0.448633, -0.249345, -0.113008, 0.415625, 0.0944688, -0.0383345, 0.0629821, 0.11238, 0.777038, -0.560178, -0.00509774, -0.296132, -0.875684, 0.373794, -0.222888, 0.0427561, 0.0681835, -0.642383, 0.244186, 0.0332063, -0.225926, 0.107985, 0.0607357, 0.0475513, -0.359197, 0.352082, -0.170845, -0.306594, 0.00535233, -0.200817, 0.353692, -0.253159, -0.0833023, 0.101255, 0.0380487, 0.200209, 0.344173, 0.131032, -1.15895, -0.149621, -0.31768, -0.114255, -0.0284721, 0.154679, -0.266218, -0.0513444, 0.282063, -0.631662, -0.563748, -0.673465, -0.106777, 0.00884898, -0.214233, 0.643438, 0.269151, 0.159793, 0.0916501, -0.0344785, -0.129459, 0.0915067, 0.260841, 0.121996, 0.10065, 0.869857, -0.420684, 0.185629, -0.482614, -1.1077, 0.478312, 0.095048, -0.825716, 0.180066, 0.0505992, -0.0729469, 0.0113001, -0.015973, -0.172534, -0.148243, 0.00382869, 0.00997901, -0.0762489, -0.0259252, 0.20854, 0.144069, -0.188524, 0.0849325, -0.174575, 0.167999, -0.0949172, 0.0682615, 0.0284209, -0.197228, -0.009413, 0.0129951, -0.0160342, -0.0270938, 0.100623, 0.197621, -0.175745, 0.153464, -0.0213857, -0.0348523, -0.000119056, 0.0893341, -0.0383629, -0.0214646, 0.0753105, 0.0855627, -0.17904, -0.0696678, -0.0229541, 0.0801811, 0.000854018, -0.16961, 0.164711, 0.115502, 0.0152874, 0.0585973, 0.156403, 0.13666, 0.161139, -0.00401039, 0.117194, 0.027982, 0.0483425, -0.179791, 0.175687, -0.0553599, -0.0585599, 0.0465979, 0.136178, -0.0434608, -0.134014, 0.0245163, -0.071137, 0.104686, 0.019988, 0.0243775, 0.0161336, 0.0746061, 0.0346176, 0.0343644, -0.108339, 0.0442007, -0.0573477, -0.0141381, 0.00940914, 0.0630189, 0.16297, -0.0690039, 0.0178145, 0.0624953, -0.051214, 0.0412551, 0.0777486, 0.118225, -0.00939878, -0.0106681, 0.0787073, -0.0973943, -0.0294392, -0.10936, -0.078257, 0.0332043, -0.0508949, 0.0440311, 0.0123039, -0.0320551, 0.00571728, -0.0804806, 0.0658818, 0.0483594, -0.0653698, 0.00205167, -0.00118461, 0.0767643, 0.0618031, -0.0302736, 0.0113741, -0.0453445, -0.0240577, 0.0485638, -0.0122903, -0.0358145, 0.0407368, 0.0750504, 0.0688246, -0.00168927, -0.0357259, 0.0724297, 0.0568692, 0.0531866, -0.0106718, -0.0199342, 0.0343914, -0.0393672, 0.0263179, -0.0753082, -0.0659508, -0.0058392, -0.0779044, -0.045496, -0.0536766, 0.00259451, 0.0572287, 0.0128755, -0.0744576, 0.0607376, 0.0394537, 0.0803325, 0.0517215, 0.0354471, 0.0574279, -0.0477259, 0.040998, 0.0797683, -0.0813619, -0.0521853, -0.0171655, -0.0316603, -0.0477315, 0.0845134, -0.00542254, 0.0603565, -0.0763549, -0.00016047, -0.0732748, 0.0419474, -0.0248073, 0.0716873, 0.0831531, -0.0605629, -0.00307485, 0.0155124, -0.0441337, -0.0416827, -0.0226807, -0.0339879, 0.0776342, -0.0626146, 0.0275062, -0.0262521, 0.0273048, 0.00774301, 0.00991382, 0.0728699, 0.00192043, 0.019032, 0.0140192, 0.0271839, -0.066489, 0.000821064, -0.0221043, -0.0158762, 0.0627382, 0.0341421, 0.00230126, -0.0134056, 0.0805125, 0.0515264, -0.0242586, 0.041541, -0.0659694, 0.0574432, -0.074913, 0.0397168, -0.0231704, 0.0505353, 0.0411397, -0.00572882, 0.0239547, 0.075807, -0.0515367, -0.01518, -0.0590213, -0.0751191, -0.0204762, 0.0248082, 0.040453, 0.0672754, 0.015309, -0.0084086, 0.0235898, 0.0243463, 0.0283693, -0.00986554, 0.0308384, -0.0717739, -0.0675285, 0.0122711, 0.0020023, -0.0797615, 0.0419719, -0.0523628, 0.0262275, 0.0547282, 0.0515981, -0.0047648, 0.0178908, 0.00677923, 0.0452968, 0.00718573, 0.0507764, -0.0094152, 0.00860668, -0.0434244, 0.033899, -0.0209725, 0.0286065, -0.00219199, 0.062956, -0.0477983, -0.0646815, 0.0187704, -0.0330185, 0.0283413, 0.0467524, 0.0211586, 0.0657026, 0.051632, 0.0494616, 0.0800999, -0.0230713, 0.0546856, -0.00411687, -0.0154148, 0.0108123, 0.0317238, 0.0619227, -0.0208053, 0.0661355, -0.0492799, -0.0559216, 0.0459493, 0.0661352, -0.0629361, 0.0561426, -0.00221157, 0.00339743, -0.0266428, -0.0547659, 0.0792751, -0.0406226, 0.0583295, 0.0214044, 0.0259105, -0.00559741, 0.000281475, 0.0665888, -0.0163237, 0.0816307, 0.0653841, -0.0133205, 0.0232245, -0.0280188, -0.020648, -0.0207494, -0.0109004, -0.0713859, -0.0338356, 0.0332266, -0.00906756, -0.0394636, -0.0173405, -0.013017, -0.065453, 0.0136313, 0.0783364, 0.0556998, -0.067208, 0.0632983, 0.0524915, -0.0628275, 0.034928, 0.0680983, 0.0117588, -0.067878, 0.0412521, -0.0174345, 0.0381893, -0.0475348, 0.0513489, 0.0377647, 0.0144575, 0.0300309, 0.0425521, -0.0223362, 0.0389359, -0.0502537, -0.0471047, -0.0573156, -0.0152006, -0.0712872, 0.0513647, -0.0507337, -0.0768202, 0.0722333, -0.0401472, 0.00480858, 0.0422748, -0.0510744, 0.0683262, 0.0493302, 0.00805929, 0.0502752, 0.0298501, 0.00212988, -0.0437333, 0.0491515, 0.011979, -0.0712262, -0.0015229, -0.0242888, -0.0393626, -0.00275996, 0.0261328, -0.0631076, -0.0157786, 0.000543967, 0.0162077, -0.0222435, 0.0767167, -0.0176181, -0.0369262, 0.0155118, 0.0611273, 0.0576758, 0.0819146, 0.0741791, 0.0644314, 0.00907484, -0.0286092, -0.0784051, 0.0156287, 0.0737083, -0.055435, -0.0176659, 0.0759889, 0.0323732, -0.0685867, 0.0627403, 0.0647964, 0.0436712, -0.0112574, 0.0146627, 0.0488814, -0.0362174, -0.00413831, 0.0112206, 0.0334666, -0.0808166, 0.0650891, -0.00481, 0.0119442, 0.0560072, 0.0767604, -0.0584749, 0.0795221, 0.00354337, 0.0746724, 0.0415087, -0.0114015, -0.0727428, 0.0280401, -0.00487607, -0.0814837, -0.0737381, 0.0215662, 0.0107267, -0.000760764, 0.0126861, -0.0334533, 0.059348, 0.0557447, 0.0363871, -0.0301355, 0.0167867, 0.02479, 0.0570362, -0.0812545, 0.0774277, -0.00742903, -0.0340244, 0.00522395, 0.0784426, 0.00276041, -0.0766668, 0.016945, -0.0743086, -0.0804582, 0.00489599, -0.0744854, -0.0279319, -0.0608406, 0.0598305, 0.0329394, -0.00756216, 0.0112083, 0.0530331, 0.013256, -0.0444592, -0.0100928, -0.0655641, 0.00873486, 0.0779251, -0.00659081, 0.0306905, 0.0390327, 0.0633736, 0.0105819, 0.0609966, 0.0605436, 0.0354205, -0.0187566, -0.018549, 0.0495908, -0.0765829, 0.0401836, 0.0257054, -0.0730276, 0.045302, -0.0436388, -0.0398249, -0.0545746, 0.0334857, -0.00323534, -0.0604219, 0.021085, -0.0502086, -0.0652627, 0.00117277, -0.0144985, 0.0695951, -0.067882, 0.0314242, -0.0389927, 0.0506973, -0.0209679, -0.000787199, 0.0577671, 0.00139844, 0.0586888, -0.0628134, -0.0364124, 0.00718169, -0.0444203, 0.06749, 0.0102514, -0.0795808, -0.0374018, 0.0637448, 0.0588391, 0.0556462, -0.0428151, -0.0146687, -0.0206417, 0.00834192, 0.0147031, 0.0692223, 0.0488426, -0.0328575, 0.00310525, 0.0505697, 0.0380232, 0.0521226, -0.0761424, 0.0776565, 0.0565251, 0.0606488, -0.065745, 0.00210471, 0.0500322, -0.0103771, 0.00565785, 0.0646594, -0.00182608, -0.0159353, -0.00616116, 0.0118568, 0.0384172, -0.00362182, 0.0241007, 0.0738747, -0.0248203, 0.0151428, 0.0579281, -0.0556526, 0.0434956, 0.0786223, 0.0147319, -0.0715521, 0.0296042, 0.0677589, -0.00834366, 0.0136325, -0.0503098, -0.0738327, 0.0332312, 0.0497285, -0.0432596, 0.00069724, -0.0503562, 0.0391348, 0.0682765, 0.00734118, -0.030728, -0.0520154, 0.0463421, 0.0732539, -0.0200484, -0.0355333, -0.0690114, -0.0415162, 0.0475769, -0.0326603, 0.0113032, -0.0644519, -0.0501795, 0.0720277, -0.0172362, 0.0136896, -0.0387464, -0.0476127, -0.0762646, 0.0603811, -0.0555902, -0.0388589, -0.00415992, 0.0222623, -0.0143113, 0.062787, -0.0621359, -0.0819759, 0.0515128, 0.0381147, 0.0152804, -0.0760213, 0.0462741, -0.0131384, -0.0613608, -0.0754971, -0.0523707, 0.014594, 0.0190002, -0.0250017, -0.0446748, 0.0264715, 0.000961408, -0.0406903, 0.0236521, -0.0303447, -0.0352325, 0.0376137, -0.0217184, 0.0282613, -0.0514976, -0.035055, -0.00838116, -0.0413548, 0.0722141, 0.0809526, -0.0105976, 0.00449077, 0.0655998, 0.0151927, 0.0628138, -0.0145208, -0.00946639, 0.0241299, -0.0514966, 0.0415598, 0.0575013, -0.0762179, -0.0261838, -0.0892166, 0.0236013, 0.043201, -0.0123679, -0.0743601, -0.0677903, -0.0566698, -0.0405316, -0.126157, -0.0447398, -0.0816512, -0.0620787, -0.198642, 0.00678927, -0.0513225, 0.0814135, -0.112786, 0.073076, 0.0576558, -0.0756292, -0.0594836, -0.0741425, -0.0334208}, {0.0378525, -0.0147862, -0.114839, 0.0188022, -0.142642, 0.11556, 0.00649057, -0.0530291, 0.00186697, 0.0367129, -0.0327385, 0.0219175, 0.00307551, -0.118916, -0.0569137, -0.105437, -0.125731, -0.102993, 0.0619027, -0.00835492, 0.0398854, -0.0105282, -0.0432876, 0.156173, 0.073059, 0.0389243, -0.0877668, 0.0118653, 0.00660108, -0.0176591, 0.0260762, -0.0113871, -0.054377, 0.0985286, 0.0185767, -0.105616, -0.0693039, -0.0295409, 0.0261605, 0.0624876, 0.0647959, 0.0367391, 0.0373312, -0.0386532, -0.0505696, -0.069734, 0.12835, 0.0982226, 0.0894677, 0.106299, -0.155887, -0.0785235, 0.174466, 0.118927, 0.122792, -0.0263276, -0.107192, -0.0064806, -0.0610328, -0.0972235, 0.00925124, -0.0317089, -0.175878, -0.0408573, 0.0564897, 0.0522072, -0.0857227, -0.227046, 0.0326186, 0.0897336, 0.0051379, 0.105878, 0.0620756, -0.0671253, 0.0393528, -0.0545892, 0.0175858, -0.00645886, 0.0491305, 0.0675507, 0.0119521, -0.00164776, -0.0138249, -0.0165402, 0.0768533, -0.0565312, -0.18059, 0.0429957, 0.153733, -0.18291, -5.88255e-05, -0.10581, 0.105301, -0.0728335, 0.154625, 0.00160414, -0.0923391, 0.0353367, -0.107687, -0.0275479, 0.1884, 0.0287214, -0.168853, 0.131769, -0.0277042, 0.140221, -0.0827329, -0.029067, 0.00352192, 0.0975347, -0.103496, 0.0943405, 0.0246553, -0.0686949, -0.0169544, -0.116324, -0.118774, 0.0607369, 0.0350926, 0.113723, -0.054184, -0.0140409, 0.0781156, 0.144736, 0.0357019, -0.0467352, -0.00387442, -0.0519507, -0.0895298, -0.129093, 0.00436767, 0.117573, -0.0434601, 0.0798267, 0.11866, -0.104117, -0.155005, -0.0449124, 0.031913, 0.0190988, 0.0688573, 0.0886541, -0.0198443, -0.0284972, 0.0312194, -0.0677725, 0.12074, 0.2109, 0.0102481, 0.174256, -0.170098, -0.164998, 0.0609757, 0.109654, 0.0854956, 0.0688567, -0.0867928, -0.0958771, 0.0342098, -0.081481, -0.038597, -0.061181, -0.107654, 0.0106674, 0.0598375, -0.0115097, 0.0372013, -0.209988, 0.0954286, 0.0334467, 0.0240695, 0.067764, 0.164909, -0.0739854, 0.211271, 0.0555293, 0.240868, -0.11562, -0.116192, -0.336496, -0.499272, -0.0592058, 0.382688, -0.130496, 0.166269, -0.00170009, -0.0186875, 0.175878, 0.0699625, -0.112001, -0.262843, 0.0836879, 0.0940244, 0.0530623, -0.154487, -0.0486004, 0.491093, 0.248085, -0.0173315, 0.198877, 0.00688012, 0.342262, 0.267811, 0.0295373, 0.0604001, 0.122246, 0.127518, -0.106613, 0.0378769, 0.000637768, 0.184967, 0.0231296, -0.436082, 0.341059, -0.000969376, 0.151228, -0.348237, 0.0888536, 0.115854, -0.0726085, -0.0190561, -0.438913, -1.11487, -0.0946608, -0.144062, -0.164706, -0.870719, 0.285014, 0.116176, 0.311438, -0.352654, -0.190411, -0.0693887, -0.206463, 0.0568254, 0.0573952, -0.0923362, -0.0759837, 0.327868, 0.00419062, 0.00882164, -0.0292788, -0.447821, -0.242067, 0.00947416, 0.186274, 0.131723, 0.224804, -0.195202, 0.447203, 0.020328, -0.794266, -0.139575, -0.109129, -0.274618, 0.0197038, 0.417325, -0.815633, -0.110112, 0.117099, -0.151204, 0.31648, 0.501881, -0.222926, -0.102303, -0.452366, 0.151825, -0.08674, 0.052992, 0.0728692, -0.289312, -0.251429, -0.0622955, 0.0353727, -0.119069, 0.056327, -0.206825, 0.0348882, -0.104418, -0.251627, -0.349665, 0.173289, 0.0244333, -0.330553, 0.039041, -0.0314594, 0.0561975, 0.0596798, 0.201888, 0.0129427, -0.186597, 0.168305, -0.057634, -0.125818, -0.0142693, -0.00380704, 0.344908, 0.23546, -0.0808546, 0.160211, -0.328381, -0.0180692, 0.285745, 0.137982, -0.120703, 0.02964, -0.0573698, -0.411171, 0.00732577, 0.079875, -0.0691307, 0.0548617, -0.135718, -0.0908899, -0.0101979, 0.210571, -0.142917, -0.0845595, 0.300492, 0.0131059, 0.0716094, -0.50953, -1.30848, 0.0373449, -0.0706254, -0.120958, -0.619453, 0.282985, 0.077875, 0.141957, -0.0221834, -0.287116, 0.128339, -0.0033827, -0.220913, 0.0832064, 0.166178, 0.0391811, 0.164859, 0.160362, -0.0705269, 0.0801948, -0.128808, -0.15758, -0.107048, -0.0637916, 0.243307, 0.210218, -0.0122245, -0.00891435, -0.0169085, -0.715429, 0.307679, 0.0556587, 0.0442372, 0.0471647, 0.253624, -0.710956, -0.173267, -0.0179573, -0.0623247, 0.257002, 0.200789, -0.099933, -0.00472544, -0.408219, -0.00961688, 0.276446, -0.0204463, 0.246482, -0.109856, -0.345762, 0.13562, -0.0352, 0.0642483, 0.0242399, -0.0580241, 0.175332, -0.0680487, -0.256949, -0.163949, 0.0588064, 0.0779459, -0.134793, -0.0731587, 0.0234227, 0.0034844, 0.267829, -0.00754749, -0.0728178, -0.508402, 0.197291, 0.0420766, -0.0573671, -0.152252, -0.0269575, 0.222843, 0.56883, -0.153741, 0.0707039, -0.225594, 0.19429, -0.0816637, 0.26312, -0.259953, 0.037907, -0.0127814, -0.192471, 0.00598223, -0.0658193, 0.137248, -0.0253123, -0.029325, -0.135403, 0.2565, 0.101726, 0.25019, 0.145918, 0.0810646, 0.0468767, 0.187197, -0.344769, -1.06465, 0.17137, -0.0396844, -0.46882, -0.412133, 0.325746, -0.0953384, 0.182441, -0.0380491, -0.0324955, 0.252625, -0.0949037, -0.221416, 0.102771, 0.23989, 0.0332056, -0.0179429, 0.0441907, 0.1285, -0.0476613, 0.183791, -0.0224908, -0.0924651, 0.0942674, 0.0710558, -0.0329353, -0.0467303, 0.155122, -0.0885016, -0.260866, 0.166438, 0.0420209, 0.0524294, -0.274152, 0.344579, -0.626312, 0.0612734, -0.0573729, 0.0359494, 0.366313, 0.241387, -0.0988078, -0.123511, -0.295505, 0.0653333, 0.0330352, -0.0113786, 0.253956, -0.0699514, -0.0567319, -0.0339031, -0.0033086, 0.0367292, 0.121591, 0.04443, 0.341761, 0.00350749, -0.0989283, -0.100214, -0.194828, 0.325561, 0.108153, 0.208419, 0.0281723, 0.101091, 0.198317, -0.245593, -0.324273, -0.327485, 0.1171, 0.0397136, -0.271778, -0.0169108, -0.0368281, 0.241955, 0.688101, -0.166025, -0.165667, 0.0010151, 0.112877, -0.284804, 0.098529, 0.0507451, 0.162396, 0.0671621, -0.180517, 0.0193925, 0.0411391, 0.119217, -0.0559501, 0.391586, -0.0325303, 0.481826, -0.0933739, 0.214688, 0.115059, -0.202556, 0.0628132, 0.141658, -0.24091, -0.469704, 0.112131, 0.0235872, -0.500113, -0.214343, 0.252195, -0.149083, 0.125849, 0.0820877, 0.155946, 0.212543, 0.0293785, -0.601153, 0.0423751, 0.234657, -0.071772, -0.0241371, -0.0938035, 0.00762642, 0.102708, -0.0325009, 0.0677885, -0.137512, -0.110618, 0.255016, 0.00194843, -0.0301066, 0.0954704, -0.0807859, -0.252109, 0.150889, -0.297006, 0.127484, -0.471161, 0.133239, -1.02939, 0.0641875, -0.0388173, -0.115176, 0.508427, 0.212367, -0.172948, 0.00610016, -0.138377, -0.17791, -0.0323828, 0.0169186, 0.0534949, -0.0974499, -0.187465, 0.125483, -0.134377, -0.111979, -0.0458742, 0.110201, 0.104076, 0.171853, -0.00730607, 0.0977983, -0.072936, 0.169519, 0.0931632, 0.172024, -0.200426, -0.080514, -0.0322971, 0.00889595, -0.0673821, -0.244402, 0.060999, -0.0093423, -0.0979874, 0.118976, -0.0517671, 0.38958, 0.42383, -0.0194545, 0.017459, -0.0710164, 0.11504, 0.0717527, 0.0422797, -0.154421, 0.0352143, -0.0130798, -0.140229, 0.00937641, 0.0626891, -0.00207967, 0.048551, 0.299712, -0.239699, 0.373084, -0.114833, 0.0826054, 0.22851, -0.118938, -0.227256, 0.172277, -0.0521733, -0.50375, -0.0657737, -0.183676, -0.439373, -0.457573, 0.102957, -0.0732342, -0.215654, -0.121378, 0.311687, 0.0804684, -0.0444886, -0.285281, 0.0309433, 0.405668, -0.0570144, -0.0330562, -0.0851873, 0.0482322, 0.137278, 0.103041, -0.0355994, 0.156154, 0.0319421, 0.177895, 0.136397, 0.00808324, -0.199741, 0.118929, -0.249476, 0.184943, -0.0475664, 0.190255, -0.441339, 0.0981189, -1.07526, -0.161378, 0.0204206, -0.0292931, 0.440669, 0.113878, -0.100245, -0.109807, -0.176607, -0.104145, -0.134676, -0.0297665, 0.178607, -0.230743, -0.20135, 0.168694, -0.142787, -0.141173, 0.270637, -0.020546, 0.0641324, -0.0419744, 0.192208, 0.130521, -0.243302, 0.0263707, 0.36668, 0.0414537, -0.0743211, 0.0633646, 0.144402, -0.13133, -0.049524, -0.325618, -0.0371827, -0.0586064, -0.0544177, -0.0952363, 0.0281825, 0.1491, 0.118505, -0.0521298, 0.0105594, -0.162059, 0.0401127, 0.206102, 0.0855137, -0.119904, -0.016934, 0.0062248, -0.0249577, -0.0149811, 0.223969, -0.0066318, 0.0435022, 0.442613, -0.0808188, 0.123526, -0.10607, -0.155933, 0.260379, -0.00453011, -0.0338541, 0.301044, -0.0475976, -0.184455, 0.140159, -0.420433, -0.227139, -0.575168, -0.241432, -0.235863, -0.317424, -0.0684632, 0.302142, 0.00386122, 0.100674, -0.208276, -0.0473392, 0.486132, -0.000860769, -0.0161279, 0.161305, -0.215411, -0.0322595, 0.0910991, -0.143425, 0.319358, -0.0672105, 0.235369, -0.130923, 0.0307856, -0.187461, 0.121975, -0.0461998, 0.0577362, 0.131638, 0.21583, -0.544194, -0.0167225, -0.843198, -0.00400982, -0.0756544, 0.0902845, 0.201762, -0.0424006, -0.0197587, -0.185979, -0.0928873, -0.123752, -0.0390795, 0.0972186, 0.24256, -0.264828, -0.0268478, 0.0280532, -0.0895248, 0.0832694, 0.267973, 0.11814, 0.320776, 0.0285943, 0.336731, 0.196394, 0.0569338, 0.091885, 0.331914}, {-0.181942, -0.114127, 0.050114, 0.0775109, 0.117593, -0.154987, -0.345917, 0.115938, 0.0190627, -0.0744489, -0.0340225, -0.0132834, -0.0558942, -0.432139, 0.0932211, 0.0984728, -0.195798, 0.022786, 0.078186, 0.0365321, -0.0567999, -0.111384, -0.130772, 0.241604, -0.0356752, 0.212332, -0.063147, 0.295458, 0.404729, -0.0623346, 0.272153, -0.0620781, -0.0309993, 0.194507, -0.0886476, 0.0217463, 0.436966, 0.0728785, 0.0238308, 0.158241, -0.070204, -0.0524639, -0.206057, -0.43926, 0.0772191, -0.146526, 0.147032, 0.298199, 0.145109, -0.0376575, -0.202891, 0.0618459, 0.456712, -0.00298075, 0.0528007, 0.255437, -0.242983, -0.236198, 0.0376319, -0.267413, 0.239886, 0.052304, 0.321576, -0.322775, -0.032127, 0.0403484, 0.385624, -0.136377, -0.0112169, 0.216886, 0.337573, -0.624568, 0.0225439, -0.812655, -0.125989, -0.228741, -0.084867, 0.11268, 0.0290667, -0.0528748, -0.257806, 0.0294764, -0.217298, 0.0358034, 0.00858241, 0.0855532, 2.4379e-05, -0.0222491, 0.149974, -0.0658114, -0.0895549, 0.033801, 0.268751, 0.108527, 0.00395736, 0.366514, 0.071825, 0.154154, 0.138318, 0.345244, -0.146813, -0.0634405, -0.0206191, 0.0640847, 0.188027, -0.337006, -0.24848, 0.0132934, -0.177425, 0.0411211, -0.10938, 0.00836919, 0.00945622, -0.906908, 0.00553675, 0.202045, 0.107882, 0.0463294, 0.177573, 0.180706, 0.122264, -0.264754, -0.0736957, 0.143131, 0.0520771, 0.263022, -0.0378783, 0.0361501, 0.223949, -0.0263947, 0.0538776, -0.232507, -0.0391552, 0.310569, 0.266442, 0.00714178, 0.22948, 0.192306, 0.05274, -0.069678, -0.0190255, -0.0822519, 0.0322094, -0.26146, 0.0959198, 0.0291683, 0.101885, 0.428802, 0.232336, 0.0608411, 0.153712, 0.252096, 0.341647, 0.0107994, -0.0865206, 0.169559, -0.509401, -0.324871, 0.0588229, -0.10127, -0.079165, -0.0626466, 0.11363, -0.289138, 0.0545794, 0.106008, 0.480007, -0.136358, 0.0881373, 0.0544174, 0.142502, -0.539221, -0.233719, -0.785951, -0.080334, -0.432806, 0.00069057, -0.128633, 0.0871195, -0.157284, -0.0703882, -0.249988, -0.0480636, -0.0773095, -0.0550539, 0.109268, 0.204122, -0.0579651, -0.0287709, -0.0564285, -0.0988015, 0.271696, 0.316848, 0.0660711, 0.0365349, 0.344894, 0.101582, 0.139532, -0.0155068, 0.275749, -0.135625, -0.255727, 0.125589, 0.0946826, 0.0130847, -0.103236, -0.156023, 0.034643, -0.199699, 0.0242883, -0.144399, 0.047687, -0.098393, -0.678793, 0.0341637, -0.0672554, 0.21511, -0.0196598, 0.243928, -0.0272765, 0.110475, -0.189774, -0.136732, 0.134491, -0.00017999, 0.080612, -0.0649742, 0.0227304, -0.0107593, 0.0523874, -0.284884, -0.282197, -0.00631838, -0.122601, -0.0173746, -0.0698667, 0.150746, 0.281137, 0.282902, -0.115067, -0.267457, -0.00356901, 0.0838799, -0.0665919, 0.0966331, -0.0598175, 0.0938258, 0.445176, 0.29564, -0.0206363, 0.142749, 0.0292911, 0.373581, -0.0649341, -0.0921294, 0.145249, -0.524798, -0.217266, 0.255294, 0.0169436, -0.360964, -0.0807315, 0.0839456, -0.167746, 0.319415, 0.0371407, 0.52322, 0.0116167, 0.185004, 0.144294, 0.0241772, -0.334796, -0.11122, -0.701827, -0.110566, -0.521995, 0.037611, -0.330572, 0.00907327, -0.0614446, -0.441909, -0.360699, 0.00660348, -0.237706, 0.0685684, 0.165406, 0.109737, 0.0724935, -0.255507, -0.0241825, -0.216709, 0.212971, 0.389375, -0.115228, -0.242072, 0.491326, 0.125565, 0.3763, -0.0539177, 0.270197, 0.140648, -0.322977, 0.104855, 0.123869, -0.0248971, -0.149663, 0.0612594, -0.00745822, -0.0170101, 0.209178, 0.0891047, -0.0454958, -0.283406, -0.286544, -0.0730772, -0.232648, 0.0878468, -0.154176, -0.0544141, -0.0261989, 0.140511, -0.251096, -0.0229916, -0.132523, 0.0229904, 0.30102, -0.106032, 0.0737351, -0.156538, 0.113402, -0.445278, -0.12881, 0.149121, -0.121462, -0.344927, -0.308943, -0.114009, 0.163682, 0.251126, -0.166592, -0.292761, -0.076634, 0.102551, -0.149894, -0.025761, 0.175845, -0.00904956, -0.493767, 0.39368, -0.360612, -0.0552169, 0.0452429, 0.100911, 0.0413809, -0.125506, 0.236127, -0.83154, -0.111437, 0.439279, -0.131154, -0.53463, -0.031065, 0.232751, 0.0906908, 0.410434, -0.0418047, 0.415657, -0.0486177, -0.00641573, 0.0855201, 0.0582626, -0.178536, -0.243158, -0.704812, -0.260485, -0.478447, -3.93336e-05, -0.330423, -0.083536, -0.060695, -0.503576, -0.526448, -0.100582, -0.280072, 0.0655744, -0.283655, 0.2789, 0.0329509, -0.429284, -0.0248755, -0.224657, 0.156965, 0.200541, -0.00112601, -0.18977, 0.133252, 0.120178, 0.492669, -0.202435, 0.162319, -0.16732, -0.704291, 0.0833091, 0.156131, -0.104488, -0.0898599, 0.289366, 0.105365, -0.256063, 0.0549317, 0.179976, 0.0281946, -0.0545491, 0.11456, 0.0368853, -0.103193, 0.144834, -0.0253989, -0.104646, 0.00436214, 0.110517, -0.0645709, -0.224738, -0.350999, -0.0708115, 0.362234, -0.107485, -0.0197034, -0.190077, 0.0120169, -0.490613, 0.0941976, 0.0514626, -0.101571, -0.29826, -0.260549, -0.619264, 0.218588, 0.329463, 0.0743808, -0.27935, -0.0732048, 0.193592, -0.0326617, 0.081905, 0.174954, -0.0506029, -0.83962, 0.346272, -0.348402, -0.0463663, 0.275809, 0.123002, -0.0170543, 0.150406, 0.191921, -0.644727, -0.164425, 0.324182, -0.23524, -0.140255, 0.177264, 0.158406, 0.196982, 0.027132, -0.0762537, 0.18625, -0.430892, -0.102218, 0.137856, 0.0426069, -0.0985584, -0.00805753, -0.746529, -0.239588, -0.186004, 0.0089847, -0.433447, -0.0766206, -0.110988, -0.58128, -0.980497, -0.208234, -0.109274, -0.088713, -0.516004, 0.150522, -0.0252636, -0.456108, 0.169045, -0.107847, 0.119147, 0.550279, 0.147998, 0.215662, -0.238132, 0.0336521, 0.572029, -0.258462, -0.0207127, -0.100708, -0.488072, 0.140877, 0.0355306, 0.064698, -0.060708, 0.259444, 0.0949496, -0.145095, -0.159458, 0.102306, -0.00292066, 0.0514197, -0.00788738, -0.119263, -0.255038, -0.0917679, -0.14297, -0.169283, -0.0260871, 0.141745, -0.0956999, -0.298073, -0.621813, 0.0517852, 0.311254, -0.288767, -0.0849416, -0.215457, 0.163549, -0.542752, 0.0235021, 0.156299, 0.0481373, -0.222075, -0.0540945, -0.802643, 0.288832, 0.172796, 0.116596, -0.295947, -0.190866, 0.101654, -0.0833053, 0.0603261, -0.0518332, -0.0623372, -0.808573, 0.519335, -0.356425, -0.149269, 0.252164, -0.0578053, -0.0100806, 0.104809, -0.126019, -0.599511, 0.0698288, -0.022561, -0.0467242, 0.138803, 0.0825472, 0.10776, -0.0820479, -0.957834, -0.0638765, 0.0702446, -0.41555, -0.234646, 0.0368882, 0.116589, -0.24219, -0.144004, -0.396237, -0.235097, -0.327764, -0.0932893, -0.322526, -0.0284073, -0.0186462, -0.24481, -1.24147, -0.25241, 0.083763, 0.0638743, -0.529442, 0.217675, 0.133087, -0.775718, 0.392482, 0.016653, -0.114435, 0.77275, 0.0814885, 0.182075, -0.176771, 0.0941172, 0.049173, 0.0264462, 0.21443, -0.304341, -0.41174, -0.0795697, 0.131536, 0.101031, -0.0476152, 0.274233, 0.161155, 0.211826, -0.214279, -0.0736013, -0.0837532, 0.0448018, 0.0504787, -0.0256258, -0.0891543, -0.0391957, -0.0671319, -0.0727756, -0.108636, 0.35726, -0.00221223, -0.348574, -0.633561, -0.0222177, 0.11524, -0.49694, -0.264644, -0.0716449, 0.220828, -0.210063, -0.246258, 0.0473181, 0.27589, 0.0251466, 0.0741864, -0.443554, 0.271991, 0.153864, 0.000425438, -0.416942, 0.161467, -0.26647, -0.114029, 0.0662601, -0.00078735, 0.139877, 0.0400483, 0.361671, -0.313094, -0.194385, 0.305558, -0.146702, 0.0164119, 0.159989, 0.0245402, -0.448346, 0.263503, -0.292155, 0.374677, 0.10819, 0.113206, 0.179555, -0.0532, -1.09365, -0.0514352, -0.114071, -0.0174783, -0.323294, 0.0454149, -0.0915724, -0.566308, -0.097811, -0.0459625, -0.159888, -0.298626, 0.0350025, -0.023068, 0.0072781, -0.194155, -0.1175, -0.404589, -0.292066, 0.204108, -0.0142605, -0.533385, 0.0337917, 0.229152, -1.19675, 0.420216, 0.105015, 0.00503135, 0.681238, 0.208006, 0.165299, -0.391461, 0.218506, -0.558356, 0.0293941, -0.00982962, -0.449391, -0.554085, 0.0114302, -0.176039, 0.13006, -0.145348, 0.311184, 0.186324, 0.0418741, -0.230672, -0.0648241, -0.0667352, -0.177558, 0.141118, -0.0592606, -0.303339, 0.132743, -0.103251, -0.205842, 0.191978, 0.0274854, 0.139031, 0.0672785, -0.448569, -0.0301603, -0.0417736, -0.40769, -0.478478, 0.0796926, -0.177272, -0.0298642, -0.167887, -0.0816408, -0.0112596, 0.119539, 0.1564, -0.346769, 0.250691, -0.187764, 0.06867, -0.71367, 0.0471715, 0.0189418, 0.0026944, 0.0975761, -0.354662, 0.168037, 0.431884, 0.296362, 0.0409412, -0.227919, 0.4559, 0.0936106, -0.0639173, 0.203662, 0.0198879, -0.339283, 0.291301, -0.184114, 0.698193, 0.00967653, 0.0166876, 0.211881, -0.180151, -0.34424, -0.183413, -0.339226, 0.505371, 0.0618185, 0.0580392, -0.113364, -0.344366, -0.206036, -0.200102, 0.121449, -0.362933, -0.187263, -0.0864281, -0.137019, 0.293199, -0.00233115, -0.131737, -0.219299, 0.351053}, {-0.277246, -0.296985, 0.0951185, 0.0085794, -0.497399, 0.250331, 0.0764456, -0.123391, 0.684289, 0.194959, -0.00335011, -0.31961, 0.293714, -0.82283, 0.242232, 0.00976377, 0.00975321, -0.500336, -0.0118383, -0.300257, 0.266051, 0.0381763, 0.190674, 0.148519, 0.0445665, -0.14928, -0.113858, -0.0751431, 0.0695949, 0.0457699, 0.000785852, -0.248095, 0.176966, 0.247603, 0.01012, 0.355467, -0.13168, 0.0733018, 0.383884, -0.258205, 0.073875, -0.0475007, -0.226543, -0.181136, 0.0756483, -0.0481626, -0.098459, -0.341938, -0.129872, -0.211577, 0.186643, 0.0490732, -0.478663, 0.110014, -0.356693, -0.129363, -0.596907, 0.0882784, -0.13363, 0.0280187, 0.0751165, -0.206481, 0.243491, 0.171087, 0.165322, 0.371587, 0.0259555, 0.105327, 0.0599615, 0.0659638, 0.168665, -0.0785283, 0.0242476, 0.191013, -0.211595, 0.369697, -0.00391697, 0.120875, 0.0996332, -0.117859, 0.156208, 0.0198965, -0.364513, 0.198919, 9.66667e-05, 0.0548063, -0.285739, 0.102662, -0.162252, -0.0924306, 0.238695, 0.0135928, -0.182386, 0.0530554, 0.0384021, -0.0951265, 0.198537, 0.168446, -0.0619741, 0.292999, -0.175579, -0.365457, 0.383244, -0.112834, -0.0312456, -0.199809, 0.10394, -0.144824, 0.467888, 0.326923, 0.049436, -0.192102, 0.358415, -0.252367, 0.129411, -0.0371439, 0.0489834, -0.443358, 0.0942517, -0.268794, 0.0722065, 0.0896782, 0.279002, 0.0254409, -0.181496, -0.0102519, -0.0709384, -0.0427393, -0.142753, -0.145818, -0.0758433, -0.125366, 0.106605, 0.150076, 0.00375701, 0.576256, -0.151871, 0.186577, 0.271668, -0.165198, -0.0491101, -0.233501, 0.00779029, -0.220748, 0.0127258, 0.144619, -5.28269e-05, -0.62761, -0.22748, -0.260919, 0.175525, 0.370586, -0.386961, 0.0628034, -0.156054, -0.0107556, -0.435309, 0.176863, -0.0824473, -0.0186954, -0.0989142, -0.273588, 0.163631, -0.100104, 0.341451, 0.553248, 0.128555, 0.123994, 0.177275, -0.0256698, 0.147564, -0.280672, -0.0664049, 0.143936, 0.0625939, 0.307075, -0.107291, 0.185977, -0.0439777, 0.175298, 0.191124, -0.0478168, -0.277857, 0.176206, 0.150107, 0.08063, -0.169806, -0.279364, -0.0543957, 0.128152, 0.180956, 0.169176, -0.00941005, -0.0502571, -0.0675626, -0.138434, 0.00949382, 0.13016, -0.139055, 0.138321, -0.309729, -0.174166, 0.134408, -0.215827, -0.00696678, -0.58079, -0.108292, -0.0973629, 0.0955193, 0.199117, 0.0211082, -0.206115, 0.207378, -0.259178, 0.198286, 0.0484566, 0.155217, -0.446544, 0.0239088, -0.219135, 0.149257, 0.00404031, -0.046251, -0.131853, -0.0397235, -0.0963446, -0.229113, 0.0499985, -0.0284786, -0.199785, 0.0555552, -0.189928, 0.306292, 0.204446, 0.149522, 0.507906, 0.21784, 0.281683, 0.365863, -0.185809, -0.0603556, -0.163228, 0.0275415, -0.040241, 0.0324744, -0.0307939, 0.170363, -0.662227, -0.118155, -0.227842, 0.160135, 0.1989, -0.46338, 0.189966, -0.256583, -0.193311, -0.342552, 0.189423, 0.245086, -0.00380507, 0.129345, -0.0695778, 0.211967, -0.0817957, 0.101506, 0.388711, -0.0165396, -0.109307, 0.307983, -0.0515986, 0.0815002, 0.0129625, 0.113723, -0.188363, -0.0751948, 0.306857, -0.144955, -0.148961, -0.135713, 0.157511, 0.363327, -0.166522, -0.218678, -0.128778, 0.000944058, 0.0587709, -0.305408, -0.358372, -0.134277, 0.102442, -0.110342, 0.0419618, -0.0122429, 0.086087, -0.0501207, -0.0301242, -0.0174292, 0.148782, 0.224342, -0.285461, -0.265958, -0.230241, -0.116252, -0.0113031, -0.167942, -0.928281, -0.0798386, -0.200579, -0.0330742, 0.0944089, 0.258672, 0.0951492, 0.153425, -0.433963, 0.264476, 0.00407399, -0.0652944, -0.410206, -0.130264, -0.120146, 0.163841, 0.170504, 0.034004, -0.0351953, -0.0479015, 0.0105289, -0.0113997, -0.0516706, -0.0630582, -0.139545, 0.112424, -0.201492, 0.333191, 0.107026, 0.214207, 0.419394, 0.191742, 0.150841, 0.491495, -0.137148, 0.0144105, -0.291195, 0.120305, 0.171758, -0.249826, -0.0886477, 0.024856, -0.697823, 0.0607458, 0.011337, 0.099182, 0.109531, -0.44513, 0.00893035, -0.12321, -0.0191557, -0.223465, -0.0476012, -0.0794549, -0.0131988, 0.0624593, -0.0538503, 0.00655297, -0.0523391, 0.271592, 0.408802, -0.0481159, -0.132919, 0.300505, -0.0124881, 0.0573843, 0.0123203, 0.216446, -0.680244, -0.16495, 0.0916662, -0.0431731, -0.0263925, -0.134832, 0.077832, 0.323215, -0.261057, -0.55473, 0.00448518, -0.14698, 0.126375, -0.245698, -0.229384, 0.180631, 0.168729, -0.141932, 0.130886, 0.00554459, 0.0718039, -0.00756836, -0.1212, 0.108959, 0.149664, -0.00447005, -0.351493, -0.312602, -0.30915, -0.733443, -0.0465797, -0.0931703, -1.10762, -0.0229336, -0.163281, -0.0285136, 0.225484, 0.321923, 0.174612, 0.0613404, 0.019983, 0.211614, 0.11719, 0.0114961, -0.128963, -0.2583, -0.216988, 0.125938, 0.178056, 0.0305982, 0.0141116, 0.0698486, 0.00647228, -0.241014, 0.0634216, -0.162798, -0.09041, 0.201454, 0.100891, 0.658043, -0.303269, 0.628175, 0.612247, 0.31946, 0.0865602, 0.536615, -0.369879, -0.0656834, -0.141512, 0.205514, 0.255683, -0.330365, 0.17142, 0.0954976, -0.973588, -0.04216, 0.32196, 0.0148878, -0.0420401, -0.651247, 0.0890022, -0.192775, -0.149657, -0.145319, 0.163607, -0.0678122, 0.00197384, 0.340336, -0.112232, 0.064183, 0.139666, -0.0145374, 0.673713, -0.374336, -0.357895, 0.0388179, 0.0250285, -0.113679, 0.383924, 0.180894, -0.922927, -0.345881, -0.0454894, -0.0465445, 0.00115854, -0.0256091, 0.0939403, 0.324801, 0.145875, -0.68292, -0.689341, -0.315594, 0.0678417, -0.316586, -0.446401, 0.434642, 0.08572, 0.0144299, 0.241689, 0.021287, -0.13819, 0.217586, -0.0501816, -0.0548982, -0.029804, 0.110528, -0.542344, -0.428472, -0.457021, -1.20902, -0.261144, 0.0141649, -0.960745, -0.0667835, -0.100274, 0.0296279, 0.313545, 0.131206, 0.451272, 0.110243, 0.335294, -0.306678, 0.185434, 0.447721, -0.458328, -0.391744, -0.0478509, -0.0622752, 0.360088, 0.245061, 0.212901, -0.00661539, 0.107711, -0.0465269, -0.049546, -0.152962, 0.0305018, 0.101226, -0.196007, 0.5763, -0.566795, 0.250126, 0.936918, 0.0133846, 0.192451, 0.358997, 0.101715, -0.0292007, -0.0178432, 0.0270776, 0.395123, -0.634576, 0.164648, -0.159789, -0.619582, 0.314317, 0.00853418, 0.00524656, -0.33415, -0.657587, 0.0658749, -0.0163994, -0.0837662, 0.153493, 0.0987333, -0.011598, -0.355837, 0.3208, -0.0972536, -0.156047, -0.000722731, -0.17604, 0.689558, -0.177245, 0.102503, 0.23615, -0.00324098, -0.103648, 0.0447799, 0.299924, -0.882671, 0.00777515, -0.341454, -0.0786208, -0.132046, 0.0663428, 0.132797, 0.20646, 0.424713, -0.730837, -0.67212, -0.262462, 0.0100827, -0.0874703, -0.243981, 0.361384, 0.00979998, 0.148169, 0.250596, 0.0497799, -0.262134, 0.160856, 0.12688, 0.134012, 0.215932, 0.453265, -0.694551, -0.48852, -0.28002, -0.910802, 0.00921121, 0.0992543, -1.00696, 0.127903, -0.0141971, -0.167821, 0.0620285, -0.0416268, -0.148976, -0.0575163, 0.0762866, -0.0891158, -0.108804, 0.0601117, 0.214366, 0.158644, -0.257041, 0.0035728, -0.0569257, 0.272041, -0.255028, -0.0123345, 0.0969161, -0.131492, -0.0501628, 0.0583217, -0.11483, -0.0750976, 0.108745, 0.125178, -0.0801503, 0.0727001, 0.0516905, 0.124409, -0.108252, 0.0872082, -0.0111971, -0.0664894, -0.011238, 0.201793, -0.161345, -0.109084, 0.0800074, 0.100144, -0.0954, -0.0843066, 0.156788, 0.211382, 0.121971, 0.0299661, 0.016864, 0.116214, 0.204106, 0.154891, 0.055858, 0.184969, -0.052561, -0.189206, 0.135745, -0.118049, 0.0229112, 0.0419916, 0.0698524, 0.0941411, -0.107482, -0.0136048, 0.0806393, 0.109767, -0.00608619, -0.179204, -0.0226857, 0.0746699, 0.0802323, -0.0829871, 0.032912, 0.0177546, -0.0725685, 0.0327567, -0.0238492, 0.0170073, 0.109375, -0.0188607, -0.126463, -0.0308614, -0.039568, -0.00248257, -0.0227435, 0.146342, -0.125942, 0.273368, 0.0112153, -0.150506, -0.0100796, -0.116038, 0.0262378, -0.0808788, 0.00432444, 0.156181, 0.0661966, 0.0747, 0.00536887, 0.033232, -0.0354114, 0.0307301, 0.00980039, 0.0543227, -0.0237655, 0.0490751, -0.109225, 0.0843885, -0.00208607, -0.0583696, -0.0136812, 0.0745829, 0.0397989, -0.0180119, -0.0705242, 0.106925, -0.0122833, 0.0704775, -0.0901029, -0.0684479, -0.0465046, -0.105211, -0.0721207, -0.0561821, -0.0889239, 0.0331067, -0.0310615, -0.00811256, 0.0553172, -0.0373997, -0.00151013, -0.00216515, -0.0803746, -0.0622144, 0.0860413, -0.0560041, -0.0489182, 0.0799092, -0.0419098, 0.0201455, -0.0444544, -0.00693635, 0.00328366, 0.0851074, 0.0639496, -0.0245254, 0.0673126, -0.0459494, -0.0438114, -0.015313, 0.00892165, 0.0798912, -0.0450041, 0.087749, -0.0631883, -0.0304176, -0.010517, -0.0999089, -0.0608732, -0.0193332, 0.0138794, 0.0609366, -0.0265403, -0.008647, 0.0466357, -0.0201777, -0.0487763, -0.0701866, -0.045139, 0.069756, 0.093977, 0.0293335, -0.0518742, -0.0240591, -0.00807261, 0.0810492, 0.0447472, -0.0553022, 0.0223119}, {0.0367308, 0.0768727, -0.0742692, -0.0462212, -0.00411539, -0.0889035, 0.0165423, 0.00792302, 0.0929163, 0.0634269, 0.0355086, 0.0205876, 0.0539242, -0.0416344, 0.0431027, 0.0137024, -0.00815268, -0.072878, 0.0318869, -0.0568517, 0.0118935, 0.00467727, 0.0586779, -0.00639779, 0.0128495, -0.0238715, -0.0042247, -0.0466641, -0.000340484, 0.0458962, 0.0778318, -0.0622874, 0.018582, 0.054396, -0.0802747, -0.0588218, 0.0335476, 0.0452818, 0.00630836, 0.0403482, -0.0726947, 0.0482762, 0.0548496, 0.0643275, -0.0675687, 0.0476739, -0.0631303, -0.0484671, 0.0705124, -0.0591002, 0.0545433, 0.0190341, -0.0288044, -0.00913406, 0.0334202, 0.00423632, 0.0525907, -0.0277113, 0.082062, 0.0381368, 0.0721887, 0.0555166, 0.0410494, 0.0774616, 0.0730704, -0.0304775, -0.000820386, -0.0207333, 0.0450425, 0.0698914, 0.0282511, 0.0180351, -0.0758491, 0.0276828, -0.0340037, 0.00428129, 0.0702301, 0.00308171, 0.0107262, -0.0121748, -0.0648556, 0.0201671, -0.0483087, 0.0231646, 0.0696761, 0.00587627, -0.0700406, 0.0440907, -0.0140924, -0.0254548, 0.051787, 0.0234051, -0.0652028, -0.0220994, 0.0338217, -0.0377269, -0.0555843, -0.0376893, 0.0130129, -0.0216609, -0.0401803, -0.0675708, 0.02204, 0.0409934, -0.0415513, -0.0670795, -0.076924, 0.0772708, -0.0309487, -0.0411895, 0.0660248, -0.0716193, -0.0349936, 0.0480115, -0.0358337, 0.0542316, -0.00948007, -0.0290063, -0.00879938, 0.0420937, 0.0501815, 0.06308, -0.0797493, 0.076666, -0.0326038, 0.0421662, 0.0369899, -0.0352319, 0.0300117, 0.0168886, 0.028859, -0.0343503, 0.00401989, 0.0360093, 0.0544359, 0.0535537, 0.0177294, 0.0769381, 0.0811511, -0.0319735, 0.0758379, -0.0767898, 0.0237205, -0.0602741, -0.0302095, -0.068183, -0.0675213, 0.0354494, -0.0536847, -0.0484393, -0.00729787, 0.0198461, 0.0315264, 0.0122566, -0.035445, -0.0662952, -0.0608219, 0.0498075, 0.0636313, 0.0433863, 0.0137167, 0.00257421, -0.0261957, 0.038963, 0.0449634, -0.000782348, 0.0425947, 0.0397073, -0.0523403, -0.0732954, 0.0618518, -0.0653991, 0.0615488, 0.0499099, -0.0631865, 0.0526924, 0.065082, -0.000246137, -0.063098, -0.00168948, 0.0670366, 0.00379809, 0.0490117, 0.0132067, -0.0659032, 0.073479, -0.0432537, 0.0403345, 0.0518934, -0.028635, 0.067582, 0.0403419, 0.02547, -0.0528739, 0.0743874, 0.00444324, -0.0341649, 0.0638935, 0.0297744, 0.0291855, 0.0489388, 0.0519929, -0.0424963, -0.0688668, -0.0654782, -0.0100819, -0.0593471, 0.014477, 0.0324322, 0.0135702, -0.0522415, -0.0462223, -0.0530802, 0.0492365, -0.00979052, 0.0426936, -0.0271294, -0.0620492, 0.0764873, -0.0585861, 0.012861, -0.0344503, 0.0409487, 0.0514746, -0.0375088, -0.0601745, 0.0334713, -0.0507041, -0.0493425, 0.0549681, -0.0654509, -0.0563866, 0.028947, -0.049885, -0.0437233, -0.0740075, -0.0802185, 0.0223295, 0.0116706, 0.0534977, -0.0820594, 0.00148568, 0.0421434, -0.0761171, 0.0553503, 0.00597242, 0.063666, 0.068673, 0.0670432, -0.0580307, 0.0369545, 0.0579589, -0.0359018, 0.0326679, 0.00229558, -0.00282867, 0.0778109, -0.03577, 0.055976, 0.0614549, -0.0478758, -0.0322991, -0.0469466, -0.0528232, -0.0330325, 0.0586999, -0.0553248, -0.0653827, -0.0379869, -0.0336945, 0.0116247, 0.00721449, -0.0225442, 0.072123, -0.0566282, 0.0437346, -0.0574503, -0.0216639, -0.0764324, 0.014744, 0.0543243, 0.0768906, 0.0378299, -0.0728018, -0.0679671, -0.00859288, -0.0791384, 0.0725134, 0.0699642, -0.0233204, -0.0311726, -0.0228235, 0.0407821, -0.0553134, 0.0248065, -0.0512694, -0.0378057, -0.00494712, -0.0707798, 0.0390073, 0.0651687, 0.0772472, -0.00241532, 0.0317906, -0.0559676, 0.00917564, -0.00196964, -0.050167, -0.0173039, 0.037289, -0.0697767, -0.0155272, 0.053159, 0.0296351, -0.019019, -0.0651569, 0.0136467, 0.0650964, -0.0612106, -0.0637434, 0.00264234, -0.0301198, 0.0626936, 0.0654954, 0.00338757, -0.0164774, 0.0626307, -0.0815857, 0.0664944, -0.0590341, -0.00707847, -0.0153917, -0.0714681, -0.0586997, 0.0531103, -0.0659811, -0.0108884, -0.0175946, 0.0724843, 0.0819751, 0.058218, 0.0588191, -0.0182819, -0.0136349, -0.0664007, -0.0471539, 0.0438318, 0.0463985, -0.00963912, -0.0503034, -0.017978, 0.0465155, -0.0669831, 0.0264093, 0.0557514, -0.0588578, 0.0196324, 0.0658926, 0.0660567, 0.0500457, 0.0784661, 0.0288581, -0.0572964, -0.043802, 0.0385394, 0.0531676, 0.0079077, -0.0194512, 0.0503557, 0.059256, -0.0215313, -0.0760008, -0.0540294, 0.0322344, 0.0473802, -0.0126908, 0.07364, -0.000195891, -0.0295478, -0.00809629, 0.0556227, -0.0202003, 0.0785055, -0.00278316, 0.0814685, 0.0807641, -0.0703036, -0.0204147, -0.0270056, 0.0563144, -0.0128287, -0.0185937, -0.0681335, 0.0504115, 0.0291811, -0.0251136, 0.0234601, -0.0808463, 0.0439365, 0.00492524, 0.0739172, 0.0120899, -0.0251554, -0.0155321, -0.0468613, 0.0590682, 0.0074546, -0.0697009, 0.0712718, 0.0555272, 0.0346452, 0.0396178, -0.068746, 0.0297721, 0.0502423, 0.041013, -0.0800235, 0.0334745, -0.048746, -0.0318054, 0.0189949, -0.0462053, -0.00835193, 0.0702039, -0.020863, -0.0359448, 0.17525, 0.00628821, -0.0972569, -0.0035978, 0.0353073, -0.0316496, -0.0689542, -0.0791011, -0.124187, -0.0780203, 0.101613, -0.17821, 0.0343941, -0.031187, -0.00589225, -0.0844033, 0.248402, -0.0714271, -0.0746324, -0.0275419, -0.141635, -0.023672, -0.0183839, -0.0754548, -0.0181995, 0.0858053, 0.00165354, 0.136109, -0.058345, -0.0420684, 0.0202832, 0.0706706, -0.0504867, 0.0356823, -0.0233488, -0.00222878, 0.0258988, -0.0454199, -0.0165601, -0.0951602, 0.0103958, 0.0346053, -0.0225426, -0.124913, -0.0309653, 0.076575, 0.00533503, 0.0226001, -0.0239086, -0.0587415, -0.0682173, -0.0453162, -0.00309417, 0.0392525, -0.030261, -0.0133837, 0.0176497, -0.0712342, -0.170449, -0.030204, -0.012391, 0.0349431, 0.119156, -0.0437415, 0.0459524, -0.0463206, 0.00977852, -0.00552922, 0.0426132, 0.118022, 0.00806396, 0.230317, -0.12699, 0.0414655, 0.20929, -0.000394743, 0.120922, 0.0893072, -0.0886763, -0.102712, 0.066848, -0.033713, 0.0319715, -0.114317, -0.126745, 0.0381087, -0.0817827, 0.0300804, -0.069334, -0.172136, 0.0252378, 0.120424, 0.12701, 0.199268, 0.124905, -0.185374, 0.00184995, 0.0432076, 0.0014736, -0.0128304, -0.00734446, 0.049519, -0.000770552, 0.0131376, -0.120185, -0.0481154, -0.0629933, -0.137009, -0.179702, -0.0462501, 0.0318123, -0.18823, -0.0294503, -0.0971002, 0.15215, -0.106946, 0.198122, 0.0752448, -0.173456, 0.0619501, -0.125995, 0.0351004, 0.117015, -0.0221398, -0.105544, 0.0632187, -0.0385883, 0.129438, -0.0335979, -0.0274064, -0.040362, -0.0354485, -0.180973, 0.135471, -0.0181236, -0.0880883, 0.0242476, -0.0382609, -0.0704325, 0.0675381, 0.119549, 0.0330868, -0.0517286, -0.0146899, 0.00194589, 0.0610275, 0.0694677, -0.0633743, -0.0520403, -0.0611398, -0.0320929, -0.123322, 0.0277488, -0.0109063, 0.0173514, 0.124355, 0.0557155, -0.0424691, -0.166117, -0.0579165, 0.0245816, 0.0402119, 0.0583634, -0.0379504, 0.119676, -0.0633379, -0.00599698, -0.0928082, 0.177986, 0.164562, 0.0331138, 0.179718, -0.0856281, -0.0278639, 0.0686696, 0.0485672, 0.117156, 0.0775274, -0.121986, 0.00751649, 0.0104002, -0.0742702, -0.0678809, 0.0304385, -0.099245, 0.0680436, -0.0107829, 0.0833427, -0.0546536, -0.12686, 0.143357, 0.0739761, 0.0123453, 0.200276, 0.132669, -0.175742, 0.134547, 0.105649, 0.305734, 0.0302091, 0.290822, -0.607962, -0.424048, 0.0577683, 0.462814, -0.293759, 0.422041, -0.134514, 0.0869931, -0.242021, 0.0414028, -0.0543011, -0.222578, 0.0444911, 0.00575039, -0.293334, -0.42931, 0.0386175, 0.297032, 0.225891, 0.175203, 0.0900647, 0.21814, 0.0628103, 0.185551, 0.0379778, 0.096589, -0.17383, 0.13029, -0.551437, -0.0621607, 0.0334686, 0.071073, -0.2245, -0.758361, 0.152034, 0.298491, 0.0257427, 0.08721, 0.0157576, -0.0877913, -0.228147, 0.321894, -0.327848, -1.08674, 0.00830024, -0.152224, 0.0200765, -0.953286, 0.1399, -0.182694, 0.249742, -0.566231, -0.211001, -0.0951783, 0.0363716, -0.131785, -0.0164042, 0.0678055, 0.034992, 0.276393, -0.392312, -0.0487871, 0.418012, -0.287048, -0.0659646, -0.151994, 0.0451162, -0.0464362, 0.211628, -0.00475551, 0.488515, 0.0647603, -0.69104, 0.280876, -0.0800962, -0.165055, -0.0188645, -0.133628, -1.24556, 0.234442, -0.134786, -0.219838, 0.310603, 0.530603, -0.284945, -0.332438, -0.152586, 0.107077, -0.103652, 0.0518752, 0.288164, -0.415702, -0.123136, -0.180478, -0.0860652, 0.0893469, 0.0231633, -0.0362774, -0.0267077, -0.0483278, -0.640175, -0.0512429, 0.273118, -0.156064, -0.379436, 0.286176, -0.101838, 0.0693442, -0.0693338, 0.0765521, -0.274392, -0.470863, 0.0298003, -0.107519, -0.227337, -0.255521, -0.032669, 0.226918, 0.277351, -0.0663804, 0.182843, -0.0607856, -0.0254357, 0.28879, 0.112109, -0.059938, -0.103803, -0.0175662, -0.591015, -0.00367786, -0.0336106, -0.0929857, -0.0492257, -0.168216, 0.27255, 0.109871, 0.234021, 0.164037, 0.016868, 0.20138, -0.0642969, 0.23467, -0.508859, -1.17188, -0.0299336, -0.138648, -0.135114, -0.807353, 0.244657, 0.269323, -0.0284083, -0.264392, -0.205062, 0.0341891, 0.177435, -0.112645, 0.0192793}, {0.114264, -0.0825423, -0.0224757, -0.22622, 0.0116181, 0.350643, 0.0962471, 0.0355479, -0.0568143, 0.0223727, 0.096817, 0.246041, 0.0384736, -0.0119453, -0.129235, -0.689325, 0.425703, 0.015175, -0.162985, -0.139287, -0.145155, -0.877099, 0.145381, -0.231504, 0.0551299, 0.185831, 0.230759, -0.124758, 0.107287, -0.18175, -0.01052, 0.168588, -0.322878, 0.183226, -0.249388, -0.614604, 0.08045, 0.137171, 0.0237215, -0.104829, 0.108679, 0.0474079, 0.111026, -0.643127, 0.242864, 0.111614, 0.0026063, -0.276522, -0.0131536, -0.0630825, 0.0676695, -0.0170377, -0.258052, -0.292142, -0.368598, -0.211034, -0.00724332, -0.0419457, -0.21823, 0.0185251, 0.142787, 0.559489, -0.329629, -0.0636434, -0.254138, 0.161403, 0.0508825, 0.231193, -0.247212, 0.115908, 0.0496008, -0.315245, -0.0247593, -0.0831152, 0.162072, 0.0423666, 0.0825008, 0.0698508, 0.15812, 0.135875, 0.243003, 0.0528395, 0.0778766, -0.00714631, 0.227575, -0.354311, -0.549134, 0.13162, -0.19969, -0.460081, -0.229578, 0.372016, 0.1941, 0.0981357, -0.218688, 0.00779191, 0.130182, -0.0358741, -0.198748, 0.00143122, 0.408818, -0.0525338, -0.0819629, 0.108596, 0.137741, 0.307434, 0.334835, 0.0101966, -0.165365, 0.33018, 0.102204, 0.159453, -0.102428, -0.198261, -0.108148, -0.322036, 0.402048, -0.0214646, -0.229771, -0.19115, -0.0407483, -0.937574, 0.169158, -0.0274754, 0.0186472, 0.343615, -0.0414267, -0.0883605, -0.218059, -0.335521, -0.00607952, -0.00493945, -0.302191, 0.0613581, -0.0368981, -0.276264, 0.0790598, -0.00688229, -0.160679, -0.0787753, 0.20424, -0.038924, 0.0430149, -0.47358, 0.180108, -0.177393, 0.118804, -0.343113, 0.15981, 0.058101, 0.116892, 0.0140096, -0.0897847, -0.066996, -0.311017, -0.127113, 0.166425, -0.122455, -0.345883, -0.0712505, 0.244241, 0.661138, -0.16842, 0.0202876, -0.0583334, -0.058109, -0.119324, 0.251816, -0.149921, 0.0553173, -0.0832516, -0.0671443, -0.057257, 0.179512, 0.127121, -0.000411682, 0.259586, -0.0050512, 0.197946, 0.0357271, 0.132486, 0.214073, -0.0954162, -0.148721, 0.0111848, -0.256583, -0.410386, -0.0844861, -0.0580808, -0.435029, -0.224532, 0.324129, 0.072873, 0.0277348, -0.199392, 0.0239313, 0.27394, 0.0781089, -0.440024, 0.0694165, 0.381092, -0.0194954, -0.111862, -0.00395686, 0.149337, 0.277146, 0.227831, 0.391401, -0.0664688, 0.268901, -0.156251, 0.098165, -0.0163899, 0.0129373, -0.216072, -0.31009, 0.187347, 0.0618081, -0.1138, -0.25872, -0.121188, -1.13519, 0.165078, 0.0143653, -0.0635716, 0.419391, 0.117268, -0.047533, -0.142023, -0.148928, -0.233681, 0.0233556, -0.286242, 0.0731521, -0.165813, -0.18421, 0.158331, 0.0597113, -0.0949674, -0.0650321, 0.314888, -0.0596348, 0.0522018, -0.354055, 0.12234, -0.033582, -0.0339474, -0.247191, 0.103295, -0.0602596, 0.0870394, -0.208745, -0.0790541, -0.088186, -0.162296, -0.312658, 0.260607, -0.148001, -0.268082, 0.00246735, 0.329319, 0.466626, -0.129581, 0.0869303, 0.0245554, 0.0731224, 0.215422, 0.219934, -0.016188, 0.0423615, 0.00508495, -0.0804407, -0.0295407, 0.114617, 0.0471141, -0.196576, 0.164654, -0.17229, 0.343494, 0.264739, 0.0882202, 0.15003, -0.0258088, -0.228048, 0.0746863, -0.0929838, -0.205216, -0.0890262, -0.201581, -0.61276, -0.350053, 0.0590704, 0.0258944, -0.00788298, -0.255576, 0.124141, 0.348679, 0.0642975, -0.147174, 0.246129, 0.396439, 0.0388249, 0.00897699, -0.0595601, 0.0253645, 0.234167, 0.272109, 0.376934, 0.380565, -0.0495813, -0.0271661, 0.205028, -0.0112572, 0.0272947, -0.170692, -0.176787, 0.193472, 0.0251162, -0.0248208, -0.262203, -0.139724, -1.17762, 0.0783108, -0.0179498, -0.118861, 0.383207, 0.176639, 0.144635, -0.154549, -0.167765, -0.134091, -0.157306, -0.287863, -0.0314638, -0.204873, -0.269935, 0.230179, -0.0100122, -0.243812, 0.134454, 0.309163, 0.135194, 0.124, -0.104282, 0.220563, -0.0350812, 0.0934932, -0.0621868, 0.126541, -0.128118, 0.0542418, -0.231684, 0.0785735, -0.0785539, -0.208556, 0.00568024, 0.243783, 0.0817899, -0.113353, 0.00291021, 0.075355, 0.245627, 0.0946843, 0.02964, -0.053687, 0.0297886, 0.0660498, 0.0866975, 0.0170809, 0.026845, -0.1246, -0.0321604, -0.0710799, -0.0246737, -0.117421, 0.0118956, 0.272796, -0.120852, 0.376729, 0.173747, 0.149501, 0.252337, -0.261288, -0.00539818, 0.292431, -0.0235972, 0.209016, -0.0127103, -0.124192, -0.288999, -0.324634, -0.203344, -0.103328, -0.118951, 0.0574596, 0.25899, 0.384804, 0.0372353, -0.0901582, 0.144804, 0.448357, -0.0922211, -0.121259, -0.0203913, -0.0287164, 0.00310457, 0.0782983, 0.0410793, 0.414287, 0.156509, -0.00346045, 0.0870263, -0.100127, 0.0011622, -0.1108, -0.0312017, 0.0967178, 0.109604, 0.20545, -0.227888, -0.0763564, -0.744535, -0.0994342, -0.27534, -0.0109094, 0.263377, 0.300611, -0.0451246, -0.368318, 0.125074, 0.080909, 0.010001, -0.112308, 0.0589063, -0.364721, -0.187906, 0.131382, -0.050733, -0.0195955, 0.0628358, 0.31181, 0.259493, 0.0613367, 0.167245, 0.137193, -0.053207, -0.0650409, 0.0229553, -0.0619865, -0.0805669, 0.00525985, -0.0697682, 0.217321, -0.0859441, 0.0050398, 0.0251151, 0.0223514, 0.140961, -0.0616718, 0.0258851, 0.136507, -0.356113, 0.297455, 0.162375, 0.0667482, 0.0859877, 0.0951622, 0.0873145, 0.123822, -0.0339891, -0.344786, 0.128417, -0.0715718, 0.108736, 0.0543383, 0.0576763, 0.306528, -0.00470707, 0.327749, 0.128074, 0.0523094, 0.213379, -0.210747, 0.0691215, 0.191912, 0.104025, 0.517391, 0.028693, -0.00205877, 0.161743, -0.298736, -0.0383063, 0.0099313, -0.251751, 0.0507103, 0.460959, 0.177672, 0.0239583, 0.0259938, 0.123448, 0.396756, 0.033748, -0.0617086, 0.145884, -0.18701, -0.148851, 0.102563, -0.0722895, 0.28474, 0.0564984, 0.0785863, -0.105497, -0.109486, 0.0117104, 0.324995, -0.013735, -0.0645371, -0.056779, 0.199909, -0.249032, 0.109632, -0.775219, 0.00655011, -0.36972, -0.0109773, 0.205878, 0.162501, -0.0585793, -0.219337, 0.120749, 0.03841, -0.143947, -0.177882, 0.0646756, 0.0589688, -0.203718, 0.00419062, 0.30821, -0.271591, 0.101417, 0.460919, 0.168316, 0.201369, 0.523823, 0.0799734, 0.105683, 0.166583, 0.156671, 0.0481655, -0.100249, -0.0194496, -0.0846638, -0.133757, -0.0786176, 0.0801404, 0.0713538, -0.0668072, -0.159562, -0.163967, 0.0294826, 0.0555804, -0.659469, 0.115391, 0.0355845, 0.244873, 0.154829, 0.100798, 0.102297, 0.0878793, -0.0837488, -0.177645, 0.198384, -0.00341482, 0.0773674, 0.148037, 0.00724818, 0.188146, 0.000476171, 0.269232, 0.0358779, 0.132624, 0.195464, -0.158071, -0.0694635, -0.0627548, 0.449978, 0.429706, 0.00059104, -0.0725742, 0.137884, -0.0465085, 0.0668709, 0.194003, 0.00548734, 0.0739287, 0.365252, 0.38806, -0.103603, 0.107462, 0.088146, 0.151994, 0.0234535, -0.0718571, 0.310822, -0.284431, -0.273143, 0.141088, -0.00100436, -0.0223115, 0.0229242, 0.096463, -0.0618906, 0.0648296, -0.000448525, 0.191786, -0.146097, -0.225261, 0.0857821, 0.198174, -0.0612556, -0.0638224, -0.774227, -0.0675531, -0.566536, -0.12044, 0.0832476, -0.00728405, -0.0212993, -0.132521, -0.22278, 0.13666, -0.234035, -0.132784, 0.138546, -0.00154405, -0.0162302, -0.35307, 0.0422729, -0.215062, 0.154548, 0.67598, -0.114378, 0.0409596, 0.536973, 0.0558121, 0.0441793, -0.0692872, 0.191848, 0.277407, -0.123236, -0.0263431, -0.1898, -0.0771852, 0.0837098, 0.116364, 0.0738206, -0.0533785, -0.0873607, 0.0260758, -0.0123496, -0.0196895, -0.482286, 0.259564, 0.00573968, 0.263498, -0.191432, 0.196315, -0.00957522, 0.00244845, -0.113074, -0.341514, -0.0157622, -0.0841964, 0.116976, 0.0710253, -0.0365557, -0.161962, 0.0236022, 0.100786, -0.0558521, 0.0305132, 0.20145, -0.0635, -0.206089, -0.312542, 0.323913, 0.377772, -0.100891, -0.105467, 0.263698, -0.176921, -0.052136, 0.079684, 0.0527779, 0.129643, 0.233839, 0.497918, -0.0858896, 0.161538, 0.242646, -0.0137262, 0.0194229, 0.0846541, 0.268551, -0.283107, -0.134328, 0.324948, -0.133521, -0.446313, 0.0676245, 0.0971551, 0.0181403, 0.31249, -0.238937, 0.320444, 0.167071, -0.330181, 0.0906588, 0.142545, 0.103733, -0.117378, -0.533975, -0.112817, -0.427797, 0.0249301, -0.0882057, 0.239327, 0.097194, -0.427891, -0.0527417, 0.0987993, -0.0694464, -0.0876494, -0.00641781, -0.0661993, -0.00705338, -0.411857, -0.126674, -0.350285, 0.126044, 0.577367, -0.201917, -0.049211, 0.509705, 0.00495165, 0.44605, -0.162192, 0.179995, 0.166938, -0.0491027, 0.0414295, 0.142, -0.106847, -0.00964163, 0.148083, -0.128625, -0.00187817, -0.0686348, 0.11768, -0.0209288, -0.164095, -0.300002, 0.0300653, -0.176018, 0.0431653, -0.204927, 0.051572, -0.0756146, 0.197125, -0.178927, -0.133876, -0.246219, 0.0261821, 0.0644186, 0.0948647, 0.00993874, -0.0309829, 0.0374435, -0.0488298, -0.101562, 0.000920175, 0.120205, -0.286041, -0.409627}, {-0.38368, 0.239354, 0.131088, -0.120177, -0.221431, 0.107597, -0.247845, -0.128534, -0.0965005, 0.145813, 0.0851355, -0.312244, 0.334305, -0.244766, 0.082439, 0.316777, -0.191743, 0.0204247, -0.00568186, 0.268752, -0.75716, -0.0232978, 0.144865, -0.279244, -0.436498, 0.0230855, 0.062292, 0.195212, 0.269094, -0.279766, 0.148457, -0.140078, -0.197269, 0.0418391, 0.200838, 0.0984259, -0.0716702, -0.331652, -0.100519, -0.379549, -0.0482807, -0.331923, 0.000319516, 0.0314304, -0.321002, -0.0236006, 0.0409472, -0.223545, -0.103989, -0.100921, 0.0803312, 0.0479296, -0.345975, 0.0606838, -0.240183, 0.112744, 0.536677, -0.147967, -0.178447, 0.502269, -0.125678, 0.281858, -0.121906, 0.141719, 0.0466789, -0.293598, 0.0681353, 0.249981, 0.0171713, 0.129585, 0.27794, -0.0968654, -0.332506, -0.0929834, 0.0636497, -0.0929805, -0.0479721, -0.0786403, 0.0444943, -0.16949, -0.0415074, -0.208768, -0.0924329, -0.393239, -0.00851281, -0.167957, -0.267235, -0.330432, -0.00495001, 0.34517, -0.0274631, -0.275729, -0.210831, 0.00937123, -0.312501, 0.183567, -0.0864925, 0.0381483, -0.131282, -0.311432, -0.63787, 0.0494227, 0.082583, 0.103078, -0.212065, 0.175445, -0.107802, -0.00772832, -0.156429, 0.147965, 0.0863823, -0.771295, 0.21302, -0.331157, 0.134083, 0.336899, -0.150886, -0.0047733, 0.127525, 0.108806, -0.773686, 0.205955, 0.0666892, -0.146729, -0.304419, 0.0615147, 0.0886896, 0.0223947, -0.373694, -0.498762, 0.280074, -0.354615, -0.00681516, 0.00627992, 0.296562, 0.0340944, -0.0084329, -0.447377, -0.232009, -0.301963, -0.033655, -0.516721, 0.114604, -0.0734286, -0.227984, -0.742677, -0.128602, -0.301787, -0.231148, -0.255958, 0.300488, 0.143889, -0.42671, 0.404828, -0.23361, 0.0500253, 0.814395, 0.0263245, 0.167264, 0.390448, 0.0417062, 0.000917426, -0.137693, 0.141421, -0.0105704, -0.0201041, 0.0514631, 0.252692, -0.208857, 0.167016, 0.175732, 0.0454474, -0.126974, -0.0948122, 0.00213532, -0.0542017, -0.193103, 0.0138786, -0.040892, -0.212996, -0.0902393, -0.025911, -0.143277, -0.194164, 0.107532, -0.126365, -0.482954, -0.505917, 0.0318002, 0.220314, -0.132756, -0.214675, -0.00282701, 0.156134, -0.331444, 0.285752, 0.00330853, 0.101155, 0.0323726, -0.00326574, -0.581587, 0.225339, -0.0664195, -0.0890325, -0.285267, 0.080232, -0.248634, 0.00169112, 0.00675258, 0.102967, 0.138699, -0.375539, 0.5154, -0.300569, -0.0866784, 0.334536, -0.146871, -0.125887, 0.00465837, 0.0855462, -0.913071, 0.389582, -0.0700686, -0.149925, -0.111803, 0.0920833, 0.287517, -0.161927, -1.07842, -0.175908, 0.252546, -0.361651, -0.391968, 0.136454, -0.0566377, -0.0899599, -0.00933727, -0.236908, -0.16662, -0.140087, -0.0499814, -0.150182, 0.139824, -0.0176378, 0.0259457, -0.971564, -0.329753, -0.100753, -0.323875, -0.21769, 0.2091, 0.251244, -0.875308, 0.482436, -0.209032, -0.211068, 0.644, -0.0419848, 0.0942072, 0.109098, 0.22609, -0.503935, -0.175032, 0.145152, -0.325185, 0.0414436, 0.0308643, 0.10884, 0.00409436, 0.118109, 0.217394, 0.0392174, 0.00937322, -0.203622, -0.0706013, -0.0111158, -0.119563, -0.179776, 0.0510854, -0.311232, -0.0835053, 0.201226, -0.0672788, -0.270066, 0.0684066, -0.174116, -0.253514, -0.384921, -0.0339023, 0.0842905, -0.387934, -0.224604, 0.151393, 0.150466, -0.140424, 0.223322, -0.164364, 0.217574, 0.126651, 0.237391, -0.342017, 0.199281, -0.103294, 0.122004, -0.415564, 0.171573, -0.435148, -0.0542612, -0.0358839, -0.076581, 0.195281, 0.0295329, 0.658212, -0.415993, -0.20821, 0.262104, -0.163806, -0.0701771, -0.0343563, 0.0640541, -0.967628, 0.229937, -0.0145774, 0.355181, 0.0421985, 0.218926, 0.139669, -0.0883887, -0.660994, -0.0560151, 0.000695687, 0.00280935, -0.253515, 0.0289436, -0.213333, -0.556448, -0.0503653, -0.180968, -0.0999205, -0.147815, 0.0896274, -0.119288, 0.221, -0.0588244, 0.0944017, -0.396361, -0.591967, 0.0903225, -0.340656, -0.410737, 0.179103, 0.256222, -0.774406, 0.167006, 0.0584177, -0.394163, 0.43961, 0.0211439, 0.219228, -0.348225, 0.437408, -0.799215, -0.11907, -0.0582753, -0.162067, 0.272474, 0.0537224, -0.105891, 0.0724193, 0.189032, 0.314879, 0.115871, 0.170015, -0.128605, 0.00734307, 0.0102262, 0.0283888, -0.0801819, 0.140687, -0.295715, -0.0622465, 0.207151, -0.331878, 0.0803216, 0.126345, -0.00911318, 0.259374, -0.286443, -0.00601095, 0.0119034, -0.613926, -0.282422, 0.0550092, -0.0144729, -0.166119, 0.163174, -0.356596, -0.118777, 0.276736, 0.269415, -0.323037, 0.176257, -0.183365, -0.153397, -0.7294, -0.0181978, -0.0630184, 0.104621, -0.0901642, -0.270839, 0.218367, 0.248297, 0.432602, -0.156795, -0.209997, 0.320949, 0.0139255, -0.0255703, -0.163949, 0.0688181, -0.99101, 0.300879, 0.125876, 0.601191, 0.197382, 0.28605, -0.107874, 0.0559015, 0.100677, -0.200517, 0.163925, 0.322031, 0.157577, -0.0931565, -0.420442, -0.298957, 0.0534102, -0.0186029, 0.245482, -0.389201, 0.00244173, -0.0341083, 0.126958, 0.0236119, 0.104862, 0.0726111, -0.747841, 0.144426, -0.483708, -0.214538, 0.233403, 0.0541986, -0.542491, -0.0834195, 0.0445847, -0.225305, 0.283301, -0.229363, -0.0254547, -0.354514, 0.265619, -0.520345, 0.0270832, -0.135258, 0.0601855, 0.198474, 0.164658, -0.110426, -0.0076391, 0.130626, 0.1357, -0.140313, 0.218534, -0.137385, -0.0102251, 0.0579074, 0.221365, -0.190235, 0.020417, -0.316404, -0.00678216, 0.320807, -0.0519853, 0.190232, 0.156395, 0.0644643, 0.529939, -0.439618, -0.0405137, 0.0821729, -0.435708, -0.0583624, -0.074021, -0.144136, -0.0726899, 0.0731795, -0.285696, -0.116429, 0.197875, -0.0399115, -0.282028, 0.203633, -0.0904844, -0.11522, -0.469424, -0.0817204, -0.202896, 0.0811699, 0.110799, -0.153139, 0.199779, 0.150505, 0.310432, -0.11731, -0.0513703, 0.286431, 0.00605149, 0.0213803, -0.154604, 0.0987379, -0.39483, 0.0205644, -0.0290409, 0.184706, 0.0632666, 0.428222, -0.290801, 0.0577176, 0.458492, -0.103374, -0.354283, 0.225997, 0.0885108, -0.0172634, -0.219746, -0.0428133, -0.0892343, -0.0740472, 0.206459, -0.0832447, -0.126483, 0.0253862, 0.398913, -0.132966, 0.195186, 0.122996, -0.800506, 0.296542, -0.497822, -0.293001, 0.139695, -0.118301, -0.390441, -0.828537, -0.00732879, 0.117841, 0.0339719, -0.130057, -0.0887898, -0.569982, 0.289944, -0.0818213, 0.0544191, -0.0988357, 0.330849, 0.0973977, 0.130357, -0.0359666, 0.251354, 0.304135, 0.00394945, -0.271779, -0.0885258, -0.111584, -0.249583, 0.0477915, -0.141919, -0.0909646, 0.256448, -0.145218, 0.179853, 0.199921, 0.10848, 0.565691, -0.0231972, 0.0302218, 0.570991, -0.222489, 0.0533022, -0.0730785, -0.219367, -0.129433, 0.000438711, 0.104381, -0.173579, 0.106351, -0.219125, -0.385333, 0.110739, 0.343766, -0.502726, 0.196629, -0.121817, -0.268192, -0.23818, 0.288024, -0.199877, -0.0941924, 0.0409845, -0.0201754, -0.00314311, 0.106368, 0.263793, 0.317407, -0.0028586, 0.0936942, -0.011384, -0.050479, -0.0508389, -0.0976708, -0.367896, -0.0301601, -0.180536, 0.324534, 0.0240061, 0.248653, -0.482445, 0.306049, 0.372071, -0.0788358, -0.0798002, 0.184909, 0.219194, 0.108029, -0.096009, -0.271728, -0.196869, 0.075733, 0.103989, 0.101444, -0.0249458, -0.392511, -0.063852, -0.050329, 0.0775067, 0.230135, -0.732531, 0.103989, -0.625075, -0.0384411, 0.0726363, -0.266887, -0.021358, -1.01247, 0.106018, -0.123844, -0.120726, -0.118098, -0.167799, -0.234698, -0.00492338, -0.128623, 0.36561, -0.085201, -0.0014835, 0.147859, 0.133376, -0.0622751, 0.120311, 0.316838, -0.0519275, -0.385194, -0.065405, -0.106633, -0.335954, 0.00662618, -0.103585, -0.0701991, 0.151027, -0.360429, 0.372793, -0.0370713, -0.102823, 0.395701, 0.148551, 0.0140198, 0.48453, -0.199216, -0.0578754, 0.0114114, -0.204959, -0.0813032, -0.0474288, 0.0619862, -0.0987159, 0.0265027, -0.157432, -0.340683, 0.13486, 0.153678, -0.561927, 0.149213, -0.0817907, -0.0749597, -0.115351, 0.442493, -0.134143, -0.219085, 0.119684, 0.147059, -0.0247479, 0.059237, 0.319928, 0.372525, -0.115517, 0.106155, 0.169654, -0.067425, 0.0775291, 0.0868044, -0.119012, -0.209918, -0.197428, 0.217267, -0.0525982, 0.0637708, -0.397271, 0.0378769, 0.351442, -0.239145, -0.0469482, 0.229754, 0.0404945, 0.131763, -0.265846, -0.413663, -0.245146, 0.118006, 0.129008, 0.203983, 0.13932, -0.24646, -0.0310313, -0.140673, 0.124853, 0.139109, -0.844143, -0.0141827, -0.468967, -0.379199, 0.127843, -0.183011, -0.179624, -1.10533, 0.0257339, -0.101808, -0.0595847, 0.164408, 0.218154, -0.0389058, -0.0675164, -0.216375, 0.235758, -0.144694, -0.155404, 0.0557324, -0.0787552, -0.10285, 0.32283, 0.261275, -0.139338, -0.101015, -0.0647058, -0.0733731, -0.0347576, -0.0665057, 0.113917, -0.277983, 0.0550498, -0.117436, 0.401854, -0.234585, 0.125819, 0.373037}, {0.271145, 0.0222166, 0.495421, 0.0191537, -6.41532e-05, -0.0991028, -0.00111325, 0.193322, -0.195801, -0.0389405, -0.0204302, -0.185986, -0.169666, -0.0270597, -0.00738038, 0.159666, -0.632472, 0.0417144, -0.234207, -0.0479154, -0.0932505, 0.118396, -0.245656, -0.0938028, 0.188021, -0.120331, -0.014573, -0.0212127, 0.353702, 0.556661, -0.251342, -0.136961, 0.218838, -0.0116763, 0.197553, 0.0898981, 0.173274, -0.410572, -0.025011, -0.0118181, -0.0101619, -0.0134467, -0.314702, 0.0367449, 0.266891, -0.121224, -0.354744, 0.0451344, -0.0265426, 0.224993, -0.206857, -0.209292, 0.128779, 0.047466, -0.0786676, 0.0721128, 0.00826761, -0.295016, 0.0522974, -0.203654, -0.0421485, 0.12982, -0.802879, 0.0621021, -0.571607, -0.381913, -0.0357193, -0.176982, 0.00658852, -0.693384, 0.078879, -0.0516953, -0.227953, 0.142623, -0.0345427, 0.301649, -0.240921, -0.102558, 0.2857, 0.216639, -0.0143721, -0.114762, 0.0796961, -0.18384, 0.260563, 0.236178, -0.215221, 0.0438373, 0.110584, 0.114743, -0.0818823, -0.0355142, -0.0387729, -0.0196857, 0.00446432, 0.0806671, 0.544706, -0.788338, 0.351057, 0.664363, 0.299914, 0.140778, 0.594229, -0.255091, -0.0799106, -0.102368, 0.145825, 0.192788, -0.217764, 0.178314, 0.217531, -0.205404, -0.34356, 0.0495619, -0.0493232, -0.162629, -0.557144, -0.130805, 0.21933, 0.014647, -0.220822, 0.430074, -0.151353, 0.032326, 0.194061, 0.0159037, -0.0713541, -0.0330771, 0.000812757, 0.635058, -0.379819, -0.287552, -0.0107567, -0.046418, 0.0316725, 0.221818, 0.408613, -0.986134, -0.237123, -0.00303546, -0.0362524, -0.00580025, -0.200781, -0.158333, 0.299467, -0.226842, -0.572503, -0.532635, -0.0452958, 0.203833, 0.0495009, -0.265025, -0.00736504, 0.0177689, -0.0371222, -0.124694, -0.0410968, -0.134646, 0.15344, 0.00532629, -0.0632828, 0.00564804, -0.691772, -0.278067, -0.75351, -0.307069, -0.843368, -0.362611, 0.154351, -0.861666, 0.0123866, 0.0397922, -0.11208, 0.198013, -0.0370387, 0.428155, -0.24022, -0.0618546, 0.374142, 0.517175, 0.365131, -0.152931, -0.406512, -0.123334, 0.161715, 0.322594, -0.328424, 0.280873, 0.118256, 0.0078033, -0.283189, -0.06577, -0.0192292, -0.162997, 0.217861, -0.202393, 0.591691, -1.04951, 0.326091, 0.376541, 0.269508, 0.279898, 0.26149, 0.0984901, 0.0617725, 0.0837391, -0.054126, -0.155187, -0.329586, -0.257557, 0.0438621, -0.0041484, -0.216716, -0.332008, 0.0241745, -0.143751, -0.506099, -0.261707, 0.0763834, -0.0406849, 0.071646, 0.210364, -0.0291296, -0.140507, 0.0601411, 7.25654e-05, -0.221183, -0.164454, -0.0324083, 0.710778, 0.13011, -0.0341445, -0.146828, 0.00787184, -0.0270425, 0.423225, 0.301386, -1.04702, -0.220263, -0.424102, -0.115086, -0.163718, -0.1352, -0.00664702, 0.267397, -0.0765982, -0.691568, -0.529355, 0.300881, 0.0612176, -0.105448, 0.150567, 0.172315, -0.0647521, 0.0833973, 0.135966, -0.0193999, -0.218866, 0.0915069, 0.152308, 0.26824, -0.110192, -1.03975, -0.221058, -0.685346, -0.348286, -0.976413, -0.305172, 0.327331, -0.779302, 0.203175, -0.0610749, -0.011229, -0.103918, -0.0233798, -0.0748967, -0.14833, -0.034068, -0.0874234, -0.265522, -0.0291627, 0.185303, 0.223138, -0.214649, 0.02551, 0.00724913, 0.271666, -0.190959, -0.198833, 0.122474, -0.185504, 0.0782702, 0.0551528, -0.0247666, -0.0311617, 0.152101, 0.153921, 7.1647e-05, 0.0915948, -0.0392631, 0.12964, -0.0946686, 0.28256, -0.0370391, -0.0411164, 0.140336, 0.117794, -0.144864, -0.136824, 0.108608, 0.0876204, -0.0670353, -0.0179404, 0.179756, 0.219883, 0.141413, 0.00245144, 0.0746111, 0.211745, 0.059254, 0.131019, 0.203978, 0.125148, 0.0361207, -0.0803933, 0.0927249, -0.101198, 0.0331049, -0.0496985, 0.105845, -0.00782705, -0.136177, 0.0687756, 0.0686276, 0.104661, -0.0754291, -0.105777, -0.0747937, 0.0719922, 0.164417, -0.00217396, -0.0307055, -0.0332609, -0.12835, 0.0323806, 0.0418282, -0.0778488, 0.0233253, 0.0134286, 0.00707644, -0.107644, -0.0536264, 0.0682606, 0.0192223, 0.0532664, -0.184071, 0.258036, -0.160441, -0.0557143, -0.0546557, -0.11426, 0.011983, -0.0104545, -0.108911, 0.122127, -0.00513466, -0.0640156, 0.0090717, -0.0136946, -0.0410716, -0.0670727, -0.00320187, 0.017012, -0.0252488, -0.0215483, 0.0277799, 0.014522, -0.0670881, -0.00250886, -0.0570589, -0.0214628, 0.0224679, -0.026296, -0.0186772, 0.0194828, 0.0153571, -0.0434832, -0.0975446, -0.0533509, 0.0295324, -0.00569578, -0.055125, 0.0479341, -0.0506148, 0.00130233, -0.0334169, -0.0116126, -0.0811804, -0.0279724, -0.0801945, 0.0680646, -0.0960321, -0.00134141, 0.0537653, -0.067363, 0.0678466, 0.0649894, 0.0098227, -0.0351376, 0.112171, -0.102029, 0.0543134, -0.0225561, 0.0918071, 0.0105502, -0.0100772, 0.0410376, 0.0513199, 0.0792175, -0.0177816, 0.0101101, 0.109012, 0.0459661, 0.0530746, -0.0529456, -0.0625959, -0.00654876, -0.0677737, -0.0349311, 0.00620158, -0.000153177, 0.0346361, -0.00859946, -0.0649199, 0.00169819, 0.0631681, 0.0185256, 0.0313332, 0.0696416, -0.0180327, -0.0272562, -0.0228504, 0.0148651, -0.0651715, -0.0355691, -0.0131231, 0.0782569, -0.0370995, 0.0362742, 0.0346971, 0.00167171, 0.0767129, -0.00832987, -0.00525787, 0.0353008, -0.0930215, 0.0891478, -0.0468906, -0.0303565, 0.00329841, -0.10958, -0.0204309, -0.0143278, -0.00410494, 0.0305428, 0.0661323, 0.081602, 0.0131065, 0.0310166, -0.0560999, 0.0487194, 0.0746839, 0.0659489, -0.00423308, -0.027631, -0.055384, 0.0499722, -0.018241, -0.0800666, 0.0639938, 0.0229984, -0.0236148, 0.0816953, 0.0477034, 0.065225, -0.0271127, -0.0513402, 0.00172502, 0.0649386, -0.0112056, 0.0700711, 0.00206076, -0.043116, 0.0664493, -0.0151262, -0.0340158, 0.00464604, -0.0556777, -0.047438, 0.0471089, -0.000711203, -0.0192974, -0.00941986, 0.0359432, -0.0327182, -0.00202195, -0.0710224, -0.0407173, -0.0249936, 0.00516799, 0.00421902, 0.0726902, -0.059738, 0.0494296, 0.0536629, 0.0125771, -0.0627521, -0.0564351, -0.076803, -0.0340442, -0.0100003, -0.072032, -0.0601103, 0.0432759, -0.0640663, 0.0354901, 0.0301425, -0.0682754, 0.0663479, 0.052917, 0.0538814, -0.0197569, 0.0619308, -0.0192517, -0.0730242, -0.00308074, -0.0463195, 0.00511496, -0.0679705, -0.0234437, 0.0783367, 0.0767337, 0.0766851, -0.0209218, -0.0507067, 0.0803109, 0.0808701, -0.071514, 0.00670177, 0.058815, 0.000983134, -0.0393804, 0.0531015, -0.0252845, 0.041827, -0.0237733, 0.0623611, 0.0679178, -0.0192976, -0.0268031, 0.00071431, 0.0282168, 0.0718572, -0.0173497, 0.048546, 0.0474246, -0.0110223, 0.0685869, 0.0814374, 0.0750306, 0.0752085, -0.0604037, 0.0140619, -0.0772164, -0.0611958, -0.0813162, -0.0513322, 0.0483778, -0.00624955, -0.0700106, 0.0804945, -0.0356466, -0.0779486, -0.0127742, 0.0316876, 0.0336496, -0.0178181, -0.0295156, 0.0238466, 0.0768847, -0.0596908, 0.0312096, -0.0823081, -0.0277802, 0.0267192, -0.00999264, -0.0105329, 0.0527625, -0.022258, 0.0343444, -0.0345557, 0.0597851, -0.025624, 0.0632625, 0.0681853, -0.0132927, -0.0560254, 0.0663673, 0.0210087, 0.0139676, 0.0147557, 0.00795922, -0.0153039, -0.0319441, -0.0498184, 0.000919722, 0.0438913, 0.0666628, 0.0556189, -0.0476484, -0.0766415, 0.0284232, -0.0341653, 0.0806756, 0.0448769, 0.0410376, 0.0530027, -0.00354292, 0.0229736, -0.0620789, 0.0530863, 0.0111032, -0.0545356, 0.025172, -0.0142057, -0.0566008, 0.0351146, 0.0803516, 0.036917, 0.00278475, -0.0122525, -0.0379354, -0.0432253, 0.053798, -0.0815822, -0.0221425, 0.0743609, 0.0303756, 0.0235979, 0.00805058, 0.0617063, 0.04868, 0.0431968, -0.0272065, -0.0142891, 0.0560872, 0.0757474, -0.0589974, 0.0816213, 0.00375871, -0.0401836, 0.00875787, -0.0728953, 0.0201357, 0.0660814, -0.0605729, -0.0722098, 0.0707247, 0.0819577, 0.0417675, -0.0267772, -0.0742318, 0.0168247, 0.0372139, -0.00184159, -0.0781053, 0.00278901, -0.0562473, 0.0183984, 0.0169021, 0.0198907, 0.0711473, 0.0515296, -0.0417335, -0.0235774, -0.0265564, 0.0388091, -0.00783466, -0.026732, 0.00250892, 0.0565503, 0.0106833, 0.0521632, -0.0574942, -0.0273123, -0.0810922, 0.0774425, -0.0448864, 0.00328851, -0.0128015, 0.037592, 0.0659467, -0.0260746, 0.0302461, 0.00928657, -0.0418821, -0.0780505, -0.0308126, -0.0158534, 0.00649789, 0.026061, -0.0405635, -0.0517709, 0.0445623, -0.0476401, -0.0739426, -0.00372573, -0.0010919, -0.0187403, -0.0189563, 0.0357018, 0.0686654, -0.0597909, 0.0391167, 0.00203379, 0.0228929, -0.0742259, 0.0709676, 0.0477897, -0.00122962, 0.000419892, -0.062957, 0.0536185, 0.0249272, 0.0618108, -0.0590995, -0.0699721, 0.078524, 0.0393067, -0.0493939, -0.0541221, -0.0390041, 0.0522758, 0.0245477, 0.0430931, -0.0201425, 0.0176586, -0.00921091, -0.00454049, -0.00769506, 0.0458018, 0.0609362, -0.01443, -0.0367455, 0.00406432, -0.0747561, 0.0442026, 0.0341262, -0.0589191, 0.00489292, -0.053626, 0.0275854, -0.0590501, -0.025679, 0.0645947, -0.00450087, 0.0348419, 0.00449926, 0.058151, 0.0496964, 0.0206677, -0.0713107, -0.0577486, 0.0405898, -0.0366604, -0.0463547, -0.0575785, 0.0190215, -0.0199358, -0.0437208, 0.00243889, 0.0440257, -0.0195381, 0.0753318}, {0.0213889, 0.00586887, -0.00471369, 0.00415945, -0.0100579, -0.00288632, 0.0624782, 0.0606343, 0.0405918, -0.00383511, -0.0600502, -0.0684058, -0.0363797, 0.0721733, 0.0484143, 0.0753179, -0.018061, 0.0430054, -0.0785318, 0.0310427, 0.0202089, 0.0686844, 0.0341141, 0.00430819, -0.0729741, 0.0311289, -0.0248577, 0.0137818, 0.0104312, -0.056772, 0.0172566, 0.0176201, -0.0286327, -0.0726092, 0.0623673, 0.0754327, 0.082096, -0.0490384, 0.051967, 0.0325636, -0.0423443, 0.0573537, 0.0611092, 0.0456901, 0.0199343, -0.0573405, -0.0406129, -0.0286326, -0.0346183, -0.0428949, 0.0437903, -0.0471768, -0.0368311, 0.0622657, -0.0379646, 0.0266668, -0.0553298, -0.0225909, 0.0214948, -0.0266037, -0.0672377, -0.0805165, 0.0802094, 0.0119381, -0.0131484, 0.00979482, -0.0538236, 0.0788272, -0.00266857, 0.0161963, 0.0252588, -0.03161, 0.0715912, -0.0622508, 0.0644601, -0.0682315, -0.0024431, -0.0111036, 0.00645874, -0.0174398, -0.0747121, 0.0189868, 0.0776702, 0.00430214, -0.0762826, -0.0458772, 0.0567674, 0.0399242, -0.0532943, 0.0374283, 0.0660151, -0.0342144, -0.0324984, 0.0455361, 0.0217974, -0.0764606, -0.0208671, -0.0756776, -0.0215159, -0.0625222, 0.00256927, -0.210639, 0.0486571, -0.10967, 0.036213, -0.0757276, 0.107704, -0.0437978, -0.0709792, -0.0746672, -0.0420214, -0.0878325, -0.0103463, -0.0743026, -0.0765486, 0.0216938, 0.0234037, 0.1024, -0.0115419, -0.0334549, -0.0310904, 0.0787702, 0.00302414, 0.000173749, -0.0632148, -0.0413675, 0.0423119, -0.0816817, -0.04044, -0.154813, 0.0412025, 0.111952, -0.0151783, -0.0111082, 0.0267592, 0.134065, 0.0175889, 0.0534385, -0.0357577, 0.0606205, -0.0561886, -0.15976, 0.0120789, 0.0198956, -0.0342159, -0.0101598, 0.0205306, -0.105167, -0.116137, -0.0391693, -0.101438, -0.0259201, 0.110925, -0.0392893, 0.132015, 0.0563695, 0.0104252, -0.0820456, -0.0112314, 0.0978194, -0.0280083, 0.0831376, 0.0199336, -0.0535005, 0.187443, 0.0350663, 0.0774916, 0.0524173, 0.0175396, -0.0501253, 0.0401929, 0.0160624, 0.00721254, -0.032291, -0.122128, 0.005991, 0.029071, 0.0523137, -0.0636523, -0.145394, -0.0693286, 0.130148, 0.0852719, 0.171477, 0.123106, -0.131836, 0.00409547, 0.0730271, 0.0113548, -0.0126125, 0.0833609, 0.0263028, 0.0124502, -0.0224247, -0.116346, -0.00278955, -0.0558139, -0.15062, -0.188941, 0.0230856, -0.0302678, -0.101711, 0.0376248, -0.102142, 0.14234, -0.107716, 0.10016, 0.0380644, -0.161574, -0.0651106, -0.144932, 0.0313258, 0.109916, 0.0159614, -0.12443, 0.131145, -0.149019, 0.192137, -0.0333077, -0.0609443, 0.0677145, 0.077204, -0.198549, 0.125909, -0.044026, -0.125117, -0.0313568, -0.159958, -0.179582, 0.00165691, 0.118867, 0.0131482, 0.0191263, -0.0150825, 0.0444652, 0.162043, 0.0435, 0.0169229, -0.106657, 0.0283401, -0.00637117, -0.0964408, -0.00934072, 0.11441, -0.0887074, 0.0746516, 0.14085, -0.087533, -0.133089, 0.029745, -0.0883185, -0.00673568, 0.166886, 0.0976604, 0.069586, 0.0101706, -0.0455792, 0.0181518, 0.166869, 0.172178, 0.136711, 0.150682, -0.112432, -0.0507498, 0.119542, 0.0717956, 0.150693, -0.0638176, -0.127469, -0.110606, -0.0111913, 0.00242581, -0.0900256, 0.0310902, -0.22395, 0.0644184, 0.0503745, 0.0912056, -0.0673312, -0.0670705, 0.120639, 0.00839818, -0.0302722, 0.124441, 0.0696221, -0.0449201, 0.150298, 0.101327, 0.0910943, -0.13838, 0.13784, -0.645925, -0.375818, 0.2042, 0.203733, -0.273668, 0.514785, 0.045027, 0.263585, -0.572902, 0.348913, -0.14202, -0.401498, 0.112228, -0.020503, -0.26289, -0.142043, 0.0224239, 0.423842, 0.100547, 0.0479663, 0.0443468, -0.201187, -0.0287725, 0.0423392, -0.0558551, -0.0828758, -0.216944, 0.17925, -0.573527, 0.048257, -0.106876, 0.00638078, -0.122885, -0.269928, 0.0796775, 0.23852, -0.00370658, 0.44361, -0.0171527, -0.0364162, -0.137681, 0.333915, -0.249793, -0.947652, -0.0847212, 0.00182571, -0.419441, -0.820791, 0.0220142, -0.261344, 0.150275, -0.540591, -0.213979, 0.0160493, -0.167423, -0.180313, 0.0511467, 0.262612, -0.0188132, 0.351812, -0.119643, -0.062385, 0.325636, -0.0284695, 0.0254603, -0.277553, -0.0495204, 0.0182654, 0.0745096, -0.190454, 0.464893, 0.218002, -0.358664, 0.211961, 0.0907598, 0.00422892, 0.0360094, -0.390729, -0.971785, 0.143604, -0.314865, -0.171059, 0.355642, 0.294013, -0.305567, -0.22393, 0.20489, -0.0901361, 0.322188, -0.158995, 0.334892, -0.310093, 0.164259, 0.0231534, 0.105345, 0.0685905, -0.074416, -0.00877537, -0.0188571, 0.162896, -0.648151, 0.113148, 0.19423, 0.132572, -0.3473, 0.425258, 0.102075, 0.263405, -0.427569, 0.000556919, -0.167098, -0.506724, 0.0251747, -0.191435, -0.0981784, -0.127296, 0.0145381, 0.173399, 0.262664, 0.0692737, 0.0069232, -0.304413, -0.230372, 0.255711, -0.156599, 0.0556448, 0.00435303, -0.0642789, -0.304198, 0.0235303, -0.0179858, -0.117071, -0.14507, -0.263502, 0.304748, 0.333685, 0.26234, 0.315804, -0.0490848, 0.223427, -0.0987269, 0.389251, -0.317721, -0.653883, 0.0610207, -0.0466608, -0.615682, -0.599016, 0.178121, 0.132609, -0.0522271, -0.386491, -0.11828, 0.0488884, 0.0448453, -0.136317, -0.0687306, 0.390024, 0.0396333, -0.0398063, -0.305281, 0.241884, 0.265537, 0.120199, -0.000519213, -0.234585, 0.0704667, 0.257011, 0.121284, 0.0991678, -0.0284216, -0.115564, -0.0914294, 0.420641, 0.121982, -0.0474478, 0.00608195, -0.32726, -0.938188, 0.0612345, -0.457957, -0.0234225, 0.20538, 0.0832595, -0.305975, 0.0945104, 0.0649014, -0.0529943, 0.0823593, -0.37992, 0.28931, -0.149488, -0.302809, -0.0102063, 0.0562491, 0.0266562, -0.13102, 0.0444514, -0.02298, 0.207024, -0.558114, 0.101347, 0.149869, 0.160966, -0.431113, 0.234408, 0.0900219, -0.00843432, -0.279476, -0.12291, -0.0502288, -0.303568, -0.04207, 0.0406169, -0.109213, -0.16472, -0.0393618, 0.139041, 0.466064, -0.0486724, -0.155427, -0.236673, -0.00362826, -0.0754705, 0.106357, -0.094857, 0.202134, -0.0920789, -0.149776, -0.0517433, -0.0751594, 0.0375323, -0.151018, -0.0606759, 0.088089, 0.203233, 0.198592, 0.0177287, -0.0314847, -0.049425, -0.0315501, 0.0296423, -0.186852, -0.232511, -0.0271168, -0.149438, -0.778625, -0.319661, 0.262739, 0.194639, 0.281369, -0.117805, -0.0860351, 0.136473, -0.12004, -0.247461, 0.154768, 0.466744, -0.0912336, 0.0467781, 0.193716, 0.237159, 0.171125, 0.471215, -0.156112, -0.173861, 0.232333, -0.0192523, 0.00800712, -0.137154, -0.240078, -0.0364548, 0.214391, 0.39263, 0.0816546, 0.00387527, -0.059828, -0.272739, -0.758633, 0.0483003, -0.17455, -0.107366, 0.315775, 0.174083, 0.0235782, -0.0671672, 0.152799, -0.0642676, -0.0147408, -0.476238, 0.174527, 0.0108701, -0.150195, 0.0967878, -0.0439162, -0.0428085, 0.0258086, 0.207907, -0.226479, 0.0237253, -0.553556, 0.294877, -0.058204, 0.148023, -0.53241, 0.308148, 0.126373, -0.0659663, -0.219911, -0.0587719, -0.113945, -0.164955, -0.0909766, 0.13831, -0.0255319, 0.0362363, -0.0189812, 0.146796, 0.455069, -0.121559, 0.00219263, -0.0816491, -0.206822, 0.104045, 0.0159421, -0.193011, 0.187695, -0.118268, -0.0701, 0.0487871, 0.214151, 0.00790074, -0.189405, 0.11746, 0.0100819, 0.16881, 0.157051, 0.0602709, -0.0780152, 0.0531351, -0.0503481, -0.0822076, -0.253392, 0.00457953, -0.0910974, -0.0888981, -0.978375, -0.0438624, 0.254779, 0.190431, 0.101633, -0.112408, 0.00633584, 0.223562, 0.129057, -0.232018, 0.203621, 0.339639, 0.0437866, 0.0932128, -0.032059, 0.080367, 0.138396, 0.400549, 0.173871, 0.153546, 0.18992, -0.202688, 0.0667575, 0.0415252, -0.0276174, -0.124412, -0.00377352, 0.172972, 0.110419, 0.166901, -0.029176, -0.0689861, -0.884017, 0.135838, -0.0133723, -0.0442678, 0.380762, 0.0358694, -0.0866279, 0.0278594, 0.0808285, -0.0471585, 0.0407889, -0.281153, -0.121301, -0.140912, -0.209217, 0.264529, 0.134425, -0.0665891, 0.0591907, 0.163265, -0.0888958, -0.161445, -0.544119, 0.227778, 0.108665, -0.0766215, -0.457289, 0.215723, 0.259763, 0.00986643, -0.353195, -0.0167816, -0.00856588, -0.0867089, -0.208992, 0.00127134, -0.0974759, -0.0846748, -0.0208136, 0.117187, 0.390863, -0.016984, 0.0914849, 0.107813, -0.125595, 0.133221, 0.0538397, 0.0127244, 0.0114262, 0.0116292, -0.190099, 0.0429557, 0.0892947, -0.0183334, -0.343464, -0.00199212, -0.169625, 0.343415, 0.301286, -0.0157754, 0.228528, 0.132323, -0.0809714, 0.0911669, -0.270913, 0.132959, 0.0871639, -0.0298059, -0.60664, -0.0946618, -0.0772163, 0.00342261, 0.0371796, -0.0132595, -0.0832216, 0.276973, -0.0386223, 0.030203, 0.294781, 0.510551, 0.0440708, 0.113124, 0.0228618, -0.00237239, 0.1271, 0.304537, 0.213885, 0.343402, 0.0515966, -0.110861, 0.0228264, 0.00980617, 0.119509, -0.11721, 0.187955, 0.199144, -0.110337, 0.103767, -0.224221, -0.16179, -0.711031, -0.0672422, -0.172129, -0.023492, 0.503538, 0.120749, -0.00702424, -0.213949, 0.0661219, 0.0334703, -0.123324, -0.373981, -0.12462, -0.133614, -0.1575}, {0.179414, -0.103195, 0.0285565, 0.128614, 0.324019, 0.0649339, -0.160824, -0.369475, -0.0207004, 0.143833, -0.000650258, -0.272142, 0.0928611, 0.138622, 0.0298305, -0.272002, 0.0755582, 0.0319241, -0.0767461, -0.157566, 0.211774, -0.0314568, -0.287408, -0.0552132, 0.0997202, 0.285667, 0.255823, 0.1045, 0.154141, -0.0261721, -0.0483845, 0.198538, -0.0377412, 0.161866, -0.0944024, -0.125225, -0.00746258, 0.161197, -0.00581276, -0.138583, 0.29116, -0.12261, 0.374585, 0.183089, -0.0120825, 0.278372, -0.133945, 0.255646, 0.12696, -0.247453, 0.255123, 0.0250607, 0.0634672, -0.00809302, -0.182605, -0.122238, 0.185676, -0.0326668, 0.182821, 0.152587, 0.257221, -0.0289646, 0.148905, 0.263872, 0.332724, -0.0127691, -0.0337914, -0.00470647, 0.0368808, 0.030353, 0.167741, 0.0486938, 0.575119, 0.217102, -0.0906393, -0.102869, -0.0714727, 0.0384907, -0.220467, 0.123892, 0.0418695, 0.0940506, -0.0216843, -0.133376, -0.119185, -0.616775, -0.0130284, -0.232482, 0.00867308, 0.470528, 0.320882, -0.0663424, -0.309865, 0.34038, 0.174285, -0.140878, -0.472533, 0.063179, -0.138835, -0.270214, 0.098495, -0.116916, 0.0385536, 0.28138, 0.410723, -0.0259115, -0.286574, 0.02205, 0.123974, 0.0681674, 0.0158081, -0.0310011, 0.198049, 0.129928, 0.0168968, -0.0270906, 0.00325166, -0.119674, 0.0786888, 0.0299902, -0.00479257, -0.0403403, -0.0233374, -0.0945055, 0.239551, -0.261119, 0.297908, 0.0471629, 0.1354, 0.0191801, -0.132861, 0.161333, 0.146244, 0.0625042, -0.142469, 0.209478, 0.0272277, 0.189424, 0.174461, -0.151063, 0.145382, -0.140945, 0.523613, 0.131441, 0.0850996, 0.329024, -0.228858, 0.224628, -0.0747685, -0.166672, 0.391275, -0.124628, 0.0621054, 0.300496, -0.12955, -0.178889, 0.239806, 0.0576486, 0.147078, 0.319391, 0.328174, 0.0914601, 0.313358, 0.213139, 0.0179404, 0.0351426, 0.170999, 0.17, 0.168223, -0.233288, 0.10206, 0.137013, 0.503126, -0.064906, 0.134563, 0.0254244, -0.0692734, 0.13451, -0.0865767, 0.0502173, -0.0870583, 0.0235628, 0.0408068, 0.04768, -0.179349, -0.519886, 0.0264049, -0.433224, -0.128092, 0.432604, 0.220044, -0.102323, -0.203588, 0.359056, 0.086541, -0.0793179, -0.450083, 0.0606982, 0.0204638, -0.185845, -0.0041867, 0.056218, -0.00311269, 0.313519, 0.447271, 0.00315687, -0.0875495, 0.333837, -0.0262471, 0.108018, -0.0375281, -0.122214, 0.156668, 0.141419, -0.0862167, 0.02048, -0.126632, -0.0395036, 0.159372, 0.0935798, -0.119372, -0.131857, 0.143384, 0.070738, -0.0106167, -0.574609, 0.228743, 0.0272217, 0.114713, -0.0274201, 0.0851615, 0.110871, 0.205118, 0.185808, -0.245499, 0.197986, -0.0869678, 0.101006, 0.201168, 0.00292563, 0.0114676, 0.0219114, 0.320507, 0.227668, 0.0474791, 0.185609, -0.0130591, -0.0981549, -0.334195, 0.25048, 0.113247, -0.0319541, 0.0215291, 0.199963, -0.303368, -0.0981059, 0.246774, 0.116586, 0.230121, 0.412681, 0.214807, -0.0742353, 0.351283, 0.167606, -0.0364476, -0.0786166, 0.186447, 0.271053, 0.210175, -0.207793, 0.297761, 0.0977813, -0.201678, -0.0283675, -0.00832433, 0.0788202, 0.157689, 0.15808, 0.0248437, 0.0885936, -0.52067, 0.0185237, 0.171379, 0.121655, -0.118092, -0.35268, 0.0182041, -0.111796, -0.343475, 0.146691, 0.158636, 0.0530733, -0.12968, 0.152187, 0.090164, -0.0745889, -0.352327, 0.0963261, 0.00189467, -0.181883, -0.547063, -0.299428, -0.184276, 0.2825, 0.461076, -0.190815, -0.117423, 0.339075, -0.0559596, 0.0172716, 0.004405, 0.206374, 0.401, 0.113166, -0.0523459, -0.212746, -0.0354829, -0.0741119, 0.199736, 0.127675, 0.246073, -0.11994, 0.150882, 0.0732936, -0.0342085, -0.273612, 0.0525897, 0.0758889, 0.155892, -0.202468, 0.207598, -0.0907243, 0.364596, 0.0565522, -0.217108, 0.127277, 0.0620609, 0.0570489, 0.164135, -0.016565, 0.0401525, 0.0578799, 0.240316, 0.0165702, -0.124437, 0.231628, 0.0372616, -0.386865, -0.391757, 0.203807, 0.136295, 0.0261698, -0.096847, 0.249625, -0.236941, -0.128027, 0.0648754, 0.00129864, 0.273642, 0.104827, 0.259588, 0.0128265, 0.248186, 0.145217, -0.272169, -0.0823595, 0.231353, 0.0554692, 0.0728041, 0.00615101, 0.141847, -0.102864, -0.559312, 0.125389, -0.0303306, 0.0130251, 0.231806, -0.0572728, 0.137321, 0.150224, -0.5193, -0.0225114, 0.270181, 0.0905027, -0.0355241, -0.233448, -0.0840549, 0.00379534, -0.245942, -0.119524, 0.116678, 0.0443345, -0.0551359, 0.306695, -0.0574934, -0.133542, -0.508638, 0.110268, 0.0849279, -0.184089, -0.617322, -0.0109209, -0.0173565, 0.262114, 0.482076, -0.175036, 0.0057931, 0.535356, -0.156762, 0.153994, -0.043188, 0.302963, 0.356904, 0.17131, -0.0178816, 0.155102, 0.095351, 0.185033, 0.240588, -0.102197, 0.080313, -0.0873579, 0.0353933, -0.0345942, -0.0491037, -0.0985448, -0.103536, 0.0434952, 0.128844, -0.250444, -0.0420244, -0.20154, 0.201388, 0.107534, -0.123493, -0.0973142, -0.0917307, 0.0634749, -0.0270435, -0.0395387, -0.217199, -0.0407709, -0.0216999, -0.111176, -0.062441, 0.207024, -0.0455237, -0.412631, -0.214762, 0.254791, 0.046552, -0.122499, -0.299147, 0.37937, -0.298426, -0.1236, -0.0885641, 0.17387, 0.199777, -0.463219, 0.251663, -0.112531, 0.273209, 0.245771, -0.0489575, -0.0189098, 0.0917059, 0.137567, -0.0783469, 0.222449, 0.0280621, -0.311401, -0.570415, -0.0905962, 0.0687901, 0.112008, 0.0558887, -0.405034, 0.0644829, 0.122428, -0.159084, 0.0965264, 0.234187, -0.0017602, 0.285391, -0.0955058, 0.0403648, -0.0337318, -0.24624, -0.231816, 0.128573, 0.016474, 0.237081, 0.279346, 0.0187345, -0.104849, -0.73217, 0.199625, 0.0601056, 0.0708202, -0.550914, 0.269413, 0.0401765, 0.108768, 0.4617, -0.0817676, 0.0814665, 0.61805, -0.058943, 0.0509702, -0.0174553, 0.0205856, 0.169184, 0.281839, -0.05904, 0.181635, 0.0328504, 0.166201, 0.323661, -0.0129447, -0.173826, -0.0816014, 0.0837308, -0.0372028, -0.0866587, 0.0466267, -0.094403, 0.00704002, -0.0259079, -0.0530886, 0.0844137, -0.391933, -0.052084, -0.175387, -0.406107, -0.0772967, -0.00949854, 0.219246, 0.0609409, -0.116348, -0.17943, -0.0089175, -0.0763945, 0.163748, 0.00887815, 0.246518, 0.0859808, -0.0413807, -0.306762, 0.117932, -0.0136348, -0.0160394, -0.0413597, 0.225222, -0.349613, -0.101122, -0.00579527, 0.0928071, 0.200361, -0.463685, 0.238991, 0.0184361, 0.137788, 0.222228, -0.281285, -0.069582, 0.0653586, -0.0930938, -0.139273, 0.34411, 0.0398602, -0.321098, -0.264219, 0.00685527, 0.131596, -0.126857, -0.501307, -0.437227, 0.0507994, -0.193362, -0.226008, 0.0428504, 0.240476, -0.0170431, 0.19063, -0.19038, -0.00252852, 0.163156, -0.128179, -0.273741, 0.263133, 0.0840451, 0.353359, -0.217489, 0.229852, -0.388451, -0.712095, 0.102151, 0.13959, 0.249008, -0.561883, 0.162248, -0.115407, -0.0836359, 0.482011, -0.104419, 0.274902, 0.599039, 0.0324498, -0.327704, 0.0300843, 0.12257, -0.101653, 0.383029, -0.0764628, 0.0493112, -0.00926075, 0.294882, 0.221235, 0.0534763, -0.188682, -0.120652, 0.110204, 0.00869663, -0.0898629, 0.0504699, 0.0693026, -0.117489, -0.253716, 0.231921, -0.00345836, -0.585831, -0.127514, -0.288375, -0.281266, -0.0396827, -0.0871166, 0.40403, 0.0485761, -0.0595353, 0.0957265, 0.0535281, -0.0547574, 0.289327, 0.14287, 0.133481, 0.0143124, 0.301634, -0.0303301, 0.264798, -0.182367, 0.24078, -0.0911371, 0.298465, -0.401524, -0.0999232, -0.0725243, -0.197046, 0.278261, -0.310256, 0.367028, -0.175075, 0.231823, 0.167326, -0.278358, -0.050511, 0.0809521, -0.0241641, -0.407118, 0.350218, -0.00663842, 0.0856346, -0.159169, -0.0328196, 0.0348529, 0.0198188, -0.666729, -0.0809003, 0.177205, -0.155499, -0.193234, 0.111341, 0.118957, 0.0764732, 0.21471, -0.0644329, -0.260115, 0.116808, -0.134389, -0.181174, 0.295892, -0.0141519, 0.390705, -0.521967, 0.114119, -0.147516, -0.692179, -0.00552593, 0.0438386, 0.160565, -0.71746, 0.201028, -0.179762, -0.379104, 0.21261, -0.175137, 0.246663, 0.105186, 0.0679387, -0.635219, -0.164349, -0.0788388, -0.393732, 0.632218, -0.123976, -0.0091021, 0.0357723, 0.242645, 0.0288299, 0.167586, -0.115654, -0.293656, 0.147556, -0.0497186, -0.165242, -0.253381, 0.000144041, -0.0521613, -0.346037, 0.296214, -0.194183, -0.594846, -0.0973575, -0.315114, -0.140021, -0.017289, 0.052179, 0.436492, -0.44345, 0.220763, 0.0641898, 0.0392402, -0.254628, 0.173485, -0.00963723, 0.0865775, 0.113825, 0.40066, -0.0378164, 0.109665, -0.181033, 0.21335, -0.156164, 0.188027, -0.0662458, 0.0704489, 0.0114999, -0.0323898, 0.252867, 0.0225417, 0.420367, -0.276238, 0.0360002, 0.256919, -0.337979, -0.0682725, 0.0971971, 0.112394, -0.587525, 0.248874, 0.0674875, 0.367371, 0.129011, 0.135606, 0.252543, 0.124493, -0.104711, 0.0599364, 0.176272, -0.0134454, -0.147245, -0.0707333, -0.0368102, -0.186858}, {0.0741549, -0.0522608, -0.156926, 0.00870431, 0.00292333, -0.240818, 0.258087, 0.0628947, 0.0533813, -0.519931, -0.181473, 0.218037, -0.630059, -0.205292, 0.216732, 0.166434, -0.875311, -0.105871, -0.14387, -0.412672, 0.0700719, -0.114426, 0.249688, -0.281709, 0.305909, -0.390136, 0.0116421, -0.112583, -0.133117, 0.724582, 0.0235645, -0.0584725, -0.153852, 0.329961, 0.00573008, 0.115175, -0.0183039, -0.346807, 0.0165084, 0.000964919, 0.23118, -0.224723, 0.107331, -0.188035, -0.334225, 0.299846, -0.281353, -0.322136, 0.131891, -0.0369112, 0.425771, -0.0497381, -0.09565, 0.177923, -0.559233, 0.203016, -0.122904, -8.79725e-05, 0.0668926, -0.0223409, -0.308258, -0.0595641, 0.203432, 0.312024, -0.135547, 0.154736, -0.163428, 0.0972301, -0.398184, 0.282725, -0.0385166, 0.200402, 0.21347, 0.000777367, 0.390134, 0.132892, 0.393081, -0.21874, -0.23835, 0.288488, -0.195277, -0.0970035, -0.144558, 0.296989, -0.591542, 0.25934, -0.0138654, 0.0992913, 0.0971572, -0.0446519, -0.145907, -0.123247, 0.434708, 0.268814, 0.289139, 0.305943, 0.243242, -0.247468, -0.494363, -0.342474, -0.101723, 0.00830404, 0.160685, -0.133114, -0.201012, -0.442667, 0.366611, 0.169027, -0.0366181, -0.184027, -0.585463, 0.508748, -0.748169, -0.310958, 0.265942, 0.174473, -0.779461, -0.706983, 0.0225338, -0.218851, -0.430065, -0.18057, -0.0616711, -0.261789, 0.0815188, -0.102311, 0.181056, 0.0569681, 0.0104406, 0.544296, 0.158712, -0.00162896, 0.00431148, 0.370626, -0.073921, -0.0600466, 0.21295, -0.110922, 0.0260532, 0.00800323, 0.164035, -0.253412, 0.0496297, -0.275905, -0.0142981, 0.154479, 0.0120664, -0.0597894, 0.286288, -0.115163, 0.585392, -0.331319, -0.0429181, -0.04818, -0.104277, 0.0875979, -0.101753, 0.184666, 0.0928957, 0.00786785, -0.29809, -0.0604894, 0.0317889, 0.0886648, -0.257286, 0.0611918, -0.0577394, -0.148892, -0.122842, 0.039187, -0.301356, -0.0548594, 0.12597, 0.233241, 0.185517, 0.111406, 0.109905, -0.244662, -0.163957, 0.00148708, -0.0637212, -0.0105093, 0.0214969, -0.0105259, -0.175976, 0.0576502, -0.216827, 0.0520954, -0.0404461, 0.179359, -0.638984, -0.0939866, 0.610744, -0.019689, 0.102934, 0.00843982, -0.0505793, -0.0539169, -0.315555, -0.226252, -0.214143, -0.0608477, 0.324058, -0.0666991, -0.0978351, -0.293015, 0.361579, -0.0649198, -0.0037757, 0.146626, -0.617492, 0.337457, -0.559338, -0.0754965, 0.0732809, 0.189677, -0.527436, -0.963035, 0.0658079, 0.00265277, -0.614096, -0.31376, -0.0742755, -0.272976, 0.218144, 0.049491, 0.124399, -0.15008, 0.292649, 0.48623, 0.00628687, -0.078075, 0.145506, 0.437656, -0.0420443, -0.104097, 0.116408, -0.0245568, -0.285216, 0.0304274, -0.0162409, -0.157231, 0.0847342, -0.0508099, 0.212442, 0.0200529, 0.116441, 0.171519, 0.254205, 0.03694, 0.644691, -0.0503726, -0.0694336, -0.100392, -0.136874, 0.0497012, -0.127131, 0.150619, -0.159689, 0.335652, -0.0370984, -0.38212, -0.106412, -0.0335945, -0.344255, 0.073251, -0.0821787, -0.206937, 0.16229, 0.0711251, -0.179918, -0.190405, 0.122864, 0.0519186, -0.0305117, 0.192313, 0.126054, -0.0389219, -0.241229, 0.0101269, -0.160143, 0.0470542, 0.0545531, -0.0721753, -0.249079, -0.0899635, -0.217228, 0.232368, -0.00612505, 0.126103, -0.367171, 0.210021, 0.350381, -0.144415, 0.0691127, 0.0279805, 0.154682, -0.147962, -0.202065, -0.256328, -0.355296, -0.0396441, 0.0531458, -0.0636029, -0.0454228, -0.302735, 0.182985, -0.147445, 0.0718518, 0.196008, -0.772751, 0.00362891, -0.629258, -0.108787, -0.0623672, 0.00972287, -0.328281, -0.990299, 0.0139473, -0.122455, -0.361086, -0.0978702, -0.178563, -0.0957973, 0.0808833, -0.117688, 0.303563, -0.137264, -0.181185, 0.380724, -0.0315491, -0.0989972, -0.00375208, 0.388376, -0.115185, -0.179326, -0.0324953, -0.12164, -0.0101293, -0.0481982, -0.0707746, 0.0115274, -0.147449, -0.13867, 0.347488, -0.300251, -0.0192585, 0.07017, 0.127852, -0.0191667, 0.256217, 0.0159694, -0.0472461, 0.113428, -0.115282, 0.0676254, -0.153239, 0.132143, -0.0320398, 0.145064, 0.0892255, -0.223499, 0.00340419, -0.0210223, -0.485668, -0.0916904, 0.050021, -0.0219948, 0.10986, 0.230743, -0.0605595, -0.282973, 0.211535, -0.173197, -0.173712, 0.0376533, 0.354695, 0.286118, -0.306343, 0.0152293, -0.105792, 0.0500443, 0.110066, 0.000205784, 0.0794518, -0.0609038, -0.119952, 0.0521195, 0.135661, -0.0693941, -0.239601, 0.136611, 0.142778, -0.183813, -0.0232315, -0.0214484, 0.206382, 0.0695904, -0.163088, -0.443572, -0.251504, 0.062076, 0.0874172, 0.0834501, 0.0242925, -0.338143, 0.249595, -0.108705, 0.111387, 0.23133, -1.27709, 0.236277, -0.494702, -0.357995, 0.0151442, -0.190618, -0.00127002, -0.852352, 0.0050751, 0.0166985, -0.341974, -0.114026, 0.0712219, -0.0884024, -0.151336, -0.00136773, 0.181623, -0.204504, -0.0905333, 0.148356, -0.0870879, 0.0255522, 0.211825, 0.425936, -0.186235, 0.0098279, 0.221044, -0.0309186, 0.0790802, 0.0587299, 0.0851198, -0.113189, -0.130961, -0.0815015, 0.244717, -0.535999, -0.0577839, 0.134275, 0.298718, 0.0151087, 0.439858, 0.181371, -0.0331561, -0.0066875, -0.06422, 0.0637469, 0.0221016, 0.242033, -0.0100231, 0.0431158, -0.203237, 0.0484574, -0.271567, 0.165959, -0.340954, -0.143935, -0.111244, -0.0936823, 0.0184738, 0.22045, -0.185976, -0.0773725, 0.177662, -0.153023, -0.123301, -0.00194256, 0.424497, 0.408875, -0.307007, -0.234331, 0.0189357, 0.0221319, 0.188212, -0.0464222, 0.0885051, -0.00401511, -0.198952, 0.00475495, 0.14072, 0.140222, -0.277789, 0.123784, 0.21345, -0.434059, -0.069926, -0.221016, 0.226695, 0.176786, -0.196689, -0.175339, 0.116817, 0.171725, 0.0405443, -0.0111027, -0.159121, -0.165667, -0.000526697, -0.128192, -0.0072747, 0.2429, -1.37548, 0.384206, -0.705027, -0.336601, 0.127661, -0.296658, 0.0316566, -0.484317, 0.0802399, 0.0834932, -0.388365, 0.254977, -0.260183, 0.0265533, -0.276415, -0.00234937, 0.297238, 0.185892, 0.0309714, 0.218167, 0.156755, -0.0985671, -0.0529456, 0.166307, -0.160763, 0.0890007, 0.141704, 0.0436796, 0.147278, -0.0329962, 0.251382, -0.0747151, -0.0899788, -0.0603843, 0.480797, -1.18314, 0.229719, 0.0718023, 0.325908, 0.173667, 0.577269, 0.110051, 0.0265696, -0.111734, 0.0943226, -0.0745785, -0.188516, 0.474464, 0.189879, 0.17394, -0.255979, 0.0408655, -0.0262154, -0.115901, -0.220321, -0.0607392, 0.0372041, 0.00525878, -0.00576137, 0.180724, 0.0258801, -0.00171075, -0.0080752, -0.121257, -0.419193, -0.0294092, 0.212823, 0.485518, -0.178244, -0.00818341, -0.114646, -0.0746098, 0.196444, 0.26276, 0.324776, -0.425686, -0.0667144, 0.2761, -0.203252, 0.0328226, -0.394747, -0.0678895, 0.0400591, -0.406883, -0.446591, -0.0415165, 0.0572568, 0.122727, -0.0147088, -0.0566643, -0.137857, -0.0995528, 0.184388, -0.0976497, 0.0621719, -0.03982, 0.0427907, -0.0895808, -0.118529, 0.0675226, -1.74086, -0.166034, -0.609912, -0.316619, -0.243788, -0.455001, 0.233854, -0.583821, 0.213747, 0.121568, -0.325341, -0.0262829, -0.582644, -0.0165829, -0.376477, -0.25852, 0.609997, 0.563522, 0.212544, 0.304078, -0.102432, 0.0382706, 0.126337, -0.122333, -0.419313, 0.385347, 0.450039, 0.105095, -0.138214, 0.0434673, 0.294521, -0.306157, 0.117184, -0.199695, 0.522174, -1.31299, 0.597872, -0.30167, 0.280898, 0.229123, 0.507408, 0.318545, -0.0384945, 0.118312, 0.0365698, -0.486449, 0.0609314, -0.14542, 0.238221, 0.0683565, -0.240882, -0.0971329, -0.0741867, 0.0759016, -0.034871, -0.40502, 0.0980193, -0.207571, 0.0868182, 0.0894928, -0.214233, -0.0776382, -0.24601, 0.0981288, -0.658424, -0.363505, 0.254551, 0.754452, 0.414041, -0.298026, -0.197654, -0.104427, 0.163423, 0.103302, 0.155931, -0.327026, -0.185922, -0.0743827, -0.214117, -0.0556392, -0.260209, -0.0909239, 0.0203612, -0.549187, -0.280611, -0.0362588, 0.298374, 0.0562736, -0.0877878, 0.45034, -0.115952, -0.0123136, 0.16906, 0.0395171, -0.0612433, -0.0355344, -0.165393, -0.0175414, 0.00697346, 0.169264, -2.24332, 0.166653, -0.655421, -0.204736, -0.750587, -0.110076, 0.445653, -0.298056, 0.506753, 0.00902819, -0.0416088, -0.00647125, 0.0339399, -0.0514397, -0.0223039, 0.0284341, -0.0552974, -0.190386, 0.0379171, 0.225398, 0.200925, -0.130957, 0.0750291, -0.0763869, 0.243736, -0.179024, -0.160511, 0.162159, -0.214299, -0.0807881, 0.00138829, -0.0795739, -0.10346, 0.17843, 0.227541, 0.0562741, 0.138373, -0.0100277, 0.108437, -0.0805444, 0.235235, 0.0331803, 0.0156959, 0.119048, 0.167561, -0.186954, -0.0867891, 0.0574196, 0.0502521, -0.172457, 0.0799462, 0.217673, 0.2126, 0.0395106, -0.0463701, 0.00493898, 0.0654115, -0.0804746, 0.0827399, 0.191268, 0.243299, 0.0804488, -0.106774, -0.0182574, -0.0156052, -0.0817893, -0.123389, 0.124492, -0.0620574, 0.0166222, 0.0779175, -0.0133876, 0.0413093, -0.0713404}, {-0.111135, -0.037373, -0.00885921, 0.0494648, 0.0340037, -0.00696534, -0.156435, -0.106074, 0.0359024, 0.0145843, 0.0177659, 0.0938935, 0.0213562, -0.0718943, -0.0553019, -0.00202291, 0.00650818, 0.0181174, 0.0760676, -0.227499, 0.175363, -0.0306155, -0.140411, -0.0209063, -0.142588, -0.0437688, 0.0125531, 0.00238575, 0.105022, 0.0361878, 0.063162, 0.0225229, 0.00481649, 0.0734138, -0.0449356, -0.0546275, 0.048872, -0.00890782, -0.0572433, -0.0546881, 0.0335539, 0.0535039, -0.0408674, -0.0262508, 0.0747957, 0.051391, 0.0145955, -0.0207645, 0.0300865, -0.0461528, 0.0314818, -0.101811, 0.0618256, 0.035031, 0.0219947, 0.0110925, -0.0738661, -0.0198231, -0.0229974, 0.0752074, 0.0202462, -0.0809283, -0.00961142, 0.0412032, -0.00685481, -0.0472607, 0.0443426, 0.0467649, -0.0456494, -0.00216286, -0.0231175, -0.0485771, -0.0336964, 0.0111537, -0.0304804, -0.000884031, -0.0473488, 0.0211196, 0.0873368, 0.0882821, -0.0510601, -0.052309, -0.00558978, -0.0470505, 0.0485622, -0.046005, -0.0109208, -0.0653851, -0.0205137, -0.0371613, 0.00162438, 0.0629732, -0.00289143, -0.0287465, -0.0274202, -0.0303925, -0.00436204, -0.00142594, -0.0130529, 0.0547015, -0.0279618, 0.0716133, -0.0404396, -0.0431205, -0.00212917, -0.0651258, 0.0585719, -0.0271463, 0.0606618, 0.0101292, 0.0464055, -0.0424474, -0.0620586, 0.0240378, 0.00848773, -0.010508, -0.0262281, -0.0122895, 0.0288567, -0.0856739, 0.00130745, 0.0519807, 0.0225159, -0.0594918, 0.0281733, 0.024317, -0.0720613, -0.0484666, 0.0474238, 0.0129281, -0.0390555, 0.0772385, 0.0415418, 0.0389473, -0.00747167, 0.0309339, -0.00223019, -0.0453748, -0.000319541, -0.00068339, 0.0334471, 0.0719975, -0.0538942, -0.0616503, -0.0456865, 0.0557925, 0.00520453, -0.0437258, -0.006801, 0.00466847, 0.0144685, -0.0649795, 0.0101549, 0.00361039, 0.0777055, 0.0509918, -0.015359, -0.0804158, 0.0264298, 0.0195858, -0.0084802, -0.013676, -0.0461697, 0.0492714, -0.0805261, -0.0696117, 0.0453051, 0.0650542, -0.0358646, 0.057505, -0.0207533, 0.0288903, -0.00224045, -0.0471907, -0.0725224, 0.0635711, -0.0508651, 0.0478909, -0.0143304, -0.0722388, 0.013147, 0.0453807, 0.0634038, 0.0802561, 0.0622967, 0.00464447, 0.00368264, -0.035008, -0.0589031, -0.0811669, -0.0323073, -0.0823688, -0.0694555, 0.0335348, 0.050972, -0.0469744, -0.0332454, 0.0437745, -0.0215921, -0.00422515, -0.0478718, -0.0223429, 0.0707461, 0.0755584, -0.0125714, -0.0786229, 5.93215e-05, -0.0823199, 0.0671148, -0.0109811, -0.0794969, 0.0610496, 0.0237519, -0.0737283, 0.00408708, 0.0640908, 0.0204397, 0.0753428, 0.0559858, 0.0132111, -0.0785049, 0.0804878, 0.0211329, 0.0203282, 0.0249533, -0.0817221, 0.0756163, -0.0534119, -0.0149531, -0.0240009, -0.043681, 0.00750636, 0.0706017, -0.0599496, -0.0372847, -0.0345901, 0.0197236, 0.0477658, -0.0452865, -0.0569601, 0.046264, 0.0263053, 0.0695187, -0.0187837, -0.0150384, 0.0674758, 0.0765369, 0.0058198, -0.0634085, -0.032615, 0.0467776, 0.0680463, -0.0154426, 0.0319101, 0.00822196, -0.080625, -0.0760919, 0.0135466, -0.00884328, 0.0524109, -0.0674409, 0.0225246, -0.062535, -0.0697892, 0.0799353, 0.0128259, -0.0313762, -0.0276593, -0.0362196, -0.0591541, -0.0519892, -0.0114483, -0.0255933, 0.0795472, 0.0576108, -0.0404718, -0.0296475, 0.0693482, 0.0101801, 0.0244506, 0.0631465, -0.0755059, 0.0130575, 0.0716605, 0.00224667, 0.0727887, -0.0745252, 0.00736745, -0.0496354, 0.0495105, 0.0415723, -0.00486417, 0.077396, -0.0365645, -0.0778653, 0.0815377, 0.0378463, -0.0543424, 0.00251006, -0.0238901, 0.0579073, 0.0559232, 0.0129169, 0.000846423, -0.0293035, -0.0182838, 0.00425161, 0.00874073, 0.0318401, 0.0455111, 0.00303167, -0.0494485, 0.0314141, -0.00747943, 0.0422708, -0.0167695, -0.0603302, -0.0238682, -0.0797803, 0.0545843, 0.0272232, 0.0113221, 0.00758184, 0.0775488, 0.0269918, 0.00681395, 0.0262998, 0.00292131, 0.0439511, -0.00678965, 0.0253993, 0.0587455, -0.0678374, 0.0769618, -0.068466, -0.0341981, 0.038083, 0.0236552, -0.0481009, 0.0727057, -0.0748371, 0.0781598, 0.0802648, -0.0278007, -0.00360328, 0.00699085, -0.00960819, 0.0244859, 0.054168, -0.0514313, -0.013869, 0.0420975, -0.0285582, -0.073059, 0.0460804, 0.0158245, -0.063777, 0.00680035, 0.0820768, -0.0721839, -0.0179635, -0.0325885, 0.0224722, 0.00860288, -0.00621999, -0.0754124, 0.000299625, 0.063157, -0.0402068, 0.0190383, -0.032292, 0.0211175, 0.0475944, 0.0355665, 0.0585096, 0.0120077, -0.0647069, -0.00304057, 0.0227107, 0.0193583, 0.0772529, 0.0374768, -0.0639675, 0.0503489, -0.0122722, -0.0154438, 0.044987, -0.0275326, -0.00363502, -0.0225021, -0.0731432, -0.067362, 0.0416203, -0.0573297, -0.014542, 0.0368484, -0.0189115, 0.047734, -0.0725157, 0.02442, 0.0186487, 0.012212, 0.0635435, -0.0734705, -0.051892, -0.00273988, 0.0525789, 0.0580933, 0.053464, 0.00220571, 0.0563445, -0.050784, -0.0359988, -0.000120252, -0.000493728, -0.0511516, 0.0520091, -0.00415137, 0.070496, 0.0662001, 0.015124, 0.0340445, -0.0372248, -0.0708849, -0.0248454, 0.054028, -0.0819623, -0.0178773, -0.0504451, -0.0171559, -0.0675041, 0.0034136, 0.00708083, 0.076355, 0.0732684, 0.00761026, -0.0292194, -0.0707886, -0.0799192, 0.00739928, 0.0654752, 0.0571291, -0.00524395, 0.0530543, 0.0388467, -0.030025, 0.0371401, -0.0813059, 0.0354794, -0.0299525, 0.00347102, 0.0740536, -0.0144738, -0.0116783, -0.0269563, -0.020647, -0.0539562, 0.0185175, -0.00793332, -0.0726247, -0.0161942, 0.0568947, -0.0290484, 0.00606272, -0.0584073, 0.0267512, 0.032465, -0.0491569, 0.0137085, -0.0380572, -0.0133968, -0.0805928, -0.0292974, -0.0451757, -0.0821096, 0.0422632, -0.0035218, -0.0595766, -0.0258042, 0.0414538, 0.0203029, 0.0503592, -0.0201514, -0.0058342, -0.075571, -0.0401014, -0.0803383, -0.0806237, 0.0281944, 0.000883386, -0.0112381, -0.0467912, 0.0246919, 0.0680821, -0.0757639, 0.00814836, -0.0707899, 0.0337135, -0.0486514, 0.0698789, -0.0586623, 0.0240983, 0.0635564, 0.0794762, -0.0393928, 0.0241334, 0.0167678, -0.0740934, -0.020686, -0.00993044, -0.00897351, 0.0297254, 0.0390137, 0.0593586, -0.0303745, -0.00974002, 0.0425599, -0.0113102, 0.0493058, -0.0523759, -0.0813185, 0.0375814, -0.0698814, 0.0364042, -0.037084, -0.0635539, 0.0163539, -0.0518091, 0.0658483, 0.0746787, 0.0139295, 0.0695678, -0.0150714, 0.0299991, -0.074156, 0.0762466, 0.0106872, -0.0101749, 0.0617856, 0.0796689, 0.00675406, -0.106452, -0.00102186, -0.00350277, 0.0453386, -0.0364876, -0.0376376, -0.0771476, 0.0827352, -0.22272, 0.0223869, -0.104347, -0.0255526, -0.0448339, 0.127967, 0.0258351, -0.0818085, -0.104042, -0.102778, -0.00635949, 0.136873, 0.0475473, -0.0632989, 0.00655692, -0.0876387, 0.192452, 0.0512924, -0.0269001, -0.0761057, 0.105357, -0.112272, 0.0345572, -0.00278365, -0.0741913, 0.0249692, -0.159409, -0.0885807, -0.0492134, 0.116839, 0.0603619, -0.00522066, -0.0478324, -0.0123647, 0.175513, 0.0433726, -0.021791, -0.00481425, -0.0290859, -0.0800516, -0.171929, -0.00721394, -0.0247292, 0.0710069, 0.0796521, -0.0148276, -0.116321, -0.143067, -0.0733522, -0.0972673, -0.0167671, 0.125998, -0.0522025, 0.00172719, 0.0430683, 0.0139949, 0.0570959, 0.0873857, 0.111085, -0.00449049, 0.197441, -0.0142394, -0.0566754, 0.126322, 0.126027, 0.074417, 0.121706, -0.0637128, -0.104659, 0.0929921, 0.0230871, 0.0125254, -0.0436263, -0.141175, 0.017955, -0.0338992, -0.0287246, -0.0682449, -0.118976, -0.0162911, 0.147116, 0.173069, 0.11522, -0.00622499, -0.0678752, -0.014975, -0.019349, 0.00218527, -0.139145, 0.0492739, -0.00403611, -0.0138879, 0.0596517, -0.146275, -0.11112, -0.0241967, -0.129811, -0.0163339, -0.0476019, -0.0662544, -0.248831, -0.0441917, -0.0829858, -0.0215314, 0.0052627, 0.180119, -0.0696601, -0.107387, -0.021446, -0.048357, 0.00469876, 0.0380081, -0.147181, -0.136723, 0.214229, -0.0344279, 0.212838, 0.0423772, 0.00886436, 0.070742, 0.0434495, 0.00977779, -0.0254401, 0.0745376, -0.0635441, 0.0617586, -0.0830893, -0.18213, 0.0972317, 0.0410066, 0.0160317, 0.0155002, 0.00899456, -0.0261702, 0.174786, 0.0717388, 0.0531546, 0.0344489, -0.0441489, -0.114011, -0.0137442, 0.015006, 0.0521518, -0.154647, -0.0139444, 0.0534762, -0.169685, -0.158739, 0.0635892, -0.0424262, -0.0780009, 0.0607235, 0.135976, 0.146506, -0.00192316, -0.0458461, 0.0327043, 0.153867, 0.125032, 0.0437205, 0.138928, -0.0855351, -0.11367, 0.0968627, 0.109669, 0.077703, 0.0233996, 0.0118398, 0.0130327, 0.0949001, -0.0230562, 0.0810162, 0.0372026, -0.104992, -0.0488599, -0.016616, 0.0776736, -0.0290566, -0.0606303, 0.122877, 0.0758452, 0.000364321, 0.220369, 0.145476, -0.161732, 0.0553026, 0.0498344, 0.291107, -0.328132, 0.15316, -0.340477, -0.00992523, 0.0742745, 0.35291, -0.311953, 0.674584, 0.0565875, 0.197355, -1.50159, 0.421919, -0.223331, -0.609628, -0.109547, -0.262926, -0.215785, -0.253475, -0.0412747, 0.0606406, 0.225104, 0.123299, -0.0274273, -0.394323, -0.267099, 0.108236, -0.0953071, -0.44397, -0.29111, 0.0157374, -0.524001, -0.051325, 0.0282852, 0.0468433, -0.232615, -0.304497, 0.0616142, 0.277297, -0.395475, 0.584325, -0.017274, -0.168573, 0.0493872, 0.199111, -0.0224484, -0.65248, -0.049638}, {0.0166779, -0.5607, -0.747119, -0.113034, -0.140076, -0.0506618, -0.41988, 0.0518632, 0.166485, -0.131728, 0.0706607, 0.11531, 0.312752, 0.00155166, 0.237666, -0.0101338, 0.0707246, 0.329251, 0.259915, 0.358675, -0.016367, -0.307808, -0.0759361, 0.288735, 0.0693418, 0.374352, 0.348554, -0.0765083, 0.217643, 0.220696, -0.20326, 0.245123, -0.569736, -0.627899, -0.0335157, -0.240865, -0.199443, 0.214442, 0.0799942, -0.213931, -0.00563766, 0.200645, 0.0246212, 0.208842, -0.12632, 0.00148584, -0.0908333, 0.279559, 0.200872, 0.142679, 0.145507, -0.337981, 0.271906, -0.320602, 0.112141, -0.428065, 0.0656191, 0.126441, 0.139719, -0.458076, 0.398111, 0.196539, 0.0960394, -1.16917, 0.415148, 0.0905346, -0.486005, 0.110729, -0.124512, 0.0107416, -0.364766, -0.0861705, 0.00207196, 0.375589, -0.00864705, -0.131349, -0.461169, -0.167806, 0.2258, -0.024303, -0.292206, -0.191955, -0.18037, -0.321461, 0.0570453, -0.120792, 0.0138786, -0.11376, -0.514416, 0.141766, 0.0578458, -0.0919861, 0.309982, -0.218243, 0.178265, 0.0264668, 0.268878, 0.00894184, -0.332327, 0.0230628, -0.0982451, -0.883852, -0.194585, 0.144837, 0.262802, -0.00480575, -0.188147, -0.103371, 0.294448, -0.173892, -0.164865, 0.274385, 0.369565, -0.0653051, -0.149664, 0.136595, 0.0645317, 0.183221, 0.194846, 0.225045, -0.309104, -0.387246, 0.123993, -0.031157, -0.0919293, 0.159576, 0.0970415, 0.154499, 0.425893, 0.264317, -0.00749293, 0.252103, -0.515948, -0.634234, 0.0263691, -0.0865688, -0.197664, 0.134376, -0.131353, -0.0729357, 0.155417, 0.0619844, -0.00756356, 0.0673393, -0.172742, 0.095372, -0.158041, -0.0270702, 0.0769925, 0.147069, -0.221181, -0.215987, 0.347439, -0.257824, 0.154228, -0.388001, -0.013264, -0.00438133, 0.0810207, -0.438235, 0.318937, 0.141527, -0.089909, -0.742155, -0.0641363, -0.0591984, -0.196022, -0.193531, -0.116875, -0.00354749, -0.0532094, -0.0375574, -0.0968967, 0.345786, -0.159916, 0.0361476, -0.147617, -0.106898, -0.147316, -0.0679464, -0.141326, -0.00188561, -0.234852, -0.0620366, -0.0844945, 0.0436193, 0.130439, -0.0487562, -0.186311, 0.0281516, 0.12846, -0.0454324, 0.00374804, -0.122666, 0.079847, 0.204031, 0.0582009, -0.181388, -0.0753553, 0.0387266, -0.125382, -1.07678, -0.0901452, 0.252654, 0.233815, 0.11459, 0.249217, -0.00403114, 0.11014, 0.022721, -0.0857542, 0.127078, 0.400865, -0.0781138, 0.0605568, 0.234787, 0.0393507, 0.110523, 0.422519, 0.092322, 0.0974334, -0.182254, -0.187164, 0.155217, -0.14412, 0.00877141, 0.0816696, 0.270672, 0.181534, 0.107361, 0.0273479, 0.0631655, -0.27918, -0.137726, 0.162216, -0.0321838, -0.0802761, 0.220252, -0.0196789, 0.0154581, 0.190358, 0.0145706, -0.0655511, -0.0943612, -0.30257, 0.037856, -0.126964, -0.0349561, 0.110883, 0.0150951, 0.0387399, 0.0379524, 0.246885, -0.278917, 0.0924335, -0.719383, 0.0693555, 0.0677636, 0.0748161, -0.496705, 0.282163, 0.279986, -0.0364844, -0.722091, 0.0208731, -0.105765, -0.0243502, -0.21423, 0.012187, 0.0631611, 0.0788587, -0.03197, 0.19053, 0.230322, 0.0289671, -0.14935, -0.260005, -0.327409, 0.184372, 0.137256, -0.0131439, 0.0763143, -0.130991, -0.161841, -0.0461831, 0.0946952, -0.00196785, -0.24995, -0.16073, -0.0528292, 0.22773, 0.0603317, -0.0679043, 0.0955269, 0.12506, 0.215145, 0.0328067, -0.40959, -0.0775656, 0.0419508, 0.0196914, -1.06978, -0.112969, 0.226206, 0.114966, -0.00771837, 0.161584, -0.0822152, 0.313699, 0.0147056, -0.0755378, 0.247222, 0.473261, 0.033889, 0.182695, 0.00378958, 0.202633, 0.00509803, 0.286971, 0.0624183, 0.258971, -0.208131, -0.105697, -0.0467169, -0.0219643, 0.103648, 0.190552, 0.090297, 0.0303288, 0.0543213, -0.237978, 0.16034, -0.0896712, -0.0589931, 0.203127, -0.194316, -0.0724318, 0.296113, -0.202699, -0.149638, -0.0750157, 0.201127, 0.0795367, -0.155688, -0.0586427, -0.224291, -0.0901161, -0.22153, 0.234025, 0.0242277, 0.0886368, 0.227365, 0.0490446, -0.347314, -0.179863, -0.772688, 0.0893429, 0.188025, 0.11377, -0.216463, 0.187008, 0.289037, -0.0809669, -0.386175, -0.0473302, 0.118751, -0.155111, -0.0746654, 0.0891352, 0.0373838, -0.0972361, -0.0377133, 0.169398, 0.365133, 0.337699, 0.064127, -0.123992, -0.218008, -0.105644, 0.0932082, -0.0397846, 0.0586588, -0.0462448, -0.226795, -0.000533328, 0.16144, -0.0444491, -0.108981, -0.0363454, -0.294521, 0.205485, 0.00940295, -0.172153, 0.1066, 0.0657902, 0.123936, -0.0731986, -0.366005, 0.104874, -0.0941622, 0.100761, -0.444428, -0.233433, -0.17992, 0.154657, -0.0557837, 0.137853, -0.0345551, 0.141388, -0.0606647, 0.234093, 0.273619, 0.218403, -0.0846725, 0.00408459, 0.206271, 0.235229, 0.0969484, -0.010309, 0.14908, 0.562456, 0.0581525, -0.18587, 0.0734504, 0.0979184, -0.0013438, -0.0845953, 0.251505, -0.0884109, -0.0456092, -0.19957, 0.0627813, -0.0807109, -0.0127298, -0.115573, -0.180614, -0.142065, 0.651576, 0.120269, -0.0574657, -0.0743931, 0.300886, 0.0603011, -0.0324825, -0.347309, -0.178769, -0.137096, -0.20609, 0.127824, 0.045701, 0.0819305, 0.127897, 0.211238, -0.0182605, -0.264187, -0.560038, 0.111692, 0.266285, 0.103438, -0.349619, -0.0514605, 0.327802, 0.0493178, -0.336943, 0.00843929, 0.0621376, 0.0496941, -0.0299817, 0.151373, -0.0781472, -0.0466223, -0.0882192, 0.158743, 0.135761, 0.251241, -0.0462118, -0.061858, -0.0502654, -0.145526, 0.0723099, 0.019012, 0.241367, 0.162547, -0.10375, -0.058268, 0.0161869, 0.0541048, -0.131108, -0.0507664, -0.149472, 0.437077, -0.0373859, -0.0267281, 0.10353, -0.0375986, 0.1137, -0.134919, -0.387182, 0.241711, -0.0388518, -0.064783, -0.0109401, -0.0927993, -0.343268, 0.23618, 0.0965255, 0.108765, -0.0823449, 0.179557, 0.102135, 0.451799, 0.205933, 0.10911, -0.0173066, 0.124811, 0.0399341, 0.104435, -0.0364605, 0.0181396, 0.0986837, 0.613262, 0.0764813, -0.257816, -0.00230348, -0.182855, -0.0207765, -0.153867, 0.253115, 0.105832, -0.0392439, -0.207321, -0.0756291, -0.0812801, -0.24283, 0.026486, -0.206477, -0.137661, 0.512969, -0.00866451, 0.0768071, 0.00622117, 0.256762, -0.00146813, 0.140274, -0.319733, -0.141391, 0.0762176, -0.0428601, -0.00388218, 0.262783, 0.179951, 0.333382, 0.261767, 0.0399628, -0.450062, -0.251128, 0.0811549, 0.0629841, 0.0394501, -0.267449, -0.028621, 0.422493, -0.167412, -0.049048, -0.032691, 0.0206804, 0.274325, 0.187065, -0.00912756, -0.108827, 0.0396081, -0.083668, 0.156413, -0.169604, 0.268792, -0.147436, 0.149628, -0.0124865, 0.0755032, 0.166856, 0.213922, 0.193517, 0.00140476, 0.0749915, 0.0635635, 0.160966, 0.170028, -0.299777, 0.00546587, -0.0492669, 0.361322, -0.112698, -0.18781, 0.369156, -0.0206842, -0.0435051, -0.362885, -0.352457, 0.0927142, -0.117788, 0.141292, 0.380754, -0.262156, -0.209506, 0.310748, 0.160698, 0.128287, 0.180815, 0.169503, 0.0418831, 0.576556, 0.220685, -0.121909, 0.018471, 0.21178, 0.207857, 0.280748, -0.299806, 0.0268154, -0.0321343, 0.255434, -0.246666, -0.186702, 0.183282, -0.141767, -0.104438, -0.0915303, 0.137098, -0.264814, 0.128265, 0.0137217, 0.0728438, -0.17777, -0.153606, -0.0174306, -0.144661, -0.103953, 0.453364, 0.130165, -0.0803844, 0.00232145, 0.108813, 0.0777505, -0.00863757, -0.326167, 0.0303244, 0.0334946, -0.246607, -0.225644, -0.0101301, 0.112335, 0.292871, 0.346424, -0.118012, -0.396314, -0.0320329, -0.134729, 0.0904038, 0.110273, -0.126221, 0.0192533, 0.342065, -0.165333, -0.0264631, -0.058797, -0.128824, 0.295296, 0.056823, 0.0251131, 0.0272564, 0.118275, 0.0240833, -0.030616, -0.248061, 0.0565395, -0.114413, 0.141138, -0.0509332, 0.210925, 0.140862, 0.187597, 0.235679, 0.0606612, 0.0431343, -0.0946312, 0.00993897, 0.110302, -0.12039, 0.0821337, 0.0492583, 0.338877, 0.0492379, -0.301881, 0.257032, 0.0958909, -0.199436, -0.471008, -0.272767, 0.120945, -0.135706, 0.156051, 0.40984, -0.381997, -0.19495, 0.20221, 0.15006, 0.111513, 0.207574, -0.00953256, 0.000967506, 0.414211, 0.119582, -0.174082, 0.0189086, 0.105321, 0.128561, 0.16854, -0.187005, 0.145816, -0.134598, -0.615984, -0.210161, -0.275947, 0.207601, 0.0814813, -0.133286, -0.130567, 0.0398113, -0.592813, 0.0103562, 0.275229, 0.0507939, -0.0498471, -0.0581387, -0.0266631, 0.204272, -0.212778, 0.266333, 0.0612024, -0.0273324, 0.109003, 0.193605, -0.0271783, 0.0369847, -0.304199, 0.169078, 0.141952, -0.37409, -0.706145, -0.0634053, 0.0474882, 0.248583, 0.353517, -0.160633, -0.0498903, 0.301547, -0.161938, 0.00977451, 0.00532024, 0.0549144, 0.350916, 0.41784, -0.242127, -0.029901, 0.065469, -0.0178547, 0.149973, 0.00570974, 0.234882, -0.0237276, -0.0755216, 0.0151715, -0.134882, -0.151623, -0.0645255, -0.0197571, 0.0574329, -0.242594, 0.156925, -0.0491661, 0.166797, 0.116019, -0.0755613, -0.0308535}, {0.0321966, 0.142698, -0.000619746, 0.0377709, 0.128889, -0.0874629, 0.193445, 0.100052, -0.325644, 0.0891561, 0.215287, -0.628263, -0.222535, 0.128242, 0.0340964, -0.0260534, 0.0953107, 0.162157, -0.157245, -0.0654999, 0.0444358, -0.111302, 0.312683, 0.122523, 0.114829, -0.158837, 0.20151, 0.225023, -0.0354125, 0.00818379, 0.0999044, 0.0762913, 0.260333, -0.0124997, -0.0129269, -0.103576, -0.548094, -0.0670637, -0.148231, 0.0365853, 0.0792365, -0.192652, -0.0606317, -0.0387591, -0.282699, -0.156914, 0.290272, 0.268688, 0.0670782, -0.0984299, -0.0643967, 0.429676, -0.30379, -0.158914, 0.041372, -0.0199514, 0.131447, 0.26085, 0.0578008, 0.183219, -0.385031, 0.21878, 0.10262, -0.344027, -0.673718, 0.237491, 0.168873, 0.400163, 0.2054, -0.0479484, 0.0858973, 0.394864, -0.167483, 0.156895, 0.0387957, 0.209165, 0.391749, 0.544969, 0.0655273, 0.0121554, 0.166483, 0.0142292, 0.240005, -0.0169717, -0.111418, -0.0460929, -0.0935483, -0.102895, 0.00758832, 0.0821446, -0.0536945, -0.00279195, 0.0259621, -0.267565, -0.0463741, -0.0828049, 0.0263901, 0.0518116, -0.0329494, -0.275492, -0.0606747, 0.112115, 0.0436244, -0.07115, 0.0639365, 0.0602903, 0.233673, 0.149604, -0.0872215, 0.209001, 0.190334, -0.264247, 0.0940378, 0.0683199, 0.0892143, -0.0640993, -0.0370387, 0.20524, -0.053703, -0.130559, -0.13151, -0.00308825, 0.142967, -0.119041, 0.209248, 0.0972525, 0.0908865, 0.243622, 0.0481243, -0.00698223, 0.0925351, 0.0216364, 0.348021, 0.246823, -0.0933606, -0.226017, -0.183572, -0.3079, 0.067907, -0.0487246, -0.00831707, -0.265566, 0.0637604, 0.0830324, -0.156126, 0.0244307, 0.122589, 0.24279, 0.139988, -0.00478356, -0.00694167, 0.39286, -0.203018, -0.0542212, 0.0272665, 0.0416618, 0.41647, 0.318954, 0.0566363, -0.00385013, -0.473078, 0.141137, -0.0566382, -0.358598, -0.515127, 0.159868, 0.228004, 0.336497, 0.0849269, -0.013737, 0.171744, 0.415275, -0.194214, 0.0382497, -0.0276884, 0.251027, 0.249808, 0.579942, -0.135145, -0.173219, 0.200391, 0.150061, 0.30059, -0.327402, -0.0517255, -0.0442483, -0.0222931, -0.0822536, 0.211918, 0.0211225, 0.0331532, 0.156831, -0.138265, 0.291908, 0.12686, -0.39249, -0.00761164, -0.073333, -0.06096, -0.171306, -0.0975632, 0.327868, -0.257064, -0.0546475, 0.164476, 0.0325852, 0.126344, 0.129261, 0.0850225, 0.281133, 0.342859, 0.134374, -0.079105, -0.0403744, -0.0908487, 0.0944852, 0.288818, 0.105594, -0.163835, -0.283234, -0.0257888, -0.0841066, 0.158986, -0.372151, 0.1471, 0.0558066, 0.126815, 0.248536, -0.203921, 0.00653436, 0.101218, -0.0634018, 0.376903, 0.432696, -0.0600523, -0.159814, -0.0630443, -0.0242162, 0.151114, 0.16899, -0.432903, -0.195266, 0.0028413, 0.129452, -0.0239009, 0.19315, 0.0492192, -0.119479, 0.253106, -0.117954, -0.213699, 0.38727, -0.109552, -0.116141, 0.194859, 0.175607, 0.39275, 0.0142931, 0.366537, -0.213655, -0.260646, 0.0801317, 0.0333721, -0.188693, -0.545416, 0.109318, -0.0120038, 0.200771, -0.0837765, -0.178146, 0.252545, 0.346555, -0.00976998, -0.306799, 0.0138831, 0.227904, -0.211786, 0.50367, -0.154977, -0.169298, 0.0496605, 0.199373, 0.13539, -0.0317722, -0.152407, -0.242817, 0.153247, -0.0847598, 0.194206, 0.139034, 0.0392689, 0.128501, -0.157197, 0.445398, 0.126062, -0.665874, 0.10587, -0.251465, -0.107106, -0.105827, 0.00755028, 0.496276, -0.0923547, 0.110292, 0.0991703, 0.122891, -0.1142, 0.186178, 0.260791, 0.319557, -0.088344, 0.300033, 0.0348936, 0.131282, -0.046784, 0.104912, 0.280302, 0.109011, -0.157682, -0.199333, -0.0200422, -0.266304, 0.427393, -0.0663138, 0.117148, -0.0743516, 0.0307636, 0.0770631, -0.166414, -0.0325675, 0.218288, 0.013653, -0.0496913, 0.40525, -0.0244334, -0.0134815, 0.11446, -0.174574, 0.0128709, 0.344229, -0.206267, 0.208092, 0.143992, 0.0400125, -0.122912, 0.25266, -0.0472031, -0.102265, 0.16772, 0.00389649, -0.301122, 0.140202, -0.104846, -0.0462449, 0.311104, -0.044103, -0.113535, -0.436206, 0.332262, -0.142311, -0.127224, 0.195732, 0.199147, -0.0981206, -0.559622, -0.172476, -0.12548, -0.548559, -0.434541, -0.133334, 0.409863, 0.22391, 0.0161582, -0.488766, -0.0734325, 0.0113329, -0.39032, 0.538588, -0.247996, 0.0811674, 0.0382234, 0.140342, -0.0458714, 0.14366, 0.148371, -0.291811, 0.253707, -0.0790492, 0.151259, -0.0155705, 0.0886365, 0.0703229, -0.276706, 0.279467, 0.202051, -0.830531, 0.0633153, -0.285541, 0.217898, 0.0852902, 0.00678424, 0.384576, -0.265835, 0.283232, -0.111515, -0.279255, -0.196262, -0.0507268, 0.139509, 0.180227, -0.0637487, 0.247606, -0.0695262, -0.0594591, 0.119749, 0.257455, 0.122251, 0.110844, -0.0625835, -0.155587, 0.193529, 0.0461121, 0.30894, 0.0523003, 0.326974, -0.246158, 0.0258013, 0.3279, -0.270153, 0.0222839, 0.209117, 0.0399501, -0.0561999, 0.182711, -0.0501337, 0.0559158, 0.140796, -0.133013, 0.0421934, 0.283276, 0.0797013, 0.228184, 0.0102316, 0.0768418, 0.0605967, 0.106251, -0.117876, 0.0279523, 0.169709, -0.124612, -0.223396, 0.0311959, -0.171302, -0.241085, 0.547886, -0.0760166, -0.378639, -0.393381, 0.146543, 0.157534, -0.247117, -0.0511384, 0.250742, -0.230504, -0.743298, -0.618651, -0.304157, -0.409938, -0.487783, -0.00442643, 0.158357, 0.0313264, 0.0028686, -0.181489, -0.126227, -0.0404807, -0.386814, 0.790394, -0.0800392, 0.0643652, -0.115952, 0.0913831, -0.0119857, -0.00388517, 0.127558, -0.251801, 0.0418606, 0.0563754, 0.273465, -0.26624, 0.0161929, -0.00672586, -0.194618, 0.0685895, 0.120978, -0.562148, 0.250085, -0.160794, 0.398848, 0.112478, 0.00355433, 0.10639, -0.267288, 0.39231, -0.0646386, -0.368851, 0.0118581, 0.0803636, -0.0904197, -0.0506958, 0.111983, 0.317368, 0.119954, -0.00931027, -0.0493992, 0.0374856, -0.263972, 0.0274887, 0.0834523, 0.00306153, 0.321805, 0.221112, 0.197553, 0.085806, 0.230983, -0.262761, -0.212786, 0.299155, -0.196891, 0.0165588, -0.14577, -0.0156557, -0.0347118, 0.000671139, -0.0357443, 0.129337, 0.0623942, -0.287952, -0.621248, 0.144716, 0.272473, 0.0746657, 0.262865, 0.224516, 0.202331, -0.112628, -0.0839063, -0.179116, 0.0516859, 0.0651484, 0.0972247, 0.0666157, -0.14626, -0.240379, 0.309683, -0.080704, -0.0976059, -0.0404757, -0.0013871, 0.519482, -0.144202, -0.114946, 0.00998515, -0.161925, -0.501821, -0.891487, 0.00492205, -0.141573, -0.618361, -0.231268, 0.0878411, -0.169247, -0.0783928, -0.0686396, 0.159937, -0.090782, 0.0712356, 0.807385, 0.0592306, 0.166097, -0.0849072, 0.272889, -0.173877, 0.0836434, -0.0162289, 0.0307113, -0.0684716, -0.0471767, 0.15261, -0.13481, -0.21357, -0.0170918, 0.206361, -0.114778, 0.0655712, -0.753741, 0.266479, -0.166096, 0.439738, 0.0385695, 0.0325378, -0.124012, 0.0535671, 0.271571, -0.161685, -0.142508, 0.12265, -0.203692, 0.126422, 0.00930565, -0.303635, -0.094363, -0.0314137, -0.14075, -0.0292662, -0.11764, 0.0551093, -0.107747, -0.27317, 0.0306211, 0.0378646, 0.281574, -0.0183266, 0.243772, 0.186394, -0.184953, -0.19822, 0.0279395, -0.246083, -0.0300021, 0.0812622, -0.0758514, -0.167084, 0.0118277, -0.0435049, -0.0255842, 0.0713816, -0.279076, -0.591873, -0.0101517, 0.489255, 0.00519843, 0.0256782, 0.0618534, -0.179037, -0.227366, -0.118808, 0.0126033, -0.283957, 0.0391104, 0.204684, 0.211935, -0.0219255, -0.402283, 0.355726, 0.0954655, 0.202884, 0.0741445, -0.318064, 0.265851, -0.219773, -0.00426621, 0.0200746, 0.135051, -0.273704, -0.931217, 0.221302, 0.0792622, -0.483127, -0.151089, -0.108292, -0.0964323, 0.033661, 0.00104293, 0.229397, -0.062393, -0.000779769, 0.726234, -0.0765009, -0.0948911, 0.168094, 0.298551, -0.1176, -0.12456, -0.053327, 0.02941, -0.359715, -0.0923468, 0.0381682, -0.0839402, -0.0254843, -0.098759, 0.269714, -0.338515, 0.124489, -0.42624, 0.417525, -0.251408, 0.542149, 0.111776, -0.0809428, 0.018586, -0.0226883, 0.00928667, 0.00515244, -0.165285, -0.0645403, -0.0327946, 0.288101, -0.0786235, -0.365955, -0.324104, -0.0811062, -0.0558115, 0.0147296, -0.109673, 0.172942, 0.0321976, -0.109985, -0.270699, 0.151457, 0.0550491, -0.117626, 0.116574, 0.210863, -0.00719163, -0.194446, -0.0952685, -0.181949, 0.00588461, -0.0286028, 0.0357455, -0.177738, -0.0304768, 0.0683101, -0.0950617, -0.0047483, 0.000796348, -0.158914, -0.0399158, 0.0838148, -0.102393, -0.0410707, 0.246554, 0.0864448, -0.145916, 0.0276229, 0.10508, -0.376353, 0.0259992, 0.0867232, -0.0121764, -0.0263224, -0.0833356, 0.31578, -0.0167549, 0.127375, 0.164146, -0.60271, 0.0853091, -0.207588, -0.0687187, -0.0213832, 0.00190569, -0.190053, -0.814851, 0.176433, 0.106158, -0.417569, -0.13991, -0.118208, -0.0468321, 0.113548, 0.0426372, 0.0791057, -0.241085, -0.150112, 0.478621, 0.0188033, 0.0214459, 0.112334, 0.285282, -0.0658508, -0.0444161}, {0.00732944, -0.0762173, -0.161487, 0.045837, -0.176937, 0.147442, -0.231905, -0.0786219, 0.225806, -0.596265, -0.0613235, -0.663803, -0.00153118, 0.140703, 0.333014, 0.304839, -0.0507461, 0.327966, -0.00205659, -0.0613902, -0.0867585, 0.0120141, 0.00515142, 0.0907959, -0.0112463, -0.263812, -0.191546, -0.245969, -0.295821, -0.274713, -0.0360893, -0.106782, 0.276681, 0.228858, 0.100817, -0.155518, -0.0874174, -0.161798, -0.335825, -0.04773, 0.293677, 0.169256, -0.201626, -0.110419, -0.297038, -0.107959, 0.0882595, 0.222767, -0.0636145, -0.0622869, -0.323304, -0.238577, 0.032854, 0.0920608, -0.352087, 0.0525569, 0.102806, -0.290444, -0.142537, -0.158827, 0.0325142, 0.205203, -0.00459822, 0.21522, -0.221476, 0.149456, 0.273168, -0.110295, -0.00269235, -0.101627, 0.121905, -0.115211, 0.0407568, 0.171216, -0.994651, 0.111711, -0.196727, -0.250617, -0.0033859, -0.278709, 0.0152169, -0.602002, 0.316746, -0.0200228, -0.402966, -0.0783071, -0.14311, -0.17649, -0.0635631, -0.0288982, 0.0081616, 0.0264469, -0.0560845, 0.465547, 0.0146758, 0.081578, 0.181583, 0.0155433, -0.0886895, -0.103714, 0.0481861, -0.0208008, 0.0272771, 0.0609188, 0.0123262, -0.176348, -0.188316, 0.0995874, 0.206499, -0.894854, -0.0212083, -0.346945, 0.0405462, 0.0719735, 0.388991, 0.226695, -0.0542029, -0.128376, 0.0161661, -0.118856, -0.0546307, 0.165684, 0.0465386, -0.146398, -0.179543, 0.115188, -0.253163, -0.0556679, -0.135378, -0.170972, -0.130759, -0.027409, 0.217213, 0.0238006, -0.117753, -0.0610621, -0.126698, -0.13373, -0.553847, 0.00701208, 0.394998, 0.229102, -0.315564, -0.210717, -0.189974, -0.0102259, 0.180487, 0.0832899, -0.216053, -0.0514343, -0.2248, -0.035726, -0.0318802, 0.199196, -0.169857, -0.139493, 0.0365236, -0.667645, -0.282869, -0.133576, 0.275768, 0.184303, -0.0679187, 0.299178, -0.0594479, 0.0141513, 0.0507591, -0.0911342, 0.0260659, 0.0213747, -0.0403472, -0.0772091, 0.0334677, 0.128705, -1.3213, 0.0540336, -0.308923, -0.177023, -0.10537, -0.179458, 0.0608808, -0.387725, 0.221813, 0.155736, -0.272895, 0.199143, -0.483291, -0.350813, -0.203331, -0.176633, 0.141266, 0.152537, -0.104176, 0.545788, 0.306266, 0.0452853, -0.115612, -0.4017, -0.158406, 0.0605184, 0.366488, -0.0362893, -0.0160509, -0.0832798, 0.194888, 0.0340981, -0.01513, 0.0101815, 0.341379, -0.881631, 0.236527, -0.639423, 0.259422, 0.209374, 0.180417, 0.287886, 0.0528109, 0.0532428, 0.193238, -0.270656, 0.0451308, 0.471947, 0.112834, -0.0334152, -0.291735, 0.187696, -0.0256876, 0.0884177, -0.0654756, -0.030667, -0.102362, -0.0405505, 0.188418, -0.0140362, 0.117257, -0.159738, -0.0664717, -0.215272, -0.629469, -0.116583, 0.271738, 0.387368, -0.120285, -0.0926844, -0.103246, 0.0398765, 0.117296, 0.18574, 0.233024, -0.265689, -0.179144, -0.0544806, -0.00997434, 0.17025, -0.263603, -0.213091, -0.188858, -0.648763, -0.33181, -0.0488579, 0.140769, 0.215749, -0.00687275, 0.276777, -0.31232, -0.218395, 0.181091, 0.0845634, 0.134727, -0.00245427, 0.211181, -0.0645956, -0.0129039, 0.102715, -1.41386, -0.393308, -0.25307, -0.261986, -0.172329, -0.523364, 0.178133, -0.335777, 0.248256, 0.0544259, -0.146245, 0.107205, -0.773794, -0.139294, -0.286445, -0.24014, 0.181954, 0.188578, -0.0686005, 0.57779, 0.266192, 0.203584, 0.301136, -0.519669, -0.375233, 0.495109, 0.588974, 0.0710592, -0.267039, 0.0611676, 0.321307, -0.0657443, 0.0229912, -0.232664, 0.321048, -0.915439, 0.504932, -0.675373, 0.2454, 0.105834, 0.195655, 0.325034, -0.0527191, 0.00406504, 0.34181, -0.351703, 0.266029, -0.0400864, -0.145581, 0.0178585, -0.22162, -0.17478, -0.122173, -0.00749931, 0.00320794, -0.0803577, 0.388675, 0.00910823, 0.0666802, 0.0935565, -0.223373, -0.0456397, -0.473015, 0.00944146, -0.600793, -0.238185, 0.215475, 0.1923, 0.187024, -0.185439, -0.228037, 0.0358138, 0.366989, -0.354223, 0.254814, -0.0735723, -0.214785, 0.00137552, -0.15614, -0.0486334, -0.213319, -0.135093, -0.0762883, -0.480945, -0.159675, -0.297789, 0.0750118, -0.1966, 0.136005, 0.516635, -0.504325, -0.0314313, -0.0425202, 0.504188, 0.0318928, 0.150372, 0.013376, 0.119718, 0.237778, 0.240264, -1.75868, -0.268451, -0.518116, -0.263712, -0.319596, -0.465753, 0.35122, -0.00811574, 0.385891, 0.0258603, -0.00685988, -0.000473173, 0.0327048, -0.160581, -0.0390619, 0.0842772, -0.102478, -0.193607, -0.0379036, 0.144502, 0.134674, -0.0713636, 0.00646474, -0.0791259, 0.243778, -0.270081, -0.0586384, 0.0522671, -0.0885744, 0.0248861, 0.0520837, -0.0660336, -0.118042, 0.0719179, 0.179139, -0.0651526, 0.0865334, -0.00828916, 0.112985, -0.033673, 0.193425, -0.0624921, 0.0498273, 0.0272233, 0.286852, -0.240255, -0.152228, 0.144136, -0.0297106, -0.0459732, 0.0458916, 0.178634, 0.175334, 0.147774, 0.0494031, -0.0096076, 0.235201, -0.0637153, 0.148285, 0.110858, 0.103819, 0.0241012, -0.241399, 0.0644956, -0.0380561, -0.0436287, -0.156302, 0.151458, -0.00033036, -0.0673253, 0.0997508, 0.0738225, 0.0751337, -0.089391, -0.0772839, -0.00135001, -0.023213, 0.0480313, -0.0767341, -0.0881697, -0.0853157, -0.153427, 0.04895, 0.0651645, 0.0740069, 0.0413743, 0.0308718, -0.0776515, -0.0256878, -0.0689187, 0.0996489, 0.0228108, 0.136702, -0.213802, 0.232395, -0.187898, -0.129889, 0.00518903, -0.0256895, -0.0727672, 0.0199995, 0.0447953, 0.0687391, 0.101028, -0.0168952, 0.0728718, 0.00963666, 0.0549584, -0.154241, 0.0453233, 0.0798885, 0.0115952, 0.0276221, -0.0142272, -0.0183719, 0.0735194, 0.0325901, -0.058308, 0.038373, 0.00663979, 0.0335372, -0.0569159, 0.0853829, -0.0607211, 0.0196883, -0.0708164, -0.0386855, -0.0420198, 0.0380707, -0.0612161, -0.0115933, -0.07009, -0.114245, 0.0649065, 0.0184545, 0.0182147, -0.032643, 0.00536039, 0.087956, -0.00459085, -0.0271402, -0.0110013, 0.00296441, 0.0579109, -0.0263907, -0.068853, -0.0838175, -0.0252789, -0.0856375, 0.00844099, 0.100929, 0.0607226, 0.0579841, 0.00469594, -0.000793502, -0.0664292, -0.0268243, 0.0802825, 0.0176279, 0.042388, 0.0560758, -0.0681001, 0.0307607, -0.00609653, 0.0346546, -0.0735868, 0.0443203, 0.0411214, -0.0166136, 0.0379089, 0.0697961, -0.0464704, -0.00538842, -0.056182, 0.0597685, 0.0124863, 0.0096936, 0.110164, -0.0442364, -0.0779744, -0.0186133, 0.0523037, 0.0468728, 0.0169408, 0.039085, 0.0729749, 0.00254325, 0.0265124, 0.0214727, -0.0158521, 0.00401454, 0.0479588, -0.00146351, -0.112428, 0.0976414, -0.00521693, -0.0488078, -0.0784685, -0.0349812, -0.0205356, -0.0610555, -0.0105269, 0.0545996, 0.0526366, 0.056169, -0.022485, -0.0757205, -0.04139, 0.0225644, -0.0345188, -0.0810832, -0.0556262, 0.0714535, -0.0338043, -0.0764882, 0.015701, 0.0563849, -0.0353044, 0.0490134, -0.00234254, -0.00907936, -0.0263123, -0.0759172, -0.00314974, 0.0012935, 0.0521619, 0.0118468, -0.0655956, -0.0538614, 0.0399619, -0.0553828, 0.00546921, 0.0269783, -0.0407313, 0.0500519, -0.0440626, 0.0808542, 0.0518521, -0.0641452, -0.00568287, 0.00224669, 0.0322941, 0.0312021, 0.0653469, -0.0206084, -0.013563, -0.00606558, 0.0135214, 0.0352692, 0.0478843, -0.0675384, 0.0201726, 0.0342322, -0.0782795, -0.044727, 0.0169388, 0.0502436, 0.0447284, -0.0749144, -0.0400309, 0.0622931, -0.0326577, -0.0331965, 0.0523423, 0.0102721, 0.0120194, 0.0409172, -0.0637369, -0.0237013, 0.0755993, -0.0689397, -0.0533309, -0.00650091, -0.0255419, -0.036377, -0.0592147, -0.0064541, 0.0706618, 0.000474066, -0.0176597, -0.0450193, 0.0768854, 0.0778152, 0.0795492, 0.0145662, 0.0698171, 0.00860257, -0.0450195, 0.0694531, 0.068043, 0.0420166, 0.00894884, 0.0449334, 0.0773108, -0.0715266, 0.0349112, -0.0233002, -0.0194625, -0.00406338, -0.0800252, 0.0662464, -0.0814341, -0.0785815, -0.067845, 0.0808896, 0.0283333, 0.00889781, -0.0486977, -0.055498, 0.0435302, -0.0390316, 0.00621527, -0.0774113, -0.0798098, -0.0781302, -0.0491303, -0.0222335, -0.0608069, -0.0601656, 0.00608676, 0.0436822, -0.0522624, 0.0747447, -0.0780926, 0.0284025, -0.0375726, -0.0802, 0.0744712, 0.0426006, -0.0424869, 0.0536054, 0.0273327, 0.0184164, 0.0037097, -0.0284358, 0.0447833, -0.0444949, -0.019165, 0.0211757, 0.0679713, 0.045412, -0.0758942, -0.00590153, 0.030391, 0.00293144, 0.0174606, 0.066432, 0.00242992, 0.0751044, 0.0253561, -0.00979257, 0.0429269, 0.00820108, 0.00181003, -0.0454526, 0.0416263, 0.0464129, -0.00262119, 0.0122837, 0.0466198, 0.0449327, -0.0545408, 0.0771326, -0.0191244, 0.0387414, -0.0653228, 0.0106694, 0.0512458, 0.0286888, 0.0365163, -0.0630714, 0.0333582, 0.0373862, -0.079227, -0.0610846, -0.0397899, 0.0485378, -0.000555836, -0.0780586, -0.0818826, 0.00455485, 0.0489034, 0.0289039, 0.0640571, -0.0119419, -0.0283248, -0.0822561, 0.0580323, 0.0688142, 0.00418027, -0.0357844, -0.0374411, 0.00316932, 0.0645995, 0.00884499, 0.0455031, 0.0582108, 0.0732533, 0.0106205, -0.00204088, 0.0785004, 0.0229942, 0.0539446, -0.0587518, -0.00088618, -0.0295045, 0.0415098, -0.0505886, -0.0153971, -0.0173775}, {-0.078205, 0.0597041, 0.0189233, 0.081646, 0.011204, 0.00535495, 0.0264883, 0.0565086, 0.0526107, 0.0457612, 0.0506956, -0.00915439, -0.0801191, -0.0506343, -0.0319487, -0.0773867, 0.000532933, -0.0772423, 0.0344203, 0.0542632, 0.00851504, -0.0800515, 0.0344766, -0.0816923, 0.0286191, -0.0418592, -0.0336301, -0.0678465, 0.00104952, 0.0716836, -0.0182745, 0.0054521, -0.0164128, -0.0717775, 0.0512141, -0.0777989, 0.0823462, -0.0210655, 0.0645812, 0.0712511, -0.0122724, -0.0304354, 0.0469033, -0.0179925, 0.00168208, -0.00443237, 0.00441271, -0.0748653, -0.00792184, 0.0349858, 0.0122821, 0.0330295, -0.0541692, -0.0053305, 0.0140281, 0.0380816, 0.0645832, -0.0282306, 0.0240422, 0.0575202, -0.0783276, -0.073052, -0.055792, -0.0216301, 0.0427673, 0.073923, 0.0419541, 0.00246105, -0.0458238, 0.0189567, 0.0133648, -0.00826973, -0.0406808, -0.0386398, -0.0047373, -0.0332857, -0.011819, -0.0136384, 0.00115113, 0.0141471, 0.0142878, 0.0148802, -0.048329, 0.0793957, -0.0289649, -0.0239103, 0.0751303, 0.0406837, -0.0110223, -0.0756842, 0.0503816, 0.0149579, -0.0345566, 0.0362522, 0.0740344, -0.0578976, -0.0646021, 0.0618026, -0.0011954, -0.027091, 0.0306125, -0.0663924, 0.00360917, 0.0786727, -0.0293068, -0.0640837, 0.0777844, 0.0448464, -0.052848, 0.0783119, -0.0510879, 0.0380801, -0.0652906, -0.0685466, -0.0350538, 0.0469329, -0.0727383, -0.0662315, -0.00532279, -0.0802081, 0.00344659, -0.0240239, 0.0414707, 0.0426076, -0.0339868, -0.0371726, -0.0214526, -0.0567693, -0.0379383, 0.0321618, 0.0745335, -0.015705, -0.0401163, 0.0628192, -0.0472474, -0.0433325, -0.0100278, 0.0218735, -0.046023, 0.0574154, 0.041508, 0.00250746, -0.0217409, -0.0646515, 0.062856, -0.0216537, -0.0722684, -0.0381463, 0.0138846, -0.0769448, 0.0256919, 0.00184996, 0.0239952, 0.0484923, 0.0706929, -0.0709531, 0.0656546, -0.0434986, 0.0689671, 0.0646989, 0.0275473, 0.013474, -0.0325663, -0.0508849, 0.0393962, 0.0732303, -0.0194133, 0.0591344, 0.0485288, 0.0598837, -0.0115058, 0.0434384, 0.0166695, 0.0789345, -0.0674533, 0.0351902, -0.0159091, -0.0131925, -0.00858239, 0.0283713, 0.0114381, 0.0758194, 0.0733262, 0.0335365, 0.000909887, 0.0812288, 0.0642882, -0.0197909, 0.0182156, 0.0301085, 0.02254, 0.0309549, -0.07977, -0.0133045, -0.0278576, -0.0196316, 0.0146555, 0.0212263, -0.0352986, -0.0551422, 0.00359183, -0.0219804, 0.0857702, -0.0629702, 0.0120203, -0.0955995, 0.0726573, 0.0108223, 0.0108092, -0.136628, -0.0458797, 0.0631759, -0.0555255, -0.0764203, -0.0808451, -0.114755, 0.0290935, -0.105883, 0.172617, -0.0119547, -0.111158, -0.0290349, -0.167607, 0.0318486, -0.0182986, -0.0342476, -0.0492974, -0.10673, -0.100164, 0.111439, 0.0280369, 0.0918772, -0.076999, -0.0126844, -0.109944, -0.000610287, 0.0790316, 0.0427051, 0.0703037, -0.0728081, -0.0269251, -0.0179788, 0.0415979, 0.136411, -0.0220073, -0.0949806, 0.00679614, 0.173234, 0.0926108, -0.0348026, 0.0474098, 0.0661483, -0.083944, -0.109464, -0.00191969, -0.0280553, -0.0778936, 0.0117281, -0.0993022, -0.228084, -0.147619, 0.0341258, -0.0587485, -0.0692736, 0.090578, -0.0458662, 0.111709, 0.0884181, -0.0344438, -0.00898669, -0.00579443, 0.211128, -0.0488598, 0.120163, -0.0844986, -0.0347134, 0.0713466, 0.11278, 0.0993736, 0.0940282, 0.0190653, 0.00432796, 0.0268719, -0.0762886, 0.0621237, -0.0324169, -0.0352588, 0.146259, 0.0336672, 0.0437814, -0.0518031, -0.063498, -0.122421, 0.170086, 0.128354, 0.144384, 0.00454725, -0.0563475, 0.0342469, 0.014372, 0.0475948, -0.0738246, 0.165313, -0.0277051, -0.027112, 0.0596699, -0.104734, -0.0377625, -0.00665199, 0.0638942, -0.0031945, 0.0221809, -0.00962577, -0.173331, 0.0557931, -0.144232, 0.0803067, -0.133928, 0.0780803, -0.0738892, -0.00809501, -0.136182, -0.177967, 0.0127075, 0.0159524, -0.0856489, 0.0122473, 0.0928017, -0.00458309, 0.170837, -0.0208733, 0.0375236, -0.0441705, 0.0759293, 0.0713784, -0.0285711, -0.0208682, -0.0655577, 0.0534411, -0.0760862, -0.132067, 0.0287967, 0.209969, 0.0477503, 0.020435, -0.0844144, -0.0197076, 0.107234, 0.0547017, 0.104865, -0.10884, -0.0465773, -0.0976615, 0.0707962, 0.0791876, -0.0129373, -0.0258362, 0.121447, 0.114187, -0.201869, -0.0062616, 0.0518996, -0.133805, -0.0368459, 0.0905945, 0.0448642, 0.155551, -0.0750366, -0.0282228, 0.061806, 0.048958, 0.068615, -0.0187665, 0.154023, -0.0334345, 0.0311915, 0.157141, -0.0230809, 0.045969, -0.0184908, -0.0601658, 0.0105361, -0.0334849, -0.100284, 0.0622879, -0.139283, -0.0748826, -0.0742991, 0.056845, 0.087234, -0.0938558, -0.169102, 0.0257017, 0.162914, 0.121669, 0.234569, 0.0386149, -0.0967578, 0.0753613, -0.0518763, -0.0287124, -0.382296, -0.0882643, 0.233081, 0.0803768, -0.0350513, 0.29234, 0.110104, 0.33306, -0.0745005, 0.149616, -1.40358, 0.54374, 0.00651729, -0.259188, -0.262295, -0.0522473, -0.0269698, -0.355471, -0.0909743, -0.129686, 0.0270709, -0.131216, -0.0182912, -0.0409676, -0.246028, 0.178639, -0.0882299, -0.361906, -0.367595, 0.0351332, -0.0929607, 0.0279404, 0.23728, 0.28299, -0.459355, -0.706277, 0.0873256, -0.152058, -0.51674, 0.505878, -0.312332, -0.00536507, 0.0577423, 0.231091, 0.299378, -0.390676, 0.00919067, 0.0147908, -0.567544, -0.24022, -0.193052, -0.0771997, 0.00347735, -0.0804808, 0.209186, 0.262164, -0.152107, -0.033524, -0.1629, 0.47325, 0.0734428, -0.00725669, 0.0030504, 0.314453, 0.255089, 0.143853, 0.482133, -0.191137, -0.43947, -0.152954, 0.256126, 0.146892, 0.192469, 0.227712, -0.278952, 0.47375, 0.193353, -0.086151, 0.42045, -0.73425, -0.1752, -0.035113, 0.0924171, 0.00243314, 0.236518, -0.110384, 0.05884, -0.0973314, 0.0386108, -0.104156, 0.171867, -0.0286585, -0.179912, 0.203958, 0.350943, 0.0730419, 0.0751596, -0.105287, -0.537157, 0.0601619, -0.263322, 0.158221, -0.0770197, 0.0549194, 0.0906896, 0.128215, -0.308044, 0.329841, -0.0145472, 0.0834935, -1.47383, 0.356783, 0.0262669, -0.351506, 0.171242, -0.191845, 0.218745, -0.153892, -0.0204648, -0.118774, 0.247987, -0.0129021, 0.0753441, -0.43492, -0.273203, 0.156073, -0.109209, -0.481641, -0.212782, -0.179986, -0.152637, 0.00185778, 0.073653, 0.0710789, 0.00948852, -0.850416, 0.125094, -0.0473398, -0.407414, 0.129199, -0.258628, 0.194216, -0.0990585, 0.2793, 0.197605, -0.058351, -0.0946232, -0.172594, -0.932638, 0.105152, 0.0968223, 0.12535, -0.0831179, 0.173149, -0.00927365, 0.248387, -0.137015, -0.400873, 0.104308, 0.199644, -0.0187512, -0.112167, 0.0837017, 0.131629, 0.0684579, 0.183503, 0.332492, -0.333285, -0.685104, -0.183051, 0.0667101, -0.088284, 0.178567, 0.353919, -0.0740039, 0.505548, 0.0376275, 0.273385, -0.0270629, -0.479855, -0.198551, 0.0785503, -0.117636, -0.242154, -0.133509, 0.0635222, 0.139468, 0.0600285, -0.0916595, 0.0764488, -0.123279, -0.00680256, -0.117223, 0.0836659, 0.0480252, 0.0795561, 0.0835193, -0.0147889, -0.429527, 0.20246, -0.483269, 0.115986, -0.295527, -0.00196488, 0.155653, -0.158263, -0.275858, 0.262851, 0.0600668, -0.15146, -0.790533, -0.0550276, 0.224355, -0.196501, 0.00644523, -0.173402, 0.0140213, -0.12878, -0.0160592, -0.102628, 0.351958, 0.21123, 0.0401044, -0.293783, -0.000626259, 0.0622407, -0.182103, -0.362596, -0.211803, -0.11044, -0.0640894, -0.0336746, 0.0386774, 0.249415, 0.144078, -0.383087, 0.120547, 0.151548, -0.432408, -0.176243, -0.117302, -0.0345631, 0.146029, -0.0903472, 0.0415434, -0.107503, -0.0315993, 0.0187029, -0.843182, 0.0520301, 0.167841, 0.230737, 0.180187, 0.09322, 0.0237003, 0.109799, -0.0359019, -0.0379094, 0.0833069, 0.136797, -0.00226225, 0.195395, 0.0875823, 0.1306, -0.0570911, 0.352219, 0.415062, 0.0956435, -0.61565, -0.216762, 0.0835189, -0.209156, -0.0221393, 0.105236, 0.244851, 0.0686492, 0.0810419, -0.0617683, 0.174895, -0.335574, 0.191558, 0.150606, -0.268, -0.151766, 0.015945, 0.0544518, 0.0139805, 0.164995, 0.00214817, 0.101765, -0.070741, -0.168946, -0.00537956, 0.00531563, 0.207878, 0.199657, -0.0504204, -0.0159308, -0.233146, 0.126618, -0.353365, 0.226041, -0.469735, 0.0249511, 0.0915847, 0.0465806, -0.347281, 0.215664, 0.0196023, -0.0513659, -0.743657, -0.0695925, 0.0262795, -0.103976, -0.215176, 0.0408406, 0.023056, -0.280552, 0.0490026, 0.0040375, 0.24868, 0.245134, -0.0773384, -0.169156, -0.13158, 0.0829652, 0.0469652, -0.0355849, -0.187093, -0.144003, -0.121009, -0.0123891, 0.0714339, 0.220934, -0.0506766, -0.533464, -0.0732362, 0.198428, -0.207876, -0.166998, 0.0602732, 0.0676344, -0.0185836, -0.171727, -0.367922, -0.035609, -0.0165979, -0.0302762, -0.458549, -0.300616, 0.198092, 0.209358, 0.23507, 0.0710358, 0.0398784, 0.119371, 0.159913, 0.105181, 0.137632, 0.2357, 0.00130922, 0.1847, 0.0180696, 0.213439, 0.00915708, 0.179416, 0.145097, 0.389129, -0.43568, -0.100434, -0.20333, 0.00935897, -0.211815, 0.172194, 0.311663, -0.143214, -0.013338, -0.388164, 0.0573401, -0.0293452, 0.378951, 0.299522, 0.00466187}, {-0.00132506, 0.179172, -0.169436, -0.0584672, 0.0486245, 0.090779, 0.0173385, -0.151619, -0.075287, -0.0520546, -0.0258692, -0.0141641, 0.17492, 0.162172, -0.033782, -0.0152367, -0.0594252, -0.217272, 0.045892, -0.59058, -0.102525, 0.143979, 0.120988, -0.262877, 0.142918, -0.0210121, -0.106161, -0.482792, 0.184976, 0.00780275, 0.0124962, -0.169153, 0.165847, 0.0679697, -0.0145013, 0.00943789, 0.0240259, 0.319559, 0.184714, -0.0500811, -0.350333, -0.204736, -0.18956, 0.102873, -0.335262, 0.0502707, -0.036286, -0.137149, 0.0622555, -0.00775547, 0.0581844, -0.158296, -0.433542, -0.328369, 0.191111, -0.154551, -0.0547501, 0.0472884, 0.16942, 0.037128, -0.0764003, -0.412036, 0.0495983, -0.11905, -0.14828, -0.31706, -0.15454, -0.0868178, 0.147652, 0.12736, -0.021844, -0.230115, 0.0885604, -0.0134786, 0.376686, 0.228253, 0.179835, -0.110102, -0.0779105, -0.00836836, 0.31504, 0.150974, 0.00997075, 0.0580098, 0.444058, -0.295173, -0.0916493, 0.22946, -0.103687, 0.0117034, 0.0642365, 0.427357, -0.027827, 0.11417, -0.457764, 0.201644, -0.0402216, 0.16454, 0.0526942, -0.209172, -0.0221402, 0.522994, -0.20199, -0.0513076, 0.151475, 0.304031, 0.179579, -0.17454, 0.0204649, 0.0125787, 0.0286229, -0.134917, 0.0539209, 0.0905617, -0.321865, 0.193373, -0.0669089, -0.115988, -0.151686, -0.556089, 0.011782, 0.189112, 0.164684, -0.317659, -0.224914, 0.175981, 0.015668, -0.252587, 0.0793891, -0.00382068, -0.105406, 0.0755766, 0.114154, 0.0160941, 0.0861383, 0.00851836, -0.0285657, 0.0514825, 0.197678, -0.288052, -0.00512508, -0.058111, -0.0417134, 0.206873, -0.183151, 0.328353, -0.0176395, -0.186638, 0.0168175, -0.0289523, 0.0852961, -0.00291531, -0.340818, -0.25174, 0.287197, -0.244393, -0.130341, -0.0470897, -0.139019, -0.15604, -0.28979, -0.731881, 0.132538, -0.0278487, -0.158498, 0.27689, -0.200362, -0.217595, 0.145171, 0.234238, 0.224509, -0.243253, 0.0593537, 0.0396244, 0.481899, 0.216372, 0.0454029, -0.0284089, 0.0073904, -0.0187763, 0.186944, -0.046048, -0.0773492, 0.0238535, 0.411409, -0.47293, -0.158664, 0.00911099, -0.17328, -0.0583439, -0.0842215, 0.295496, 0.0759215, 0.158192, -0.247515, 0.0391201, -0.10884, 0.129163, 0.0565338, -0.261522, -0.140013, 0.434586, 0.0600038, -0.0421143, 0.0598419, 0.246932, 0.147374, -0.0118357, 0.213459, -0.0135949, -0.0302311, -0.162304, -0.0728579, 0.00864703, -0.0193489, 0.297303, -0.0878318, -0.0721813, -0.284089, -0.563595, 0.0872107, 0.0935579, 0.0911097, -0.263896, -0.113465, 0.311149, -0.126296, -0.152745, 0.0363272, -0.147004, 0.0227766, 0.0265887, 0.121113, -0.0376634, 0.099073, -0.0220567, 0.166824, -0.139119, 0.110911, -0.0603672, 0.140433, 0.139212, 0.232668, 0.0498388, -0.0218576, 0.299793, -0.00574688, -0.101203, 0.0158854, 0.168501, 0.0806627, -0.151199, -0.169138, -0.0423767, 0.409079, -0.111494, -0.345521, 0.211061, -0.0265175, -0.448005, -0.220286, -0.689847, 0.0149376, 0.00331649, 0.139899, 0.465841, -0.338357, -0.340473, 0.328802, 0.20706, 0.168398, 0.0251398, 0.100362, 0.138423, 0.3356, 0.103451, -0.0732455, -0.0134874, 0.0655175, 0.121162, 0.115489, -0.137437, 0.0637784, -0.213322, 0.0419738, -0.741204, -0.267562, 0.124028, -0.162769, -0.197867, -0.190565, 0.0865892, -0.0548482, 0.00858537, -0.205477, 0.178449, -0.283665, -0.0843332, -0.0200286, 0.0516442, -0.198161, 0.316619, 0.218747, 0.0279024, 0.154636, -0.12103, -0.0052611, -0.0351201, 0.0281779, 0.136021, 0.102497, -0.364893, -0.17552, -0.132775, 0.0779021, 0.258389, 0.0151101, -0.119081, -0.146161, -0.131203, 0.043859, 0.127019, 0.163896, -0.334888, 0.0984829, 0.527106, -0.239723, -0.139923, 0.127679, -0.173744, 0.171897, -0.129448, 0.236175, 0.0855582, -0.0515803, -0.0684873, 0.0810698, -0.037837, 0.0121547, 0.147757, 0.132207, 0.066778, 0.168648, 0.202336, -0.0287082, 0.0989771, -0.121031, -0.151817, -0.00192278, 0.208881, 0.0300019, 0.109666, -0.014593, -0.0216522, 0.269756, -0.0476557, -0.624974, 0.0487587, 0.408644, -0.800735, -0.0983692, -0.730324, 0.0864705, -0.123097, 0.189625, 0.573576, -0.303122, -0.144509, 0.226683, -0.0430027, 0.15415, 0.0468442, -0.0459655, -0.209593, 0.194325, 0.156618, -0.0328172, -0.0733885, -0.0103983, 0.158751, 0.275295, -0.0661497, -0.0211614, -0.312964, -0.549505, -0.603325, -0.250954, -0.0973579, -0.153345, -0.211488, -0.0219317, -0.0514564, -0.232255, -0.168537, 0.0349533, 0.164855, -0.116691, 0.0431995, 0.0300064, 0.450406, -0.0190591, 0.166613, -0.105893, -0.196273, 0.240782, 0.084335, 0.141967, -0.105994, 0.137983, 0.219105, 0.0721492, -0.483696, -0.486441, 0.0547266, 0.06945, 0.389689, -0.163213, -0.097381, 0.0380058, 0.133727, -0.275629, 0.0171736, 0.171934, 0.11551, 0.346264, 0.645407, -0.115702, -0.0998322, -0.00820957, -0.0529046, 0.321693, -0.0442663, 0.359702, -2.16562e-05, -0.14021, -0.077543, -0.0518628, -0.0320127, -0.147721, 0.0953297, -0.143472, -0.154106, 0.161084, 0.110242, 0.219596, 0.140636, 0.0601249, -0.225807, -0.0460766, 0.331108, -0.0370402, -0.123537, 0.0823835, -0.20187, 0.335656, 0.0259537, -0.338514, -0.00865069, 0.250052, -0.539417, -0.0612183, -0.391682, 0.0579089, 0.00978018, 0.0924731, 0.427911, -0.100246, -0.195045, 0.0523117, -0.0877, 0.0872495, 0.0221508, 0.0195811, -0.103143, -0.191487, -0.0254715, 0.0111063, -0.0548421, -0.157887, 0.0600474, 0.239632, 0.124064, 0.0378633, -0.271447, -0.358761, -0.243687, 0.0672768, -0.273373, -0.248258, -0.0236423, 0.0371239, 0.0774259, -0.157308, -0.136429, 0.110541, 0.13951, 0.150133, -0.029829, 0.121557, 0.49727, -0.0723677, -0.074633, -0.0440423, -0.0343925, 0.427021, 0.416476, 0.0894216, 0.0272738, 0.12306, 0.143844, 0.167117, -0.596549, -0.32914, 0.0711816, 0.0525245, 0.579627, -0.394792, -0.0836117, 0.217742, 0.0507011, -0.153754, -0.0377534, -0.0810713, 0.187942, 0.55205, 0.707345, 0.158887, -0.0899794, -0.00705134, 0.0649621, 0.448949, -0.101152, -0.0739599, 0.00310642, -0.0510787, 0.0214907, 0.0971557, 0.0108745, 0.0649587, 0.150635, -0.120527, -0.00649571, 0.0130741, 0.0392333, 0.294006, -0.0200577, 0.0441632, -0.191259, -0.019807, 0.2909, -0.110302, 0.0615883, 0.177484, -0.0131118, 0.234089, 0.0416764, 0.0898205, 0.0700421, 0.3191, -0.05331, -0.186196, -0.266257, -0.0513075, 0.0975607, 0.281538, 0.197618, 0.0627463, -0.262778, 0.00322775, -0.15893, 0.0517324, -0.215779, -0.125009, 0.0576765, -0.194373, 0.179125, -0.0916688, -0.0678544, -0.129892, 0.0349773, 0.358342, 0.322759, -0.0502031, -0.133951, 0.125985, -0.0998028, 0.16591, -0.0176285, -0.00301959, -0.0308734, -0.0663326, -0.0589226, 0.0602695, -0.0126934, 0.0816275, 0.00476777, 0.148455, -0.206259, 0.179254, 0.543551, 0.0782233, -0.0272619, 0.151752, -0.0355823, 0.498598, 0.229289, 0.249739, -0.261434, 0.348764, 0.247886, 0.0769448, -0.614455, -0.20117, -0.0597231, -0.0180304, 0.339997, -0.425804, -0.18908, 0.259558, 0.0621386, -0.253708, -0.0426004, -0.0433441, 0.31763, 0.315735, 0.548413, 0.113479, -0.0916639, 0.176356, 0.110005, 0.11985, -0.117402, -0.0694212, 0.0542483, -0.0798355, 0.0283478, -0.01221, -0.14807, 0.173717, 0.266072, -0.319699, 0.218225, -0.052857, -0.135505, 0.143772, 0.0153402, 0.110016, 0.00684087, -0.0242994, 0.447551, -0.190169, -0.053785, 0.217136, 0.075139, -0.0736202, 0.0550994, 0.236849, 0.125349, 0.176413, 0.347054, -0.270953, -0.101445, -0.198519, 0.129416, 0.421713, 0.20147, 0.076341, -0.302772, 0.0417569, -0.31518, 0.188041, -0.284873, 0.212608, -0.0481798, -0.206081, 0.261417, -0.125901, -0.0700519, 0.148882, 0.0750849, 0.322307, 0.526264, 0.123306, -0.00867203, 0.21604, -0.149655, 0.356319, 0.244658, -0.0392308, 0.233389, 0.151289, 0.0154445, 0.02629, 0.178349, 0.187021, 0.0693541, 0.0395505, -0.105493, 0.0452559, 0.187673, -0.025315, -0.121895, 0.24708, 0.15994, 0.0879913, 0.0066168, 0.254399, -0.221582, 0.476355, 0.128199, -0.152193, -0.587552, -0.116602, -0.273437, -0.015317, 0.0608238, -0.530391, -0.333103, 0.232821, 0.175758, -0.132113, -0.48666, 0.0455986, 0.260276, -0.365005, 0.498832, -0.0594377, 0.0681459, -0.131518, 0.219478, 0.0292287, -0.0124347, -0.192962, -0.106307, 0.0596444, 0.0438269, 0.209934, -0.0647065, 0.199252, 0.194185, -0.178588, 0.274364, -0.0469839, -0.268759, 0.171675, -0.224268, 0.321682, 0.098414, -0.0569924, 0.729665, -0.238812, 0.387271, 0.364798, 0.145188, 0.146497, -0.0263823, 0.332868, 0.0599476, 0.184825, 0.406233, -0.116066, 0.0227841, -0.0664519, 0.293227, 0.228453, 0.364936, 0.0826521, -0.358566, 0.0808537, -0.179618, 0.25064, -0.132615, 0.341139, -0.287973, -0.188645, 0.281093, -0.15063, -0.029597, -0.0504921, 0.200868, 0.329734, 0.406828, -0.0717423, 0.0267415}, {-0.00637025, -0.181424, 0.0997022, 0.331203, -0.0122374, 0.431716, -0.0882901, 0.0219139, -0.0140112, 0.233138, 0.0645735, -0.0149628, -0.136817, -0.0359134, -0.14722, 0.00843408, -0.0494774, 0.021471, 0.342318, 0.126459, -0.450294, -0.167477, 0.160532, 0.269776, 0.528137, -0.012615, 0.0107426, -0.523628, -0.351283, -0.320993, -0.274414, -0.428887, -0.786991, -0.152525, 0.191355, 0.236431, -0.0292459, -0.168094, 0.000689529, 0.051406, -0.453757, 0.20043, -0.244659, 0.000661893, -0.211591, 0.242387, 0.217697, 0.0851288, 0.156119, -0.3891, 0.0584417, -0.0345283, -0.139784, -0.027696, 0.0946916, 0.204994, 0.0425745, 0.21741, 0.0291877, -0.70302, 0.0526602, -0.166399, 0.408302, 0.274164, -0.0188531, 0.350892, -0.34157, 0.386401, 0.0687757, -0.279782, -0.0529918, -0.141378, 0.161807, 0.0123566, 0.119525, 0.211763, 0.099226, -0.161647, 0.264466, 0.390074, -0.0223634, 0.0160783, 0.0169459, -0.314158, 0.0938924, 0.0817162, 0.221249, -0.0658796, 0.410614, -0.309108, -0.155046, 0.224326, -0.195458, 0.021725, 0.0753025, 0.1415, 0.104168, 0.277089, 0.162786, 0.182429, -0.0136439, -0.233626, -0.373818, 0.30087, 0.0313564, 0.38164, -0.196733, 0.175972, 0.0755537, 0.0203749, 0.115631, -0.0658306, 0.103682, -0.103962, -0.061904, -0.0328019, -0.00998789, -0.0726833, 0.400956, 0.0800263, -0.366255, -0.235383, 0.224728, 0.391408, 0.502698, 0.0101014, 0.0439156, -0.479372, -0.537364, -0.929514, -0.243708, -0.193611, -0.597212, -0.173966, 0.0785468, 0.106274, -0.154352, -0.0290891, -0.0896963, -0.0517472, -0.610226, 0.409393, -0.109525, 0.000958457, -0.0278099, 0.266383, 0.220114, -0.00138416, -0.153858, -0.275402, -0.0408984, 0.0587694, -0.142286, -0.143489, 0.0583477, 0.112521, 0.125001, -0.168621, -0.0809737, -1.0296, -0.0794048, -0.118994, 0.302132, 0.137817, -0.0386381, -0.0378383, -0.203951, 0.314253, -0.0733792, -0.302879, -0.0538225, 0.0592404, -0.0507672, -0.0598066, 0.15905, 0.138103, 0.0969202, -0.0437741, 0.152306, 0.256438, -0.17089, -0.034976, 0.0561028, -0.165902, 0.0717815, 0.267089, 0.0379623, 0.158906, 0.297636, -0.137952, -0.276225, 0.139369, -0.26256, -0.094983, -0.0538623, 0.15299, -0.0547484, -0.0495257, 0.023067, 0.459769, 0.165466, -0.0565258, -0.663826, 0.125833, 0.244775, 0.170424, 0.0432224, 0.216005, 0.232132, -0.10756, 0.176574, -0.0291956, 0.012875, 0.0422411, 0.145773, 0.00481766, 0.188262, -0.193241, 0.125855, -0.0869682, 0.0885677, -0.277707, 0.12909, 0.337289, 0.478574, -0.0629827, 0.104599, -0.238856, -0.416311, -0.851518, -0.000153699, 0.0404329, -0.427563, -0.247531, 0.011687, 0.150983, -0.0160448, 0.000332926, 0.193531, 0.280786, -0.131963, 0.31234, -0.131446, 0.158479, -0.193352, -0.0914009, 0.0451162, 0.115582, -0.0613743, -0.0839894, -0.135521, -0.036468, 0.101837, 0.0114137, 0.20351, 0.23307, 0.136877, -0.25777, 0.0959752, -1.37222, 0.191944, -0.197872, 0.262945, 0.161519, 0.0118067, -0.134069, -0.0514114, 0.22742, -0.0046212, -0.121351, 0.111614, -0.159174, -0.0956956, -0.0703804, -0.027585, -0.0940287, -0.091739, -0.21145, -0.0203174, -0.0255217, 0.205591, -0.027383, -0.187857, -0.106798, 0.138828, 0.0293043, -0.164814, 0.0489363, 0.122051, -0.0959756, -0.150493, 0.047482, -0.0610515, -0.0803192, 0.079039, 0.195301, -0.263566, -0.0556575, -0.22668, -0.13668, 0.159565, -0.0524534, -0.323548, 0.0453457, 0.213685, -0.0322309, 0.33036, -0.0688784, 0.038106, -0.169745, 0.042219, 0.23943, -0.0441581, 0.0530376, 0.147521, 0.127998, -0.0803326, -0.0739914, 0.342594, -0.0810217, 0.211752, -0.0805853, -0.106124, 0.0607172, 0.316693, -0.0957204, -0.0122909, -0.154973, -0.0379724, -0.645075, 0.103198, 0.130163, -0.35546, -0.256614, -0.0589149, -0.0279969, 0.17657, 0.0802136, 0.103176, 0.16897, 0.0541533, 0.439048, -0.0766191, 0.107062, -0.00156231, -0.368042, -0.00613513, 0.0708834, -0.0483454, -0.127126, -0.321844, -0.00468513, -0.115251, 0.0926419, 0.0768231, 0.089884, 0.223532, -0.559961, 0.0605669, -1.37985, 0.0278623, -0.36685, 0.279616, -0.0064953, 0.0409343, -0.131133, 0.0511705, -0.0694715, -0.00542905, -0.239024, 0.148707, -0.0268898, 0.0054245, -0.158027, -0.148832, -0.0138812, -0.0879084, -0.200307, 0.0737139, -0.180403, 0.358872, 0.11277, -0.0733329, -0.187651, -0.0877593, -0.209457, -0.326507, 0.105783, 0.130083, 0.116305, -0.0954006, 0.0710565, -0.146689, 0.0222528, 0.0208539, 0.242756, -0.323824, -0.0806063, -0.135408, -0.411571, -0.0090741, -0.00148677, -0.0267638, -0.176849, 0.0580684, -0.0280328, 0.266341, 0.194943, 0.128384, -0.157119, 0.160201, 0.274649, -0.275881, 0.0219654, 0.286222, -0.025109, -0.169298, -0.225157, 0.245719, 0.004331, -0.0396781, -0.0898709, -0.1721, 0.0978215, 0.359287, -0.289317, -0.0861877, -0.286882, -0.0546623, -0.209013, 0.243481, 0.0427844, -0.357399, -0.162288, -0.138545, -0.155819, 0.200341, -0.14852, 0.282567, -0.063995, -0.0424951, 0.397314, 0.156404, 0.000207808, 0.0731924, -0.615968, 0.0803881, -0.0717779, 0.0785343, -0.0513223, -0.131363, 0.073729, -0.135044, 0.0883147, -0.149811, 0.121788, 0.196112, -0.75435, -0.300815, -1.11393, -0.152532, 0.134479, 0.236434, 0.297952, 0.0523036, -0.243295, 0.131916, -0.241806, -0.14855, -0.171897, 0.061586, -0.062546, -0.153308, 0.0943827, -0.206661, -0.147951, 0.0955038, -0.156761, -0.0368702, -0.133062, 0.225298, 0.06787, 0.1343, -0.175363, -0.172681, -0.1146, -0.471987, 0.0169634, 0.224119, 0.00952704, -0.356269, -0.194867, -0.193462, -0.0736594, -0.0150947, 0.268223, -0.35388, -0.0177003, -0.431672, -0.246227, -0.125611, 0.0293964, -0.345419, -0.29156, -0.0779051, -0.438188, 0.0919413, -0.038635, 0.141741, 0.0393341, -0.00836049, 0.288242, -0.229325, -0.0626114, 0.132564, -0.0777348, 0.0541281, 0.18719, 0.0663605, -0.0437578, 0.00487753, 0.145158, -0.379619, 0.167148, 0.225601, -0.097426, -0.101928, -0.272141, -0.0918492, 0.00403544, 0.546921, 0.156989, -0.337502, 0.104731, -0.409388, -0.255099, 0.0523827, -0.183336, -0.0513568, 0.0638936, -0.0838624, 0.481896, 0.156366, 0.108033, 0.0980218, -0.819101, 0.0282225, 0.103283, 0.305057, -0.0923232, -0.0368483, 0.0480233, -0.020541, -0.0733888, -0.201749, 0.0785749, 0.174961, -0.807966, -0.169882, -0.896245, -0.00827585, -0.00579303, 0.187636, 0.128592, -0.0580693, -0.66826, 0.123785, -0.242736, 0.037984, 0.0695229, 0.104885, -0.256963, -0.0498278, 0.213579, -0.121986, 0.102909, 0.0963607, -0.0900675, -0.0634895, -0.0894832, 0.166026, 0.0286321, 0.202202, -0.0295654, -0.248078, -0.129456, -0.605847, -0.114722, 0.0871509, 0.174468, -0.176663, -0.0966025, 0.019251, -0.00813751, -0.0620934, 0.118103, -0.175956, -0.299119, -0.341493, 0.00574235, -0.0158229, 0.139682, -0.20638, -0.305412, -0.0445008, -0.719451, -0.175742, -0.0736948, 0.171819, 0.0822046, -0.148902, 0.11989, -0.205431, -0.00238383, 0.0622617, -0.165444, 0.0492949, 0.189363, 0.0839771, 0.0574573, 0.111999, 0.242945, -0.316807, 0.0473127, 0.160828, 0.0255094, -0.409413, -0.112175, 0.148587, 0.228173, 0.254697, 0.0820559, -0.202699, 0.284706, -0.415559, -0.591992, -0.163214, -0.114645, -0.238187, 0.22373, -0.0443524, 0.465764, 0.287564, 0.133852, -0.073667, -1.1476, -0.0640382, -0.0253956, 0.619569, -0.288112, -0.087065, -0.0769331, -0.0416006, 0.00448708, -0.026012, -0.0278773, 0.303381, -0.412235, 0.0817946, -0.983101, 0.267973, -0.0108782, 0.143256, 0.120947, 0.00317154, -0.636031, 0.271577, -0.554197, 0.267456, 0.275642, 0.156134, -0.115878, -0.109673, 0.163185, -0.117748, 0.0864549, 0.146536, -0.0211274, -0.07678, -0.398086, 0.185002, 0.138866, 0.0800553, 0.0184089, -0.0698382, -0.232785, -1.01816, 0.0139144, 0.238687, 0.147689, -0.152358, -0.0370905, -0.11428, -0.0831527, 0.0743942, -0.122751, 0.0668831, -0.107798, -0.222173, -0.0149296, 0.0853061, 0.188639, -0.179682, -0.41867, -0.361686, -0.674874, -0.148026, -0.341147, 0.0828513, 0.00899288, 0.0868084, 0.227953, -0.373972, -0.15269, 0.217109, 0.22551, 0.0486986, 0.117601, 0.222033, 0.0735555, -0.0719968, 0.230527, -0.259187, -0.320753, 0.148642, 0.0166315, -0.299735, -0.485923, 0.129422, 0.115959, 0.281964, -0.0695696, -0.16306, 0.187138, -0.494832, -0.279737, -0.0544102, -0.273106, -0.39776, 0.0451767, 0.0731702, 0.162645, 0.410839, 0.0457549, 0.118615, -1.20514, -0.174583, -0.0146702, 0.545913, -0.125924, -0.160149, 0.0636455, 0.07328, 0.00529622, -0.01337, -0.262347, 0.174431, -0.511545, 0.00433884, -1.00627, 0.329764, -0.119521, -0.0148917, 0.164857, 0.00788136, -0.690205, 0.464227, -0.407949, 0.419573, -0.0663505, 0.0924485, -0.261749, 0.0676381, 0.0201538, -0.24622, 0.182374, 0.221481, -0.0127081, 0.190932, -0.20027, -0.12271, 0.219711, -0.10006, 0.154238}, {-0.310824, -0.501735, -0.938787, -0.129227, 0.0308601, 0.0520206, -0.153969, -0.0827716, -0.244847, 0.0333398, 0.0114795, -0.396558, -0.0649485, 0.281739, -0.214742, -0.0121814, -0.129238, 0.0149138, -0.127668, -0.31873, -0.243002, -0.217622, 0.201444, -0.413103, 0.312839, -0.083821, 0.206416, 0.485177, -0.486998, -0.119207, 0.141648, 0.334558, 0.0468835, -0.0564997, 0.267163, 0.034156, 0.154945, 0.21851, -0.572196, -0.466978, -0.175874, -0.113169, 0.077496, -0.436875, 0.330575, 0.338896, 0.0937368, -0.37299, 0.0226368, 0.0411935, -0.00505509, -0.10373, -0.109436, 0.0801445, -0.0288801, -0.164439, 0.0630499, 0.0992004, 0.0822288, -0.0570876, 0.0446562, -0.124413, 0.163485, -0.127262, -0.0380868, 0.033965, -0.0296378, -0.00682195, 0.0493185, 0.0231162, -0.0548844, -0.0338895, 0.169251, -0.0958081, 0.104819, -0.0795927, 0.0384177, -0.0571768, 0.216534, -0.0974096, -0.0784281, 0.0955821, 0.0920003, -0.14753, 0.0238991, 0.166534, 0.0113122, -0.0736464, 0.0688169, 0.141162, 0.149965, 0.0245884, 0.0811744, -0.0328987, 0.234837, -0.042555, 0.0528795, 0.0714924, 0.124357, -0.0349363, -0.112596, 0.0924855, -0.0833816, -0.0867275, 0.06888, 0.184915, -0.0245854, -0.0548901, 0.0836215, 0.0529091, 0.00474616, -0.104531, -0.062051, 0.0778635, 0.0125229, 0.0451085, -0.0285235, -0.113915, -0.107727, -0.184956, 0.0360107, -0.0276081, -0.00398378, 0.00282049, 0.0129193, -0.0469491, -0.0299294, -0.0589987, 0.0952923, 0.00582133, 0.0613971, -0.132922, 0.226015, -0.0823006, -0.148921, -0.00114274, -0.103876, -0.110895, 0.0891648, -0.071188, 0.0359218, 0.0405681, 0.0683945, 0.060305, -0.0658811, 0.0643279, -0.000496888, 0.0409714, -0.0183268, -0.0282746, -0.0298144, -0.106581, 0.0321816, 0.0267683, 0.020282, 0.0020999, 0.00218436, 0.108891, 0.0999526, -0.0927092, -0.0202756, 0.0114822, 0.0357976, -0.0256654, -0.0171641, -0.02868, -0.00468702, 0.052515, 0.0123479, -0.0585399, 0.0339984, 0.0322526, 0.0102908, 0.0511665, 0.111226, -0.0646985, 0.0272956, -0.0222158, -0.0543865, -0.0716061, -0.0162159, -0.0578602, -0.0244202, -0.101428, -0.0672203, -0.0164658, 0.0396047, 0.0143256, 0.0539061, 0.0384917, 0.020516, 0.0376522, -0.0454232, -0.0415815, 0.0527688, -0.0356333, 0.0475059, -0.0232694, -0.00736146, 0.00998066, -0.00372663, 0.000257172, -0.0337575, -0.040825, -0.0208082, 0.0643228, -0.0540721, -0.0644912, 0.0141496, 0.036502, 0.0772398, 0.0788257, -0.0498341, -0.0773803, 0.0493983, 0.0987519, 0.0436375, 0.0106904, 0.060807, 0.0413211, -0.0649736, -0.0299082, -0.022916, 0.00601604, 0.0124465, -0.0233837, -0.0905936, 0.0337988, 0.0225634, -0.0433865, 0.0933518, -0.113357, 0.0872354, 0.0471012, 0.106571, 0.00803893, -0.109776, -0.0285978, 0.0126699, 0.035917, -0.0545444, 0.0586804, -0.00762473, -0.0037669, -0.0263303, -0.0122503, 0.0340237, -0.0782781, -0.0110538, -0.0936787, -0.0383647, 0.0456764, 0.0127659, -0.0587542, 0.0574286, -0.0419471, -0.0298923, 0.00903737, 0.0379835, -0.0987769, 0.105633, -0.0693663, 0.00390662, -0.0622764, -0.00642511, -0.0392985, 0.00518139, 0.0418646, -0.0391223, 0.0331477, -0.0422388, -0.0369262, 0.0295545, -0.0634274, -0.0520505, -0.0149287, 0.0316791, -0.0462187, 0.0820535, -0.0795777, -0.0743254, -0.00504871, 0.0713286, -0.0328052, 0.0399136, 0.0814883, -0.0211353, 0.0784887, -0.0442157, 0.0513907, 0.0468283, 0.0256174, -0.0815919, -0.0655056, -0.0167338, -0.0398914, -0.0196581, 0.0986921, 0.00408015, 0.050229, 0.0751394, 0.00952508, 0.0389619, -0.0105902, -0.0402353, -0.0162341, 0.0292647, -0.102169, 0.0120367, -0.0337656, -0.0421527, -0.0303938, 0.0367874, 0.00496701, -0.00959001, 0.00857393, -0.0364388, -0.0568446, 0.0705293, 0.0241436, -0.0703388, 0.0199618, -0.0410184, -0.0517961, -0.0133862, -0.0628894, -0.0798932, -0.0451201, -0.0453478, 0.0007067, 0.0939213, -0.0661749, 0.0134392, 0.00758614, 0.0949927, -0.0747043, -0.0714022, 0.0816798, -0.0504857, 0.0442183, -0.0662717, -0.0522695, 0.00188251, -0.0432564, -0.0669693, 0.0454858, 0.024343, 0.0564792, 0.043071, 0.0310694, 0.00759011, 0.0232362, 0.0324084, 0.0311834, 0.0253566, 0.000977255, -0.0257068, 0.0199609, -0.0737573, 0.0205626, -0.0291994, 0.0426598, -0.0646873, 0.034371, 0.0692001, 0.000720747, -0.0752461, 0.0123953, 0.00286609, 0.00906989, -0.042471, -0.0582077, 0.00454728, -0.0628106, -0.0484154, 0.0341019, -0.0318171, 0.0637546, -0.00714056, 0.0583101, 0.0708716, 0.054052, 0.0609338, -0.0685063, -0.0366104, 0.0733, 0.0017346, -0.0293557, -0.0309954, -0.0285485, 0.0624785, -0.0136579, -0.0351294, 0.0493847, -0.0433703, -0.0391646, 0.022938, 0.0649219, 0.0535962, -0.0512346, -0.0282052, -0.0222894, -0.0100015, 0.0547703, 0.0305387, -0.0628279, -0.0261293, -0.0633042, 0.0625656, 0.0288807, 0.0446274, -0.0453427, 0.025109, -0.0129044, -0.0410497, -0.0583132, 0.0484407, 0.0624922, -0.0520885, -0.0783544, 0.071666, -0.0573031, -0.0715657, 0.0165719, -0.0725081, -0.0608177, 0.0589071, 0.0383731, -0.021752, 0.0686998, 0.0186433, 0.0802136, 0.0461873, 0.063953, 0.0535318, 0.00376466, -0.0712307, 0.0428921, -0.0592751, -0.0813859, 0.0613695, -0.0171258, -0.0318517, 0.00955682, -0.0603586, 0.0546847, 0.0268846, 0.0537525, 0.0404276, 0.0729837, 0.038983, 0.00029479, -0.0661195, 0.0453787, 0.0338166, -0.0495587, -0.0167423, -0.0385836, -0.000163577, 0.0115258, -0.0636136, -0.0660302, 0.0726206, -0.053659, 0.0355385, -0.0360265, 0.0111682, 0.0823384, -0.0656257, -0.0119431, 0.0750351, -0.0645851, -0.0800497, -0.0180761, 0.0275905, 0.0694109, 0.0301035, 0.00585606, 0.0105105, -0.043268, -0.0040151, 0.0243323, 0.0110509, -0.00300626, 0.0165609, -0.0245802, 0.046637, -0.0296313, -0.0246952, 0.0345777, -0.0190581, -0.0590362, -0.0800191, -0.021091, -0.0395661, 0.0761883, 0.0369051, -0.0275149, -0.0408389, 0.0717092, -0.00405114, 0.0443128, 0.0580863, 0.0102996, -0.0726185, 0.0279936, 0.00450847, -0.00697814, 0.0559126, 0.040159, -0.0555544, 0.0295119, 0.0028521, -0.0766127, 0.0814635, 0.00807688, 0.0375372, 0.0024132, 0.0598747, 0.02597, 0.0296079, -0.0571699, -0.0728675, 0.0680686, 0.0595697, 0.00698625, -0.0394069, -0.0522403, 0.0564942, 0.0171565, 0.0549109, -0.0652528, -0.0326802, 0.0311419, 0.0810319, 0.0813375, 0.0625598, -0.0640988, 0.0738893, 0.0680694, 0.0329532, -0.00418775, -0.0696034, 0.0644933, -0.0332152, 0.06562, 0.00871484, 0.0127935, 0.0466724, 0.0578147, 0.0403739, 0.0289223, 0.0138596, -0.0800235, 0.0388418, -0.0636217, 0.0563005, 0.000151046, -0.0686361, -0.0190171, 0.013044, 0.0250525, -0.00562835, 0.0380288, 0.0175865, -0.0208648, -0.0390488, 0.044681, -0.0746901, -0.0822788, -0.0564843, -0.0337598, -0.0474654, 0.0327911, 0.0411656, 0.0236142, 0.0270811, 0.0815078, 0.0608293, -0.0264536, -0.0522282, 0.0170165, 0.00349636, -0.030401, -0.0692183, 0.0802874, 0.0144829, -0.0087024, 0.0693823, -0.00331467, 0.0451063, -0.0694526, 0.0135218, 0.0165303, 0.0386905, 0.0392522, 0.0361335, -0.047986, -0.0802647, 0.0377038, -0.0417655, 0.0475392, -0.0484105, -0.0610921, -0.0716727, -0.0283652, 0.0712297, 0.0788465, -0.0331273, 0.0804172, -0.0157171, -0.0164725, -0.0750131, -0.0602008, 0.00894697, -0.00746187, -0.0565595, 0.0240088, 0.0655966, -0.0201911, 0.0130017, -0.0199986, -0.00664475, -0.0135172, -0.00779853, -0.0153697, 0.0621318, 0.0497622, -0.0427658, 0.0688184, 0.0503307, 0.0717023, -0.0804483, -0.0683021, -0.0675429, -0.00186514, -0.0761634, -0.0686095, 0.0559661, 0.0137029, -0.0782915, -0.0208308, -0.0506779, 0.0280671, -0.0514878, 0.0293278, -0.0507099, -0.0402384, -0.068982, 0.025489, 0.0573414, -0.0437307, -0.032757, 0.0477847, -0.0622929, 0.0612655, -0.0433922, -0.139516, -0.044775, -0.00730716, 0.0668128, -0.187731, 0.014532, -0.0952177, 0.0549012, -0.156749, 0.0681615, 0.0665079, -0.089454, -0.0631344, -0.100911, -0.131669, -0.0120818, 0.0480851, -0.0572359, -0.082108, 0.0695795, 0.200069, 0.00132828, 0.0559519, 0.0772459, 0.0716661, 0.0522049, -0.0844002, 0.0463116, 0.0227742, 0.0271229, -0.203653, 0.0136672, -0.0994669, 0.187535, -0.0257225, 0.0497018, -0.0136866, -0.0430233, 0.192216, -0.0114911, -0.0281352, 0.0280816, -0.0526081, -0.0444699, -0.0285116, -0.0361106, -0.0664621, -0.0328895, 0.0500225, -0.0583601, -0.123446, 0.0155738, -0.0767557, -0.130571, -0.0640787, 0.0630465, -0.00453832, 0.0930916, -0.064771, 0.033936, -0.0188803, 0.0991299, 0.0537305, 0.0532785, 0.0990479, 0.0212029, -0.0149401, 0.19171, 0.0284706, 0.0780703, 0.0415042, -0.0109167, -0.102076, -0.00633054, -0.110795, 0.0527938, -0.0538471, -0.0638243, -0.018691, 0.00518811, -0.0640342, -0.00634633, -0.0681722, 0.0449078, 0.0558732, 0.0808639, 0.0750632, 0.0392901, -0.119253, 0.0662957, -0.0455214, -0.00258886, -0.0620153, 0.0424511, 0.0690657, 0.0422098, -0.0364898, -0.0331626, 0.0723771, 0.0513365, 0.0668113, 0.0221642, -0.0956103, 0.0122901, -0.159081, 0.063159, -0.109508, 0.0332772, -0.0826837, 0.0361933, 0.055683, 0.0475133, -0.1039, -0.0879377, -0.0363204, 0.162309, -0.121883, -0.0182018, 0.107765, -0.010547, 0.223179, 0.0719616, 0.12798, 0.0125635, 0.0559529, 0.131375, -0.044582}, {-0.0471476, 0.0671641, 0.0669465, -0.125802, -0.0880718, 0.0767483, 0.233628, 0.142763, 0.10444, -0.0265923, -0.0406642, 0.115697, 0.125641, 0.0970102, 0.0324984, -0.0144403, -0.0769285, -0.0299348, -0.0448649, 0.0546155, -0.0773881, 0.0483257, 0.00202342, -0.138605, -0.0271392, 0.0659514, 0.0434822, -0.0469346, 0.0957975, 0.0916557, 0.174696, 0.0241466, 0.0411658, 0.000280981, 0.13487, 0.190669, 0.00696361, 0.091499, -0.0971679, 0.0736199, 0.229329, -0.0466831, 0.0346575, -0.0484013, -0.0903286, -0.0640339, 0.00880248, -0.0126295, 0.0814048, -0.153218, -0.178455, -0.0969443, 0.032961, 0.0621664, -0.131623, -0.151817, 0.139847, 0.13424, 0.131483, 0.168624, 0.0472496, -0.104316, -0.0623232, -0.046881, -0.0740903, -0.304247, -0.209375, 0.722278, 0.0187688, -0.11003, -0.0401976, 0.087314, 0.262675, -0.182705, -0.20992, -0.964477, 0.296798, 0.0990796, -0.0374531, -0.284551, 0.0435631, 0.230491, -0.0465767, 0.0634955, -0.422649, 0.180516, -0.13423, 0.251557, 0.0671568, -0.246263, 0.129962, -0.000339977, -0.0868101, -0.279873, -0.251553, -0.00714995, -0.0734947, 0.20155, 0.384042, -0.403087, -0.978897, 0.352813, -0.495825, -0.653813, 0.275737, -0.40913, 0.0184233, -0.006705, 0.362562, 0.714532, 0.100316, 0.127683, 0.14747, -0.594447, 0.0530436, -0.125574, -0.0667854, 0.0966246, 0.477992, 0.287014, 0.147313, -0.012093, -0.235406, -0.0525341, 0.285449, 0.0020713, 0.0900615, -0.247446, 0.373974, 0.15932, 0.360158, 0.031585, -0.17536, -0.398048, -0.192575, 0.14733, 0.395424, 0.0607464, 0.0893616, -0.192085, 0.408745, -0.084827, 0.201812, 0.300728, -0.814584, -0.0599852, -0.128042, 0.116233, 0.0753887, -0.239232, 0.00672984, 0.639669, -0.216909, -0.0436129, 0.070328, -0.0449067, 0.159865, -0.211946, 0.0266114, 0.206849, -0.0993164, 0.0492959, -0.0202322, -0.408789, -0.0234697, -0.117278, 0.12138, 0.109483, 0.0192717, -0.0711348, 0.089204, 0.00133732, 0.347905, -0.10041, -0.0772095, -0.609394, -0.0339833, 0.146822, -0.029745, 0.139434, -0.0246548, 0.239803, 0.140138, -0.0586973, -0.232549, 0.139754, 0.238698, 0.160225, -0.250389, -0.124516, 0.275615, -0.181117, -0.180353, -0.258215, -0.182672, 0.00789792, 0.0366493, -0.00363555, 0.116805, 0.0643318, -0.986864, 0.237634, -0.236776, -0.75468, 0.0936089, -0.32337, 0.0264974, -0.0895608, -0.0249839, 0.355262, 0.138296, -0.132896, 0.0957841, -0.531758, 0.143706, 0.170938, -0.0260931, -0.084973, 0.187535, 0.0227492, 0.109096, -0.0472913, -0.104558, 0.05736, 0.167229, -0.0929576, 0.242779, 0.163283, 0.0384063, 0.159877, 0.317163, 0.109726, -0.0489403, -0.502122, -0.094425, 0.160514, -0.0201454, -0.150028, 0.22889, 0.0260483, 0.2317, 0.0323102, 0.362171, -0.0689364, -0.339841, 0.18762, -0.141027, -0.135707, -0.247439, -0.138024, 0.0874699, 0.390952, 0.155079, 0.139687, 0.0154739, -0.232031, -0.0539819, -0.245613, -0.0656791, 0.352083, -0.190114, -0.134866, -0.369538, -0.341217, -0.0158857, -0.337141, 0.199517, -0.154997, -0.0935538, -0.0353125, 0.0865641, -0.0963672, 0.358681, -0.212123, 0.0232635, -0.371907, -0.108487, 0.0106453, -0.0516306, -0.122348, 0.0381137, 0.132386, -0.118326, 0.00756445, -0.0518351, 0.235596, 0.178806, -0.0494514, -0.22442, 0.0541505, -0.0189787, -0.0715977, -0.181317, -0.395457, -0.0466807, -0.144586, 0.061639, -0.0812723, 0.069835, 0.114184, -0.843415, 0.177531, -0.0224593, -0.768797, 0.0624331, 0.0199943, 0.0583546, -0.114465, -0.146802, 0.307567, 0.0952933, -0.0767959, -0.0347597, -0.308741, -0.0720297, 0.241359, 0.0721061, -0.0324264, 0.116604, 0.189401, -0.0858256, 0.0438758, 0.0587828, 0.130602, 0.126215, -0.0786359, 0.101788, -0.107646, 0.116333, -0.0776821, 0.37453, 0.226931, 0.203454, -0.379789, -0.248201, 0.209862, 0.0183791, -0.203601, 0.100384, 0.299418, 0.0349884, -0.0374823, -0.0122141, 0.00398262, -0.386817, 0.388871, 0.2062, -0.161249, -0.107597, -0.0512295, 0.0578733, 0.170075, -0.0165835, 0.0726421, 0.177144, -0.165617, 0.0874797, -0.0964483, -0.0936905, 0.296921, 0.0610329, -0.103158, -0.192547, -0.27733, -0.0402585, -0.234323, 0.230725, -0.196249, -0.032528, -0.0468999, 0.167536, -0.0778305, 0.193812, -0.0928915, 0.00151469, -0.586008, 0.0383277, 0.0737187, -0.192461, -0.148869, 0.0450799, 0.0825912, -0.293548, -0.0903061, -0.0645083, 0.303259, 0.373918, -0.185, -0.184272, -0.142106, -0.0523979, 0.0325934, -0.0505628, -0.412418, -0.184369, -0.195498, -0.0700597, -0.0788816, 0.0972507, 0.0413194, -0.853976, 0.0922989, -0.0665043, -0.575737, -0.0788466, 0.0163793, 0.00733724, -0.292863, -0.080194, 0.0550769, -0.0611893, 0.0153196, -0.0867073, -0.282464, -0.0766679, -0.0527401, 0.120049, 0.205486, 0.0936496, -0.128945, -0.0882846, -0.14022, 0.23693, 0.271844, 0.0318915, -0.00648465, -0.0823613, -0.0763114, 0.153029, 0.0345857, 0.158145, 0.0577163, 0.212416, -0.382608, -0.0193867, 0.057984, 0.00555198, -0.0232922, -0.0022085, 0.369275, -0.0981598, -0.113958, -0.180904, -0.168987, -0.123962, 0.183589, 0.223017, -0.0481644, -0.133819, 0.0881558, 0.0602689, 0.14592, -0.0162218, 0.00992814, 0.101569, -0.0427048, 0.298122, -0.0623777, -0.00765353, 0.264825, 0.223078, -0.125057, -0.290765, -0.158594, -0.0229213, -0.24823, 0.257216, -0.389682, 0.0263656, 0.0447934, 0.0916737, -0.0815427, 0.0385083, -0.0597967, -0.0358967, -0.369192, 0.208349, -0.0758201, -0.117482, 0.0363094, -0.0331844, 0.159481, -0.2588, -0.0794137, 0.0215986, 0.058171, 0.345103, -0.1635, -0.126644, 0.0242229, -0.120302, 0.00550381, -0.188051, -0.140837, 0.0207629, -0.000623053, -0.0303288, -0.194247, 0.0311512, -0.131423, -0.676817, 0.0259605, -0.198916, -0.276027, -0.00797947, -0.0167792, 0.0283188, -0.229972, -0.142149, -0.109483, 0.00545765, -0.0588662, -0.0431498, -0.26935, -0.204888, -0.181502, 0.144616, 0.157053, 0.151237, -0.321951, 0.0489168, -0.0281529, 0.533244, 0.291011, -0.0699959, 0.0277734, -0.0422687, -0.121855, 0.240904, 0.125854, 0.0697195, -0.0790858, 0.28708, -0.415975, -0.018872, 0.176562, -0.0750807, 0.102708, 0.0743995, 0.381935, 0.0225771, 0.0965027, -0.210265, 0.0746084, -0.109813, 0.0156417, 0.122598, -0.115903, -0.117811, 0.235776, -0.0780798, -0.165786, 0.0771372, 0.121757, -0.0557445, -0.0593084, 0.37975, -0.0370286, -0.0502261, 0.262008, 0.0402372, -0.00591842, -0.199084, 0.0886836, -0.296759, -0.325296, -0.00165682, -0.524341, -0.0938576, 0.128261, 0.0187534, -0.227162, -0.11063, -0.0538914, -0.0283888, -0.405162, 0.0933453, -0.0342287, -0.189535, 0.177329, 0.152403, 0.0220066, -0.0945562, -0.0552605, -0.0648618, 0.209704, 0.351988, -0.144444, -0.0512372, 0.101882, 0.0814061, 0.0734211, -0.0829987, 0.0338147, -0.157001, -0.0564621, -0.066443, 0.00908677, 0.23058, 0.00767624, -0.398407, -0.314395, 0.0376832, -0.227928, -0.146856, 0.0302411, -0.138434, -0.30512, -0.303019, -0.551713, 0.00378123, -0.0778233, 0.0364157, 0.3171, -0.316474, -0.269712, 0.105852, 0.254609, 0.0475717, -0.0458023, 0.154962, 0.0658134, 0.591116, 0.0978759, -0.172967, 0.00525067, 0.106974, -0.0303228, 0.0683551, -0.182265, -0.0188748, -0.139682, 0.396574, -0.520381, 0.0198521, -0.0552554, -0.0293399, -0.0224076, -0.148763, 0.128158, -0.0261094, 0.0732204, -0.380085, 0.0223764, -0.158971, 0.049554, 0.175989, 0.059532, 0.0867678, 0.342257, 0.0998307, -0.0948598, 0.109055, -0.034153, 0.081719, 0.106432, 0.53019, 0.0370282, -0.0106648, 0.0854629, -0.00212083, -0.0612533, 0.00697984, 0.13632, -0.415182, -0.267179, -0.123863, -0.342276, -0.0359247, 0.0702666, 0.196113, -0.274715, 0.0839212, 0.0798408, 0.00539778, -0.175211, 0.097752, 0.140903, -0.20214, -0.136528, 0.199017, 0.274658, -0.0891549, -0.00220446, -0.00370267, 0.0248589, 0.219468, 0.0989606, -0.00682338, -0.0664492, 0.0501789, 0.0710299, -0.184121, 0.0133676, -0.091536, -0.121123, -0.0741472, 0.142144, 0.0133518, -0.00573472, -0.14387, -0.0974185, 0.23888, -0.0935329, -0.530117, 0.129315, 0.0273417, -0.643291, -0.363842, -0.789834, -0.0178156, 0.0819079, 0.238893, 0.449035, -0.161536, -0.275447, 0.0633234, 0.0864164, 0.232032, 0.0557044, 0.0305314, -0.119836, 0.35467, 0.0599562, -0.0466273, 0.00367801, 0.178157, -0.0146542, 0.0144882, -0.280592, 0.0272737, -0.31509, -0.140772, -0.569385, -0.181021, -0.170967, -0.318869, -0.228051, -0.00220252, 0.0246474, -0.062924, -0.240252, -0.239464, 0.0571652, -0.0656181, 0.0570355, 0.0284181, 0.309044, 0.0872649, 0.376826, 0.233015, -0.223708, 0.391989, 0.0657806, 0.0610807, -0.168963, 0.555464, -0.0293446, 0.0867442, -0.110036, -0.0661495, -0.0999902, -0.0550829, 0.118359, -0.252388, -0.229245, 0.050618, -0.374019, 0.0256801, 0.0593372, 0.205699, -0.328072, 0.217643, 0.157673, -0.0465393, -0.0807068, 0.177702, 0.0744798, -0.0414966, -0.0537098, 0.305504, 0.221467, -0.126337, -0.010729}, {-0.13366, 0.0278457, 0.178596, 0.283429, 0.135022, -0.0302394, 0.194783, 0.0480354, -0.24345, 0.035799, -0.155747, -0.166851, -0.0644232, 0.273613, -0.166249, 0.0980327, -0.107831, -0.0336569, 0.358632, -0.0271172, -0.654627, 0.0291379, 0.309548, -0.814889, -0.122758, -0.832448, 0.0238444, -0.177304, 0.305842, 0.565263, -0.140087, -0.145391, 0.0449687, -0.011626, 0.0520929, 0.142986, 0.0413983, -0.158481, -0.0246792, 0.103042, 0.0662855, 0.0161057, 0.0929085, 0.176751, 0.0312788, -0.0421006, 0.0794787, -0.0896371, -0.479441, -0.446511, 0.057874, -0.0016522, -0.226547, -0.0714456, 0.249191, -0.0193335, -0.237113, -0.0790118, -0.226785, 0.160853, -0.00287655, 0.0865048, 0.262923, 0.462986, 0.188359, -0.0153193, 0.149774, -0.172007, 0.141894, 0.127893, 0.091429, -0.232746, 0.50159, 0.139886, -0.150487, -0.43853, -0.710605, -0.0579755, 0.0633378, 0.270725, -0.521159, -0.281271, 0.152329, -0.0156804, 0.0663144, -0.0931099, 0.0825373, -0.0313524, 0.288979, 0.0593235, -0.126212, -0.170071, 0.0462642, 0.18017, 0.213434, 0.0284796, 0.311117, 0.124858, -0.0576369, 0.0183828, -0.0129338, -0.201453, 0.0626279, 0.299361, 0.086588, -0.079841, 0.161327, 0.0267874, 0.102024, -0.120557, -0.0684297, -0.128861, -0.0830496, 0.231612, -0.253349, 0.145653, 0.200933, 0.148135, 0.356677, 0.0812363, -0.445662, -0.0097076, 0.167532, -0.265277, -0.156588, -0.497876, 0.0350589, -0.104961, 0.173926, 0.622521, 0.0156163, -0.189955, 0.176869, -0.230557, -0.025598, -0.0533529, -0.00371363, 0.0916424, -0.302094, 0.0477423, 0.00722408, -0.0234451, -0.228946, 0.0831162, 0.0978811, 0.159996, -0.0366214, 0.0102951, -0.298508, -0.0770718, 0.245202, -0.195864, -0.0768306, -0.0623134, -0.139481, -0.06445, -0.0770241, -0.173165, -0.236636, 0.0514212, 0.0154818, 0.0561119, 0.309447, 0.278627, 0.168645, -0.0364031, 0.179602, -0.124191, 0.262428, 0.165891, 0.0527798, -0.0344905, 0.48744, 0.112479, -0.0732343, -0.41752, -0.492041, -0.130629, -0.137438, 0.246603, -0.648637, -0.0862919, 0.340389, -0.0152349, -0.106399, -0.100639, 0.0152932, 0.041601, 0.386136, -0.0118932, -0.0586595, -0.208679, 0.0416146, 0.220088, 0.309962, 0.00243371, -0.112327, -0.00324439, 0.0645018, -0.078614, -0.0716224, -0.354011, 0.142153, 0.435776, -0.1206, -0.171551, -0.0750402, 0.0977834, 0.279725, -0.207972, 0.0153845, 0.0734801, -0.0527192, 0.267911, -0.484181, -0.0021016, 0.0295855, 0.276471, 0.205615, 0.0164372, 0.0342301, 0.00753884, 0.124435, 0.293694, -0.128328, -0.462477, 0.0161832, 0.0650519, 0.321268, 0.360211, 0.177108, -0.143875, 0.0892926, -0.269294, 0.107659, -0.309906, -0.0018209, 0.114532, -0.219189, 0.0475538, -0.120103, -0.0966847, -0.0717385, 0.180714, 0.333437, 0.279817, -0.18952, -0.0923976, 0.0779335, 0.129998, 0.23373, 0.0357985, 0.000281798, -0.0185173, 0.198981, 0.0274727, 0.251158, 0.228406, 0.0207424, -0.0396589, 0.170006, -0.0104597, 0.20401, 0.215134, -0.049114, -0.0833124, 0.0778472, -0.157897, 0.358903, 0.0849787, 0.0988121, -0.211065, 0.686719, 0.106915, -0.0940921, -0.642236, -0.619426, -0.219769, -0.0495619, 0.47955, -0.634483, -0.203821, 0.152368, 0.13397, -0.0769539, -0.194908, 0.00607063, 0.260808, 0.0911772, -0.0791425, 0.0887482, -0.00660357, -0.00486391, -0.126475, -0.0420007, -0.13978, -0.23109, 0.137377, 0.0231693, 0.0241042, -0.0532037, -0.271314, 0.133467, 0.288569, -0.244459, 0.0482626, -0.0838712, 0.0649202, 0.321476, 0.00292242, -0.0384595, 0.176791, 0.0536328, 0.267883, -0.0903471, 0.0907705, 0.10829, 0.484857, 0.101944, -0.144479, 0.349595, -0.000940943, 0.11839, 0.425716, -0.0626715, -0.245427, 0.055819, 0.0272548, 0.26761, 0.120601, -0.00337313, -0.197682, -0.0329766, -0.237588, 0.383691, -0.123397, -0.0296339, -0.0857551, -0.282495, 0.0962027, -0.0743769, -0.0280234, 0.152939, 0.269259, 0.395503, 0.354697, 0.0137509, -0.0531184, 0.153234, 0.0867017, 0.229444, 0.253077, -0.151964, 0.259562, 0.240588, -0.0520671, 0.0362297, 0.278093, 0.103806, 0.0342379, -0.225641, 0.0509804, 0.0228315, 0.0570992, 0.0382423, -0.0756862, 0.0244704, 0.0838093, -0.110091, 0.112282, 0.212168, -0.181429, 0.589279, 0.0625857, 0.0312023, -0.691948, -0.32586, -0.49686, -0.441319, 0.101676, -0.651613, -0.121743, -0.047195, 0.259372, -0.157936, -0.399526, -0.0670458, 0.188083, -0.486889, -0.241305, -0.238724, -0.0708666, -0.19042, -0.0925816, 0.143389, 0.0947892, -0.206216, -0.329553, 0.0781136, -0.0513608, -0.0443032, -0.172116, -0.032068, 0.274658, -0.0366358, 0.0842504, -0.0459163, 0.0103531, 0.238491, 0.0258298, 0.087446, 0.440626, -0.0103577, 0.201719, -0.108078, 0.192996, -0.0453951, 0.205088, -0.0319132, -0.18731, 0.216093, -0.190931, 0.0690931, 0.380013, -0.00468189, -0.147786, 0.30458, 0.277524, -0.0840986, 0.00227494, 0.0720046, -0.0829272, 0.213985, -0.231703, 0.412185, -0.154888, 0.278176, -0.271647, -0.0245484, -0.0310431, -0.271314, -0.0618647, 0.132824, 0.48251, 0.36241, 0.276277, 0.17564, -0.0379384, -0.02844, -0.214105, 0.0479876, 0.370943, -0.122771, 0.465855, 0.210999, -0.0158412, 0.207324, 0.13767, 0.043135, 0.0517382, -0.264638, -0.056687, -0.225636, -0.0645471, -0.230078, 0.0594464, -0.02161, -0.036789, -0.228485, -0.170479, 0.193172, 0.145117, 0.570683, -0.0744427, 0.049269, -0.589075, -0.367433, -0.4994, -0.397602, -0.428473, -0.473259, -0.16993, -0.148104, 0.13239, 0.0738286, -0.153254, -0.108378, 0.0738444, -0.550239, -0.305259, -0.331685, -0.141899, -0.0914243, -0.349306, 0.0484326, 0.0937041, -0.124639, -0.644906, -0.131145, -0.0954188, -0.204248, 0.00598367, 0.0771525, 0.355355, 0.148581, -0.0365887, -0.0654497, -0.499397, 0.0394294, -0.0308121, 0.0642979, 0.120704, 0.029027, -0.223137, -0.213351, 0.308713, -0.0644092, -0.117739, -0.0812934, -0.0437867, -0.0682001, -0.0650028, 0.116809, 0.319212, 0.0205846, -0.166251, 0.204896, 0.372045, -0.201681, -0.0664905, -0.0373676, -0.26566, 0.229187, 0.120649, 0.396202, 0.109506, 0.207263, -0.168285, -0.00491811, 0.158782, -0.243171, -0.0433505, 0.10402, 0.376075, 0.099625, 0.278718, 0.062647, -0.10184, 0.121909, -0.146741, -0.598485, 0.244386, 0.15269, 0.621559, 0.0379893, -0.0437507, 0.204365, -0.118161, -0.0497894, 0.0516261, -0.148957, -0.0311492, -0.0971316, 0.170864, 0.178783, 0.0163996, 0.0689977, -0.17388, -0.147176, -0.2684, 0.133181, 0.352484, 0.627535, 0.160154, 0.18779, -0.281499, -0.298816, -0.534989, -0.107642, -0.252677, -0.231856, -0.429815, -0.133363, 0.124839, -0.173148, -0.101517, -0.250411, 0.0553754, -0.343085, -0.279447, 0.0153486, -0.259223, -0.171873, -0.578733, 0.00352346, -0.0534602, -0.0625599, -0.568568, -0.0937978, -0.0109638, -0.0292127, -0.0322418, 0.112999, 0.233734, -0.0321644, -0.223138, -0.183606, -0.907213, -0.0332877, -0.174202, 0.0102756, 0.0152679, -0.0936856, -0.638749, 0.0485336, 0.0592023, -0.0168126, -0.245016, -0.00212089, -0.00706694, -0.213393, 0.244257, 0.280975, 0.0114358, -0.0332239, -0.156853, 0.207764, 0.305686, -0.12437, -0.0565969, -0.0427947, -0.00546613, 0.0301246, 0.0727259, 0.0191105, 0.0133146, 0.116055, -0.0508118, -0.105663, 0.110767, -0.151677, 0.0136579, 0.0961918, 0.48275, -0.0568101, 0.0535191, -0.16499, 0.12804, 0.0518272, -0.143038, -0.774992, 0.173865, 0.157068, 0.305644, 0.23795, -0.0223832, 0.194047, -0.175995, 0.00573049, 0.0122508, 0.125683, -0.0135724, -0.0943545, 0.117657, 0.168559, 0.00393252, -0.00502534, -0.16273, 0.00864485, -0.343724, 0.0771586, 0.367089, 0.71903, 0.00340492, 0.0723231, -0.213856, -0.1093, -0.311165, 0.0857158, -0.108205, -0.3943, -0.287442, -0.264357, 0.105592, -0.209519, 0.087538, -0.131859, 0.131592, 0.104935, -0.273413, 0.156688, -0.0844093, -0.0298368, -1.15967, -0.0798109, -0.0522624, -0.192811, -0.432145, 0.0557586, -0.000511722, -0.0895172, 0.0780417, -0.00824731, 0.241948, 0.0959786, -0.504673, 0.0893533, -1.4026, -0.130652, -0.10126, 0.0324244, 0.0559969, 0.054112, -0.526318, 0.13369, -0.0182754, -0.158291, -0.428257, 0.25774, -0.299085, -0.0552376, 0.0627313, 0.277554, -0.0897307, -0.0257347, -0.253565, 0.0738013, 0.0906867, 0.158785, -0.00682615, -0.0660448, -0.167343, -0.0838011, -0.0947974, -0.226888, -0.035277, 0.129691, 0.13602, -0.181004, -0.176087, -0.00614679, -0.057195, 0.136444, 0.309945, -0.274284, -0.0205504, -0.16074, -0.136295, 0.0513776, -0.218577, -0.122688, -0.11026, -0.132986, 0.129068, 0.286135, 0.146118, 0.113454, -0.126312, 0.23258, 0.216568, 0.0939568, -0.0301451, 0.0948362, 0.0637145, 0.000393073, 0.0452831, -0.0357156, -0.0830331, 0.0651926, -0.220928, 0.126124, 0.2289, 0.564217, -0.193441, 0.0184913, -0.240306, 0.141011, -0.0155499, 0.389525, 0.0750327, -0.375902, -0.15556, -0.383026, -0.0160686}, {0.0469292, 0.0378858, -0.0152103, 0.0688856, 0.184323, -0.0774576, 0.156648, 0.203653, 0.0841528, -1.91301, 0.148572, -0.286294, -0.099123, -0.257838, -0.0386405, 0.0653985, -0.0926617, 0.110576, -0.117004, 0.227837, 0.201953, -0.502264, -0.132788, -1.35111, -0.115735, -0.0299305, -0.120743, -0.110807, -0.0748601, -0.790715, 0.294502, -0.206627, 0.0244337, -0.273097, 0.104632, -0.0521677, 0.0239859, 0.0263903, 0.25681, 0.0895105, 0.0581106, -0.265537, 0.231975, -0.0119125, 0.295427, 0.200467, 0.0433039, -0.108459, -0.263258, -0.04952, -0.61943, 0.0579739, 0.0047437, 0.224049, -0.111144, -0.0715957, -0.1087, -0.0937549, 0.106289, 0.121042, -0.503415, 0.0378948, -0.126975, -0.265927, -0.0310413, -0.162304, -0.0256313, -0.130325, -0.00720607, -0.0434384, 0.16133, -0.0949902, 0.138025, -0.22439, 0.200993, 0.311759, -0.152415, -0.00153288, 0.41896, -0.0739266, 0.0116125, -0.0969581, 0.128606, 0.0439234, -0.0683614, -0.132941, 0.157628, 0.115552, 0.67009, -0.180823, 0.0857917, -0.316444, -0.09823, 0.194938, 0.286218, 0.104362, -0.217966, -0.0831927, -0.425861, -0.181242, 0.148093, -0.0897683, -0.0141561, -0.0635623, 0.0359993, 0.0153717, 0.231617, 0.24251, 0.0172864, -1.81663, 0.0346324, -0.247932, 0.164727, -0.295037, -0.0787046, 0.0433919, -0.100642, 0.132857, -0.187436, 0.289021, 0.231946, -0.397293, -0.131609, -1.47271, 0.104439, 0.0382049, -0.111868, 0.00754156, -0.0881462, -0.85427, 0.193014, -0.0734774, -0.137648, -0.0169708, 0.0757056, -0.259549, 0.0964008, 0.160288, 0.0521686, -0.0451881, 0.0559363, -0.0328224, 0.0577583, -0.0469716, 0.501689, -0.00382448, 0.237468, 0.0103712, -0.162842, -0.18887, -1.05806, -0.129072, 0.247376, 0.0653652, -0.394477, 0.00525087, -0.109469, -0.00751751, -0.25373, -0.0538249, -0.35798, 0.0917474, -0.311826, -0.139119, -0.00712431, -0.0975625, -0.303353, -0.169197, -0.0678352, -0.343234, 0.320545, -0.04594, 0.145912, -0.127714, 0.0726393, 0.123481, -0.17124, -0.0395165, 0.434363, -0.0784903, -0.104693, 0.0630877, 0.156895, 0.0871663, -0.122001, -0.0332837, 0.314038, -0.0307551, 0.40527, 0.0705691, -0.0853266, -0.285993, -0.0756933, 0.380181, 0.482916, -0.0782653, -0.297456, 0.177351, -0.355907, -0.369254, -0.0851938, -0.0369796, -0.246828, 0.0767311, 0.060039, 0.0435783, 0.430742, 0.338093, 0.011437, -1.40793, 0.0253463, -0.0744453, 0.408883, -0.418971, 0.216752, -0.0503724, -0.208827, -0.00421678, -0.418744, 0.143728, 0.454851, -0.211055, -0.0973208, -1.32418, 0.0275199, -0.0510679, -0.195049, -0.0631543, -0.0562131, -1.38936, 0.0428209, -0.110008, 0.0320102, 0.362648, 0.0541046, -0.44394, 0.0667297, 0.178856, -0.0943889, -0.0538456, 0.147325, -0.038238, 0.0727241, -0.327235, 0.175162, -0.081098, 0.0342312, 0.153678, -0.0289601, -0.136926, -1.20912, -0.115617, 0.0331061, 0.174025, -0.340011, 0.0499273, -0.0363767, -0.0323848, 0.0333397, -0.21072, -0.358573, -0.0678871, -0.283324, 0.0493895, -0.0333532, 0.0864095, -0.107019, -0.360222, -0.152583, -0.512262, 0.0653781, -0.187381, 0.0419183, 0.0914939, -0.0270026, -0.124902, -0.292448, 0.0323416, 0.207346, -0.151796, -0.127786, -0.00565741, 0.274064, 0.0195255, -0.31267, 0.108338, 0.205584, -0.0352381, 0.360312, 0.0782005, -0.331819, -0.107429, 0.100302, 0.498017, 0.360285, 0.0193074, -0.161589, 0.205979, -0.323181, -0.278247, -0.0917068, 0.160931, -0.376738, 0.18541, -0.0173033, -0.00209793, 0.579229, 0.35145, 0.00152672, -1.19422, 0.212979, -0.25167, 0.538038, -0.456212, -0.130581, -0.0878677, -0.208663, 0.0579408, -0.348781, -0.014285, 0.139491, -0.0675519, -0.0471847, -1.27094, 0.50384, 0.00619663, -0.22039, -0.338964, -0.00516129, -1.24735, 0.191549, -0.323818, 0.250591, 0.34868, -0.0605747, -0.197497, 0.112254, 0.299491, -0.101539, 0.159149, 0.212653, -0.0637909, -0.0723151, -0.621845, 0.0434773, 0.239652, -0.0428561, 0.148801, -0.0159101, -0.305146, -1.09399, -0.118985, -0.0283772, 0.0606631, -0.054408, -0.142428, -0.192398, -0.00429387, 0.0902633, -0.583713, -0.387234, -0.12529, -0.611775, -0.0181052, 0.141945, 0.0404175, -0.0922401, -0.421405, -0.0640081, -0.40777, 0.204084, -0.355358, -0.0379183, 0.0648543, -0.0593268, 0.035409, -0.446676, 0.0928981, 0.235635, 0.117916, 0.0522463, -0.163004, 0.391597, -0.114771, -0.0137451, 0.272051, 0.369069, -0.184557, 0.255314, 0.0788703, -0.00178193, -0.471891, 0.172919, 0.320662, 0.386125, -0.313468, 0.0293804, 0.202708, -0.278963, -0.268401, -0.383419, -0.322101, -0.3595, -0.139384, 0.191068, 0.0641882, 0.47382, 0.234528, -0.0697084, -1.15355, 0.146826, -0.112487, 0.379545, -0.0789801, 0.143859, 0.0570803, 0.169462, -0.0134391, -0.019989, -0.204044, 0.147611, 0.0506783, -0.215534, -1.2723, 0.331641, 0.0392859, -0.255383, -0.202144, 0.045346, -1.19167, 0.345368, -0.243022, 0.377847, -0.0544734, -0.191596, 0.0113642, -0.0777231, 0.0272993, 0.0127995, 0.164464, 0.369955, -0.0104922, -0.36035, -0.712564, -0.154855, 0.207311, -0.165798, 0.130321, -0.220997, -0.656956, -1.21364, -0.576056, -0.166468, -0.00638215, 0.00561483, -0.0613812, -0.163578, -0.0332758, 0.153533, -0.838091, -0.484733, -0.0562007, -0.257464, 0.0420606, -0.115153, 0.196512, -0.364471, -0.509996, -0.32304, -0.136443, -0.00275039, -0.219658, -0.0617934, 0.153484, 0.0688344, 0.036417, -0.183139, -0.14283, 0.0385412, 0.237872, 0.0113858, -0.209644, 0.299777, -0.0100841, 0.162869, 0.36161, 0.374985, -0.06392, 0.0474493, 0.184284, -0.0857355, -0.307142, 0.124692, 0.237761, 0.0205571, -0.565475, -0.108919, -0.00774427, -0.0556813, -0.0219309, -0.0125941, -0.0214659, -0.0167234, -0.0722148, -0.0234469, 0.196918, 0.343904, 0.120033, -0.0871855, -0.089406, 0.214101, -0.261526, 0.0693758, 0.0174055, -0.141773, -0.0392241, 0.0473296, -0.0274489, -0.0954612, -0.12287, 0.243901, -0.0495796, 0.216597, -0.028973, 0.115587, 0.0609566, 0.172066, -0.0621149, 0.0103687, 0.0772784, 0.224788, -0.260142, 0.0843749, 0.0906107, -0.0170865, -0.0170927, -0.027847, 0.0701147, 0.0986086, 0.00150279, 0.0264542, 0.0775379, 0.276238, -0.055416, 0.12204, 0.0920962, 0.277559, -0.0107, -0.295172, -0.0276621, 0.0276403, -0.0619431, -0.082917, 0.194156, 0.0271649, -0.217214, 0.086518, -0.0524286, -0.0119135, -0.157828, -0.0218869, -0.0269023, -0.0488863, -0.0387351, -0.0677812, -0.055546, -0.158517, -0.23631, -0.0796547, 0.0163291, -0.0452632, 0.081306, 0.0740194, -0.0707842, -0.0779788, 0.0563932, 0.0909201, -0.027387, 0.233854, -0.195113, 0.276259, -0.0481169, -0.181453, -0.0467728, 0.0032724, -0.0123055, 0.0836343, 0.0581627, 0.179765, 0.0890971, 0.228101, -0.18134, -0.0477942, 0.0129947, 0.00680382, 0.0240113, 0.00630396, 0.0278309, 0.0382695, 0.00809803, 0.0348046, 0.0238914, 0.0580261, 0.0477849, -0.0527579, 0.108489, -0.0461225, -0.0406944, 0.0522842, -0.00897673, 0.111446, -0.0904301, -0.0326589, 0.0374627, -0.0367734, 0.0665094, -0.0581238, -0.0846052, -0.0213724, 0.0891211, -0.0458149, -0.0240536, 0.0421606, -0.0344253, -0.0100531, -0.105557, 0.0176735, -0.087162, 0.0802367, -0.051963, 0.061298, 0.00758044, 0.0201748, 0.0186035, -0.0531315, -0.033966, 0.0393384, -0.0451905, 0.00937446, 0.0883731, 0.0946027, 0.0771807, -0.000460137, 0.0807438, -0.0179194, 0.0640484, -0.013515, 0.0140801, 0.0511804, 0.00098794, -0.109406, 0.00322894, 0.0466531, -0.024871, 0.0358492, 0.0308996, 0.0196093, -0.0596285, -0.0150399, -0.0531251, 0.0232579, -0.0635812, -0.00314589, 0.0113071, -0.0120821, -0.043217, -0.052658, 0.0236511, -0.0385277, 0.0973864, 0.0464468, 0.0979283, 0.0246924, 0.0510352, 0.00367535, 0.00153162, 0.0223952, 0.0444011, -0.0153437, -0.050641, 0.0791442, -0.0752978, 0.0985144, -0.0198053, -0.0228624, -0.0804579, -0.0759111, -0.0416703, 0.0158974, 0.0120434, 0.0808807, -0.0458503, 0.0089227, 0.0320988, 0.0108923, 0.0403187, -0.0064311, -0.0497192, 0.054348, -0.0649458, 0.00959096, 0.0165382, -0.0406329, -0.0889371, -0.00459442, -0.0253209, -0.0109722, -0.0146344, 0.0496878, 0.0158447, 0.0331149, 0.0300686, 0.0166318, 0.0139077, -0.111771, -0.0309543, -0.0499532, -0.0965022, -0.014567, 0.0791499, 0.0119169, -0.0199393, -0.00396942, 0.0139286, 0.075409, -0.0686541, -0.0644142, 0.0299251, -0.0372867, 0.0400135, 0.060429, -0.0712047, -0.059702, -0.022542, 0.0427056, 0.0584047, 0.0769383, 0.00481573, 0.0089242, -0.00862624, -0.00963362, -0.0738258, -0.0283891, 0.0268369, 0.0308131, 0.0842158, 0.11655, 0.0584656, -0.0538301, -0.0196617, 0.0319553, -0.0881264, -0.00766617, -0.0201779, -0.0500138, 0.0198503, -0.00252884, -0.0625782, -0.0319651, 0.0427505, -0.00503276, 0.0540956, 0.0540385, 0.0619133, 0.0136785, -0.00422626, 0.0204824, -0.108251, -0.0735751, 0.0657929, -0.0491662, 0.0810206, -0.0406798, -0.0968377, 0.0382551, 0.0471426, -0.0603194, -0.0633809, -0.0188361, 0.0205405, 0.0407577, -0.00620487, 0.0828514, -0.0193827}, {-0.0449355, -0.0462879, 0.0720543, -0.00839715, 0.0471698, -0.0387913, 0.0184384, 0.0795202, -0.075963, 0.0798226, 0.0123563, 0.00760828, -0.0713621, 0.0662159, 0.0132984, 0.0278563, -0.0274086, 0.0759396, -0.0468029, 0.00829395, 0.0474813, -0.0552069, 0.0367006, 0.0713537, 0.025716, 0.076348, 0.0231502, 0.0653889, -0.0808131, 0.0264424, 0.0309123, -0.00720465, 0.0455349, 0.0615039, -0.0499699, -0.063569, 0.0449598, -0.0538003, 0.0229149, -0.0113295, 0.0490539, -0.0101471, 0.0480161, -0.0340651, -0.0737577, 0.0108912, 0.00900427, 0.0474185, -0.0611153, -0.0446179, 0.0262243, -0.0469559, 0.0682215, -0.0564119, -0.0635674, -0.0107753, 0.0279721, 0.0417216, -0.0370978, -0.00952926, -0.0570751, 0.0728384, -0.0555287, -0.0107648, 0.0130526, 0.0052261, -0.0120007, -0.034153, 0.0787601, -0.0541882, -0.0423817, 0.0208947, 0.0205156, 0.0823669, 0.0467768, 0.01809, -0.0105587, 0.0324434, -0.0388327, -0.0347148, 0.00449252, -0.0211269, 0.0433547, -0.0452557, 0.0371546, 0.0181148, 0.00222231, 0.00732494, 0.0102455, 0.0753016, 0.0516741, -0.0362531, -0.0545934, 0.0711413, 0.0120439, 0.0803105, 0.0274515, 0.0295079, 0.0400046, 0.0357659, -0.0141845, 0.0773648, 0.0368261, 0.073985, -0.0596245, -0.0416991, 0.0719039, -0.0412523, 0.00534853, -0.0770892, 0.0197325, 0.056147, -0.0672734, -0.0818586, -0.0504109, -0.0539477, 0.000736505, -0.0561139, 0.0807783, 0.0500184, -0.0087346, -0.0729563, -0.0784966, 0.0407797, -0.0449412, -0.0624119, -0.0171525, -0.0502951, 0.0162061, -0.0616025, 0.054517, -0.0680014, -0.0577274, 0.0384294, 0.0256488, 0.0461132, 0.0453513, -0.0633912, -0.0314443, 0.0212679, 0.0701992, 0.0321538, 0.0210742, 0.0458846, 0.0557218, -0.02918, 0.00142924, 0.0398928, -0.0209264, -0.0253348, 0.0758752, 0.0274958, 0.0315409, 0.0647475, 0.0663304, 0.0522247, 0.0366025, 0.00970322, 0.00696718, -0.074607, -0.00819413, 0.0534146, 0.00353815, 0.00811035, -0.0038909, -0.0564073, 0.0711374, -0.000976868, 0.078926, 0.0324823, -0.0795994, -0.00523342, -0.0114027, 0.0425082, 0.0695261, -0.0754416, -0.0143709, 0.0492896, -0.0358693, -0.00125533, 0.00131609, 0.0149219, 0.0286286, 0.0625504, -0.0549504, 0.0568089, -0.0142803, 0.0801017, 0.0256793, -0.0569456, 0.0775618, 0.0283807, 0.0516536, 0.0258246, -0.0744329, -0.0183561, -0.0510243, 0.0190989, 0.0800927, 0.042349, 0.0231485, 0.0756686, -0.0697069, -0.0507755, -0.0643874, -0.0230036, -0.0715385, 0.0190096, 0.0409586, 0.0519585, 0.0744448, 0.0376435, -0.0148015, -0.00868474, -0.00236844, -0.047574, -0.0154958, 0.0796576, -0.060792, 0.0281329, 0.0627499, 0.0272805, 0.10395, 0.00673991, 0.0673514, 0.0136375, 0.117113, -0.0843792, -0.0698935, 0.0990332, 0.0117669, -0.074396, 0.113762, -0.0714906, 0.0253784, -0.0968564, 0.0493203, 0.0626365, 0.0193539, -0.047897, -0.0606993, -0.0257249, 0.0278689, 0.0902377, -0.0161538, 0.0363926, 0.0977288, -0.0878359, 0.0696513, 0.00676073, 0.0346388, 0.0546262, 0.0283489, 0.0136265, 0.0622841, -0.0120542, -0.0486312, 0.0683591, 0.00698913, 0.0378387, 0.0577557, 0.0862933, -0.0126005, -0.0635667, -0.0295276, 0.0927104, 0.0551022, -0.0219058, 0.0282823, 0.044268, -0.0385948, -0.0966079, 0.0799981, -0.0355728, -0.0150979, -0.0378651, -0.00385244, -0.0735047, 0.0585325, -0.00813915, 0.0313379, -0.0392849, 0.0136899, -0.105757, 0.00820043, -0.00966912, 0.0245497, 0.0580693, 0.0574953, -0.0373318, -0.0871545, -0.0598487, 0.0200251, 0.0386331, 0.0273431, -0.045921, 0.0560575, 0.00806914, 0.0371422, -0.0336866, 0.0353674, 0.0250019, 0.0385815, 0.0555235, 0.117471, -0.0373664, -0.0196108, -0.0469095, 0.0252597, 0.05023, -0.0311659, 0.005977, -0.0416197, -0.0526713, 0.0240609, 0.00455129, -0.0482267, 0.0520412, 0.0323124, 0.00286375, 0.0390996, -0.035178, 0.0635755, 0.0734111, 0.0698714, -0.119432, 0.0639304, -0.214065, 0.047234, -0.0571258, 0.169309, -0.0325156, 0.106099, -0.110924, -0.0979489, -0.100445, 0.114019, -0.0476403, 0.113226, -0.0613406, 0.0378386, 0.0509681, 0.0227523, 0.196194, 0.0762264, 0.127008, 0.0638247, -0.138757, 0.0751787, 0.0902157, 0.0900562, -0.0855493, -0.0899122, -0.050617, 0.120492, 0.0145127, 0.0121718, -0.0141921, -0.0725311, 0.159395, 0.177694, -0.0209143, 0.0923687, -0.0508372, -0.106096, -0.0111504, -0.0549046, 0.0468013, -0.0832052, 0.00859446, 0.0332101, -0.143774, 0.0742691, 0.0018748, -0.0856055, 0.0714934, 4.87321e-05, -0.0778907, 0.110657, 0.0132764, -0.00176808, 0.0184613, 0.109301, 0.162459, 0.0026687, 0.0641609, -0.0527119, 0.0747902, 0.223282, -0.0490385, 0.0530569, 0.0480642, 0.0399041, -0.0543274, -0.0536214, -0.0756502, 0.111694, -0.167671, -0.0740507, 0.0492842, -0.131968, 0.00329567, -0.14788, -0.107307, -0.0107322, 0.141737, 0.149144, 0.0375094, 0.0336894, -0.16969, 0.017742, -0.0508856, 0.087996, -0.125709, 0.121617, 0.0324069, -0.0147398, -0.0689393, -0.107679, -0.00156291, 0.0184774, 0.174536, 0.123902, -0.0495347, -0.0439003, -0.121904, 0.15964, -0.153607, 0.0168803, -0.0844065, 0.112506, 0.0752001, 0.0397458, -0.0596736, -0.167398, -0.065941, 0.177614, -0.0104247, 0.0610691, -0.0163254, 0.0671112, 0.200648, 0.204594, 0.0574388, -0.0278016, 0.0618816, 0.173222, -0.167314, 0.0257265, 0.0364608, -0.00901764, -0.0438495, -0.214975, 0.144077, 0.234818, 0.0129928, -0.0284196, 0.0937537, -0.0754987, 0.128577, 0.103357, 0.0570463, 0.0857796, -0.000852802, -0.125953, 0.10379, 0.010282, -0.0471167, 0.021769, 0.0756427, 0.027, -0.100472, 0.0103766, -0.0202794, -0.0785296, 0.0403868, 0.0800484, -0.00408646, 0.301619, 0.0543428, 0.0571671, -0.0238103, 0.0447451, 0.187917, -0.1116, 0.225984, -0.170072, 0.0117111, 0.194942, 0.000786104, 0.0589481, -0.0198385, -0.0807387, 0.0412342, -0.0199526, -0.0379975, 0.163268, -0.0391456, -0.183766, -0.132241, -0.00437771, -0.00374278, -0.126186, -0.118514, 0.135292, 0.0510191, 0.15709, 0.164003, 0.0101408, -0.0992748, -0.112604, -0.142999, -0.035856, 0.127797, -0.275528, 0.556177, 0.291406, -0.308636, -0.307356, 0.101239, 0.528248, -0.160436, -0.317673, -0.392521, -0.0816206, -0.0851718, 0.0444697, -0.318287, 0.0938825, 0.183519, 0.351675, 0.023759, -0.313974, 0.0849542, 0.118782, 0.195778, -0.269539, -0.154753, 0.0564329, -0.209778, 0.1199, -0.105871, -0.133951, 0.237619, -0.0571273, 0.208022, 0.249026, -0.180596, -1.01165, 0.185609, -0.537748, -0.677529, 0.217711, -0.248073, 0.148676, -0.287602, 0.19702, 0.657721, 0.2817, 0.164319, 0.217822, -0.88867, 0.548087, -0.0895144, -0.0227945, -0.0493121, -0.042137, 0.262158, -0.142347, 0.0264591, -0.414298, -0.0489189, 0.299473, -0.0547752, 0.240172, -0.308307, 0.118729, 0.0688956, 0.212011, -0.119844, -0.150594, -0.315693, 0.107822, 0.0864166, -0.0107326, -0.021057, 0.266114, 0.154116, 0.140166, 0.0490998, 0.466736, -0.0590646, -0.291631, 0.098424, -0.211481, -0.152012, -0.175398, -0.194051, 0.0927116, 0.756883, -0.044785, -0.0235683, -0.00894238, -0.153396, 0.11513, -0.222701, 0.15849, 0.160086, -0.31091, -0.0660725, -0.37738, -0.359062, -0.0569987, -0.0189295, 0.00173088, 0.30262, 0.0046704, -0.0366471, -0.0341562, 0.199057, 0.2101, -0.148774, -0.157305, -0.033877, -0.197498, 0.141714, -0.0441482, 0.00564572, 3.23959e-05, 0.331502, 0.199162, 0.00365378, -0.245595, 0.0925168, 0.306901, 0.130243, -0.324087, -0.294092, 0.101865, -0.318921, 0.041302, -0.250025, -0.169915, 0.105721, -0.0157454, 0.0703519, 0.29325, -0.0469232, -0.821314, 0.165378, -0.618244, -0.729855, 0.0226988, -0.368621, 0.195835, -0.17694, 0.044839, 0.406671, 0.140926, -0.0590269, 0.131568, -0.448316, 0.335257, 0.122249, 0.109142, 0.110683, -0.0373888, 0.0598845, -0.0130885, -0.0547468, -0.295299, 0.207516, 0.349802, 0.02748, 0.199096, -0.164936, -0.126722, 0.0619041, 0.198753, -0.289514, 0.00390816, -0.378347, 0.210941, 0.0819807, -0.0347279, -0.148129, -0.0099771, 0.200445, 0.214482, 0.0469406, 0.506, -0.0557201, -0.359697, 0.148656, -0.259079, -0.154749, -0.253629, -0.248492, 0.019581, 0.545469, 0.223669, 0.1715, 0.0302307, -0.125789, -0.0701971, -0.251252, -0.0793729, 0.161544, -0.0895279, -0.0458442, -0.312505, -0.277527, -0.257688, -0.153534, 0.0478979, 0.202398, -0.188112, 0.0304851, 0.087838, 0.0883471, 0.159767, -0.249238, -0.0311796, -0.0385464, 0.0986943, 0.0648986, -0.149993, 0.0948989, -0.0300762, 0.14557, -0.085943, -0.0233114, 0.0449237, 0.0256364, 0.171053, -0.0920138, -0.272115, -0.112676, -0.0229845, -0.193494, -0.145362, -0.432282, -0.0635923, -0.0953702, -0.024715, -0.18762, 0.296647, -0.0340524, -1.13728, 0.243174, -0.803761, -0.822111, 0.192449, -0.252349, -0.1485, -0.334987, -0.054862, 0.332957, 0.0293795, -0.203843, -0.0641471, -0.204731, -0.173322, 0.0770119, 0.105555, 0.172548, -0.0270713, 0.0653723, -0.10294, -0.0620423, 0.0834352, 0.239817, 0.215569, 0.00335428, 0.154295, -0.438002, 0.133082, 0.205854, 0.225752, -0.116837, 0.138881, -0.280377, 0.118706, 0.100567}, {0.0760775, -0.184367, 0.144392, 0.246615, 0.0804956, -0.1325, 0.296937, 0.059154, -0.277143, 0.133179, -0.196723, -0.0826853, -0.123921, -0.287316, -0.0223046, 0.343762, 0.144893, 0.177852, 0.0740649, 0.0682985, 0.00153232, -0.0512407, 0.099127, 0.11669, 0.184881, 0.148838, -0.207867, -0.329035, -0.00709516, 0.0830427, 0.32617, 0.331624, -0.116427, 0.0212305, 0.357421, 0.109884, 0.050457, -0.307427, -0.121108, -0.116518, 0.219916, 0.0341209, -0.0981784, -0.124654, -0.0211833, 0.143255, -0.167608, 0.0277536, 0.0459471, 0.135607, 0.303827, -0.124342, -0.343545, -0.0328106, 0.014651, -0.153106, -0.0410334, -0.297073, -0.0713563, -0.0762896, 0.0263108, -0.117894, 0.172004, -0.15689, -0.844568, 0.163158, -0.521442, -0.468383, -0.0354029, -0.272246, -0.00548689, -0.335458, -0.0905652, 0.333626, 0.176795, -0.0119043, -0.0658089, -0.200431, -0.0527383, -0.0705012, 0.135436, 0.00955181, 0.0305093, -0.159451, -0.29576, -0.0928278, 0.257125, 0.13438, -0.082384, -0.088203, -0.0783223, -0.280808, 0.225993, 0.0636399, 0.0964159, -0.0807937, 0.2372, -0.340607, 0.248863, -0.0090486, 0.0851116, -0.0059373, 0.0529, 0.250965, 0.0536316, -0.106795, 0.0863174, -0.106199, -0.125164, 0.0273368, -0.170844, 0.0093968, -0.225745, -0.222051, 0.0415441, 0.150351, -0.00296334, -0.00806496, -0.0358526, 0.00823271, 0.00524719, 0.011659, 0.174292, 0.249383, 0.222337, -0.0452463, -0.164313, -0.336901, -0.160857, -0.249352, 0.532002, -0.0291147, 0.111055, -0.0366479, 0.112991, -0.0217068, 0.0903237, -0.206934, 0.0657791, -0.148341, 0.273858, -0.0464961, -0.0803746, 0.156289, -0.073577, 0.179731, -0.126203, -0.0976136, -0.114988, 0.0762365, 0.268306, -0.168603, -0.135573, -0.0700989, 0.024428, -0.255337, -0.072899, -0.508445, -0.144371, -0.00483659, -0.0479665, -0.361951, 0.129163, 0.00806473, -0.524702, 0.0477764, -0.48765, -0.302398, 0.12115, -0.11707, 0.000232842, -0.343927, -0.104156, 0.252576, 0.0719359, -0.00552333, -0.129066, -0.199272, -0.260886, -0.138363, -0.00332881, 0.157519, 0.0413584, -0.137269, 0.0719846, -0.012443, 0.474979, 0.0324991, -0.189933, -0.0561911, 0.0350949, -0.37268, 0.146973, 0.106569, 0.0452574, -0.0742038, 0.354001, -0.451435, 0.269456, 0.0689067, 0.0460829, 0.19425, 0.204356, 0.234652, 0.11971, 0.123003, -0.132059, 0.0731149, -0.129315, 0.116099, -0.108961, -0.0789785, -0.169595, -0.0790821, 0.135624, -0.115723, 0.169897, 0.120243, 0.00680671, -0.0173445, 0.178448, 0.00218296, -0.0940776, 0.391825, 0.159487, -0.0714087, -0.216058, -0.13644, -0.39568, -0.437029, 0.345586, -0.252811, -0.177226, -0.00955878, 0.0503655, -0.166014, 0.0940672, -0.194724, -0.0307528, -0.298547, 0.287, -0.116496, -0.417834, -0.0286283, 0.118821, 0.204387, -0.13977, -0.043294, -0.208989, 0.212855, 0.032967, -0.143131, -0.0956587, 0.0244167, 0.112345, -0.0837337, -0.128174, -0.294358, -0.034533, -0.223846, -0.0846706, -0.00817574, 0.221164, -0.0376231, -0.146306, -0.452604, -0.406409, -0.203665, -0.0312503, -0.202445, -0.0278214, -0.281748, -0.279741, -0.241577, 0.0937371, 0.00674546, 0.00810067, 0.126406, -0.312209, -0.0732358, -0.195737, 0.0857795, 0.143395, -0.124153, 0.0108269, -0.0334756, 0.433143, -0.192125, -0.213479, -0.0764108, 0.138879, -0.234386, 0.0314234, -0.122681, 0.0657407, -0.0953336, 0.319584, -0.499883, 0.0888936, 0.0170934, -0.137859, 0.00353515, 0.297533, 0.0973657, 0.0938175, -0.0374889, -0.409607, -0.0402654, -0.084173, 0.337795, 0.0224918, 0.081773, 0.0817127, 0.327917, 0.00197166, -0.202626, 0.440496, -0.0335275, -0.072504, 0.135862, 0.264438, 0.0554511, 0.0457715, 0.301346, 0.178441, -0.00555889, -0.0907422, 0.123071, -0.530988, -0.381192, 0.221426, -0.306074, 0.0170254, 0.121204, 0.171116, -0.207607, 0.074254, -0.309806, -0.0598971, -0.0972151, 0.250346, -0.0870561, -0.326719, -0.0773383, 0.248044, 0.232969, -0.155916, -0.134247, -0.209657, -0.104722, -0.165128, -0.0770631, 0.00694012, 0.00414647, -0.0252851, 0.0780094, -0.20211, -0.264326, -0.0277902, -0.301565, -0.0446393, -0.160256, -0.0117673, 0.0154974, -0.03961, -0.170507, 0.0752426, 0.0242238, -0.504897, -0.112333, -0.014881, -0.342636, -0.289356, -0.521394, -0.0545366, -0.0278068, 0.114323, 0.467614, -0.177134, -0.0762431, 0.0393978, -0.224409, 0.0973813, 0.11704, -0.024753, -0.13324, 0.210559, -0.0371229, -0.214188, -0.0123242, 0.240395, -0.160497, 0.000949322, -0.165138, -0.025372, -0.162251, -0.102375, -0.416802, -0.00871429, -0.0653463, -0.249215, -0.0385155, 0.253615, -0.0569389, 0.0259576, -0.20814, -0.357825, 0.00683206, -0.0195776, 0.0464979, 0.0433207, 0.208462, 0.239129, 0.177843, -0.0888715, -0.223578, 0.289822, -0.000903485, 0.0158783, -0.0264379, 0.365079, 0.115164, 0.113442, 0.136698, -0.371731, 0.135259, -0.0277878, 0.0172292, -0.381501, -0.136146, 0.0453198, -0.314618, 0.00519005, 0.0929027, 0.247812, -0.570018, 0.240652, -0.550805, 0.0120824, -0.243085, 0.183333, 0.0218589, -0.156104, 0.018429, 0.060346, 0.229013, -0.0573377, -0.0393399, -0.276491, -0.17659, -0.134131, 0.086053, 0.0203497, -0.0756299, 0.0653129, 0.115483, -0.460385, -0.215061, -0.153416, -0.155141, -0.0514431, -0.194939, -0.101536, 0.0130553, -0.0895768, -0.0857074, 0.200469, 0.185267, -0.638325, -0.0841816, -0.0311194, -0.328596, -0.185225, -0.651866, -0.10068, -0.13054, 4.96691e-05, 0.420352, 0.0673721, -0.0501737, -0.02882, -0.305407, 0.0429318, 0.166654, 0.0783601, -0.280812, -0.310066, -0.144813, -0.252915, -0.0177888, 0.00929259, -0.0941442, 0.0458153, 0.0790373, -0.00972596, 0.0820436, -0.167851, -0.113724, 0.304983, -0.106172, -0.149163, 0.0584265, 0.440843, -0.0926377, 0.00383174, -0.229196, -0.282233, -0.110837, 0.0558747, 0.0603229, 0.475824, 0.487905, 0.409001, -0.130867, -0.160821, 0.0634674, 0.102453, 0.0173628, 0.00122545, -0.0457168, 0.428066, -0.161038, 0.0240974, -0.184871, -0.647107, -0.0979311, -0.108837, 0.239541, -0.331092, -0.149335, 0.0501485, -0.166175, 0.0700269, -0.134338, 0.221225, -0.130941, 0.159528, -0.725346, -0.139283, -0.247789, 0.175218, -0.0856496, 0.190222, -0.111603, -0.0516368, 0.357661, -0.204129, -0.0793707, -0.161187, -0.259728, -0.0813921, 0.335348, 0.201617, -0.0835268, -0.122152, 0.170424, -0.201275, -0.418368, -0.244652, -0.036448, -0.0831053, -0.178381, -0.1691, 0.0117443, 0.0370264, 0.295509, 0.20619, 0.0213393, -0.760129, -0.142556, -0.0868092, 0.101535, -0.256544, -0.621697, 0.0373906, -0.155914, 0.124071, 0.489224, 0.078425, -0.0992715, 0.0344226, -0.343487, 0.161267, 0.143743, -0.0181008, 0.00218622, -0.258893, -0.129994, -0.111638, 0.00876986, -0.018962, 0.0670842, 0.152183, -0.0162799, -0.137878, -0.0993911, -0.0815181, 0.318367, 0.147914, -0.315764, -0.104966, -0.215315, 0.24334, -0.0222346, -0.0438093, -0.169189, -0.246437, 0.0838163, -0.0430937, 0.22448, 0.328205, 0.253583, 0.292953, -0.0203797, -0.132403, -0.228426, 0.43114, 0.155687, -0.0786118, -0.110388, 0.566482, 0.0186959, 0.0261924, -0.0305859, -0.532013, -0.0887298, -0.233545, 0.350116, -0.431408, 0.106174, 0.0907642, 0.0106844, 0.140957, -0.140826, -0.209309, 0.184592, 0.129262, -0.906144, -0.256432, -0.336131, 0.0470255, -0.172807, -0.0833277, -0.0132831, -0.342063, 0.290255, -0.0681865, 0.00516713, -0.00594542, -0.17932, 0.0753128, 0.321973, 0.0971268, -0.122178, -0.156042, 0.0575214, -0.151943, -0.349646, -0.324094, 0.0810935, 0.0543741, -0.0211571, -0.367904, 0.0306237, 0.0742044, 0.354387, 0.0515459, -0.122417, -0.179683, -0.462276, -0.12944, 0.349164, -0.0808917, -0.48856, -0.108312, -0.136103, 0.321165, 0.13742, 0.0903115, -0.082773, 0.147018, -0.265053, 0.188259, -0.231779, 0.0174984, -0.0192386, -0.10186, 0.0394902, -0.0672928, 0.033858, 0.16736, 0.238388, 0.339681, 0.117707, -0.0898066, -0.0948486, -0.161468, 0.38218, 0.255477, 0.00725302, 0.0578743, -0.342337, 0.353005, 0.000380083, 0.141455, 0.153803, -0.00792651, -0.065276, -0.014821, 0.15051, 0.0191111, 0.056347, -0.441658, -0.18793, 0.0837887, -0.141774, 0.368411, 0.0481773, -0.147013, 0.138839, 0.499808, 0.0042334, -0.123936, -0.0170838, -0.707985, -0.305805, -0.329711, 0.432802, -0.589886, 0.0706157, -0.11368, 0.132423, 0.0489846, -0.0555578, -0.0720836, 0.293691, -0.0385687, -0.656428, -0.094157, -0.225727, 0.0377492, -0.415317, -0.0564011, -0.0395151, -0.275266, 0.131642, -0.138874, -0.0445452, 0.0152181, -0.0888222, -0.116457, 0.330637, -0.0433953, -0.113946, 0.00548597, 0.0411078, 0.0985528, -0.385047, -0.0508628, -0.0195462, -0.0557248, 0.0188619, -0.231234, -0.207709, -0.0558046, 0.27026, 0.0384353, -0.0525513, 0.195484, -0.311646, -0.225933, 0.543113, -0.042024, -0.351156, 0.135047, 0.154865, 0.224885, -0.0286485, -0.098435, 0.0285194, 0.00730507, -0.190477, 0.272149, -0.366163}, {-0.039535, -0.151491, -0.138396, -0.0989218, 0.00213344, -0.01254, 0.101469, 0.490677, 0.235689, 0.0853501, -0.020334, -0.0538838, -0.0388338, 0.343142, 0.00927026, 0.185809, 0.0389462, -0.0257643, 0.17417, 0.139479, 0.0305541, 0.0432468, 0.0144696, -0.005031, -0.117324, 0.223565, -0.0765137, -0.168157, -0.556873, 0.0251968, 0.0140978, -0.10683, -0.332796, -0.0126, 0.0289449, 0.0731149, 0.290933, 0.0197324, -0.101387, -0.00793508, -0.840872, -0.491803, -0.655419, 0.195356, -0.341307, 0.113955, -0.139661, 0.11161, 0.135762, -0.245889, -0.0657317, 0.204778, -0.441434, -0.625325, -0.11325, -0.316614, 0.132599, -0.70812, -0.0509682, 0.0775304, -0.31938, -0.145451, 0.128294, 0.0177122, -0.149059, -0.12453, -0.114358, 0.392706, 0.00395315, -0.148029, -0.0320685, 0.181654, 0.230896, 0.0621621, -0.142724, 0.230692, -0.0414217, -0.598887, -0.0250841, -0.0562167, -0.0430524, 0.145099, -0.151141, 0.0316773, 0.250923, -0.399584, -0.066716, 0.302863, 0.0109095, -0.360669, 0.189592, 0.441676, -0.070328, -0.146809, 0.0725121, -0.029763, -0.0426102, -0.023859, 0.405378, -0.0301871, 0.0116098, -0.0331808, -0.0341047, -0.0374563, -0.361519, -0.101465, 0.190875, 0.326744, 0.214071, 0.0742574, 0.0438067, -0.0771395, 0.0674912, 0.170466, -0.408313, 0.334031, 0.186667, 0.384016, 0.0147186, 0.0729828, 0.122664, -0.0263158, 0.170727, 0.234941, -0.0842245, 0.0866396, -0.342328, -0.154222, -0.287243, -0.0108318, -0.0559294, 0.0336831, -0.495681, -0.12534, 0.253843, 0.075009, 0.445533, -0.203891, -0.186307, 0.0707659, -0.353451, -0.305797, -0.241747, -0.189309, -0.0912131, -0.0994166, -0.121178, 0.057719, 0.146742, -0.209081, -0.254207, 0.255864, -0.3683, -0.841542, -0.331928, -0.173402, -0.0255392, -1.27197, 0.0754715, 0.0407312, -0.0372436, -0.521705, -0.23764, -0.0368162, -0.204951, -0.181619, 0.0342087, 0.538236, 0.239765, -0.308354, -0.104396, 0.126941, 0.0503155, 0.129135, -0.181789, 0.226776, 0.0103342, -0.695657, 0.107103, -0.0296654, 0.0707312, -0.17508, -0.15465, -0.0495571, 0.060291, -0.0313861, 0.0542454, 0.101975, -0.0875746, -0.230021, 0.194817, 0.452526, -0.0848407, -0.160185, 0.0784402, 0.0243315, 0.155587, -0.101091, 0.197173, -0.0441992, 0.263559, -0.00614917, 0.235314, -0.110881, -0.121422, 0.00383094, 0.177528, 0.256115, 0.380951, 0.178276, -0.0249828, 0.0421821, 0.104845, 0.0284482, -0.412866, 0.41569, 0.107059, 0.478113, 0.294193, 0.0391153, 0.0694804, -0.0979459, 0.0657955, 0.00149442, -0.120459, -0.0146473, -0.168573, 0.135505, 0.246128, -0.0231889, -0.166083, -0.0365958, -0.43819, -0.154395, -0.0255069, 0.194966, 0.457073, -0.212809, -0.135992, 0.211256, -0.186521, -0.0133162, 0.200335, -0.108136, -0.0537148, -0.309831, -0.150738, 0.0406421, -0.056591, -0.00467744, -0.396782, 0.11323, -0.0164708, -0.734429, 0.0758474, -0.370236, -0.0954626, -1.76689, 0.0858474, -0.130824, -0.145961, -0.788722, -0.171967, -0.103804, 0.0460933, -0.151623, -0.279862, 0.41584, 0.149545, -0.271616, -0.0403871, -0.19345, -0.0145782, -0.0350715, -0.251632, -0.0691296, -0.0120284, -0.868058, 0.311121, -0.340372, -0.188874, -0.462291, 0.127713, -0.142234, 0.0448104, 0.311429, 0.43049, -0.0309304, 0.0973611, -0.176683, 0.0967613, 0.415033, -0.0563909, 0.026707, 0.0126959, 0.287335, 0.012987, 0.0511222, -0.191132, 0.00381478, -0.00196283, 0.0164521, -0.135386, -0.0531241, -0.160761, -0.0444825, 0.0636484, 0.0548802, 0.123008, 0.132428, 0.0124801, 0.0449184, 0.0743485, -0.0704573, -0.300602, 0.248213, 0.0167072, 0.236388, 0.251642, 0.0969863, 0.196791, -0.0551038, 0.0729706, -0.0498085, -0.0245197, 0.0591865, -0.0333721, -0.0612217, 0.318437, -0.164771, -0.0735977, -0.0325035, -0.244378, -0.195194, 0.0800324, 0.0683722, 0.453896, 0.0966877, -0.0169663, 0.0921146, -0.0659095, 0.127779, 0.459208, -0.162843, -0.231909, -0.214811, -0.178101, 0.0630044, -0.0752401, -0.00382138, -0.375719, 0.104597, 0.20381, -0.723869, 0.253282, -0.128113, 0.115594, -1.73598, 0.0621524, -0.167226, -0.0970988, -0.712267, 0.00108776, 0.0385615, 0.177961, -0.0344072, -0.32634, 0.323113, -0.00441433, -0.193844, -0.142552, -0.314659, -0.218379, 0.00436934, -0.0972433, -0.167971, -0.00561778, -1.09207, 0.226624, -0.133475, -0.0620139, -0.727066, 0.193303, -0.000805051, -0.00892781, 0.0357045, 0.282391, -0.034058, 0.144843, -0.215951, 0.170401, 0.183941, 0.0625499, -0.0355041, 0.0544617, 0.190745, -0.335643, -0.134732, -0.390023, -0.0477981, 0.0633629, 0.0799732, -0.191985, -0.0709157, -0.10723, 0.000363231, -0.050059, -0.143528, 0.036903, 0.0114081, -0.154499, 0.0327908, -0.0436239, -0.10536, -0.00386026, 0.184566, -0.0952484, 0.0696419, 0.157664, -0.129889, 0.246725, 0.189398, 0.29061, 0.139717, 0.0161324, 0.0345301, 0.240913, -0.190055, 0.0730369, 0.0281587, -0.0127273, 0.0401376, -0.195938, -0.187211, 0.193632, -0.173061, 0.358119, 0.0132541, -0.161553, -0.0845133, 0.306776, 0.378089, 0.559938, 0.0680289, -0.167975, -0.229482, -0.338251, -0.0480001, -0.0586864, -0.132013, -0.404879, 0.21324, 0.105726, -0.429707, 0.35147, 0.110941, 0.0583186, -1.61123, 0.0172744, -0.276203, 0.0489541, -0.307744, 0.0280981, -0.0156982, -0.0461211, 0.129655, -0.389926, 0.470001, 0.0579823, -0.0514423, -0.206873, -0.707059, 0.00707245, 0.00207022, -0.245227, -0.206994, -0.0852339, -1.27443, 0.322688, 0.102458, 0.129426, -0.22765, -0.0821561, -0.00862422, 0.0769595, 0.313512, 0.380063, 0.0861832, 0.0998368, -0.0996945, 0.0568529, -0.199349, 0.357362, 0.0422185, -0.000938164, -0.0178699, -0.232098, 0.0123268, -0.682663, 0.0663098, -0.361569, -0.056498, -0.0781182, 0.00729529, -0.243311, 0.0409045, 0.230586, -0.256569, -0.117068, -0.192348, -0.140613, -0.250297, 0.0382068, -0.0245873, -0.0991638, 0.115186, -0.0947563, 0.0320147, 0.0446142, -0.219607, -0.0586465, -0.000521119, 0.257206, 0.153664, -0.108519, -0.174022, 0.282199, -0.175074, 0.10514, 0.0890411, 0.2315, 0.0530033, -0.329725, -0.260965, 0.396487, -0.178761, 0.458769, -0.0821356, -0.126199, 0.0249244, -0.0220927, 0.322153, 0.442667, 0.076674, 0.0190011, 0.0193091, -0.302478, -0.0646335, 0.0526182, -0.0741042, -0.420881, 0.111287, 0.00658103, -0.456453, 0.544453, 0.302492, 0.144809, -1.08328, 0.0251856, -0.294834, 0.251506, -0.406271, -0.0780775, -0.041283, -0.166789, -0.0308572, -0.413958, 0.254086, 0.24786, 0.130213, -0.0951446, -0.925255, 0.118383, -0.0671019, -0.229208, -0.287895, 0.0590635, -1.14677, 0.171787, -0.0819089, 0.00672282, 0.26559, 0.0592617, -0.148944, 0.151164, 0.151753, 0.165548, -0.135364, -0.0240411, -0.0408164, 0.0417044, -0.128508, 0.29668, 0.0137101, 0.258921, 0.167731, -0.120794, -0.150396, -0.848638, -0.110426, -0.082836, -0.0272241, -0.0416502, -0.00702346, 0.0199633, -0.0610183, 0.121083, -0.418946, -0.262012, -0.063523, -0.168156, -0.187392, -0.0190827, 0.00026368, -0.0979072, 0.0473429, -0.0828445, -0.182626, 0.226342, -0.0466986, -0.132344, 0.0272965, 0.170041, -0.16984, -0.0215733, 0.09208, 0.275309, -0.0375369, 0.0799325, 0.118069, 0.126662, 0.00489833, -0.206193, 0.0102106, 0.461022, -0.444269, 0.298866, 0.0721672, -0.20593, -0.0342039, -0.186596, 0.294535, 0.234223, -0.0141768, -0.0171308, 0.115014, -0.102939, -0.00342012, -0.0844279, -0.111034, -0.552425, 0.0131431, 0.16277, -0.320681, 0.400805, 0.385355, 0.00768544, -0.528071, 0.302611, -0.329958, 0.208914, -0.30233, -0.0216794, -0.0452814, -0.219832, 0.0387681, -0.328425, 0.291628, 0.385564, 0.142446, -0.145494, -0.89553, 0.101835, 0.132787, -0.156427, -0.326567, -0.0611206, -1.05252, 0.0881261, -0.236718, -0.0479049, 0.335993, -0.0336927, -0.201187, -0.0860589, -0.0452361, 0.0417867, -0.0151224, -0.0813058, -0.0101479, 0.16961, -0.543109, 0.158395, -0.105724, 0.274531, 0.233657, -0.138385, -0.336799, -0.935507, -0.241239, -0.0984219, 0.0210345, 0.0150036, -0.0403682, -0.0444747, 0.00297299, 0.151593, -0.746358, -0.355363, -0.0229897, -0.258722, -0.00774636, 0.0116661, 0.172838, 0.0203445, -0.275331, 0.182302, -0.437769, 0.169883, -0.276991, -0.0458621, -0.191142, 0.106062, -0.403761, -0.102664, 0.11786, 0.108953, -0.177965, 0.216813, -0.0629112, 0.116662, -0.226796, -0.231358, -0.0809635, 0.422273, -0.589707, 0.318, 0.0733089, -0.243128, 0.0631146, -0.0981222, 0.331631, 0.460272, -0.0729258, -0.00144881, 0.0898747, -0.395157, -0.463861, 0.124756, -0.0902759, -0.60762, 0.0153659, -0.0551106, -0.285105, 0.398436, 0.0825087, 0.0346798, -0.541797, 0.325008, -0.332487, 0.293945, -0.333026, 0.101632, -0.0818101, -0.0539759, -0.0701282, -0.262312, 0.135056, 0.161414, 0.298423, -0.32751, -1.00386, 0.292574, 0.035675, -0.333418, -0.247563, -0.0133193, -0.8202, 0.0661675, -0.0699194, 0.23815, 0.413052, -0.0732406, -0.209952}, {0.240442, 0.0542904, 0.0413785, 0.0403741, 0.111108, -0.171817, -0.233649, -0.632141, 0.234934, 0.0200082, 0.247184, 0.109646, 0.107663, -0.532998, -0.693059, -0.0712216, -0.168353, -0.046088, 0.142968, 0.116946, -0.0656783, 0.0856132, -0.00716357, -1.09203, -0.458997, 0.0341499, -0.449423, 0.119567, -0.128073, 0.081776, -0.217224, -0.310261, -0.00918095, -0.231148, 0.0929326, -0.129938, -0.111828, -0.0536798, -0.173903, -0.602663, -0.251887, -0.160559, 0.0191919, 0.298252, 0.113576, -0.279547, 0.241453, -0.384701, -0.0818266, 0.175985, 0.36405, -0.688363, 0.419502, 0.196009, 0.037759, -0.0241939, -0.0686909, 0.423204, 0.289361, -0.432412, -0.147287, -0.0230019, -0.0305875, -0.321148, 0.136225, -0.211753, -0.555037, -0.34056, 0.251277, -0.266547, 0.329615, 0.302619, -0.0839752, -0.315221, 0.197749, 0.163856, 0.342053, -0.20709, 0.188556, 0.0351823, -0.0385569, 0.415796, 0.0860172, 0.0737336, 0.0534258, 0.385923, -0.25836, -1.02407, 0.363832, 0.286983, -0.0727729, -0.628478, -0.055201, -0.98184, 0.121964, 0.0529704, 0.433003, 0.0394489, -0.0363915, 0.206613, -0.0935337, -0.121895, -0.274257, 0.104779, 0.28748, 0.0672287, -0.491239, -0.389102, 0.194644, 0.263777, 0.204737, 0.0510385, 0.0143305, -0.945356, -0.56412, -0.228691, -0.282627, -0.0137851, -0.106594, 0.181677, -0.118635, 0.00692022, 0.266772, -0.948761, -0.745642, -0.272206, -0.139827, -0.0625014, -0.0734126, 0.266625, -0.0548458, -0.410554, -0.401528, -0.233699, 0.0382419, -0.103994, -0.136986, 0.375045, 0.111136, -0.562573, -0.230042, -0.197083, -0.0497983, 0.108261, 0.00378443, -0.178447, 0.467714, -0.159111, -0.0976228, -0.113389, 0.643794, -0.631984, 0.0945945, 0.136779, 0.00474392, 0.0174971, 0.000331597, 0.0147026, 0.0819457, -0.452734, 0.0404765, -0.0783437, 0.0336684, 0.0503482, -0.0256514, 0.10317, 0.0659565, -0.059681, -0.0823305, 0.199007, 0.261767, 0.0280249, -0.09782, -0.00474437, 0.231944, -0.286216, 0.0752348, -0.0795039, -0.193477, -0.0481176, 0.159268, -0.0514743, -0.116406, -0.0787109, 0.246557, -0.0717719, 0.287283, -0.0517003, 0.223743, 0.118565, 0.205579, -0.0922254, 0.0110894, 0.146954, 0.218318, -0.243142, 0.161355, 0.236596, 0.017643, -0.0677849, 0.00845608, 0.134006, 0.174564, 0.13694, 0.081121, 0.06961, 0.224905, -0.0270817, 0.303117, 0.217311, 0.163217, -0.0551138, -0.33197, 0.0368163, 0.00135394, -0.0891759, -0.139473, 0.235128, 0.0718348, -0.272984, 0.168668, -0.0386574, 0.0631849, -0.100489, 0.0232927, 0.055815, -0.0178849, 0.0852435, 0.0329244, -0.00133982, -0.145502, -0.17783, -0.0237994, 0.112622, 0.0667057, 0.0549121, 0.11103, -0.0894827, -0.174972, 0.00314741, 0.0812699, 0.0146798, 0.265211, -0.213359, 0.235426, 0.0114435, -0.262128, -0.0279078, -0.0449337, -0.108367, 0.0725617, 0.0530605, 0.0991183, 0.00302861, 0.24018, -0.0373512, 0.0321682, 0.0774628, -0.00897402, -0.0602705, -0.00887933, -0.0927703, -0.00226867, -0.102293, -0.0209904, -0.0435063, -0.0705204, -0.059364, -0.0607141, 0.0843277, 0.0165216, -0.018953, -0.0514624, -0.00331189, 0.0413578, 0.0223979, 0.0267568, -0.0428457, -0.0109133, -0.0196161, -0.0379619, -0.0389584, 0.0177325, 0.0735058, 0.0415748, -0.0818846, 0.0813835, 0.0736463, 0.0895886, -0.0940267, 0.0676525, 0.0426566, -0.0516853, 0.0806591, 0.0261259, -0.0905511, -0.0668211, 0.0944244, 0.00340661, 0.0240847, 0.0135974, 0.0893261, 0.108378, 0.0298062, -0.0373471, 0.0334556, -0.0121482, -0.0559023, 0.0974684, -0.00143723, 0.0979822, 0.0266982, 0.0113788, -0.0675704, -0.00614911, 0.0454481, -0.0334859, -0.0383177, -0.0383456, -0.0184293, 0.00734444, -0.062396, 0.0482508, 0.0347019, -0.073504, 0.0721676, 0.0405836, 0.0911266, -0.0514254, 0.038635, -0.0606398, -0.0918525, -0.000341614, 0.0645467, 0.0477151, -0.0218485, 0.00808832, -0.0789785, 0.0104135, 0.0523543, 0.013759, -0.0377539, 0.0185338, 0.0410498, 0.00389115, -0.00354662, 0.0331442, -0.0553575, 0.033662, -0.0096942, 0.00724722, 0.0137199, 0.0434497, -0.0443868, -0.0670233, -0.0535437, 0.0481302, 0.0519695, -0.076548, 0.000650197, -0.0493688, -0.0721712, -0.00880077, 0.00229273, -0.105848, 0.0693921, -0.0317067, -0.0475225, 0.0614742, 0.0261228, 0.114166, 0.00201097, -0.0311788, 0.0756688, -0.0330457, -0.0785062, -0.011662, 0.0153488, -0.0500797, -0.0647934, -0.00331599, 0.0200313, -0.0990968, -0.0692253, 0.0999559, 0.0013127, -0.0177573, -0.0242946, 0.0400792, 0.0781363, 0.00878787, -0.103467, 0.0784334, -0.068914, 0.0942223, -0.0502409, -0.077129, 0.0637112, 0.0216857, -0.00080014, 0.0447462, 0.0405778, 0.0377988, -0.0565076, 0.0136769, -0.0696967, 0.0561676, -0.032844, -0.00974134, -0.0205429, 0.076967, 0.0491217, 0.014074, 0.0808978, 0.0452279, -0.0980301, -0.0349419, 0.0180993, -0.0269739, 0.0326901, 0.0713413, 0.0158121, 0.039206, 0.0482176, -0.0458561, 0.0209587, 0.0433515, 0.0692211, -0.047643, 0.0812676, 0.0136186, 0.0620777, 0.0428211, 0.065969, -0.00687565, -0.0390986, -0.0134391, -0.00943073, -0.0718101, -0.0800297, 0.0254991, -0.029453, 0.0169551, -0.014719, 0.0436177, -0.0236764, -0.00184217, 0.0246884, -0.0062862, -0.0674822, 0.0811682, -0.0386631, 0.0922964, 0.0464113, 0.0278343, -0.0301204, -0.0452874, 0.0541025, 0.0648593, -0.00655558, -0.00177149, 0.000119209, 0.0467752, 0.0780506, 0.0702728, 0.0451143, -0.0649963, -0.0197512, -0.0245845, -0.0153397, -0.0727302, 0.0131412, -0.0691659, -0.0714751, 0.00243227, -0.080084, 0.038959, -0.0226522, -0.0397206, 0.0125406, -0.0619112, 0.0491133, 0.0462056, -0.00742429, 0.023754, 0.0456783, 0.0810544, 0.0644644, 0.0446139, 0.0307965, -0.0719468, -0.0107923, -0.0479893, -0.0446229, 0.0491723, -0.0218062, -0.00883342, -0.0178797, -0.0724098, -0.00132626, 0.0607895, -0.0518368, 0.0258321, 0.0262448, -0.0104988, 0.0399045, -0.0253353, 0.0235013, 0.030677, 0.047883, 0.0584859, 0.0205344, 0.0586096, -0.0365916, -0.0355242, -0.0362454, 0.0732512, -0.0530679, 0.0506659, 0.0652792, -0.024719, 0.00725374, 0.0686989, -0.0320021, 0.0443868, -0.0671001, 0.0550553, 0.0182296, 0.0307005, 0.0635545, -0.0816008, 0.0283728, -0.0459348, 0.0238692, 0.0117945, -0.0143663, -0.00724366, 0.0181627, 0.0551782, 0.053557, 0.0632236, 0.0426646, 0.0319496, -0.0727143, -0.0728301, -0.0221094, 0.00451811, -0.0404108, 0.0669427, -0.0260573, -0.05825, 0.0459574, -0.0257592, 0.000162438, 0.0167824, 0.0523213, -0.0697359, -0.0723794, 0.0597976, -0.0366627, 0.00814473, -0.025735, -0.00436723, -0.0299315, -0.0213368, 0.00124598, -0.0762925, -0.0789769, -0.0596545, -0.065323, 0.0962271, 0.00105516, 0.083468, 0.0749647, -0.0614696, -0.0709408, -0.0743977, -0.000566393, -0.0190627, -0.0601404, 0.0213985, -0.00083474, -0.0579726, -0.037189, -0.0291283, 0.0705001, 0.0230975, -0.0971727, 0.0634116, 0.0361782, 0.0800711, 0.0375678, 0.00150137, -0.00228524, 0.0645088, -0.0970071, 0.0121141, -0.0567547, 0.104477, -0.0348467, 0.0445192, -0.0340088, 0.105124, -0.0256621, 0.00828315, 0.0503718, -0.0202653, 0.106228, 0.015053, 0.0552888, -0.0059041, 0.0634229, -0.0603031, 0.098628, -0.011406, 0.0360279, -0.044343, 0.0277427, -0.0871013, 0.023183, 0.0942971, -0.0725732, 0.0181837, -0.0440515, 0.0486887, -0.0291063, 0.023346, 0.0949616, 0.0195294, 0.0390339, -0.00950973, -0.0627082, -0.0690839, -0.0948456, -0.0212328, 0.0825755, 0.00553077, 0.0426745, -0.0212189, -0.0191108, 0.0738687, -0.053109, 0.0407849, -0.0414181, 0.0983821, 0.0339846, -0.0493426, -0.0453585, -0.0266108, 0.0352779, -0.0422963, 0.0358336, 0.110065, -0.0464275, 0.0178445, 0.0218006, 0.015573, 0.059962, -0.0424046, -0.0831156, 0.0735721, -0.0970705, 0.0647763, -0.0477529, -0.037606, 0.0192427, -0.0525731, 0.0175397, -0.0348254, 0.0247167, -0.00173594, 0.0210743, 0.0339943, -0.0146032, 0.066814, -0.0558204, -0.0740313, 0.0217119, -0.0879876, -0.0159905, 0.105659, -0.0614057, 0.0407843, 0.00613394, 0.00690732, 0.054488, 0.0739145, 0.0171241, 0.0292274, -0.041668, 0.0998589, -0.00316588, -0.0358751, -0.00837626, 0.0795285, -0.0887907, -0.0608871, -0.00800397, 0.0329938, -0.062519, -0.0418347, 0.115703, 0.0437679, 0.0912274, 0.053409, 0.064149, 0.0176519, 0.0123359, 0.0393104, 0.0594087, 0.0152075, -0.077448, 0.010473, 0.0777123, -0.0300108, -0.069668, -0.0896219, 0.0470028, 0.00202259, -0.0887683, 0.0438861, 0.0231934, 0.121994, -0.0275724, -0.0704394, 0.000951662, 0.111705, 0.0992683, 0.0170376, -0.0395485, 0.0493098, 0.0627436, 0.0666361, 0.0502231, -0.0484251, 0.080974, -0.0230472, -0.142396, -0.145179, -0.035078, 0.0568744, 0.0425006, -0.0506887, -0.0924732, 0.00960462, -0.0193231, -0.019381, 0.0334366, -0.0433459, -0.108146, -0.0893091, -0.0311039, -0.00942953, 0.0438103, -0.0177359, -0.0578141, 0.0531315, -0.0680519, 0.0113822, -0.084263, 0.130095, -0.00717536, 0.0814468, -0.055997, 0.0227523, -0.0490748, 0.00166378, 0.024471, 0.0344582, -0.00298159, -0.0217954, -0.0574404, 0.0265067, -0.181146, 0.0373656, -0.200853, -0.00340833, -0.0914525, 0.0585976, -0.0366354, -0.00857173, -0.0826307, -0.0563767, -0.0786076}, {0.0276213, -0.0991063, 0.0433776, -0.10444, 0.127916, 0.0540225, 0.0654144, 0.115766, -0.0782652, 0.216564, 0.0116054, -0.0369519, -0.0376904, 0.0130043, -0.0498834, -0.104502, -0.108435, 0.0832808, 0.202825, 0.043829, -0.0386893, 0.113831, 0.0120653, 0.21204, -0.00638286, 0.00379442, -0.0103432, 0.045266, 0.0157511, -0.0339793, 0.0499546, -0.0222854, -0.0313575, 0.0179095, 0.0496033, -0.231858, 0.00662581, -0.0620267, -0.0766479, 0.0222073, 0.0579839, 0.0873481, 0.166099, 0.0803616, -0.0167474, 0.0617592, 0.0374636, 0.0320946, 0.0590191, 0.109044, 0.104564, 0.0243629, 0.0725946, -0.0592266, -0.00152237, -0.0885336, -0.0764755, 0.0239838, -0.0395657, 0.0108571, 0.065817, -0.0921915, -0.10302, -0.0191392, -0.0534785, -0.0500804, -0.00521134, -0.164603, 0.147189, 0.146488, 0.217084, 0.0820616, -0.0348232, -0.103027, 0.0806876, -0.0285859, -0.0573726, 0.10326, -0.0297661, 0.0814337, 0.0285143, -0.0678776, 0.0223372, -0.0649958, -0.0351895, 0.188366, 0.184629, 0.0953435, -0.0805072, -0.217491, 0.116818, -0.138502, -0.0382872, 0.0838056, 0.100368, 0.0602045, 0.0389905, -0.160007, -0.0981416, 0.126494, 0.123427, -0.0500567, 0.0183243, 0.01638, 0.0825592, 0.214784, 0.189521, 0.220987, -0.0308401, 0.084292, 0.109241, -0.0702079, 0.207275, 0.164294, 0.148568, -0.0596732, -0.126402, 0.0256439, 0.175887, 0.136435, 0.109203, 0.213479, -0.078717, 0.19203, 0.0200511, -0.0985933, 0.054904, -0.0145889, -0.0919847, 0.0326824, 0.058417, -0.177093, -0.156322, 0.0492641, 0.0845863, -0.144802, 0.0101808, 0.0815668, -0.0389575, -0.151444, 0.0469736, -0.0414243, 0.212417, -0.0245131, 0.0703831, -0.102811, 0.0231072, 0.138933, -0.105777, 0.14415, 0.0013762, 0.0524547, 0.114344, -0.00147607, 0.11126, -0.0478478, -0.256252, 0.0290366, -0.0580337, -0.137488, 0.05544, -0.0504441, -0.0691847, -0.0523169, 0.0786747, -0.0345124, -0.138076, -0.19396, 0.12958, 0.0590517, 0.158784, 0.117619, -0.0323098, -0.0943269, -0.181612, -0.0933606, -0.167911, 0.18861, -0.100327, 0.344895, 0.263538, -0.350143, -0.263788, 0.159695, 0.327328, 0.0470119, -0.256174, 0.373272, -0.553243, 0.0800238, 0.115661, 0.0746057, 0.0853123, 0.182187, 0.614364, -0.0542426, -0.0422621, 0.0814794, 0.174765, 0.0684427, -0.13695, 0.187029, -0.0367198, -0.0116686, 0.053136, 0.255013, 0.0355551, 0.289598, -0.0750197, -0.0418192, 0.250343, -0.0122897, -0.660176, -0.0901076, -0.443069, -0.30028, -0.115496, -0.328234, 0.0309657, -0.110907, -0.103916, 0.469082, 0.131364, -0.0756985, 0.107812, -0.676163, 0.589734, -0.046628, -0.19187, -0.108367, -0.118649, 0.281994, -0.47255, 0.0956472, -0.71978, 0.0139367, 0.157456, 0.0379902, 0.0822891, -0.272252, 0.0268335, 0.237551, 0.117044, -0.121605, -0.149098, -0.255772, -0.170498, 0.00452499, 0.120187, -0.142872, 0.235633, 0.246523, -0.180911, -0.237381, 0.342472, -0.144405, 0.0728429, 0.0428129, -0.448903, -0.156163, -0.152946, -0.070294, -0.0823711, 0.645189, 0.00524106, -0.0337864, -0.0568787, 0.0508324, 0.271231, -0.10848, 0.0992873, -0.242023, -0.21757, 0.113316, -0.232482, -0.288201, -0.176554, 0.197289, -0.23193, 0.417923, -0.095614, 0.0554409, -0.14382, 0.0563046, 0.137802, 0.0267758, -0.0891485, 0.275953, -0.420121, 0.0189282, -0.0602483, 0.226206, -0.166607, 0.300632, 0.400413, 0.0287438, 0.0142784, 0.00529928, 0.137979, -0.0214817, -0.361339, -0.33712, -0.0055307, -0.0734484, 0.102809, 0.0418758, -0.0285542, 0.137, 0.0382561, -0.162708, 0.296425, 0.0365978, -0.572264, 0.175967, -0.680481, -0.602344, 0.159006, -0.185242, 0.377792, -0.350433, 0.118814, 0.260722, 0.0235069, 0.159103, 0.0873943, -0.439608, 0.313685, -0.0137774, -0.152122, 0.131677, -0.308327, 0.0664752, -0.069497, -0.187712, -0.265557, 0.179809, 0.164466, -0.0463844, -0.0442228, -0.603188, -0.0363817, 0.176722, 0.0652093, -0.211682, -0.154102, -0.318342, 0.290019, 0.177313, -0.0362227, -0.217239, -0.121102, -0.0202035, -0.0254629, -0.222006, 0.41669, -0.168007, -0.0328327, 0.103675, -0.285048, -0.22359, 0.0246693, -0.0375143, -0.173828, 0.60884, 0.29278, 0.169428, 0.0348372, -0.0784717, 0.226846, -0.089269, 0.168166, -0.106617, -0.0157838, 0.0801803, -0.399749, -0.154787, -0.252381, 0.159955, -0.0624292, 0.3317, -0.346782, -0.104393, 0.0419049, 0.210677, 0.12578, -0.0518667, -0.0329242, 0.098197, -0.201345, -0.00985458, -0.0811496, 0.201988, -0.254408, 0.339725, 0.182547, -0.0451479, 0.161718, 0.0549171, 0.573632, 0.0647951, -0.285607, 0.156341, 0.0537638, -0.131732, 0.00978876, -0.270942, -0.0089057, -0.0711751, 0.0541404, -0.0760507, 0.227906, 0.0267093, -0.788593, 0.163697, -0.799977, -0.341798, 0.222883, 0.0025737, 0.0034721, -0.24545, -0.148704, 0.213327, -0.0980875, -0.0104857, 0.112557, -0.260635, 0.085599, 0.0075729, -0.0930423, 0.194681, -0.260084, -0.0506187, -0.205199, -0.0492485, 0.0299082, 0.122312, -0.0858047, 0.0176846, 0.119251, -0.449695, 0.0843791, -0.0646694, 0.161797, -0.16358, 0.108188, -0.381816, 0.272668, 0.0968333, 0.154678, -0.0635753, 0.268115, 0.356934, -0.174881, -0.221526, 0.296877, -0.0467248, -0.0233555, -0.0240859, -0.255654, -0.171571, 0.114064, -0.0487993, 0.0131993, 0.361024, 0.127874, 0.0547136, -0.0771863, 0.16676, 0.0767532, -0.21618, 0.149384, 0.109861, 0.160703, 0.100146, -0.217439, -0.274158, -0.105105, 0.267408, 0.178635, 0.288176, -0.371041, 0.122072, 0.311873, 0.24873, 0.0551366, -0.177855, -0.160305, 0.167546, 0.209702, 0.137863, -0.0262388, -0.030607, -0.0943592, 0.153352, -0.134581, 0.0628618, -0.0135059, 0.127394, 0.478555, -0.079385, -0.148758, -0.00925831, 0.205428, -0.18919, 0.0535814, -0.181804, 0.0511523, -0.00410634, -0.0497155, 0.0309889, 0.347902, -0.0680567, -0.369294, 0.356994, -0.631038, -0.376102, -0.104024, -0.257502, -0.183948, -0.0719235, -0.0696067, 0.520306, 0.0372083, -0.187415, 0.143161, 0.0773435, -0.171867, -0.0836249, -0.146015, 0.19905, -0.316857, -0.154818, -0.156695, -0.0850589, 0.416434, 0.0149754, -0.263989, 0.0338706, -0.00991698, -0.237391, -0.0208848, -0.0452051, 0.104988, -0.183525, 0.258811, -0.154703, 0.279863, -0.0600097, 0.260953, 0.0194167, 0.323485, 0.171909, -0.0236288, -0.190308, 0.112299, -0.135538, -0.0421903, 0.141416, -0.262365, -0.0724071, -0.137287, -0.027235, 0.0962147, 0.349913, 0.160104, -0.00957018, 0.0756286, 0.163504, 0.0353856, 0.0349947, 0.107222, 0.102847, 0.163728, -0.0263023, -0.227858, -0.276758, -0.239546, 0.282517, 0.415529, -0.00788927, -0.095902, 0.0824911, 0.0729495, 0.181397, 0.00459835, -0.263758, 0.0431254, 0.222208, 0.140018, 0.126605, -0.189008, 0.0487619, -0.0344072, 0.0237367, 0.0765991, 0.00110934, -0.149997, 0.277765, 0.147932, -0.0416395, -0.208528, -0.0511254, 0.121907, -0.132941, -0.0448579, -0.683469, -0.0183013, 0.0850425, -0.0637363, -0.189977, 0.349815, 0.00884096, -0.292715, -0.0659596, -0.357039, -0.304167, 0.0546449, -0.285676, -0.0288125, -0.266588, -0.0274612, 0.384659, -0.0285735, 0.05236, -0.0380209, -0.337714, -0.240144, -0.186793, -0.168232, 0.292758, -0.227532, -0.0213563, -0.114306, -0.00140007, 0.374999, -0.0989937, 0.0476573, -0.00362773, 0.0695802, -0.348004, 0.0771738, -0.131034, 0.146874, -0.029601, 0.286596, -0.181038, -0.00486032, -0.095477, 0.112001, 0.130248, 0.235517, 0.129103, -0.0341456, 0.041677, 0.196433, -0.111078, 0.119362, 0.197595, -0.0400631, -0.00841226, 0.194343, 0.0401817, 0.145321, 0.148953, 0.325674, 0.139062, 0.0124091, 0.0565624, 0.0489691, -0.13094, -0.0959775, 0.47519, 0.137369, 0.0901852, -0.119884, -0.16799, -0.297012, -0.0507541, 0.370253, -0.0905671, -0.339204, -0.003363, 0.150526, 0.0787708, -0.0902984, -0.322226, -0.0245909, -0.0211449, 0.3649, -0.107454, -0.351696, 0.171878, 0.11023, 0.17929, 0.101768, -0.100528, -0.108706, 0.273752, -0.0129139, 0.225949, -0.152211, 0.10415, -0.00453187, -0.190837, -0.0047522, -0.700962, -0.00568246, -0.0975829, -0.0182746, -0.124014, 0.224863, 0.0583023, -0.0497897, -0.795542, -0.366883, -0.163679, -0.0716268, -0.0838105, 0.0166782, -0.336467, -0.0737038, 0.298219, 0.0034085, -0.194016, -0.0820495, -0.012677, -0.484887, -0.0833272, -0.0761074, 0.224558, -0.0137649, -0.1774, -0.0659714, 0.0207248, 0.262001, -0.0920292, -0.240127, -0.0797103, 0.260747, -0.228278, 0.0559502, -0.163972, -0.0147561, -0.0611864, 0.349077, -0.137138, 0.179782, 0.0291911, -0.13152, 0.139556, 0.180372, -0.137523, 0.0661394, 0.0488939, -0.224751, -0.0702091, 0.116554, 0.20946, -0.242833, 0.0336277, 0.265745, 0.288162, 0.00336747, -0.124111, 0.405455, 0.0460927, 0.0139479, 0.277073, -0.12529, -0.0488297, -0.102142, 0.444842, -0.0595248, 0.0890743, -0.311908, -0.111432, -0.442741, -0.0833298, 0.234598, -0.117516, -0.214781, -0.0469078, 0.108077, -0.398819}, {-0.00893435, -0.489039, -0.1383, -0.0270897, 0.258435, -0.193441, -0.255405, -0.0456053, 0.138107, 0.225016, 0.0117212, -0.0346929, -0.0700889, -0.17563, -0.207046, 0.164025, 0.103393, 0.105063, -0.120447, -0.068661, 0.122074, -0.709851, -0.217599, -0.110722, -0.00997347, -0.122321, -0.144521, -0.0979417, 0.131804, -0.507849, -0.238268, -0.104098, -0.192799, 0.117278, -0.081167, -0.282703, -0.088033, -0.0353697, 0.245211, -0.326347, 0.0314832, 0.325046, -0.33171, -0.11022, -0.0212197, -0.174889, -0.0190123, -0.0616369, 0.0192069, -0.143262, 0.043052, -0.201255, -0.203772, -0.0146325, 0.143462, -0.094243, 0.0373218, -0.291861, -0.0848669, -0.0271993, 0.0990143, 0.17196, 0.155475, -0.337352, -0.135501, 0.131449, 0.318306, -0.217114, -0.104085, 0.0050927, -0.13264, -0.00361078, -0.00859095, 0.217049, -0.0232182, 0.179292, 0.401095, 0.292241, 0.0254037, -0.370529, 0.418327, 0.00489918, 0.0675265, 0.0292098, -0.108087, -0.0928946, 0.0175665, 0.553194, -0.350266, 0.105617, -0.392795, -0.0687588, -0.310009, 0.0826268, 0.275418, -0.240554, -0.129703, -0.0960152, 0.0335462, -0.88844, 0.144453, -0.405871, -0.0468576, 0.0104188, -0.0674423, -0.245263, -0.0781027, 0.000764786, 0.135069, 0.139163, 0.0530092, -0.0744616, -0.130526, -0.219428, -0.163993, 0.148472, 0.0350705, 0.0914867, -0.121325, 0.0117563, -0.0531994, -0.654517, -0.40136, 0.0878998, -0.00269823, -0.133942, -0.280708, -0.0786542, -0.075174, -0.00959772, 0.238269, 7.27415e-05, -0.426867, -0.0288218, -0.0630909, -0.0992016, -0.199402, -0.387145, 0.0695461, -0.2045, 0.0041471, 0.264057, 0.012491, 0.000556571, 0.062522, -0.45266, -0.0935742, -0.042965, 0.256022, -0.254919, -0.289507, -0.174495, -0.176675, 0.0298284, -0.0666514, -0.173228, -0.0414556, -0.15393, -0.0391135, -0.182542, -0.204071, 0.262086, 0.548911, -0.419161, -0.267121, 0.138798, 0.266576, -0.344522, -0.0228126, -0.0710729, 0.00923063, -0.192125, 0.0999916, 0.0139077, 0.290648, 0.237242, 0.545433, 0.0578297, -0.177543, -0.234489, 0.346308, -0.106504, 0.150048, -0.123275, -0.0424917, -0.2119, 0.0716235, 0.338437, -0.495776, 0.011833, -0.52766, 0.191246, -0.141309, 0.255428, 0.177691, -0.169943, 0.102679, -0.309326, 0.070461, -0.444417, 0.0255623, -0.549725, -0.109891, -0.258775, 0.0938586, -0.408319, -0.0958636, 0.0125556, -0.0639494, 0.402903, -0.00704696, -0.110513, 0.0382837, -0.0537426, -0.00771954, 0.181836, -0.132541, -0.0879361, -0.322865, 0.21705, -0.338041, -0.628876, -0.404146, 0.0685019, 0.0384753, -0.165686, -0.514818, -0.0179384, -0.0195479, 0.318024, 0.355632, 0.010671, -0.40596, -0.0844408, -0.313471, 0.132948, -0.266678, -0.530882, 0.162904, -0.170468, 0.0431707, 0.256424, 0.0893507, -0.189608, 0.162198, -0.607496, 0.023297, -0.0642027, 0.0555706, -0.0808204, -0.252711, -0.0187369, -0.0994736, -0.096666, 0.0609509, -0.243022, 0.151124, -0.180987, -0.0521652, -0.398811, -0.289101, 0.54395, 0.275949, -0.353309, -0.0344137, -0.0553326, 0.0677961, -0.303576, 0.205299, -0.0516781, 0.00795753, -0.110525, -0.140923, -0.0782357, -0.0627474, 0.102491, 0.0527113, 0.0623767, -0.0978607, -0.292968, 0.230906, 0.0794599, 0.0140294, -0.162204, 0.185281, -0.254229, -0.063901, 0.42563, -0.486327, -0.112326, -0.424234, 0.458944, -0.328797, 0.467919, -0.0589568, 0.0126022, 0.0630054, -0.149021, -0.0729081, 0.0649575, -0.0278422, -0.4227, -0.180028, -0.234318, 0.187287, -0.526982, -0.289048, 0.142513, -0.268123, 0.397868, -0.265022, -0.0197786, 0.214817, -0.159598, -0.235139, 0.101724, 0.038347, -0.20275, -0.218619, 0.0599493, -0.189502, -0.318629, -0.634766, 3.422e-06, -0.0490329, -0.07209, -0.478496, -0.032964, -0.0457459, 0.417908, 0.175822, -0.091402, -0.163366, -0.343339, -0.228738, 0.185119, -0.0729859, -0.458546, -0.0486904, -0.0965885, 0.225087, -0.0242448, 0.00298164, -0.069642, 0.1147, -0.479077, -0.188083, -0.167144, 0.143839, 0.0518524, -0.15172, 0.0738675, 0.0174463, 0.00422028, -0.0755146, -0.231231, 0.219096, -0.0158554, -0.0047572, -0.0603669, -0.149226, 0.271868, 0.010839, 0.0845071, 0.0762041, -0.252629, 0.139942, -0.0200682, 0.154158, 0.0613487, 0.00650221, -0.275937, -0.213916, 0.0397043, -0.27081, 0.0551805, -0.722854, -0.119548, -0.000817154, -0.17207, 0.145412, 0.0345402, 0.0670576, -0.187536, -0.0585648, -0.183347, -0.0255171, 0.538272, -0.626444, -0.263922, -0.361067, 0.436222, -0.0613725, 0.161121, -0.201542, 0.132014, 0.0169338, -0.178734, -0.297739, 0.212213, -0.254762, -0.148226, -0.259329, -0.339063, 0.274016, -0.303622, -0.0479544, 0.109753, -0.365674, 0.464669, -0.140565, -0.0934545, 0.336066, -0.131613, -0.103491, 0.328066, 0.140663, -0.343471, -0.0632252, 0.210086, 0.0553481, -0.0732004, -0.561112, -0.0866618, -0.0465585, 0.00861887, -0.470975, -0.214132, -0.191395, 0.24254, -0.0158316, 0.12138, 0.180872, -0.414257, -0.312369, 0.385312, 0.0231411, -0.397032, 0.0921683, 0.37128, 0.140341, -0.0176017, 0.0520946, -0.0847533, 0.0325026, -0.322795, 0.00928543, -0.234076, -0.104981, 0.0436826, 0.124887, -0.103725, -0.158717, 0.0239689, -0.0378083, -0.190321, 0.0918298, -0.210856, 0.0371842, -0.0655334, 0.0251318, 0.387617, -0.444203, 0.22939, 0.178433, -0.0680372, 0.238501, -0.0845745, 0.133106, 0.0368172, 0.150098, 0.0950797, -0.057572, -0.085572, -0.349841, -0.0237621, -0.757106, -0.114034, -0.100657, 0.0406989, -0.384788, 0.0214491, 0.113622, -0.0283234, -0.036349, -0.0413306, 0.0875151, 0.453067, -0.458108, -0.2262, -0.613429, 0.257621, 0.0217984, 0.00980608, -0.101552, 0.073256, -0.0498489, -0.0905465, -0.483041, 0.219213, -0.533501, -0.472565, -0.116678, -0.123743, 0.220296, -0.472568, 0.00417543, 0.172208, -0.339508, 0.184966, 0.0291272, -0.00313397, 0.135364, -0.276155, -0.0125743, 0.500213, 0.0977466, -0.470212, -0.0172046, 0.229184, -0.0845449, -0.0128225, -0.661384, 0.00893958, 0.0301773, -0.376092, 0.0350181, -0.286361, -0.206406, 0.0765842, -0.00751126, 0.101636, 0.194621, -0.271499, -0.143373, 0.319599, -0.227425, -0.273124, 0.119944, 0.543263, -0.0736758, -0.147857, 0.0728993, -0.0234139, -0.0498427, -0.0926113, -0.0402193, -0.00422369, 0.0247299, -0.06378, 0.181684, -0.0891057, -0.192124, 0.0371226, 0.0701518, -0.486969, 0.138793, 0.0705053, 0.00213238, 0.224474, -0.0408929, 0.295415, -0.550885, 0.331746, 0.238204, 0.319138, 0.0577159, -0.0755663, -0.0292838, -0.073148, 0.125685, -0.0178021, 0.00743359, -0.0798744, -0.246706, 0.0484986, -0.131548, -0.0502199, -0.0784997, 0.0367713, -0.550684, 0.105964, 0.0427891, -0.00953006, -0.0599196, -0.243084, -0.0919551, 0.409577, -0.0909698, 0.0477748, -0.163188, 0.0651158, 0.234614, -0.0825018, -0.0830939, 0.108818, 0.00933178, 0.0757844, -0.572919, 0.388715, -0.350633, -0.4473, -0.229292, -0.0868182, -0.0150142, -0.43455, -0.00482884, 0.212514, -0.136961, -0.389066, 0.224216, -0.0351932, 0.149242, -0.161114, -0.21242, 0.567704, 0.029159, -0.183226, -0.0389283, 0.174169, -0.0710199, 0.196326, -0.424276, -0.0196296, -0.0689777, -0.467998, 0.128346, -0.324095, 0.0803365, -0.374761, 0.107053, -0.0292608, 0.0414958, -0.146341, -0.0924926, 0.0904003, -0.0408168, -0.141199, 0.0453359, 0.410361, -0.0992397, -0.0550708, 0.0158409, 0.117185, 0.0607034, -0.10959, -0.208286, -0.0250959, 0.0876209, -0.121251, 0.122182, 0.00457914, -0.00174032, -0.0251567, 0.186182, -0.416149, -0.016943, -0.182672, 0.119186, 0.0901972, -0.0450569, -0.0540329, -0.168371, 0.420926, 0.0991088, 0.270769, 0.0729794, -0.101715, -0.0270483, 0.163616, 0.120432, -0.234616, 0.0258376, 0.245066, -0.0856262, 0.0137434, 0.0892731, -0.112218, -0.128788, 0.0649721, -0.550185, 0.0202794, 0.0899625, -0.200596, 0.0553191, -0.174745, -0.0235164, 0.519953, -0.00265806, 0.107776, 0.408716, -0.0680392, 0.135099, -0.150076, -0.170971, -0.0348956, -0.0720458, -0.0767775, -0.466266, 0.0997357, -0.0735811, -0.378593, 0.15529, -0.069677, 0.102874, -0.40092, -0.00422816, 0.102244, -0.155732, -0.876758, 0.219815, 0.0384718, 0.183368, -0.0163105, -0.329508, 0.447007, 0.1011, -0.140055, -0.0581638, 0.329597, -0.304171, 0.261614, -0.412151, -0.169266, -0.0745554, -0.400493, 0.25287, -0.36389, -0.0922675, -0.634583, 0.00405229, -0.058616, 0.126911, 0.142387, 0.0198915, -0.123609, 0.0716801, -0.312836, -0.053037, 0.554894, 0.168599, -0.205957, -0.147035, 0.309351, -0.184047, 0.0483579, -0.624556, 0.0325454, 0.0247542, 0.140309, 0.0231475, 0.0474983, -0.00664055, 0.00634893, 0.176924, -0.516169, -0.0182139, -0.136661, 0.0594254, 0.1757, -0.0024341, -0.0642956, -0.0828545, 0.415164, -0.0692601, 0.168966, 0.274184, 0.0496881, -0.0263941, 0.159744, 0.0363983, -0.224936, 0.00929748, 0.0861007, 0.249675, 0.0485102, 0.341251, -0.189635, -0.102095, 0.174933, -0.269188, -0.0767634, 0.0484159, -0.430595}, {0.0556211, 0.0232853, -0.0690186, 0.373932, 0.0878587, 0.0968438, 0.62928, 0.110773, 0.0430237, -0.128572, 0.0466378, -0.0370314, 0.242123, -0.203075, -0.752896, 0.126688, 0.158682, -0.239709, 0.401737, 0.101714, 0.111275, -0.112935, 0.0178158, -0.0998893, 0.0851372, -0.596097, -0.0155486, -0.020632, 0.0868783, -0.00270147, -0.234124, 0.417604, -0.0378707, 0.118984, -0.131621, 0.109122, -0.188734, 0.135733, -0.147964, -0.30072, 0.0562281, -0.498765, 0.24528, -0.252252, -0.00749236, -0.703821, 0.133753, 0.0450751, 0.0775126, -0.0270503, 0.0387148, -0.0646313, 0.16969, -0.230298, 0.0842233, 0.202588, 0.235025, -0.0731155, -0.237487, 0.286315, -0.286141, -0.0245389, -0.625716, 0.077857, -0.114876, -0.00359906, -0.0534688, 0.0646445, -0.0792582, -0.000959923, 0.114494, -0.605335, 0.0936091, -0.0960393, -0.147337, 0.025107, -0.0308095, -0.101019, 0.191983, 0.287157, 0.056609, 0.0320938, 0.287002, -0.153892, 0.0450899, 0.226092, 0.197415, -0.0321772, -0.0727706, 0.134537, 0.408236, -0.0758401, 0.371904, -0.0507379, -0.0956208, 0.14217, -0.384343, -0.231993, 0.169819, -0.520341, 0.152682, -0.0201015, -0.161132, 0.215767, 0.0658597, 0.125972, 0.57551, 0.112453, 0.0822532, 0.0633249, 0.0335734, -0.0126212, 0.280381, -0.112931, -0.661499, 0.281795, 0.0433252, -0.31175, 0.70151, 0.129304, 0.158011, 0.000820977, 0.148785, -0.201, 0.233018, -0.575178, -0.0702127, 0.00342237, -0.0594016, 0.123547, -0.193644, 0.323875, 0.0502188, 0.268104, -0.15392, -0.171783, 0.0992787, -0.0177601, -0.17481, -0.387738, -0.0646026, -0.421718, 0.345806, -0.187183, -0.13217, -0.224775, 0.206742, -0.0972541, 0.0576224, 0.0178559, 0.211233, 0.12098, 0.1064, 0.0261706, 0.0533981, -0.0666229, -0.0262047, -0.0343624, 0.124371, 0.253877, -0.0749163, -0.0134836, -0.574394, 0.135199, -0.164765, -0.222068, -0.0964365, 0.0471596, -0.124336, -0.0730182, 0.231865, -0.710489, -0.14858, 0.105218, -0.033491, -0.20943, -0.00603576, -0.116736, 0.0579189, 0.188802, -0.121196, 0.0420275, 0.192673, -0.073766, -0.059733, -0.10135, 0.132621, -0.252931, -0.00176844, -0.0804912, 0.169818, -0.0749203, 0.205874, 0.0822795, -0.00401762, -0.0410291, -0.420769, -0.245794, 0.210571, -0.529261, 0.0793184, 0.0240687, 0.182669, 0.248435, 0.12327, 0.0994067, 0.414545, 0.212157, 0.139738, 0.0181816, -0.16217, 0.138259, 0.193324, -0.110633, -0.521648, 0.263382, 0.0138348, -0.367709, 0.545458, 0.118357, 0.0858882, 0.0339166, 0.237822, -0.333253, 0.32878, -0.541929, -0.0447449, -0.0966927, -0.132294, 0.140003, -0.0406561, 0.225268, 0.191019, 0.240443, -0.26441, -0.427528, -0.0432951, 0.0320222, -0.035347, -0.45595, 0.0510128, -0.325943, 0.108693, -0.20203, -0.128099, 0.0795907, 0.0856781, -0.00288465, 0.163309, -0.0184642, 0.135142, -0.0130133, 0.0419162, 0.0451274, 0.0831416, -0.365021, 0.291528, -0.179921, 0.128369, 0.146977, -0.0909672, -0.225596, -0.399494, -0.108478, 0.0965631, -0.129959, 0.0330324, 0.0809702, -0.0693541, -0.000502117, 0.183757, -0.902987, -0.407902, 0.127827, -0.0731509, -0.146059, -0.0689619, 0.0496151, 0.154328, 0.0178519, -0.139172, 0.138299, 0.129348, 0.155565, 0.00946573, -0.435531, -0.0407184, -0.385315, 0.0915082, 0.0206337, 0.345037, -0.0903355, 0.158576, 0.0715011, -0.136596, -0.192322, -0.407551, -0.0649555, 0.254428, -0.640654, 0.160392, -0.0727548, 0.243993, 0.214919, 0.0755163, 0.200924, 0.446718, 0.0487742, 0.125745, -0.0608303, 0.124411, 0.198081, 0.00366676, -0.216758, -0.825905, 0.0825788, -0.0355114, -0.483604, 0.274405, 0.111166, -0.0345701, 0.122875, 0.275516, -0.223514, 0.360124, -0.204617, 0.163581, 0.0161228, 0.0364594, -0.0547571, 0.0733021, 0.373502, 0.248839, 0.274612, -0.327578, -0.435761, -0.0866756, 0.0973689, -0.14004, -0.420015, 0.0242982, -0.132124, -0.00829053, 0.0900708, -0.00893891, 0.051432, 0.119616, 0.0679879, 0.0104636, 0.0319002, 0.0103875, 0.0571789, 0.0610697, -0.206448, 0.203824, -0.74046, 0.221643, -0.141519, 0.266674, 0.014058, -0.135375, -0.429569, -0.585316, -0.230121, -0.0926699, -0.0930382, 0.238337, 0.111655, -0.103873, -0.033227, 0.134604, -0.830459, -0.63605, -0.0352289, -0.282628, 0.00836147, -0.148876, 0.0974132, 0.0343162, -0.0116092, 0.018017, -0.318294, 0.214318, -0.0990836, -0.0345732, -0.101871, 0.117316, -0.481265, 0.279164, -0.086354, 0.0970348, -0.22713, 0.109797, 0.194115, -0.0265609, -0.270239, -0.176254, -0.0913405, 0.44511, -0.820103, 0.245307, 0.107466, -0.0345639, 0.152937, 0.0879984, 0.224023, 0.435631, -0.310778, 0.0046853, 0.00470149, -0.0578596, -0.248425, 0.115126, -0.249018, -1.06321, 0.0463904, 0.00329348, -0.311342, 0.243294, -0.0357198, -0.055254, 0.085305, 0.102105, -0.205785, 0.31291, -0.397303, 0.379783, -0.110849, -0.126519, 0.0773914, 0.127541, 0.225405, 0.147108, 0.437714, -0.273121, -0.654514, 0.140037, -0.136122, 0.0632043, -0.639924, 0.0220553, -0.27031, -0.0579913, 0.0906754, 0.212892, 0.381232, 0.0390753, 0.046118, 0.0492142, -0.0668992, -0.102451, 2.21424e-05, 0.0188884, -0.0858581, -0.234061, -0.550335, 0.235714, 0.0364056, 0.419018, 0.0367003, 0.0112272, -0.777502, -0.085176, 0.222741, -0.0331975, -0.173958, 0.0709119, 0.11628, 0.0839809, -0.0564258, -0.00060528, -0.72377, -0.603294, -0.134388, -0.391316, -0.0500356, -0.180559, 0.155282, -0.0375385, 0.0334827, -0.0363672, -0.201535, 0.141439, 0.0623784, -0.174308, 0.212601, 0.0365105, -0.518641, -0.055766, -0.0663484, -0.228066, 0.198373, 0.0206633, -0.0987017, 0.247743, -0.209358, -0.302829, -0.108895, 0.3853, -0.666697, 0.150629, 0.18897, 0.0869003, 0.0858253, 0.119895, 0.388644, 0.172445, -0.496756, -0.0483181, -0.179654, 0.0761307, -0.5492, 0.218253, -0.29552, -0.823944, -0.0955367, 0.311575, -0.344727, -0.0271585, 0.13407, 0.0273414, 0.163143, 0.225909, 0.167865, 0.486336, -0.182364, 0.265977, -0.0125051, -0.231202, 0.0504281, 0.0705763, -0.0865643, 0.134159, 0.378929, -0.306946, -0.827981, 0.324138, 0.0802929, -0.0316985, -0.818293, 0.0497976, -0.381807, 0.0954533, 0.312376, 0.240864, 0.308765, 0.0316851, 0.140417, -0.0655427, -0.20329, -0.423849, 0.0932624, 0.301747, 0.223127, -0.483262, -0.242295, 0.0708561, 0.0838435, 0.276727, -0.100648, 0.0763865, -0.973893, 0.222512, 0.523079, -0.178829, 0.0290482, 0.0141354, -0.254519, -0.0557812, -0.0678933, -0.0159214, -0.672329, -0.715524, -0.182803, -0.474958, 0.0531051, 0.160933, 0.253939, -0.0916207, 0.00130492, 0.0852229, -0.283727, 0.282983, 0.160121, -0.183397, 0.0457092, -0.0726473, -0.66184, -0.0803285, 0.027915, -0.106298, 0.178471, 0.0590117, -0.311067, 0.326001, -0.212011, -0.466425, -0.216135, 0.596272, -0.397443, 0.116622, -0.0664479, 0.210602, 0.0325044, -0.149565, 0.140569, 0.277897, -0.316778, 0.0185688, -0.0446209, -0.0867297, -0.149631, -0.143724, 0.148573, -0.067028, -0.0703951, 0.02363, 0.0994649, 0.218993, 0.0306968, 0.0129652, 0.0494105, 0.308845, -0.180495, 0.0818655, -0.0844838, -0.191927, 0.0276527, 0.161692, -0.0697765, -0.21015, -0.00396805, 0.268207, -0.0401895, 0.18945, -0.10003, 0.148319, 0.0444271, 0.215748, -0.134121, -0.0468801, -0.0267515, 0.123141, -0.195563, 0.122849, 0.164196, 0.0198859, -0.138464, -0.00421584, 0.18341, 0.108579, -0.0349825, 0.121053, -0.00290492, 0.252765, -0.10888, 0.188926, 0.185737, 0.206439, 0.00742918, -0.0775661, 0.033451, -0.099953, -0.139983, -0.0634622, 0.216749, -0.00485678, -0.243001, 0.176807, -0.0433104, 0.0266882, -0.138959, -0.00468007, 0.0221276, 0.104633, 0.0495612, -0.00921802, 0.138691, -0.172207, -0.0328241, -0.0290344, -0.0134194, 0.0495568, 0.114347, 0.0969884, -0.0372073, -0.285533, -0.08844, 0.0871162, 0.0207303, 0.183721, -0.0899544, 0.0669696, -0.0586279, -0.139971, 0.0527545, -0.104654, -0.036149, -0.0178004, -0.0816042, 0.143714, -0.00391103, 0.221517, -0.235614, 0.0243537, -0.0673788, 0.0185275, 0.0514918, 0.0184987, -0.0750718, -0.126377, -0.120491, 0.0844743, 0.146909, -0.0613557, 0.0665829, 0.070233, -0.0756149, -0.0317606, 0.0152496, 0.00951739, 0.0563406, 0.106826, 0.0661098, -0.0148611, 0.128746, -0.152724, -0.082102, 0.0973547, -0.100106, -0.0569383, 0.123087, -0.0274754, 0.00610395, 0.0538585, 0.0582478, -0.00956304, -0.0146079, -0.018759, -0.0475133, -0.0665156, -0.0817614, 0.0978822, -0.0737453, -0.0226797, 0.0858076, 0.0342033, -0.0390732, 0.134733, 0.0833323, -0.0303085, 0.0362021, 0.146533, 0.0139903, -0.0456694, -0.0613758, -0.0166149, 0.0490831, 0.00620149, 0.0258558, 0.0236625, -0.0654856, -0.080456, 0.0281538, -0.0780473, 0.0969152, -0.0203722, -0.146705, 0.085884, -0.0701823, -0.00381233, 0.0377719, 0.0450823, 0.121746, -0.0124547, 0.0784076, 0.0923049, -0.0416988, -0.0720662, 0.0554797, -0.0790918, 0.0198439, 0.0808716, 0.0997974}, {-0.0295243, 0.0520238, -0.116917, -0.0862619, 0.17223, -0.126724, 0.0337695, 0.113599, -0.0767795, -0.00898409, -0.113809, -0.0791148, -0.038937, 0.0420231, 0.00801407, -0.0050446, 0.0306112, -0.0466295, 0.0158546, -0.102928, -0.0983042, -0.110515, 0.0706923, -0.0466088, -0.04769, -0.0692486, 0.00944166, -0.0328853, -0.0503292, -0.00811793, 0.0381365, -0.0480033, 0.0318353, 0.0185066, 0.0211728, 0.0101383, 0.0521025, 0.00191101, -0.0313102, 0.0412397, 0.0267626, -0.030048, -0.059988, -0.0572155, 0.0897589, 0.056251, -0.00197214, 0.0311437, -0.0451434, 0.0794026, 0.100102, 0.0349562, 0.103502, -0.0626169, -0.0313085, -0.0699875, -0.0375893, 0.0586029, -0.00538033, -0.0469732, 0.0224755, 0.0902968, 0.0185353, -0.0137566, -0.00732836, 0.0189762, -0.0457324, 0.0431554, -0.0591336, -0.0714522, 0.0471483, 0.00334702, -0.0345715, 0.0389242, -0.0397566, -0.0688151, -0.0703688, 0.0417705, 0.051578, -0.0264591, -0.0699227, -0.0426537, -0.0514135, 0.0258803, 0.0793448, -0.0622145, -0.0296372, -0.0485359, -0.0768819, 0.0487599, 0.0646731, -0.02409, -0.018369, -0.00906337, -0.018076, 0.0418061, -0.00212746, -0.042211, -0.0225653, -0.0182247, 0.063655, -0.0298683, 0.0014591, 0.0559051, -0.056215, -0.00791383, 0.0107509, -0.0312743, -0.0419905, 0.0087667, -0.0489638, -0.0125826, 0.0431607, 0.0793068, -0.0489908, 0.0266545, 0.0624309, 0.0357256, 0.00107275, 0.0181067, -0.0478251, 0.00751016, -0.0550854, 0.00902191, -0.0559033, -0.0539152, 0.0381994, -0.0260631, -0.0727519, 0.0345197, 0.0602915, -0.0362914, 0.0100649, 0.0694956, 0.0311197, -0.029126, 0.0746047, 0.0509764, -0.015498, 0.00597485, 0.0617698, -0.00242443, -0.0441107, -0.0583331, 0.0750017, -0.0107939, -0.0444395, 0.0102489, 0.0384427, -0.0468091, -0.0126083, -0.0191774, -0.0751229, -0.0794985, 0.0127349, -0.00759368, -0.0597127, 0.0663653, 0.0599137, -0.0547591, -0.0373686, -0.0611046, -0.015373, -0.0168859, -0.0339983, 0.0254461, 0.0309628, -0.0424811, -0.0185269, -0.034618, 0.0137285, -0.0137324, -0.00293847, -0.0239336, -0.0778888, 0.0262369, 0.0124837, -0.0646207, -0.0597657, -0.00473972, 0.0324616, 0.081257, -0.031624, -0.069818, -0.0203781, -0.0636702, 0.0301832, -0.0538039, 0.0162542, -0.0129105, 0.0590777, -0.0194609, 0.0214983, 0.0270963, -0.0536429, -0.0324432, -0.0577765, 0.0618437, -0.000282392, 0.0215575, -0.0167214, 0.0615522, -0.0260721, 0.063753, -0.043336, -0.0688367, 0.00182694, 0.0635878, -0.0445941, -0.00955497, -0.0227861, 0.0352996, -0.0348518, -0.00995114, -0.0435983, -0.0221176, 0.0300885, -0.0466892, -0.00257513, -0.0664038, 0.0213011, 0.0786002, -0.0562364, 0.0619798, -0.0244166, 0.0327818, 0.0191718, 0.00339977, -0.0871719, 0.0873902, -0.00820509, 0.0867126, -0.0687551, 0.023772, 0.047426, 0.0338684, 0.080081, -0.0163958, 0.0220888, -0.0819251, 0.0801021, 0.041599, -0.005976, 0.0310327, 0.0907556, -0.0726352, -0.0115259, -0.0793206, 0.0568823, 0.00519616, -0.0169323, -0.0354015, 0.089438, 0.010487, -0.0149285, 0.0113804, -0.00334328, 0.0551005, -0.0455587, -0.0265858, -0.0702209, 0.0594474, 0.0415151, -0.00809883, -0.0286057, 0.0811531, 0.0371145, 0.0265464, 0.0340371, 0.0335334, -0.0110484, 0.0876065, 0.0895473, -0.0166462, 0.0760453, -0.0494209, -0.0391944, 0.00179804, -0.102155, -0.0815216, -0.0436927, -0.0833856, 0.0718403, 0.0178666, -0.00640232, 0.00883126, 0.0166099, -0.0520008, -0.092889, 0.0228696, 0.114045, 0.0535093, 0.0247453, -0.0205249, 0.0715839, 0.000784767, 0.0451045, 0.00357275, 0.0468273, 0.12559, 0.0467442, -0.0997662, -0.119873, -0.0360414, 0.0685904, -0.0586007, -0.0531001, -0.0364002, 0.0890679, 0.00566239, -0.0449811, 0.048612, -0.0680104, -0.0882, 0.0180882, 0.0301369, 0.103812, 0.0185659, -0.00377551, 0.0072962, -0.0585161, 0.0185479, -0.070357, -0.100595, 0.00664123, -0.104728, 0.038401, 0.0478481, -0.067002, 0.0762754, 0.0524275, 0.107996, -0.0300721, -0.0347237, -0.0224128, 0.0383195, 0.0596862, -0.089857, 0.00906517, -0.0229034, -0.00462353, 0.107018, 0.0301327, -0.00451963, 0.0542595, 0.0318087, -0.0124966, -0.0812931, 0.0763355, 0.0510717, 0.0293896, 0.0378682, 0.0698038, -0.0546312, 0.0931918, 0.13339, -0.0743269, 0.0642984, 0.063176, -0.0382767, 0.0145322, -0.0397139, -0.0327348, 0.0425408, -0.051793, 0.0628128, 0.143838, 0.013681, -0.0153688, 0.0520485, -0.061125, 0.0876389, 0.0473485, 0.0773287, 0.125969, 0.0403396, -0.109828, 0.00170145, -0.0706457, 0.0227475, -0.0810274, 0.0819649, 0.0184249, -0.106697, 0.0378282, -0.00911795, 0.0366967, -0.0696817, -0.050761, 0.0305602, 0.131005, -0.00952302, -0.0158477, 0.0741803, -0.0720737, 0.00379361, -0.0320388, 0.00566419, -0.0088337, 0.00367051, 0.081338, -0.120353, -0.113712, -0.0875689, 0.00228843, -0.0526808, 0.0322122, 0.00246093, -0.0212847, -0.0789911, -0.012433, -0.0821877, -0.088039, 0.00918949, -0.0255318, -0.105951, 0.0672495, -0.0783354, 0.101477, -0.0145239, -0.0553268, 0.0198496, 0.0767157, -0.00536639, 0.0702915, -0.0584528, 0.0368338, -0.0481857, 0.0510173, -0.0577311, -0.0240363, 0.0394772, 0.0211213, 0.117293, 0.00825031, -0.0704361, -0.116689, -0.218496, 0.112359, -0.0811159, 0.0267831, 0.149107, 0.146702, -0.0284508, -0.00922494, -0.0396779, -0.0414041, 0.0237227, 0.106228, -0.0431336, 0.0173781, -0.0140597, -0.00514382, 0.192295, 0.012773, 0.118366, 0.00363504, 0.0532428, -0.0483718, 0.0694206, 0.159939, 0.0637646, 0.0539902, 0.0430045, 0.00910955, 0.0702514, 0.0760189, 0.162865, -0.0492292, 0.117714, 0.00910913, 0.159345, -0.0296051, -0.124021, 0.131244, -0.0645507, -0.0153307, 0.0588957, -0.0284742, -0.108944, -0.0294806, 0.0578779, -0.0457888, -0.00507446, -0.0157218, -0.0619373, 0.0310536, -0.038997, 0.0252797, 0.0726632, 0.115495, 0.0264291, 0.0262754, 0.0179009, 0.0178766, 0.117933, -0.144439, 0.131057, 0.0789833, -0.0185055, 0.109306, 0.0312542, -0.0490927, -0.0235303, -0.0850218, -0.0722896, 0.0206773, -0.131616, -0.0649168, -0.112479, -0.0878162, 0.0756397, 0.0909909, -0.084372, -0.147852, -0.164069, 0.113422, 0.0519282, 0.15253, -0.0115862, -0.0176768, 0.0215126, 0.025485, -0.121412, -0.112156, 0.211125, -0.111071, 0.187011, -0.127793, -0.0666754, -0.0776893, -0.0276889, -0.0584838, 0.0827844, 0.0981305, 0.191948, -0.0563561, -0.304775, 0.32083, 0.134485, 0.023724, 0.14547, 0.196721, -0.0374153, 0.0243995, -0.0463359, -0.110028, 0.0671329, 0.152052, -0.236903, -0.182218, 0.258073, 0.053118, 0.363531, 0.145645, 0.221508, -0.0261994, -0.122722, 0.0953573, 0.160358, 0.219749, 0.382025, 0.194282, 0.061345, -0.0629681, -0.145699, 0.306816, 0.121109, 0.0536984, 0.230839, -0.00429239, 0.156649, 0.0393816, -0.212741, 0.133824, -0.0113053, -0.293171, -0.0136536, 0.154415, -0.0895092, -0.122445, 0.249618, 0.169434, -0.055687, -0.075114, 0.0174071, 0.125038, -0.314513, 0.0495836, 0.0764294, 0.217971, -0.0538175, 0.305552, -0.0664618, 0.215538, -0.016947, -0.238248, 0.0877007, -0.00312121, 0.144514, 0.232267, -0.0942606, 0.173884, -0.0101402, -0.342358, -0.0815317, 0.0684892, -0.261626, 0.00125841, -0.227529, 0.0420025, 0.151341, 0.124107, 0.018828, -0.163261, -0.248735, 0.0701727, 0.156049, 0.165441, 0.246842, -0.0865052, 0.0580134, -0.00378414, -0.140069, -0.239145, 0.306903, -0.340737, 0.0588932, 0.105586, -0.323125, -0.0189009, 0.0140849, 0.19116, 0.103494, -0.188783, 0.631202, -0.877925, 0.19605, 0.156334, 0.264034, -0.193275, 0.258175, 0.50758, -0.0130543, 0.285062, 0.0170469, 0.403671, 0.0989576, -0.226296, 0.123064, 0.115204, -0.0704887, 0.175219, 0.511345, 0.0371836, 0.209866, -0.0470909, -0.147871, 0.0272202, 0.132147, -0.203666, -0.178028, -0.171813, -0.143396, -0.12899, -0.157162, 0.0939831, -0.251796, -0.415491, 0.173423, 0.186719, -0.0779603, 0.293962, -0.0753126, 0.473029, 0.0494276, -0.29075, -0.0495939, -0.0736457, 0.200003, -0.432523, 0.204664, -0.269642, 0.0754419, 0.0306364, -0.0971622, 0.127337, -0.0726352, 0.0875981, 0.145178, 0.0942695, -0.278552, -0.0208005, 0.0629033, -0.158806, -0.0108869, 0.252112, -0.309557, -0.156853, 0.102722, -0.409849, -0.106925, 0.262917, -0.173483, 0.294122, 0.0239207, -0.28485, 0.105578, -0.115867, 0.119658, -0.100456, 0.530394, 0.119276, -0.00642088, 0.0794297, 0.276557, 0.257018, -0.116424, 0.0335007, -0.320092, -0.139514, -0.0797323, -0.316666, -0.272982, -0.161617, 0.195611, -0.296431, 0.270542, -0.0247793, -0.176153, -0.147399, -0.036658, -0.0886326, 0.231522, -0.0532552, 0.44371, -0.604745, 0.0413226, -0.0561173, 0.187215, -0.308105, 0.177232, 0.244275, -0.0449426, 0.228118, -0.0728556, 0.48357, 0.0394594, -0.175707, -0.0325998, 0.0198621, 0.0339735, -0.227398, 0.207822, -0.079588, 0.216133, 0.0715864, -0.0301746, 0.136581, 0.2015, -0.354363, 0.0370415, -0.495134, -0.0126954, 0.136526, 0.0365353, 0.342141, -0.188747, -0.0476738, 0.08511, 0.0149827, 0.220974, 0.117766, -0.221951, 0.445696, 0.0352465, -0.0742886, 0.178386, -0.31075, 0.0679493, -0.1079, -0.0134459, -0.215047, 0.200565}, {-0.163148, 0.0368321, -0.120485, -0.319454, -0.127055, 0.16616, 0.0801239, -0.263029, -0.072315, -0.129678, 0.12666, 0.161548, 0.124416, -0.224429, -0.141723, 0.0643417, -0.231965, -0.253963, 0.223106, -0.101569, 0.167056, 0.0783273, -0.379391, -0.350186, 0.0446933, 0.138221, -0.0617986, 0.508584, 0.0623286, -0.186768, -0.156421, 0.075702, 0.159571, -0.078947, 0.162065, -0.0805455, -0.00625181, 0.0250552, -0.289023, -0.205617, -0.203048, 0.356543, -0.181401, 0.059145, -0.0679022, 0.0209549, -0.0106745, 0.0352818, 0.0576032, 0.119451, -0.176057, 0.239373, -0.168229, 0.214429, -0.0770635, 0.151853, -0.274572, 0.171216, 0.188157, 0.0294041, 0.0588728, 0.0669317, 0.538917, 0.0168125, -0.13915, 0.0752647, 0.0439685, -0.13918, -0.0521223, 0.0672192, -0.115931, 0.0924213, 0.0509959, 0.123264, 0.128587, 0.0465683, -0.391699, 0.181559, -0.427529, 0.0536931, -0.0416989, -0.133347, 0.0585624, -0.282564, -0.0781865, 0.169901, -0.201365, 0.0451274, 0.189033, -0.202903, 0.091731, 0.0149029, -0.153995, 0.181591, -0.341756, -0.131178, 0.00995009, 0.0367862, 0.103521, -0.0187314, -0.154608, -0.0654953, -0.0982504, -0.205673, -0.0835399, 0.0023494, 0.0608891, -0.155546, 0.0377139, -0.169057, 0.212228, -0.0277718, 0.222175, -0.0857891, 0.248689, 0.103204, -0.226554, -0.277276, 0.282245, 0.0422492, 0.113833, 0.11988, -0.223204, -0.169215, -0.0455061, 0.127451, 0.0748462, 0.426653, -0.106773, -0.107594, -0.133887, 0.171196, 0.181757, -0.111819, 0.0747731, 0.0900343, 0.10885, 0.108784, -0.29936, -0.065563, -0.223359, 0.358929, 0.15546, 0.364379, -0.123974, 0.0596836, 0.111665, 0.0167664, 0.108486, 0.038486, -0.0779743, 0.426055, -0.0354232, 0.240009, -0.0969578, 0.128153, 0.0392407, 0.275509, 0.198376, 0.0443767, 0.118751, 0.161492, 0.302812, 0.0198959, -0.0499029, -0.0247184, 0.185545, -0.0656015, -0.0978539, -0.241685, -0.113739, 0.0696556, -0.0936559, 0.0713892, 0.288089, 0.120726, -0.0389809, 0.222794, -0.284228, -0.135101, -0.0769022, -0.216004, -0.00680868, -0.187093, 0.0801325, 0.268911, -0.127684, -0.141093, 0.117141, -0.268664, -0.13691, -0.000780761, -0.235319, 0.115949, -0.487524, -0.181065, -0.0809298, 0.0547819, 0.283665, 0.0141564, -0.18414, 0.00807869, -0.10457, -0.188455, -0.00409931, -0.0357819, 0.0915384, -0.125527, 0.0904672, 0.0424155, 0.00474321, -0.308282, -0.00782705, 0.0737666, 0.290229, 0.106533, -0.0880122, -0.120788, 0.442377, 0.0104857, 0.0295779, -0.0199937, -0.29508, -0.144511, 0.12259, 0.118756, 0.106634, 0.465826, 0.0736055, -0.0818746, 0.113697, 0.105154, 0.132817, -0.0114102, 0.083095, 0.0159486, 0.167408, 0.0312786, -0.153635, -0.135815, -0.097872, 0.453271, 0.146181, 0.249583, -0.124644, -0.0740334, 0.0560705, 0.130343, 0.0517124, 0.175372, -0.0601791, 0.36894, 0.0478845, 0.119338, -0.0796952, 0.245781, -0.174406, 0.0845141, 0.306323, -0.0541041, 0.0491143, 0.0579817, -0.14268, 0.174114, -0.0925794, -0.0330991, 0.107662, -0.130654, 0.0631803, -0.52976, 0.00712698, 0.254066, -0.0821127, 0.0240116, 0.378143, 0.0950632, -0.0921979, -0.203801, -0.485379, -0.188913, 0.115529, -0.0917189, 0.0505087, -0.159999, 0.0354167, 0.441702, 0.0506863, -0.138604, 0.0253859, -0.345809, -0.34936, -0.190429, -0.134222, 0.292635, -0.402871, -0.0714435, -0.108279, 0.103944, 0.307846, 0.00652176, -0.0483775, -0.0750357, 0.204417, -0.462282, 0.0260669, -0.191901, 0.07688, -0.0898877, 0.243818, 0.0576187, 0.122419, -0.101327, 0.0522587, 0.311524, 0.254893, 0.0983324, -0.0472616, -0.00300764, 0.428383, -0.0513375, 0.123749, 0.0721579, -0.244597, 0.0686949, 0.271216, 0.230947, 0.230919, 0.351621, 0.276258, 0.0934836, 0.100571, -0.0301533, -0.191487, -0.170086, 0.0737331, 0.129675, 0.107391, -0.00966525, -0.11834, -0.164577, -0.1318, 0.271126, 0.260827, -0.0142573, -0.0604367, -0.25746, 0.148813, -0.0697483, 0.0970287, -0.123851, -0.121457, 0.297612, 0.289674, 0.0781024, -0.205576, 0.289546, -0.0358143, -0.0659986, 0.241141, 0.0102197, -0.054804, 0.130801, -0.115633, -0.015763, -0.0462901, -0.076626, 0.00779624, -0.255392, 0.33867, -0.795475, -0.171578, 0.113484, -0.0418808, -0.00550257, 0.310377, -0.0465061, -0.000548362, -0.846242, -0.596451, -0.140043, 0.0389664, 0.0258742, 0.0640569, -0.054582, 0.0394709, 0.382937, 0.229958, -0.276762, 0.211734, -0.00353195, -0.450382, -0.151203, -0.144009, 0.106959, -0.109984, -0.104417, -0.0334174, 0.0932505, 0.2635, 0.0276378, -0.163288, -0.065364, 0.360714, -0.313808, -0.0181739, -0.198033, -0.0396385, -0.119387, 0.312472, 0.133618, 0.166619, -0.193403, 0.129066, 0.256138, 0.210514, 0.0325847, -0.225839, -0.00233807, 0.351545, -0.154156, 0.172255, 0.2511, -0.269489, 0.0165879, 0.404799, 0.135377, 0.266884, 0.0426846, 0.224979, 0.147145, -0.0365046, -0.0940148, -0.35109, -0.205586, -0.152139, 0.451841, 0.0613623, 0.0360018, -0.129046, -0.198166, -0.409613, 0.228099, 0.391989, -0.0973673, -0.0639442, -0.159095, 0.179066, -0.50174, -0.0319104, 0.0363415, -0.187915, 0.240808, 0.155929, -0.229568, -0.111834, 0.0986496, 0.13163, 0.148851, 0.213398, 0.0241137, -0.102738, -0.0507814, -0.282288, 0.0865465, 0.0832026, -0.10291, -0.192559, -0.228267, 0.205479, -0.686016, -0.300234, 0.254919, -0.0294707, -0.0802076, 0.126682, 0.0649607, 0.0769349, -0.404495, -0.412294, -0.324096, -0.0971616, 0.200339, -0.0115631, 0.183066, 0.0158151, 0.00656865, 0.23617, -0.307761, 0.35736, 0.215723, -0.175652, -0.19043, -0.0181729, -0.213235, 0.049933, -0.0485777, 0.0239252, 0.196182, 0.103489, -0.203647, -0.303267, 0.00508814, 0.104828, -0.316811, 0.0465308, -0.100395, -0.120958, 0.123852, 0.194365, 0.218713, 0.105374, -0.247441, -0.184776, 0.271008, 0.0631309, -0.132957, -0.0856889, 0.113461, 0.113194, -0.140437, 0.123892, 0.173909, -0.190873, 0.157262, 0.696404, 0.0186282, -0.0351048, -0.208073, 0.375895, 0.0603396, -0.0634211, 0.0858771, -0.387169, -0.00534857, 0.0916799, 0.590986, -0.215296, 0.159652, -0.254243, -0.105484, -0.21065, 0.398559, 0.353144, -0.222213, -0.0574198, -0.244508, 0.250439, -0.963369, -0.191422, 0.123955, -0.12707, 0.14005, -0.0200853, -0.0930302, -0.147106, 0.30292, 0.14282, 0.236128, 0.356026, -0.0234631, -0.0802957, 0.0512091, -0.0637124, 0.125044, -0.120481, -0.145711, -0.195107, -0.224318, -0.120775, -0.543133, -0.408552, 0.194377, -0.0295565, -0.174857, -0.150984, 0.148667, 0.0671313, 0.252962, -0.211883, -0.276589, -0.140136, 0.088659, -0.18346, -0.0212251, -0.0814782, -0.325759, 0.179462, -0.200063, 0.227396, 0.102954, -0.00236471, -0.0330416, -0.0948551, -0.34831, 0.0719418, -0.209188, -0.00402067, 0.042437, -0.254462, -0.209844, -0.251815, -0.0702001, -0.0433501, -0.392864, -0.0289971, -0.053231, -0.0628004, -0.331736, -0.0441221, 0.335404, 0.0838541, -0.103369, -0.0941258, 0.276565, 0.00554019, -0.19764, -0.152761, 0.168204, 0.219948, -0.0154492, 0.131416, -0.0843108, -0.145139, 0.262004, 0.420763, -0.0612074, -0.189224, -0.148894, 0.141602, 0.00188602, 0.0479993, 0.048919, -0.358583, -0.399169, 0.121861, 0.657781, -0.18728, 0.124826, -0.381987, 0.444377, -0.296695, 0.234158, 0.410764, 0.0750254, -0.0572157, -0.207128, 0.23887, -0.464862, -0.316797, 0.195973, -0.184432, -0.00410382, -0.126329, -0.169514, -0.0803821, 0.162028, -0.0323837, 0.432006, 0.0950575, 0.00903271, 0.0127415, 0.0308402, -0.0276854, -0.0933952, -0.135953, -0.330227, -0.348757, 0.0210137, -0.336082, -0.412621, -0.170607, -0.0789548, -0.00108301, -0.155095, -0.396292, 0.0720598, -0.0092456, 0.492274, 0.207057, -0.105673, -0.443811, -0.126922, -0.262577, 0.037215, -0.0736051, -0.233166, 0.282836, 0.0756219, 0.0789785, 0.166677, 0.0175744, -0.0595147, -0.101486, -0.291173, -0.030324, -0.165155, 0.0447031, 0.0717189, -0.21577, -0.119057, -0.153299, -0.00737266, -0.11038, -0.540682, -0.115355, -0.102673, 0.0141669, -0.19991, 0.0331153, 0.401878, -0.0621462, -0.19569, -0.159658, 0.0614951, -0.0427473, -0.35254, -0.0371238, 0.136002, -0.018791, 0.0981775, -0.0733068, 0.0165101, -0.23, 0.194774, -0.246709, -0.15032, 0.0609261, -0.197476, -0.00730842, -0.0995627, -0.0739322, -0.0879584, -0.430532, -0.379815, 0.220058, 0.449788, -0.218193, -0.206618, -0.281938, 0.451758, -0.254155, 0.384466, 0.133127, 0.03101, -0.024967, -0.173254, -0.174746, -0.181822, -0.249429, 0.145167, -0.141006, 0.00879996, 0.0358673, -0.0847936, -0.0947769, 0.309782, 0.0508079, 0.652934, -0.0387398, 0.0244027, -0.0351976, -0.255504, -0.219315, -0.118538, -0.0387432, -0.310321, -0.165161, 0.345965, -0.40907, -0.0164585, -0.414069, -0.0239517, 0.0548942, 0.0267233, -0.417913, -0.0325641, -0.0201014, 0.508218, 0.075266, 0.0396899, -0.22539, -0.440254, -0.25315, 0.216068}, {0.183082, -0.114748, 0.0915464, 0.166319, 0.00925693, -0.0228511, 0.0202608, -0.116153, -0.216387, -0.359992, -0.219531, -0.1161, -0.0924292, 0.0838154, -0.0918006, -0.128635, -0.0228286, -0.0282383, -0.0162773, -0.648611, -0.00505062, -0.182833, 0.21104, -0.147025, -0.169078, 0.131839, -0.0929837, -0.177822, 0.0177675, -0.0385749, 0.104931, -0.0482197, 0.107607, 0.172151, 0.155451, -0.0907441, -0.00264725, -0.15492, -0.603841, -0.0506303, -0.804342, -0.213459, 0.0376275, 0.101146, 0.0513378, 0.193717, -0.102163, -0.296843, -0.437401, -0.248581, 0.329579, 0.4172, -0.190444, -0.148453, -0.413046, 0.460435, -0.143165, 0.00479972, -0.0590024, 0.118443, -0.00800784, 0.014455, -0.698409, 0.258695, -0.231304, 0.178286, -0.175483, 0.120224, 0.116012, -0.0481763, 0.115145, 0.262234, -0.155993, 0.688365, 0.0307235, 0.0224534, -0.106822, -0.199251, -0.11629, 0.0323438, 0.134171, -0.536602, 0.0878927, 0.339037, -0.287355, 0.316559, -0.504123, -0.213589, 0.0498453, 0.011762, -0.267141, -0.177336, -0.00126155, 0.143313, 0.128305, 0.0944291, 0.216851, -0.309891, -0.189941, 0.170184, 0.133832, -0.345829, -0.0280333, 0.549344, 0.134194, -0.236054, 0.0486045, 0.0180597, -0.186845, -0.203177, -0.170622, 0.0226344, -0.0628037, 0.088778, 0.108338, -0.140581, -0.139017, 0.00654541, 0.000365281, -0.770909, 0.094576, -0.189193, 0.109269, 0.0636819, -0.138872, 0.145556, -0.298222, 0.123126, 0.0552823, 0.0894185, 0.220008, -0.24289, -0.0127868, 0.26087, 0.094532, -0.0464324, 0.0943858, 0.0172857, -0.510049, -0.139614, -0.594634, -0.265967, 6.65969e-05, -0.0240464, -0.20001, 0.244581, 0.05993, -0.167236, -0.379902, -0.148739, -0.0495377, 0.219207, -0.0403599, -0.149492, -0.489816, 0.386075, 0.0668958, -0.140247, 0.0237388, -0.0763264, -0.0397198, -0.0737191, -0.880485, 0.280733, -0.360015, 0.065458, -0.118572, -0.13674, 0.10902, 0.0531529, 0.0662352, 0.154037, -0.366337, 0.509235, -0.00570494, -0.0543127, 0.0410323, -0.237189, -0.116629, 0.248219, 0.0924086, -0.37382, -0.163649, 0.361325, -0.142429, 0.0923149, -0.149563, -0.068099, -0.00913688, -0.132902, -0.0110874, -0.360735, -0.194812, -0.0633297, 0.164398, 0.0559857, 0.461329, -0.256831, -0.00650342, 0.23445, -0.0551609, -0.18276, 0.020842, 0.538556, 0.0634063, 0.192784, 0.107699, -0.0629831, 0.000251288, -0.0833369, -0.50859, 0.016072, 0.00229861, -0.140332, 0.0957777, 0.0460423, -0.172061, -0.0483008, 0.0915587, -0.998025, 0.151999, -0.231732, 0.0260711, 0.269871, -0.0247448, 0.198912, -0.469453, 0.261958, 0.0733591, 0.069502, -0.00581423, -0.18384, -0.0787327, 0.403185, 0.1567, -0.0090341, -0.0848942, 0.0603777, -0.157438, -0.213667, -0.0287666, -0.0871778, 0.00674905, -0.05934, -0.4555, 0.285818, -0.140201, -0.299606, -0.213671, -0.0614665, -0.162052, 0.220574, 0.181337, 0.0377475, -0.143971, 0.301074, -0.0262433, -0.168925, 0.13641, 0.00302925, -0.12922, 0.225484, -0.867602, 0.104411, -0.210985, 0.0618962, 0.129165, 0.0938234, 0.0879603, 0.475742, 0.147052, 0.241834, -0.0151297, 0.0791038, 0.0897599, -0.0667938, 0.0345163, -0.237405, -0.142275, 0.304132, 0.0104744, -0.166043, -0.150303, 0.36103, 0.108357, 0.124953, -0.203231, 0.0294156, 0.00281781, -0.070608, 0.0680057, -0.33223, -0.0630082, -0.523618, 0.196192, -0.175283, 0.249582, -0.237351, -0.193663, 0.0849409, -0.0807378, -0.1067, 0.158663, 0.473117, -0.0912899, 0.0934103, 0.0246729, 0.0754824, 0.144251, 0.103207, -0.4899, 0.0270585, -0.019718, -0.121444, -0.178543, 0.144487, -0.16915, -0.0555996, 0.138857, -1.03751, -0.018152, -0.284661, 0.110597, 0.0437355, -0.169309, 0.162904, -0.0415563, 0.267414, -0.0562775, 0.157028, 0.0274252, -0.107166, -0.084405, 0.373906, 0.0401967, -0.0170899, 0.0845517, 0.0803751, 0.315725, 0.0696675, 0.242837, -0.199954, -0.045951, 0.167397, -0.287643, 0.178858, -0.0911497, -0.459809, -0.224948, -0.241664, -0.0872189, 0.309287, 0.0218228, -0.0287056, 0.417919, -0.0586521, -0.0497516, -0.239657, 0.176234, 0.0779723, 0.0226613, -0.119631, -0.712515, 0.227363, -0.136201, 0.0911435, 0.296259, 0.293878, 0.0553265, 0.73506, 0.106906, 0.0544558, -0.0267689, -0.227246, 0.256081, 0.0255342, 0.0704911, -0.1273, 0.153699, 0.381055, -0.0504554, -0.0697436, -0.128778, 0.404641, -0.140891, 0.0920141, 0.0726472, -0.187119, 0.0356225, -0.043988, 0.0730817, -0.318639, -0.0159355, -0.490643, 0.178491, -0.202704, 0.165489, 0.0299442, -0.132489, -0.279887, -0.0150536, -0.326663, 0.0527185, 0.51699, 0.204832, -0.00694108, -0.134224, 0.216397, -0.157593, 0.0509134, -0.599734, 0.0379418, -0.109476, 0.0495179, -0.0846535, 0.112268, -0.0595378, -0.0191179, 0.188138, -1.03716, 0.0888049, -0.00633012, -0.0580949, 0.0361659, -0.11131, 0.00455241, 0.0751525, 0.627316, 0.0456706, 0.0330233, 0.0697245, -0.00120777, -0.0704232, 0.316491, 0.191818, 0.0620729, 0.15078, -0.0920952, 0.298352, 0.070934, 0.475343, -0.108745, -0.0386386, 0.0139641, -0.174696, 0.129517, 0.13644, -0.388309, 0.00696154, 0.121243, -0.0480115, 0.348818, 0.109108, -0.00670122, 0.495269, 0.160739, -0.0254354, -0.202165, 0.00365212, -0.166197, 0.215335, -0.0737762, -0.883465, 0.161254, -0.0810868, 0.0622712, 0.541277, 0.0679315, 0.238058, 0.676877, 0.0699197, 0.0223523, 0.257611, -0.34786, 0.126627, -0.0116333, -0.0978476, -0.0305655, 0.0228762, 0.249244, -0.0641734, 0.0845991, -0.203291, 0.264488, -0.00865538, 0.110275, -0.0996493, -0.170241, 0.0340204, -0.0656746, -0.0148526, -0.186877, -0.0240216, -0.203059, 0.0306279, -0.0662934, 0.13661, -0.119012, 0.135745, -0.033755, 0.0898996, -0.28372, -0.0762172, 0.138017, 0.257398, -0.036529, 0.0575963, 0.118939, -0.269928, 0.0378302, -0.645133, 0.155567, 0.109121, -0.0636266, 0.044332, -0.104862, -0.0506467, -0.0801066, 0.104536, -0.77808, 0.193724, 0.111236, -0.186755, -0.113656, 0.0428329, 0.116679, 0.12341, 0.598831, -0.0478925, -0.050398, 0.0137915, -0.0542434, -0.160555, 0.196963, 0.073267, 0.0546857, 0.105933, -0.0319641, 0.341761, 0.0352297, 0.450704, -0.0586649, -0.221486, -0.0312784, -0.186337, -0.00971618, 0.206509, -0.481046, -0.00207254, 0.0442889, 0.239719, 0.193691, 0.0704655, 0.206815, 0.386954, -0.0789388, -0.0866731, 0.0179373, -0.123586, -0.0775931, 0.0190891, -0.00707503, -0.965652, 0.177965, -0.0600143, -0.0404193, 0.728357, 0.092418, 0.132432, 0.568214, 0.247309, -0.0991027, 0.113142, -0.453328, 0.262489, -0.0471193, -0.112254, 0.089671, 0.165384, 0.376048, 0.051914, 0.0416119, -0.294386, 0.286124, 0.0289994, 0.0229508, -0.113753, -0.184461, 0.02916, -0.0677374, 0.150455, -0.0368268, 0.0596392, 0.0871305, 0.142434, -0.225028, 0.121531, -0.182495, 0.219463, 0.21345, 0.229368, -0.236151, -0.0298935, -0.24384, 0.0687168, -0.152186, 0.0784724, 0.147259, -0.0602836, -0.129253, -0.202717, 0.256007, 0.0612166, -0.0703064, 0.0861913, 0.0723041, 0.0293821, -0.00385701, 0.25403, -0.628722, 0.0561344, -0.0488902, -0.00526359, -0.197569, -0.00825168, 0.272997, 0.226795, 0.330861, -0.08701, -0.0490206, -0.0740973, 0.0778446, -0.0209857, 0.0288923, 0.19997, -0.241181, 0.0475275, 0.181256, 0.159514, 0.13151, 0.160083, -0.106272, -0.251052, -0.2295, -0.104615, -0.130061, 0.207428, -0.623262, -0.0727764, 0.0660886, 0.170595, 0.310499, 0.268863, -0.0470062, 0.449249, -0.275354, 0.1295, -0.0677593, 0.0515194, 0.060352, 0.073712, 0.022274, -1.04022, 0.162069, 0.0701489, -0.165638, 0.471814, 0.0254575, 0.137369, 0.292508, 0.241037, -0.125995, 0.370754, -0.538162, 0.267141, 0.0386333, -0.1242, 0.131935, 0.215072, 0.111673, 0.106624, 0.237573, -0.248657, 0.15612, -0.148375, 0.00593162, -0.224612, -0.321667, -0.012158, 0.182983, -0.273779, 0.00440436, -0.0937198, 0.180308, -0.0506707, -0.0327272, 0.246536, -0.250787, 0.104869, 0.0413521, 0.0797427, -0.393549, 0.109126, -0.725741, 0.0967494, 0.0898674, -0.0187234, 0.0264291, -0.0310319, -0.28056, -0.132185, 0.0937364, -0.0267353, -0.158136, 0.116032, 0.190272, -0.1642, -0.0611625, 0.0827442, -0.593408, 0.0564767, 0.0704519, -0.0860277, -0.328665, -0.246306, 0.0774426, 0.192861, 0.170534, -0.0399613, -0.0632827, -0.102227, -0.0762877, 0.0115795, -0.112282, 0.283945, -0.303673, 0.341034, 0.0807552, 0.126017, 0.0599805, 0.0668881, -0.0699418, -0.140468, -0.205245, -0.562994, -0.157388, 0.224951, -0.64573, -0.0959576, 0.167169, 0.118377, 0.069089, -0.022526, 0.0341429, 0.319682, -0.525816, 0.0314376, -0.144706, 0.213094, 0.0180971, 0.0818361, -0.136146, -1.16137, -0.0819301, 0.161245, -0.137006, 0.297799, -0.0817052, 0.108568, 0.26554, 0.258488, -0.0573186, 0.132348, -0.449249, 0.144611, -0.0811538, 0.130772, -0.0252095, -0.0671373, -0.0557024, 0.0905602, 0.309987, -0.270025, -0.0110891}, {-0.0615437, 0.0613275, 0.0321034, -0.433535, -0.0594596, 0.0920241, -0.195453, 0.102025, -0.0287592, -0.0770384, -0.12741, 0.00828802, 0.11283, 0.00299868, -0.147256, 0.0893951, 0.119033, -0.198016, 0.481452, -0.620682, 0.141267, -0.12833, 0.355534, -0.149166, -0.0325506, -0.500837, -0.366546, -0.0140726, -0.275429, -0.121193, 0.164135, 0.228821, -0.0643452, -0.0536807, 0.0341868, -0.391504, -0.0853388, 0.00621257, -0.0721504, 0.00778832, -0.343483, 0.143033, 0.0909979, 0.167316, -0.220302, -0.455744, 0.121232, -0.269497, -0.12054, 0.0326334, 0.144847, -0.471131, 0.0379659, -0.119832, 0.0214534, -0.015423, -0.0466317, -0.0360099, -0.126743, -0.180808, -0.444891, -0.0519549, 0.326441, -0.51293, 0.00659401, 0.111022, 0.219016, 0.0173711, -0.0433184, 0.100532, 0.222556, -0.871113, -0.142243, -0.229175, 0.124865, -0.317217, -0.0820126, -0.220221, -1.09241, 0.118813, 0.0717187, -0.0441239, 0.308685, 0.145256, -0.0139806, 0.460309, 0.19845, 0.130838, 0.063172, -0.35991, 0.355745, -0.0773872, -0.0328539, 0.0242337, 0.0247641, -0.0784971, 0.123893, 0.620062, -0.289508, -0.245316, 0.270687, -0.132268, -0.0246389, -0.723867, 0.0518376, 0.0888738, -0.0232185, 0.320935, -0.0146498, 0.156334, 0.0272463, 0.305548, 0.174063, 0.0390038, -0.26688, -0.0735499, 0.0120453, 0.0269302, 0.134584, -0.470941, 0.132929, -0.151522, 0.483423, -0.225719, 0.0339159, -0.784202, -0.0141931, 0.0446245, -0.303056, -0.0168164, 0.0495478, 0.0840445, 0.00135247, -0.075817, -0.0423439, -0.307549, -0.295225, -0.0373996, -0.312365, 0.090947, 0.0547224, 0.353893, -0.113665, 0.09407, -0.0892345, -0.650363, 0.00625485, 0.0863832, -0.225075, 0.245261, 0.1808, -0.436963, -0.307609, 0.0445816, -0.260206, 0.0877856, -0.0658022, -0.0577399, 0.174268, -0.26525, -0.567492, -0.114102, 0.39341, -0.439209, -0.0010961, 0.207267, 0.0879718, 0.216544, -0.22363, 0.0760674, 0.041492, -0.997841, 0.0784386, 0.197291, 0.369408, -0.289454, -0.084416, -0.142818, -0.754727, -0.100184, 0.16328, -0.129793, 0.0633371, 0.0140356, 0.0405129, 0.481068, 0.495994, 0.125394, 0.359799, -0.205429, 0.418021, 0.058162, -0.1259, -0.0215753, 0.120148, -0.0168534, -0.0195778, 0.357863, -0.240963, -0.567879, 0.296613, -0.0110395, 0.18778, -0.486037, 0.0591939, 0.171183, -0.0322347, 0.31372, 0.0739338, 0.230968, -0.119818, 0.16331, 0.0172546, -0.0643003, -0.356215, 0.0248449, 0.35689, 0.408044, -0.271694, -0.516757, 0.140682, 0.0753073, 0.239827, -0.20713, 0.209275, -0.512132, 0.51622, 0.0778779, -0.361266, -0.21467, 0.0306482, -0.227868, 0.00803196, 0.051644, -0.0805661, -0.19015, -0.099085, -0.426575, -0.467345, 0.331081, 0.254491, 0.310314, 0.0286703, -0.0961335, -0.0432192, -0.489247, -0.00448877, 0.114519, -0.0475791, 0.161459, 0.0778894, -0.331152, -0.221698, 0.173375, -0.29347, 0.0986531, -0.229153, -0.0154704, 0.154883, -0.216, -0.644467, 0.0263673, 0.314672, -0.221978, -0.161334, 0.168584, 0.0409287, 0.249441, -0.284537, -0.0426471, 0.210905, -0.907681, -0.0959756, -0.0738135, -0.033559, -0.113686, -0.177546, 0.13565, 0.0107641, 0.0233131, -0.0595986, 0.15079, 0.0682498, 0.133021, -0.0748325, -0.0435607, 0.169593, 0.035833, 0.0482106, -0.0978601, -0.164527, -0.0147885, 0.142948, -0.0465844, -0.21996, 0.0228679, 0.291577, 0.0628135, 0.321989, -0.0333836, 0.0737688, 0.179057, 0.193128, -0.13503, 0.0430353, 0.0232069, 0.0837804, 0.00217088, 0.00385751, 0.315925, 0.0865517, -0.204934, 0.113985, 0.203416, 0.0804993, -0.0299863, 0.0458148, -0.0269211, 0.202776, -0.00911896, 0.299229, 0.194596, 0.180683, 0.0118132, -0.112693, 0.0580213, -0.0431713, -0.0767191, 0.0282159, 0.267647, 0.0680456, -0.234824, 0.140823, 0.0292425, -0.0821696, -0.155683, -0.0957844, 0.0152272, 0.0113617, -0.00537307, -0.0673603, 0.0327356, -0.0598942, -0.00391299, -0.0111527, -0.0366391, -0.0134897, 0.138261, 0.133614, 0.120521, -0.254528, -0.136156, 0.102176, -0.067668, 0.326611, -0.05598, 0.0817209, -0.0886079, -0.1447, 0.0140412, -0.14009, -0.0834214, -0.0413288, -0.119494, 0.193522, 0.0180809, 0.219792, -0.194142, -0.0483381, 0.0113856, -0.0719026, -0.0878097, 0.00137633, -0.00201772, -0.103441, -0.0340896, 0.0456805, 0.129993, -0.0218249, 0.0244857, -0.0212682, -0.0779316, -0.0520363, -0.0834611, -0.0159751, 0.10023, 0.0344685, -0.000774621, 0.0206063, 0.0601593, -0.180308, -0.0805485, 0.0296015, -0.0576072, -0.117515, 0.0415873, -0.000906306, 0.0480195, 0.0220802, 0.0326276, 0.115779, 0.0736592, 0.0127728, -0.086014, 0.00567156, -0.106371, 0.0290469, 0.0541107, -0.0396728, -0.0243893, 0.055515, -0.0781073, 0.0930969, 0.072973, 0.0058673, 0.0378507, 0.151961, 0.0121091, 0.117634, -0.125734, 0.116624, 0.0914506, -0.0792617, 0.0686329, -0.0115473, -0.0377386, 0.0482228, -0.024984, -0.0805553, -0.0258244, -0.0549574, -0.136185, 0.0354869, -0.00390899, 0.0385591, 0.0258286, -0.0439709, 0.127677, -0.0414933, -0.0284171, 0.0583485, 0.0635084, -0.0619773, 0.051751, 0.000305823, -0.103626, -0.0796022, 0.0966308, -0.0338539, 0.0263891, -0.121026, -0.130528, 0.113398, -0.0754981, 0.185391, 0.0734445, 0.0455483, -0.0569394, 0.010436, 0.00469144, -0.000143437, 0.00101493, -0.111933, -0.0807429, -0.00504828, -0.00550929, 0.0671602, -0.0531692, -0.0448043, -0.130815, 0.0151803, -0.0298546, 0.00179457, 0.056598, -0.0720992, 0.0573817, -0.0687905, 0.0745058, 0.0207985, -0.0764089, 0.025192, 0.0619743, 0.1131, 0.0387035, 0.0277562, 0.0420168, 0.0159744, -0.0614686, -0.0427911, -0.0150183, -0.0354901, 0.01423, 0.0147742, -0.0498311, -0.0614421, -0.105669, 0.0961144, 0.0297608, 0.0330052, 0.0464906, 0.0242221, -0.00606861, -0.0285441, -0.0507543, -0.0350153, 0.0552768, 0.0811454, -0.0897547, 0.0733839, 0.0658811, -0.0259792, -0.0203632, -0.0695062, 0.0801096, -0.0315146, 0.0749345, -0.0260581, -0.0239158, 0.0638883, 0.077351, 0.0538399, 0.0345766, -0.0197688, 0.0668696, -0.0193875, -0.0437971, 0.0262614, 0.000246402, 0.0155047, 0.102182, 0.0225147, -0.0216714, 0.0974515, -0.0462214, 0.0220891, 0.0259143, 0.0737962, 0.00530735, -0.023118, 0.0361125, -0.0167611, -0.0781457, -0.0557742, 0.0402069, 0.0595542, 0.0115845, -0.0203277, -0.017486, -0.0259779, -0.0149906, 0.0615855, 0.0319067, 0.00887561, -0.0385762, 0.00650545, -0.0789726, 0.00673973, -0.0339019, -0.0369705, -0.0177813, -0.0139332, 0.0440163, -0.00392529, -0.0511855, -0.00307842, 0.090615, 0.0753199, -0.0526709, -0.022839, -0.0399234, -0.0583619, -0.0392351, -0.0651159, -0.014906, 0.0185904, -0.0638535, 0.0619746, 0.00381779, 0.0359525, 0.0639915, -0.0400421, 0.0317686, 0.017768, -0.00224088, 0.00915382, -0.0422721, -0.0426823, 0.00442847, 0.0037954, 0.033673, 0.0764079, -0.0284778, 0.0396715, 0.00223269, 0.0599269, -0.0321816, 0.00501639, 0.029681, 0.0148999, -0.0686338, -0.0812174, -0.0354721, -0.0181646, 0.0335868, -0.010712, -0.00639076, 0.0720622, -0.0342216, 0.0180573, 0.0341997, -0.0342368, -0.0489742, 0.0646445, -0.0250846, 0.0632329, 0.0580365, -0.0544287, -0.0792485, 0.0173788, -0.0806354, 0.0818301, -0.0657785, 0.0216157, -0.0693641, -0.0272388, -0.0673742, 0.0462784, -0.061294, -0.0220445, 0.0430826, 0.0682992, -0.0557919, -0.0380264, -0.0241855, -0.0213762, -0.0264988, 0.0598251, 0.0773393, -0.0582446, -0.0597312, -0.0652544, -0.00883387, 0.0599801, 0.0507777, 0.0282023, -0.0754426, -0.0290082, -0.0705825, -0.0264202, 0.0677869, -0.0622888, -0.0237329, -0.0593647, 0.0136124, 0.0818354, -0.0640103, -0.0118522, -0.0591753, -0.0125572, -0.0722172, -0.0112213, -0.00562458, 0.0107681, 0.0798385, 0.0700748, -0.0286364, -0.0556096, -0.0481, 0.0261447, 0.0316989, -0.0331774, 0.0700499, -0.0331138, 0.0520764, -0.0226645, 0.0564346, -0.066244, -0.0122529, -0.051278, 0.0937772, -0.00792576, 0.00353924, 0.0867207, -0.0693873, 0.0305367, -0.0791393, -0.0304438, -0.136367, -0.0191885, 0.00224969, -0.0268175, -0.038009, 0.0989378, -0.0118991, 0.0270432, 0.072804, 0.0652798, -0.00572622, 0.0184823, 0.000737424, -0.00077368, 0.00808026, 0.106331, 0.046237, 0.0550016, 0.0591196, -0.0325812, -0.118387, -0.0611978, 0.0572831, 0.0073166, -0.0355135, -0.0169046, 0.141657, -0.00720522, 0.0979018, -0.0713495, 0.0548582, -0.0251468, 0.126155, 0.0187537, 0.0503134, 0.00154147, -0.00929228, -0.10842, 0.0255547, -0.0803665, -0.023967, -0.04504, -0.0625645, 0.0113232, -0.065442, 0.0339534, -0.0614828, 0.0601186, -0.0586547, 0.0047035, 0.0872702, 0.00373849, 0.0206412, 0.0539836, 0.0597388, 0.0101813, 0.00180837, 0.0779463, 0.0539429, 0.0730036, 0.0988847, 0.0817925, -0.0403477, -0.0442983, -0.00346257, -0.0626365, 0.0793686, -0.0273522, -0.0158686, -0.0151147, 0.0196103, -0.0770326, -0.0492015, 0.0391181, -0.0787593, -0.0674659, 0.029491, 0.10558, 0.0514034, -0.00574683, 0.0554767, 0.0822716, -0.018092, 0.0536141, -0.0358811, -0.0426627, 0.0366215, -0.0529706, 0.0864097, 0.0410602, 0.0680372, -0.0521418, 0.104042, 0.0155726, 0.0456908, 0.111913, 0.0170384}, {0.0795212, 0.00776737, 0.0358563, -0.016434, -0.0275099, 0.0645555, -0.0251071, -0.020718, 0.128583, 0.0329235, -0.0105037, -0.0584716, 0.0641206, 0.0498828, -0.00665932, 0.0348957, -0.0358616, -0.096862, 0.103604, 0.0605429, 0.0201937, 0.141591, 0.0371192, -0.13035, 0.00136743, 0.0847434, -0.0459183, 0.0218653, -0.0546977, 0.0583046, 0.043618, 0.0947908, 0.0244012, 0.115654, -0.0866684, 0.0368704, 0.0354755, -0.0185782, -0.0455363, -0.0144878, 0.00727199, 0.123585, 0.0292183, -0.0167853, -0.0591505, -0.00707975, 0.0337506, -0.00746655, -0.0140465, 0.031408, 0.0698621, 0.0454411, -0.109687, 0.0240256, 0.128441, 0.130961, -0.0791094, -0.0602351, 0.0498099, -0.0107308, 0.0446322, 0.074486, -0.0152128, -0.00642953, 0.12013, -0.139067, -0.0119385, -0.0304632, -0.0173134, -0.0395625, -0.0859852, -0.0975949, 0.0275147, -0.0607444, -0.0134944, -0.123519, -0.0581061, -0.0486578, -0.0116062, 0.00521725, 0.114666, -0.0111478, 0.0779315, 0.0528801, 0.0698586, 0.0199058, 0.0172765, -0.123409, -0.0492271, 0.0799584, -0.0112937, 0.0311552, -0.00340541, -0.1022, -0.0663798, 0.0291355, 0.0729484, 0.0112072, 0.108485, 0.0928155, 0.0627357, -0.0888444, 0.237857, -0.00833578, -0.0164838, 0.126103, 0.00531591, -0.0337088, -0.0606759, 0.0196797, 0.130713, 0.0155274, 0.0215456, -0.120599, -0.033259, 0.0568052, 0.0592167, 0.157665, 0.173349, 0.164957, -0.0668601, -0.0876384, -0.0129574, 0.0343627, 0.187541, 0.147196, -0.00670293, 0.194611, 0.0464361, -0.0429397, 0.140698, 0.157693, -0.0321656, 0.124082, 0.0627459, 0.0847403, -0.0190082, -0.104088, 0.0638686, 0.0200993, -0.116245, 0.0931121, 0.103797, -0.0484502, -0.202447, 0.190749, -0.0181012, 0.0196951, -0.0741191, -0.0267824, 0.159829, -0.147535, -0.168561, 0.0306971, 0.157259, 0.0603706, 0.0277231, 0.00544499, 0.223205, -0.0367222, -0.20158, 0.014446, 0.0316569, 0.00141749, 0.0797492, -0.147115, -0.17822, -0.125107, -0.055239, -0.00768284, 0.0715147, -0.155078, -0.0692918, -0.0957552, -0.074457, -0.0663399, 0.0887486, -0.0967683, -0.116684, -0.155062, 0.0284426, 0.0436077, 0.213209, 0.0297815, -0.0116683, 0.163139, -0.0622507, -0.132784, -0.105718, 0.104846, -0.155043, 0.139261, -0.105164, -0.165876, -0.0861574, -0.166086, -0.0100212, 0.25031, 0.128642, -0.032876, 0.0431928, -0.39555, 0.38892, 0.0120882, -0.0375174, 0.314062, 0.0717183, 0.0654469, -0.0720403, -0.0652396, -0.159674, 0.137925, 0.287808, -0.377263, -0.197965, 0.263646, 0.204776, 0.301597, 0.146355, 0.269909, -0.0217022, -0.199197, 0.208446, 0.158846, 0.344228, 0.454926, 0.0981806, 0.107839, -0.146466, -0.0420331, 0.402029, 0.105532, -0.148406, 0.288054, 0.0622308, 0.2189, 0.154405, -0.136278, 0.377802, -0.0343948, -0.231925, 0.249333, 0.208669, -0.151752, -0.181737, 0.265382, 0.0456907, -0.0390213, -0.0846472, 0.00147727, 0.196672, -0.437195, -0.233433, 0.0794707, 0.285136, 0.0805954, 0.219345, -0.235519, 0.25488, -0.0944857, -0.244512, 0.349878, -0.023506, 0.196265, 0.243488, -0.116657, -0.0449347, -0.184065, -0.305635, -0.0480507, 0.193864, -0.404633, 0.0530718, -0.14917, -0.0552571, -0.00360883, 0.0139993, -0.0490951, -0.109302, -0.399424, -0.0591701, 0.108022, 0.286185, 0.350021, 0.0343703, 0.326666, -0.0301796, -0.0962623, -0.109739, 0.249194, -0.678131, -0.0147342, -0.0425431, -0.18488, 0.141956, -0.170476, 0.0101662, 0.136583, -0.192278, 0.630252, -1.28484, 0.24371, 0.0918847, -0.131856, -0.326139, 0.223078, 0.15126, -0.0256758, 0.18413, 0.0700447, 0.664185, 0.280284, 0.191831, 0.212696, 0.247563, -0.0152093, -0.201857, 0.165496, 0.127816, 0.143934, -0.0890138, 0.0291179, 0.179274, 0.0105048, 0.0464592, -0.270731, 0.122229, 0.211818, -0.0079902, 0.164443, -0.0486694, -0.563229, -0.338669, -0.0486438, 0.291136, 0.14826, 0.282865, -0.295194, 0.186259, 0.0168358, -0.127601, 0.187135, 0.0214948, 0.0591301, -0.127169, 0.169838, 0.0825179, 0.177055, 0.191139, 0.0536067, 0.0175104, -0.148914, -0.0364255, -0.0898834, 0.153706, -0.321758, -0.00121896, -0.0914783, -0.00919797, 0.0351961, 0.149093, -0.326888, -0.263743, 0.11128, -0.361022, -0.101781, -0.00853935, -0.329769, 0.209131, 0.250053, -0.246221, -0.151698, -0.0131489, 0.138681, 0.107142, 0.269996, 0.24524, 0.18042, -0.217323, 0.173351, 0.24423, -0.0500928, 0.0250766, -0.0401747, -0.160711, -0.437069, -0.697563, 0.0120151, 0.0337561, 0.244139, -0.307934, -0.196056, -0.0127237, -0.0302378, -0.285276, -0.189454, 0.00226117, 0.286737, -0.0844342, 0.416897, -0.715411, -0.00244329, 0.0100444, 0.148833, -0.120384, 0.198362, 0.13185, 0.00120779, -0.0273366, -0.0287188, 0.375663, 0.159473, -0.0638879, 0.0785933, -0.143773, 0.245064, -0.479586, 0.174156, 0.0509075, 0.34155, -0.0735677, -0.00673166, -0.0293208, 0.320703, -0.0307902, 0.0720132, -0.144645, 0.339324, 0.119515, -0.0474194, 0.200419, -0.37422, -0.130592, -0.0442443, -0.103752, 0.0469113, 0.315055, -0.180386, 0.361488, 0.133704, -0.102306, 0.0926756, -0.278002, 0.0725099, -0.0999703, 0.127533, 0.275425, 0.245271, 0.0235729, 0.0415388, -0.0968388, -0.166242, 0.00744508, 0.122425, 0.145965, -0.314417, 0.0780897, -0.0585175, 0.136431, 0.192503, 0.0975606, -0.299416, -0.291016, -0.12758, -0.170497, -0.059666, 0.175903, 0.0670855, 0.268366, 0.0730813, -0.127915, -0.07613, 0.0662746, 0.215256, -0.0726527, 0.660858, 0.00254366, 0.150027, 0.01919, 0.104146, 0.153983, -0.0175984, -0.123783, -0.113994, -0.0651457, 0.0129136, -0.406834, -0.0133059, -0.19825, 0.194122, -0.154944, -0.184364, -0.0878408, -0.0642567, -0.168915, 0.0203142, -0.0529881, 0.128944, -0.122647, 0.297979, -0.30859, 0.0662513, 0.0511147, 0.0907667, -0.109102, 0.192689, 0.242134, 0.00144336, -0.0478497, 0.160766, 0.24858, 0.0501406, -0.160028, -0.0205815, -0.143642, 0.0662174, -0.338356, 0.291017, -0.0442218, 0.0540426, 0.0192223, -0.106873, 0.337371, 0.248232, 0.0509885, 0.281801, 0.0273808, 0.306348, -0.256892, 0.0601233, -0.051911, -0.0389763, -0.0773583, -0.0449634, -0.125991, 0.170557, 0.0868468, -0.110007, 0.183264, 0.0765487, -0.424202, 0.154092, -0.144719, -0.0756594, -0.0750176, 0.0714156, 0.323647, -0.0616048, -0.149511, -0.00371852, 0.0651821, -0.224331, -0.0910973, 0.120631, 0.150667, -0.0203872, -0.088874, 0.0579823, 0.13025, -0.276163, 0.181454, -0.140706, 0.0443031, 0.0492479, -0.127421, -0.332699, 0.195927, -0.106734, 0.222178, 0.188375, -0.0808164, 0.0693494, 0.194798, 0.128823, -0.135463, 0.581375, 0.0699005, -0.084115, -0.0238615, 0.0964084, 0.12122, -0.225638, -0.202133, 0.0973268, 0.0397627, 0.160923, -0.236767, -0.0367232, -0.196308, 0.432359, -0.250397, 0.200857, -0.127321, -0.242285, 0.0482943, 0.0625804, -0.0202364, 0.0144572, -0.0193757, 0.359172, -0.264135, 0.0921095, -0.0758476, 0.121876, -0.0919163, 0.237186, 0.327008, 0.00212139, 0.0281143, 0.262589, 0.0219864, 0.120065, 0.0624368, -0.0579435, 0.0260641, 0.126593, 0.015651, 0.158806, -0.133185, 0.268535, 0.05628, -0.048081, 0.328821, 0.235268, 0.139628, 0.349185, -0.194634, -0.0151239, -0.238187, -0.0615, -0.0659741, -0.171364, -0.00288367, 0.162936, -0.102841, -0.213652, -0.0031042, -0.0119671, 0.152238, 0.0510312, -0.128954, 0.119386, -0.240998, -0.135458, -0.222243, 0.100251, 0.0676892, 0.011796, 0.00838424, -0.0764798, -0.104195, -0.20147, 0.00629374, -0.0547924, 0.0570731, -0.0208283, -0.00318475, 0.0178927, -0.0063999, -0.199688, 0.0861481, -0.0327688, 0.260787, 0.136683, 0.0556733, -0.178321, 0.311603, -0.118145, 0.149701, -0.0685629, -0.102894, 0.0697778, 0.192685, 0.216427, -0.00586034, 0.672966, 0.241764, -0.132646, -0.0548699, 0.0220462, 0.0250533, -0.180842, 0.178517, -0.0353432, 0.144965, 0.0449487, -0.311315, 0.0805168, 0.00600336, 0.392935, 0.0459401, 0.138912, 0.0629974, -0.247112, -0.0118954, 0.220386, 0.15246, 0.146994, -0.0976212, 0.351563, -0.0366703, 0.185167, -0.140555, 0.322342, -0.00535883, 0.207836, 0.352636, 0.0207337, 0.183773, 0.084752, -0.34052, 0.167157, 0.0103681, -0.0939621, -0.0157463, -0.0536119, 0.0707614, 0.0582366, -0.163502, 0.533863, -0.0505317, 0.120955, 0.178595, 0.160117, 0.172801, -0.314903, -0.172577, 0.137966, 0.0623019, -0.0361302, 0.0581528, -0.114348, 0.111254, 0.244271, 0.0870685, -0.0619521, 0.00397638, 0.144763, -0.0621897, -0.158977, -0.156928, 0.170857, -0.100612, -0.0560931, -0.0533418, 0.177041, 0.169048, -0.248087, -0.146076, 0.0567428, 0.147817, -0.437964, -0.186926, 0.110389, -0.0253041, -0.121336, 0.153894, -0.0668578, 0.0725337, -0.101899, 0.0801313, 0.333569, 0.32267, 0.205156, 0.00147993, -0.0959018, 0.411536, 0.0987677, 0.156136, -0.0907784, -0.170087, -0.0564467, 0.296889, 0.182024, 0.0575572, 0.627707, 0.131646, -0.117605, 0.138608, -0.00165896, -0.0063334, -0.156143, 0.0495953, 0.0798367}, {-0.1119, 0.0426062, -0.193731, -0.168822, -0.0442917, 0.415716, 0.121788, 0.00954063, -0.107639, -0.221167, 0.0647512, -0.0298325, 0.121344, 0.160653, -0.0679586, 0.391707, 0.204718, 0.191323, -0.0578245, 0.307357, 0.0100683, -0.0502684, 0.347168, -0.110602, -0.112726, 0.14203, -0.392019, -0.122366, -0.00158461, -0.114883, -0.172534, -0.04842, 0.131329, -0.242693, -0.175659, 0.550101, 0.00137612, -0.13589, 0.385805, 0.0989494, -0.0218152, -0.51728, -0.27591, 0.145716, 0.0772414, 0.0920895, 0.0557785, -0.0095952, 0.226379, 0.258435, 0.18497, -0.0772307, 0.184997, -0.0632116, -0.118484, -0.161769, -0.0670848, 0.0622941, -0.0639963, 0.0197039, -0.0405439, 0.103392, 0.18069, -0.208513, 0.0894905, -0.0075566, 0.376032, -0.402187, -0.239316, -0.150738, -0.0981193, -0.0846091, 0.117739, 0.146959, -0.0096931, -0.254716, -0.0398019, 0.0605166, 0.0518635, 0.163445, 0.0453191, 0.124739, 0.219764, -0.0924101, 0.159809, 0.0877334, -0.452792, 0.0735664, 0.349696, 0.180273, -0.0133087, 0.294073, 0.18856, 0.1532, 0.0723151, -0.202583, -0.00347859, -0.111307, -0.105607, 0.275349, -0.194767, -0.0277741, -0.0343355, -0.0943378, -0.203239, 0.254692, 0.21812, -0.143551, -0.0838019, -0.0191551, 0.00770016, -0.302439, -0.0267087, 0.149095, -0.236376, 0.348125, 0.283094, 0.0568139, -0.308296, 0.309034, 0.020712, -0.0131304, 0.250114, -0.0220576, -0.110852, 0.154061, -0.077074, -0.0780421, -0.0331633, -0.0189417, -0.216568, -0.128042, -0.0502078, -0.0885617, -0.168269, 0.155932, -0.0788122, -0.167572, 0.148378, 0.07319, 0.226436, -0.271651, -0.337189, 0.0393114, -0.072958, 0.164412, 0.0238894, 0.0818084, 0.210761, 0.181479, 0.0764716, -0.148384, 0.234573, 0.0428855, -0.011438, -0.179064, 0.0233673, -0.254797, 0.115074, -0.0521074, -0.100906, 0.081467, -0.00796895, -0.220201, -0.27261, -0.0487618, 0.148753, -0.36007, -0.103798, -0.0735966, -0.176974, 0.0477989, 0.0231562, 0.183429, -0.230129, -0.105956, 0.105998, -0.0395706, 0.0144579, 0.133291, 0.126975, 0.204343, 0.161022, 0.117841, 0.121298, -0.0246939, -0.259747, 0.239424, 0.323697, -0.189148, 0.0310367, -0.00102655, 0.07127, 0.0926177, 0.00143708, 0.052199, -0.17659, -0.0137089, -0.106766, 0.348556, -0.0997059, 0.124876, 0.0964278, -0.00612284, -0.208428, 0.226811, 0.0688112, -0.140041, -0.327729, -0.213839, 0.0308515, -0.733017, -0.23891, 0.286759, -0.142143, 0.204307, 0.0768918, 0.0670046, -0.296128, 0.355068, 0.294486, 0.161414, 0.290636, -0.0640446, -0.172184, -0.12888, -0.0177181, 0.0126464, -0.111488, -0.229461, -0.340591, -0.0595448, 0.0301383, 0.0827626, -0.172898, -0.00584386, -0.0851173, -0.187464, -0.191161, 0.114084, 0.148022, 0.0748845, -0.316066, 0.0496204, -0.256509, 0.320828, -0.120058, 0.0734973, 0.14154, 0.0520762, 0.147817, -0.111855, 0.158095, 0.190897, -0.00430154, -0.180508, -0.0210065, -0.160233, -0.0150239, -0.256993, -0.097097, 0.108871, -0.308117, 0.0169885, -0.314382, 0.0397882, 0.0650047, -0.336769, 0.0849669, -0.136223, -0.210538, -0.0824512, -0.0608687, 0.125707, -0.368458, -0.199087, 0.0360838, -0.104467, -0.0191705, 0.222055, -0.070304, 0.0918839, 0.0451136, 0.0363779, 0.0900081, 0.152449, -0.302985, 0.10052, -0.0541425, -0.239804, 0.211262, -0.143555, 0.0295463, 0.199734, 0.129689, 0.257439, -0.336227, -0.296528, -0.0469705, 0.191839, -0.0482384, 0.186493, -0.0314775, 0.273531, -0.325457, 0.0937837, 0.0213619, -0.0291477, -0.27094, -0.0755187, -0.420682, -0.39757, -0.225627, 0.247259, -0.193403, 0.203254, 0.0526363, 0.0745365, -0.193878, 0.312644, 0.421357, 0.262497, 0.0859673, 0.00795263, -0.0503176, -0.00715478, 0.0529821, -0.103216, -0.141767, -0.264575, -0.188337, 0.168663, -0.139332, 0.276586, -0.214709, -0.138785, -0.0235038, -0.092106, -0.310772, 0.0895338, 0.158113, 0.435005, -0.0744349, 0.183925, -0.370388, -0.0261114, -0.175669, 0.109146, 0.101753, 0.0440623, 0.198463, 0.113696, -0.0335826, 0.309251, -0.0807248, -0.0861464, -0.242826, -0.120079, -0.357347, -0.221271, 0.14351, -0.0368007, -0.203129, -0.161713, -0.237158, 0.021094, -0.103609, -0.438266, -0.0905817, -0.297693, -0.142885, 0.0371454, -0.212885, 0.0493431, -0.244275, -0.229357, -0.274797, -0.0453665, 0.0759316, -0.0959556, -0.256711, -0.0570193, -0.0619914, 0.0398199, 0.0698727, -0.0277528, -0.460939, 0.160738, -0.418105, -0.157633, 0.11638, 0.0737507, 0.189138, 0.280546, 0.189446, -0.066047, -0.333404, -0.368818, 0.126446, 0.0409652, -0.15137, 0.115548, 0.0125088, 0.243127, -0.165268, -0.0143392, -0.0878334, -0.0231607, -0.13386, -0.0386807, -0.596216, -0.264055, 0.0230792, 0.179659, -0.162077, 0.0860401, 0.0215394, 0.0657936, 0.0200061, 0.170521, 0.359716, 0.429853, 0.18224, -0.0562449, -0.0163812, -0.0247129, -0.101132, -0.285913, -0.0454117, -0.470271, -0.0109203, 0.0777143, -0.140333, 0.343789, -0.249126, -0.146432, 0.0294518, 0.145454, -0.499564, -0.113752, 0.00982421, 0.551335, 0.0624153, 0.155037, -0.0958402, -0.307796, -0.0570076, 0.116512, 0.152571, -0.0878698, 0.248564, 0.304424, 0.0427001, 0.100441, 0.0127703, -0.107125, -0.00423159, -0.0725306, -0.279225, -0.200125, -0.189637, 0.245358, -0.112838, -0.168462, -0.0534708, -0.0255609, -0.0462588, -0.324007, 0.0323737, -0.248756, 0.0279037, -0.0798282, -0.087313, 0.0570561, -0.190432, -0.136798, -0.134208, -0.0680139, 0.188841, 0.0817509, -0.152739, 0.0590635, 0.0298063, -0.0404751, 0.132603, -0.0733897, -0.341223, 0.115295, -0.660661, -0.147599, 0.14197, 0.141078, 0.14383, 0.20306, -0.171009, -0.171809, -0.262019, -0.221783, 0.2021, 0.0222759, 0.0436145, -0.0382187, -0.18288, 0.0571341, -0.00650316, -0.0771802, 0.0611606, -0.136638, 0.0937836, -0.0705743, -1.14732, -0.0510116, -0.00443542, 0.225045, -0.262098, 0.141062, -0.00133957, 0.0448629, 0.0756366, 0.27932, 0.114628, 0.709608, 0.352308, -0.0471423, -0.0391629, -0.167743, -0.186802, -0.198434, 0.0790499, -0.225757, 0.0548251, 0.115255, -0.162166, 0.50053, -0.250265, -0.176219, -0.0293627, -0.00313241, -0.429931, -0.137605, -0.0242155, 0.249338, 0.119168, 0.00428273, 0.36454, -0.187669, -0.1167, 0.134497, 0.00517996, -0.130437, 0.0758889, 0.573156, 0.130224, -0.209031, -0.0825186, 0.108892, -0.0812023, -0.0407479, -0.262545, -0.0679874, -0.0902072, 0.0664953, -0.0164082, -0.0944706, -0.0643921, 0.0507754, 0.214149, -0.435057, -0.114058, -0.201098, 0.0451373, 0.132764, -0.121882, -0.0957086, -0.221997, -0.0789999, 0.0395639, 0.110348, 0.247943, -0.0194679, -0.0778296, 0.276735, -0.0365784, 0.171397, 0.028474, 0.00933553, -0.310785, -0.163444, -0.506667, -0.159349, 0.167715, 0.00284536, 0.102117, 0.0705222, 0.0321456, -0.217701, -0.245073, -0.127696, 0.0160348, 0.145848, 0.182478, -0.0292396, -0.263731, 0.0740346, -0.124852, -0.250647, -0.0177594, -0.159707, -0.0241228, 0.157686, -1.19723, 0.0649648, -0.129297, 0.0536864, -0.197067, 0.134767, 0.159771, 0.153271, 0.02166, 0.253704, -0.022198, 0.628159, 0.176225, 0.063828, -0.0763135, -0.105423, -0.293957, -0.0767766, 0.141283, -0.227803, -0.151886, 0.145987, 0.072248, 0.260913, -0.0971322, -0.020988, -0.0573147, -0.133522, -0.0999353, -0.0242796, 0.0486472, -0.0985787, 0.0330373, 0.0270657, 0.378724, -0.129809, -0.108915, 0.0603196, -0.0635935, -0.0197464, 0.00951668, 0.425471, 0.118551, -0.159697, -0.0796177, -0.0779974, 0.100141, -0.0644531, -0.34302, -0.0412023, 0.104848, -0.0669589, 0.101011, -0.0491107, -0.0499887, -0.0472211, 0.137336, -0.512806, 0.0146564, -0.150413, -0.0889904, 0.165897, 0.0178486, 0.0326463, -0.251704, 0.087028, 0.00694226, -0.0353068, 0.128125, -0.21263, 0.0941385, 0.265063, -0.112576, 0.0588743, 0.0740563, 0.0970828, 0.174472, -0.146633, -0.0564904, -0.200439, -0.0536273, 0.041166, -0.0519925, 0.086556, 0.0677581, -0.348793, -0.187966, -0.0176504, 0.0373676, 0.0708346, 0.239296, 0.0402446, 0.0155415, -0.0643476, -0.120228, -0.349269, -0.0352378, 0.119264, 0.0214702, -0.0652824, -0.853958, -0.000216119, -0.353701, 0.192696, 0.19772, -3.89937e-05, 0.204893, 0.274865, 0.0556612, 0.110922, -0.177252, 0.407981, 0.126505, -0.0806783, -0.144176, 0.0694302, -0.156866, 0.166243, 0.20415, 0.0499754, -0.185326, 0.117722, 0.0282867, 0.0905604, -0.0494785, -0.154534, -0.0257795, -0.0362717, -0.0215715, -0.00706567, 0.0400278, -0.446983, 0.103076, -0.277693, 0.309358, -0.129533, -0.0821558, -0.0322524, -0.00771632, -0.0973516, 0.118894, 0.360654, 0.0827179, 0.0453006, -0.0640626, -0.052056, 0.346311, 0.225804, -0.160064, -0.00794328, -0.137314, -0.192691, 0.138468, 0.0129075, -0.0916795, -0.04071, -0.0151514, -0.349599, 0.0650307, -0.0849461, 0.0361955, 0.0247862, 0.0479662, 0.218774, -0.166882, 0.30985, -0.0395876, -0.174665, -0.159347, -0.194757, 0.227893, 0.196551, -0.13578, 0.129584}, {0.226169, -0.127881, 0.446245, 0.0342327, 0.290599, -0.201928, -0.0750971, 0.0583279, -0.159626, 0.106722, -0.191339, -0.206656, -0.21664, -0.162332, 0.0956838, -0.0626761, 0.0740639, 0.069941, 0.46494, -0.15792, 0.0676925, -0.415687, 0.0568578, 0.10585, -0.0397454, -0.0192887, -0.865129, 0.207049, 0.00631633, 0.120418, 0.313738, 0.218433, 0.192882, 0.470954, 0.122511, -0.0484992, -0.111868, 0.230965, 0.274801, -0.0325052, -0.215993, 0.0643324, 0.122348, 0.3305, -0.0326595, 0.054557, -0.199939, 0.295201, 0.0431677, 0.0596389, 0.135252, -0.0997533, -0.0505813, -0.0773822, -0.0165158, -0.0759295, -0.0753317, -0.471277, 0.0506415, -0.261407, 0.168249, -0.0196332, -0.0910735, -0.110289, 0.00183468, -0.0245231, 0.0412186, 0.332787, 0.121571, -0.0925469, -0.0834541, 0.0152762, 0.0578723, 0.0952955, -0.288855, -0.0411178, -0.0491519, -0.147456, 0.0518775, -0.0507467, -0.145185, 0.0195657, 0.235268, -0.384465, 0.188416, -0.0196025, 0.244657, 0.139981, -0.0237233, 0.131719, 0.160632, 0.410605, -0.0766486, -0.224264, -0.154376, 0.12507, -0.0409244, 0.017271, -0.126856, 0.0541574, 0.161871, -0.0657833, 0.26534, -0.0929871, 0.332362, -0.0730435, -0.020736, -0.022821, 0.000424929, 0.292752, 0.102898, -0.0814058, -0.0976015, -0.00488638, 0.0535022, 0.149824, -0.0017734, -0.0229021, 0.682442, -0.483664, -0.135645, -0.211889, 0.193342, -0.0841743, 0.102752, -0.088441, -1.10496, 0.0765564, 0.144202, 0.0678706, 0.556761, 0.105878, 0.307005, 0.411412, 0.231759, 0.0397738, 0.0907503, -0.0292187, 0.399826, -0.0190852, -0.118289, 0.0593772, 0.201609, 0.163784, 0.00746983, 0.129625, -0.291726, 0.178542, -0.0519052, 0.251996, 0.00415132, 0.0291449, 0.0388195, -0.134229, 0.0868728, 0.0579663, -0.0551502, -0.0845855, 0.00517408, -0.0339694, 0.00766029, -0.0918875, 0.0550899, 0.0502832, -0.0668322, -0.279904, -0.0534768, -0.218002, 0.0278705, -0.137378, 0.159134, -0.00810517, 0.0496475, 0.0709075, -0.46282, -0.0383415, 0.122017, -0.0543364, 0.151708, 0.0747384, -0.129955, 0.0720957, 0.349751, -0.41153, 0.225889, 0.122265, 0.191592, 0.139275, -0.0645132, 0.106035, 0.345459, 0.551977, -0.112543, -0.165116, -0.011495, -0.08996, -0.00668263, 0.0429806, 0.247792, -0.0432365, 0.0586297, -0.0230433, 0.332977, 0.000203355, 0.185186, -0.0319274, -0.0960739, -0.110254, 0.0477968, 0.0294389, 0.0064215, -0.157555, -0.127594, 0.154414, 0.224281, 0.185812, 0.1441, 0.0141673, 0.370523, -0.642135, 0.069051, -0.151913, 0.0176447, 0.0529936, -0.093078, -0.113575, -1.19298, 0.135056, -0.0149661, 0.0375277, 0.325002, 0.0139056, 0.122722, 0.358233, 0.156348, 0.0202951, 0.103877, -0.169034, 0.437672, -0.00955062, -0.0363239, 0.116165, 0.386316, 0.0940713, 0.0674109, 0.190056, -0.212387, 0.0803953, -0.0472503, 0.00164912, 0.00680388, -0.00141086, -0.0104259, -0.107594, 0.18128, 0.046178, 0.0966334, 0.18184, -0.0215418, -0.0939302, 0.0408621, 0.0240018, 0.139971, 0.271393, -0.090146, -0.3633, -0.1867, -0.640743, -0.0259661, -0.104181, 0.00975389, 0.0160741, -0.00509485, -0.0150653, -0.0176541, 0.014145, 0.10997, 0.0130415, 0.105839, 0.0312348, -0.0487864, -0.0154107, 0.319448, -0.304249, 0.178204, 0.0447318, -0.0235292, -0.176865, -0.14406, 0.0806887, 0.21676, 0.38258, -0.0112985, -0.157513, -0.172121, 0.03408, -0.0958826, 4.86354e-05, 0.280389, -0.212658, 0.273605, 0.278379, 0.13733, -0.0507401, -0.0508589, -0.0100996, -0.0627926, -0.226084, -0.187891, 0.0593075, 0.144958, -0.104374, -0.0804887, 0.242578, -0.0152009, 0.0094756, 0.199799, -0.00273931, 0.131328, -0.837109, 0.00505921, 0.00833905, 0.0727291, 0.0402468, -0.232213, -0.111722, -0.886035, -0.147746, 0.0124281, -0.0150443, 0.190633, -0.113865, 0.036199, 0.374518, 0.251504, -0.0769319, -0.0209811, -0.242462, 0.270755, 0.0547578, 0.0065348, 0.224076, 0.203923, 0.330508, -0.0046716, 0.240355, 0.0484826, -0.0239135, -0.153083, 0.200401, -0.181058, -0.210695, -0.0347606, 0.118721, -0.0227764, 0.0593176, 0.120728, 0.032741, -0.106465, -0.165945, -0.0168666, -0.078632, -0.172737, 0.200446, -0.0067577, -0.292222, 0.092599, -0.624452, 0.0193408, 0.1303, 0.0584278, 0.00241544, -0.0128388, -0.290853, 0.210908, 0.0907044, -0.130175, -0.210841, 0.00784437, -0.0100326, -0.0280182, -0.0837849, 0.235577, -0.158462, 0.216965, 0.0174769, 0.0240163, -0.145565, -0.188792, 0.176838, 0.0185681, 0.310658, 0.108224, -0.27698, -0.245924, -0.0683425, -0.218844, -0.198969, 0.186372, -0.221596, 0.0827332, 0.0453494, -0.00733673, -0.129277, -0.0732556, -0.116559, -0.187103, -0.065528, -0.304682, 0.146043, 0.142426, -0.0865063, -0.103372, 0.172503, 0.0347832, -0.214804, -0.140946, 0.158211, 0.2821, -1.11055, 0.00565935, -0.021545, 0.126159, -0.111825, -0.105393, 0.0782516, -1.0438, 0.104131, -0.106058, -0.0371999, 0.208524, -0.1496, -0.148722, 0.286821, 0.0338881, -0.196905, -0.309085, -0.553795, 0.136287, 0.0577191, -0.133063, 0.116105, 0.055303, 0.0186625, 0.209775, 0.434521, -0.0830965, -0.137395, -0.0293032, 0.0705754, -0.178348, -0.469445, -0.00656602, 0.18872, -0.140998, 0.369602, 0.0437518, 0.0672816, -0.0103714, 0.0622853, -0.0987538, 0.0936335, -0.137475, 0.0802899, -0.0157423, 0.104582, 0.104385, -0.536694, 0.0282075, 0.0945264, 0.351171, -0.152058, 0.0096773, -0.596045, 0.0831468, 0.192172, -0.319991, 0.0452306, 0.278284, -0.00429196, -0.0731947, -0.02003, 0.0733542, 0.0514903, -0.0430937, -0.093289, 0.0219385, 0.0786747, 0.00777391, 0.254513, 0.113489, 0.263906, 0.0182781, -0.311048, -0.245778, -0.180464, -0.13987, -0.17478, -0.000630149, -0.403355, -0.234649, -0.0585544, -0.205066, 0.135422, -0.0222375, 0.0323238, -0.0151947, -0.146762, -0.304879, 0.0194977, 0.214287, -0.153615, 0.115105, 0.13013, 0.274186, -0.106983, -0.353825, -0.122836, 0.274347, -1.02334, -0.347553, -0.139158, 0.168571, -0.038255, -0.125483, -0.222458, -1.05924, 0.164767, -0.158438, 0.0300386, 0.263868, -0.194664, -0.0296333, 0.316183, 0.191546, 0.025515, -0.285346, -0.455194, 0.0926148, -0.0428637, 0.0155118, -0.00240296, -0.123056, -0.0711472, 0.0192076, 0.414716, -0.0682851, -0.159729, 0.31875, 0.0558468, -0.121147, -0.706996, 0.0519037, 0.103156, 0.173638, 0.351558, -0.00693128, 0.376933, -0.120184, 0.208829, -0.0525683, 0.091882, 0.102324, 0.151955, 0.0895811, -0.255666, 0.0823553, -0.383683, -0.00915467, 0.0682199, 0.560109, -0.0995238, -0.197605, -0.640359, 0.255962, -0.0142796, -0.175233, 0.179219, 0.180815, -0.0913794, -0.0817742, 0.0667343, 0.0514739, -0.0381129, -0.122027, -0.219696, -0.297089, 0.0789146, 0.0793968, 0.324424, 0.0439215, 0.293548, 0.14424, -0.0559368, -0.0843478, -0.0637269, -0.0927663, -0.163162, 0.16834, -0.214309, -0.309241, 0.130156, -0.20049, 0.197062, -0.084456, -0.201115, -0.0561451, -0.254275, -0.295569, -0.0964855, 0.104083, -0.20753, 0.150347, 0.257412, 0.100456, -0.265417, -0.151316, -0.0349807, 0.197782, -0.970939, -0.0691665, 0.312393, 0.248479, -0.092123, -0.422007, 0.0700778, -0.740387, -0.035038, -0.0640415, -0.155385, -0.0156342, -0.177111, 0.047955, 0.120141, 0.448453, 0.122845, -0.0392343, 0.0690904, 0.663533, -0.0811817, -0.057805, 0.0419522, 0.183552, -0.0143101, -0.110247, 0.459516, 0.0210436, -0.053689, 0.0507072, 0.243156, -0.138404, -0.400866, 0.00253955, 0.135548, 0.136863, 0.585729, 0.134519, 0.202222, 0.0973973, -0.0335063, -0.238269, 0.00497029, 0.0736953, 0.0730895, 0.0958193, 0.13031, -0.287951, -0.894754, -0.339857, -0.0669651, -0.164567, -0.208446, 0.204299, -0.514742, 0.606728, -0.223135, -0.346855, -0.125747, 0.0769036, -0.120873, 0.157612, -0.0185481, 0.0339049, -0.121411, 0.137943, -0.378682, -0.486808, 0.473327, 0.260797, -0.106964, 0.0310373, 0.153318, 0.233725, -0.362063, 0.0679109, -0.195983, 0.105042, 0.291215, -0.196958, -0.260346, -0.197902, 0.245033, 0.128884, 0.211253, -0.300991, 0.0417511, 0.0132189, -0.304808, 0.0239114, -0.096467, 0.0847156, -0.108004, -0.25402, 0.415757, 0.110529, 0.0592227, -0.259001, -0.0923396, 0.141781, -0.963519, -0.0581142, -0.109692, -0.0513219, -0.0655699, -0.173705, 0.143907, -0.0655984, 0.0438355, -0.0626054, 0.038567, 0.0904039, 0.0163021, -0.00442199, 0.0534381, 0.22492, -0.0411789, 0.0193441, -0.0643097, -0.205644, 0.0129309, 0.157781, -0.125603, -0.201881, -0.0103418, 0.334555, 0.0999251, 0.337247, -0.0967043, 0.0750548, 0.122945, 0.156187, 0.0139743, 0.00890869, -0.140531, 0.186456, -0.12788, 0.0189401, 0.175484, 0.0417858, -0.215352, -0.0996302, 0.274174, 0.0369081, 0.00575641, 0.107072, -0.0517931, 0.214904, -0.124072, 0.205128, 0.134075, 0.110397, -0.0018797, -0.0870987, -0.00883656, -0.0463368, -0.173721, 0.0529349, 0.165032, 0.0171141, -0.291979, 0.117089, -0.0354904, 0.0482339, -0.143591}, {-0.00255662, -0.0200736, 0.103396, 0.096196, 0.00602473, 0.0755392, -0.125074, 0.0378331, 0.0246067, -0.133344, -0.103581, 0.114619, 0.118009, -0.0623372, -0.140827, -0.154755, 0.271509, -0.0346143, 0.323205, 0.00593404, 0.0851072, -0.0194536, -0.181227, -0.0542414, -0.0174038, -0.11122, -0.142577, -0.0780079, 0.245312, -0.144716, 0.123325, -0.197487, 0.0428067, 0.0278231, -0.0130415, -0.0810695, -0.0693869, -0.026693, -0.0248302, -0.0828572, -0.00762154, 0.136855, -0.00123055, 0.0785477, 0.0802321, 0.0317735, -0.000425504, -0.0239866, -0.124313, 0.124695, 0.130653, 0.000723939, -0.0504101, 0.0120566, -0.17912, 0.0598923, 0.164223, -0.0572565, -0.0410253, 0.132217, -0.0371201, 0.105117, 0.100993, -0.0734183, -0.062661, 0.163882, 0.0773051, -0.153819, -0.044794, -0.149954, -0.0323983, 0.0935927, -0.0731235, -0.0128517, 0.000147866, -0.0442158, 0.0678785, 0.133693, -0.0047857, -0.0669129, 0.166204, -0.0545968, 0.0948217, -0.122374, -0.0464231, 0.0745656, -0.0537629, 0.0420231, 0.054826, -0.0555824, -0.0291896, -0.0927329, 0.0755306, -0.00573024, -0.0609269, -0.0491278, 0.0308963, -0.0804232, -0.0355024, 0.0541339, 0.0653225, 0.122206, -0.0391791, 0.00492884, 0.00876164, 0.137376, -0.0300389, 0.104145, 0.0438479, -0.0688475, -0.0577672, -0.0433246, -0.00572889, 0.0856109, -0.0709403, -0.0959085, 0.066695, -0.0107158, 0.124789, 0.0263299, 0.00533219, -0.0263921, -0.122392, 0.0262879, 0.0375531, -0.0702637, -0.057982, -0.00794543, 0.141505, -0.0207861, 0.0444603, 0.00672403, -0.00784245, -0.0950454, 0.0466825, -0.0471889, -0.014497, -0.0527859, -0.016732, 0.0186897, -0.101668, 0.0799175, 0.0204329, 0.0292174, -0.0612534, 0.0777059, 0.080051, -0.0752615, -0.0572849, 0.0676361, -0.0322417, -0.0286608, -0.0276256, -0.0645282, -0.0778419, 0.0755007, 0.101551, 0.0135446, -0.0305759, 0.00114757, 0.0720242, 0.0543425, -0.0503455, 0.0613546, 0.0871184, 0.0372067, 0.0293107, -0.0255327, -0.040862, 0.0246776, 0.095732, -0.0132714, -0.0425122, -0.0329897, 0.0507794, 0.080698, 0.0358514, 0.00854655, 0.0152727, 0.0748919, 0.0257065, 0.00381671, 0.059953, 0.0812195, 0.0950037, -0.0464406, 0.0923696, -0.053507, 0.0159497, 0.0134165, 0.00653037, 0.0379968, 0.0821722, 0.0932452, -0.0601857, -0.0649943, 0.0466712, 0.00158088, 0.0164745, -0.0100588, 0.0764944, -0.0638663, 0.0389674, -0.0721279, 0.0259787, -0.0675563, 0.0632067, 0.0763276, 0.0723568, 0.00325388, 0.0708707, -0.0388516, 0.0585547, -0.0249893, 0.0327636, 0.0407534, -0.105428, 0.00729262, 0.0861894, -0.0834035, 0.0794661, -0.0163819, 0.0533317, -0.0314454, 0.0309154, -0.00318342, 0.0717895, -0.0536247, -0.00659544, 0.00488482, -0.00408862, 0.0628287, 0.0503361, -0.00568601, 0.0604238, 0.0130157, -0.0492487, -0.0522117, 0.0273527, -0.0519889, 0.0291337, 0.0599237, -0.0278612, 0.0382492, -0.0283751, -0.00555296, 0.0418364, 0.0714002, -0.0750946, 0.0585088, -0.0377909, 0.0607917, -0.0317855, 0.0645287, -0.0537763, -0.0195318, 0.0612978, -0.0437482, 0.00251271, 0.0452615, 0.0295296, 0.0161776, -0.0500657, 0.0652462, 0.0529902, 0.0130422, -0.0543728, 0.0518153, -0.0472609, -0.045102, 0.00726556, 0.000713892, 0.0783746, 0.0244317, 0.0160871, 0.0148671, 0.0730158, -0.0109413, -0.0810961, -0.0760315, -0.0368693, -0.0418169, -0.0581576, -0.0108046, -0.00668209, -0.0454991, 0.0514503, -0.0178592, 0.0366533, 0.0483207, -0.077018, -0.0389118, 0.0195457, 0.0617938, -0.0615754, -0.0501024, -0.0572078, 0.00942033, -0.026445, 0.0463553, 0.0132626, 0.0452726, 0.0439545, -0.0698291, -0.0519859, -0.0157839, 0.0575294, -0.0237649, 0.0344335, -0.028631, 0.0218138, -0.00793231, -0.0361704, 0.0702573, -0.0651631, 0.0774987, -0.066533, 0.0104916, 0.0778705, 0.00414746, -0.0375119, 0.0301195, 0.0117761, 0.0200613, 0.0142018, 0.0797527, 0.0505165, -0.0640768, 0.0482528, -0.0487352, -0.0754371, -0.0680438, -0.0757596, 0.0166289, 0.0555489, -0.00079596, 0.116625, 0.00168974, -0.0846711, -0.0453258, 0.0413141, 0.0116294, -0.00508789, 0.0215725, -0.0581856, 0.00447613, 0.0336431, 0.0146561, 0.0710463, -0.0768248, -0.0268055, -0.0665428, 0.0150944, 0.104977, -0.0266778, -0.0721214, -0.0102151, 0.00255572, -0.0424812, -0.0443567, 0.0961294, -0.045259, 0.0828253, -0.0413356, 0.0198678, -0.0400886, 0.0691107, 0.0234138, -0.0426748, 0.0726732, 0.00104212, -0.0456645, 0.07427, 0.0536921, 0.105734, 0.0756897, -0.055165, 0.0757634, 0.0915737, -0.0305169, -0.0895611, 0.0556456, -0.111371, 0.0382971, 0.0923385, -0.0335327, 0.0625691, 0.0227063, -0.00702745, 0.0523208, 0.0028784, 0.0389718, -0.0954205, 0.0159542, 0.0490148, 0.00905683, 0.00259302, -0.0231624, 0.0426281, 0.00171017, -0.0404447, 0.0838155, 0.000276306, 0.0860228, 0.0247118, 0.0602554, 0.0191537, -0.0474625, -0.0715956, -0.0714301, -0.0322911, 0.0441963, 0.0412294, -0.146271, 0.0369952, 0.0226526, 0.0328775, 0.0356532, 0.0378884, 0.0364234, 0.110795, 0.0447439, 0.0721394, -0.0615089, -0.012056, 0.00499572, 0.00225474, -0.0278056, 0.131098, 0.0311189, 0.0886978, 0.0271148, 0.0688276, 0.0819097, -0.00550391, -0.010026, 0.0921377, -0.039683, -0.0660062, -0.0552482, 0.0596393, 0.117296, -0.0684013, 0.0552665, -0.0675791, 0.11006, 0.126336, 0.015782, -0.0155136, -0.0271748, 0.137968, -0.0786717, -0.120507, 0.0585314, -0.0268612, 0.00909802, 0.0300147, 0.00767227, -0.00714337, -0.0465255, 0.11904, -0.104011, 0.0358252, -0.0523958, 0.0132974, -0.0914643, 0.199268, 0.111969, 0.0280301, 0.0579446, 0.089234, -0.140527, 0.0139378, -0.0378274, 0.0838071, 0.0674192, -0.00989052, 0.0224023, 0.142693, 0.101028, 0.0135239, 0.0923095, 0.00950294, 0.115181, 0.0747198, 0.0512875, 0.0752715, 0.0386114, 0.0159604, 0.0788491, -0.0362229, -0.0478737, -0.0285985, 0.00839581, -0.0645691, -0.0504203, 0.0106003, -0.0145883, 0.0299903, -0.00989045, -0.0632458, 0.0051135, 0.103184, 0.151453, 0.0168164, 0.0978633, 0.0378009, -0.0767809, -0.122997, -0.00197239, 0.100884, 0.0640489, 0.0365061, -0.0956362, -0.11568, -0.0849708, 0.155489, -0.0311914, 0.00810637, -0.0876886, 0.138369, -0.0469914, 0.0114742, -0.0901186, -0.114216, -0.0102572, 0.033426, -0.044355, 0.139335, -0.0531952, 0.0797351, 0.0597592, -0.0135006, 0.0912697, -0.0442162, -0.0918292, 0.0733429, -0.00270442, -0.11961, -0.0157514, -0.0589809, -0.0661396, -0.0300398, -0.0639198, 0.0351905, 0.194524, 0.106742, -0.0502, -0.033115, -0.196729, 0.349175, 0.0351916, -0.0302078, 0.294288, -0.084494, -0.0222247, -0.0723597, 0.0610978, -0.0326843, -0.0637256, 0.160708, -0.134571, -0.101479, 0.0287101, 0.0616352, 0.095982, 0.15955, 0.171922, -0.0199562, -0.159074, -0.00078272, 0.101965, 0.178982, 0.286482, 0.0142867, 0.179921, -0.143838, 0.150773, 0.289539, 0.116447, -0.0141832, 0.116051, -0.0621764, 0.0603624, 0.0413777, 0.0552699, 0.126312, -0.0495993, -0.121949, 0.1898, 0.032218, -0.0694253, -0.128096, 0.102598, 0.157703, 0.169996, -0.0941304, 0.0748269, 0.0783929, -0.217072, -0.208495, 0.0874768, 0.181427, 0.00613996, 0.227323, -0.0442407, 0.264309, -0.0710336, -0.104526, 0.0259614, 0.0883635, 0.181266, 0.0439635, -0.0502752, -0.0465814, -0.143924, -0.136514, -0.0970625, 0.11841, -0.243072, 0.10131, -0.127304, -0.0754034, -0.0870484, 0.139027, -0.0733821, 0.138329, -0.0865035, 0.0782815, 0.0128622, 0.154055, 0.248947, -0.0909207, 0.256127, -0.0508198, -0.069308, -0.0217706, -0.0702616, -0.16901, 0.168823, -0.0670104, -0.195622, -0.186097, -0.0741413, -0.000592762, 0.317424, 0.00261917, -0.0780067, 0.0752207, -0.312421, 0.464046, -0.233555, 0.0407138, 0.29782, -0.00687308, -0.02982, -0.140866, 0.0488344, -0.192296, 0.210173, 0.394254, -0.284686, -0.071649, 0.155091, 0.260119, 0.13711, 0.160224, 0.253726, 0.042703, -0.214072, 0.143754, 0.0729545, 0.295888, 0.313857, 0.218935, 0.215357, -0.287555, 0.0413544, 0.530114, 0.125416, -0.127088, 0.292357, -0.0164255, 0.337451, 0.21637, -0.0775241, 0.278755, -0.0702106, -0.249928, 0.326399, 0.116135, -0.124989, -0.0938005, 0.0612477, -0.0265932, 0.0725584, -0.114531, -0.0120912, 0.13625, -0.488427, -0.359882, -0.0172602, 0.228583, 0.183151, 0.164543, -0.203078, 0.256557, -0.212049, -0.211809, 0.251521, 0.0585996, 0.222069, 0.219679, -0.196329, 0.0144118, 0.0240834, -0.186135, -0.0627822, 0.159719, -0.405111, 0.148854, -0.104262, 0.0370783, -0.0931629, 0.0397163, 0.074749, 0.0455882, -0.352736, 0.131458, 0.176693, 0.396694, 0.456602, -0.0197714, 0.393368, -0.0468657, 0.0804863, 0.0247499, 0.505814, -0.623432, 0.138675, -0.140641, -0.129946, 0.222339, -0.186488, -0.228321, -0.0141035, -0.273339, 0.250094, -1.36696, 0.2536, -0.0206085, -0.187959, -0.220492, 0.302007, -0.0245882, 0.00435253, 0.0381893, 0.252045, 0.425016, 0.356846, -0.0795532, 0.367466, -0.128743, -0.033961, -0.207594, -0.00420154, -0.0667279, 0.0949274, 0.0166771, 0.0645111, 0.202885, -0.237834, 0.272387, 0.273784, 0.434523, 0.462346, -0.189289, -0.0207592, -0.202205, -0.344007, -0.487539, -0.379014, 0.173842, 0.266774}, {0.0830487, -0.370875, 0.0596652, 0.0948397, -0.0970744, 0.309319, 0.241406, 0.0576859, 0.0574695, -0.01695, 0.303221, -0.0183987, 0.112591, -0.0529988, -0.175655, -0.304396, -0.11299, 0.122163, 0.195795, -0.260863, 0.137651, 0.0308145, -0.0758243, 0.115521, -0.0686581, -0.0947061, -0.151266, 0.402802, -0.740532, -0.230032, -0.246003, -0.0759849, -0.0474987, 0.0178584, -0.219305, -0.0512172, 0.0781544, 0.0847997, 0.138775, 0.274199, 0.463005, 0.218972, -0.551561, 0.00258955, 0.100243, -0.0911564, 0.0196564, 0.0197061, 0.212537, -0.0108963, -0.536967, -0.066587, 0.0460028, 0.302736, -0.443934, -0.0839833, 0.0588197, 0.0154554, -0.150679, -0.178396, -0.173093, 0.0616611, 0.0174427, 0.236522, -0.936452, -0.173194, 0.152177, -0.0735099, 0.0565211, 0.247713, 0.230084, -0.0115542, -0.167847, 0.0535984, 0.390167, 0.410911, -0.00344486, 0.103768, -0.281919, 0.0472278, -0.297908, 0.241099, -0.103268, 0.21658, 0.0394649, -0.0931095, -0.031527, 0.325619, 0.49614, 0.0221713, 0.0994234, 0.570881, 0.051377, -0.0413627, 0.162932, -0.265267, -0.217927, -0.211468, 0.102715, 0.0888919, 0.0401812, -0.177054, 0.282459, 0.216016, 0.0355195, 0.120364, 0.0413915, 0.0712318, -0.193126, 0.172652, 0.243722, 0.203038, -0.100631, 0.0235754, -0.0613669, 0.0124803, -0.0225227, 0.0574118, 0.0876552, -0.28064, 0.136122, -0.000834374, -0.0858536, 0.0743134, 0.177008, -0.241586, -0.0560441, 0.146476, -0.287181, -0.248079, 0.121891, 0.127824, 0.186217, 0.0785224, -0.0300538, 0.0488969, 0.111491, -0.0256639, 0.241561, 0.320619, 0.194086, 0.170195, -0.310821, 0.0480478, 0.0412382, -0.19738, 0.0830974, -0.0820181, -0.0820658, 0.0833092, -0.330291, -0.102547, -0.0677856, 0.264003, -0.143211, 0.0477527, 0.0169639, 0.0181298, -0.144952, -0.0721337, -0.106991, -0.058833, -0.0560191, 0.095833, -0.485053, -0.00255452, 0.150251, 0.117387, -0.0505751, 0.135935, 0.279245, 0.0261523, -0.0147729, 0.140054, 0.0995732, 0.204114, -0.0394222, -0.125126, -0.27933, 0.082982, -0.408242, 0.254841, -0.13003, 0.215815, -0.00178787, -0.0958017, 0.317888, 0.180395, 0.214399, 0.186245, 0.0385913, 0.339673, 0.0379777, 0.121085, -0.15756, -0.23953, -0.0953628, -0.0165009, 0.0325795, 0.0665411, -0.0619752, -0.0141728, 0.304809, 0.0839006, -0.13463, 0.160767, -0.0704161, -0.131842, 0.00893723, -0.0791349, 0.188544, 0.275617, 0.0419208, -0.0192427, -0.171137, -0.224531, -0.0634783, 0.182927, 0.199927, -0.0430819, -0.134275, -0.114545, -0.0543822, -0.14129, 0.0428957, -0.198915, 0.0422158, 0.00657939, -0.00981872, -0.251524, 0.185786, -0.199402, 0.0012132, 0.175135, -0.260584, -0.0352635, 0.267225, 0.103181, 0.0343152, 0.494551, 0.362038, 0.104122, -0.0374138, -0.0323619, 0.162285, -0.098834, -0.0927916, -0.0295482, -0.240757, 0.239718, -0.175636, 0.0637237, -0.079836, 0.420299, -0.38805, 0.0751506, 0.0183133, -0.162955, -0.0411913, -0.0781335, -0.0120666, 0.0185912, -0.0396221, 0.0207731, -0.424868, 0.0119192, -0.153309, 0.0888132, -0.0221272, 0.110409, 0.293027, -0.0107773, -0.062764, 0.0950438, -0.000801963, 0.215815, 0.0303909, -0.120364, -0.230588, 0.143868, -0.157822, 0.344085, -0.174257, 0.255944, 0.0333788, 0.00412151, 0.0669754, 0.168682, 0.18984, 0.108064, -0.136943, 0.257488, 0.104682, 0.00332867, -0.0891427, -0.25051, -0.243565, 0.0474713, -0.100097, -0.0110157, 0.136843, -0.0476931, 0.0714895, 0.0508976, 0.178318, -0.0736284, -0.232806, -0.0018563, 0.0119241, 0.114194, 0.123266, 0.122159, 0.0426868, 0.0698501, -0.0272937, -0.169805, -0.0468779, 0.14671, -0.0284264, -0.186317, -0.127489, -0.0327173, -0.0259831, -0.0894907, 0.173245, -0.0403591, 0.0688082, 0.0713543, 0.163205, -0.0333837, 0.18598, -0.0287813, 0.0118795, 0.10229, -0.049388, 0.101791, 0.289501, 0.0392684, 0.167731, 0.568126, 0.090598, 0.121165, 0.0348701, -0.26666, 0.0325521, -0.107211, 0.0804852, -0.0152116, 0.0214885, 0.0523748, -0.145069, 1.41073e-05, 0.0209494, 0.2947, -0.425569, 0.0531538, -0.00458703, -0.266814, -0.0794609, -0.0080991, 0.0390902, 0.0683773, -0.0585542, 0.18651, -0.171201, 0.232152, -0.156871, 0.360714, 0.0243643, 0.274631, 0.240576, -0.0145533, 0.0506599, 0.203343, -0.224595, 0.193644, -0.0329606, -0.175766, -0.244006, 0.0335001, -0.0776002, 0.5076, -0.154457, 0.2639, -0.0144961, 0.0513821, 0.150932, 0.103738, 0.302861, -0.220862, 0.0835044, 0.213464, 0.0598879, -0.0191432, -0.0531023, 0.0632528, -0.0685652, 0.102293, 0.0372548, 0.0274294, 0.0910946, 0.131038, 0.0669526, 0.0451955, 0.0504264, 0.0466692, -0.176566, 0.0144477, -0.0203214, 0.121217, 0.26617, -0.102246, 0.0210635, -0.0556717, 0.0297243, -0.154107, -0.030737, 0.29363, -0.100096, -0.118116, 0.207751, -0.0543446, -0.0123333, -0.148579, -0.0283461, 0.112324, -0.0503557, 0.2223, 0.0319084, 0.021011, 0.102057, 0.0514762, 0.0763986, 0.205337, -0.140928, -0.0291287, 0.498427, 0.192121, -0.186289, 0.576094, 0.099984, 0.0957545, 0.0648271, -0.0240388, -0.0546514, -0.0911143, -0.0317544, 0.113635, -0.00105017, 0.0364421, -0.164351, -0.217634, 0.0451266, 0.165994, 0.0064991, -0.0302887, 0.0622891, -0.0750287, -0.131563, -0.19175, -0.0129756, 0.0726718, 0.0596514, 0.0769721, 0.0250721, 0.251294, -0.283908, 0.396885, 0.110169, -0.111825, 0.137402, 0.0594904, -0.102688, 0.0622408, -0.342735, -0.0970825, -0.127343, -0.029184, -0.208434, 0.0532451, 0.158376, 0.551012, -0.101959, 0.467779, -0.0318276, -0.123302, 0.302584, 0.208263, 0.0895212, -0.43066, 0.00886465, 0.210628, 0.181746, -0.125953, 0.0756684, -0.0063633, 0.075173, 0.165278, 0.158947, -0.136162, 0.278667, -0.0832145, -5.70653e-05, -0.00472108, -0.00153561, 0.0312664, -0.272647, 0.0904236, -0.0128019, 0.108538, 0.238005, -0.0680383, 0.0592206, -0.0689778, 0.142643, -0.281626, 0.0218901, 0.0404869, -0.230568, -0.0868604, 0.167489, 0.166943, -0.144347, -0.0939931, -0.002043, 0.11911, 0.109534, 0.308924, 0.201821, 0.167265, 0.325354, 0.148063, 0.0175546, 0.111539, -0.215161, 0.117801, 0.336454, 0.0252949, 0.0588765, 0.616828, 0.0199918, 0.0963146, 0.00141404, -0.169402, 0.0836997, -0.243325, -0.154754, 0.0993168, -0.228723, -0.0161172, -0.0940629, -0.234533, -0.0472532, -0.0376248, 0.0762166, -0.0265263, -0.0800692, -0.115976, 0.140342, -0.416841, -0.156741, 0.108113, 0.0910799, 0.110804, -0.0415075, 0.157118, -0.177902, -0.000216716, 0.0360372, -0.183702, 0.0549634, -0.0792534, -0.215744, 0.147936, -0.0685528, -0.244753, -0.179235, -0.0705088, -0.0422502, 0.0197833, -0.000471498, 0.280886, -0.010327, 0.0989929, 0.0182203, -0.087076, 0.135565, -0.0894429, 0.208235, -0.278678, -0.207442, 0.263615, -0.219456, 0.125014, 0.183029, -0.0976671, 0.0525799, 0.357722, 0.057902, -0.243109, 0.30551, 0.0462958, -0.0472261, -0.115214, -0.0242629, -0.187689, -0.0477316, 0.0981997, -0.0650128, -0.106461, 0.180297, -0.0812029, 0.0141326, 0.0226356, -0.0714812, -0.233007, 0.00105875, 0.00549285, -0.119249, 0.0553767, 0.151171, 0.098281, -0.394686, -0.0589373, 0.0493141, 0.0794659, 0.0958727, 0.186726, 0.0358543, 0.157217, -0.0208647, 0.208318, -0.00744445, 0.104379, -0.275211, 0.174251, -0.0217456, 0.00447155, -0.0236446, 0.114944, 0.0414368, 0.0409627, 0.00971396, 0.0659247, -0.0349181, -0.00628999, -0.143682, 0.101949, -0.268075, 0.0682434, -0.0941211, -0.0700581, -0.0505747, 0.0112001, -0.040995, -0.0358935, -0.139044, -0.124278, -0.120825, -0.389038, -0.169526, 0.0424581, -0.06194, 0.0263984, -0.0322399, 0.00284438, -0.20127, -0.119338, -0.00822789, 0.0411083, 0.193976, -0.0324253, -0.0363668, -0.0228452, 0.0684443, -0.176705, -0.0802598, -0.0683963, -0.256403, 0.166614, 0.0463544, 0.31839, -0.0137506, 0.0583758, -0.0664587, -0.122767, -0.312729, -0.153754, -0.0192847, -0.17656, -0.0142055, 0.210114, -0.245616, 0.227476, 0.0759897, -0.0670805, 0.132835, 0.209072, 0.335211, -0.000437134, -0.0287592, 0.145931, -0.0484606, -0.190209, -0.120921, -0.0331119, -0.0356738, -0.00344663, -0.142565, -0.0770333, -0.378365, 0.0102596, -0.0648355, -0.021867, -0.0642028, 0.00199443, 0.0839945, -0.0798691, -0.196699, 0.261869, -0.261199, -0.0152906, -0.334812, -0.0835349, 0.0917163, 0.107186, 0.0509242, -0.0135164, -0.271431, -0.0521863, -0.134296, 0.0774536, -0.0232956, 0.0998605, -0.537544, -0.00591986, -0.230315, 0.0309681, 0.142491, -0.154507, -0.0895415, 0.0386913, -0.10326, 0.246671, -0.215608, 0.119135, -0.00852734, 0.0117328, -0.0981113, -0.0311549, -0.0824572, 0.0685583, 0.0189845, 0.0304542, 0.0433718, 0.0637142, -0.10426, 0.0798183, -0.717981, -0.42443, -0.0108575, -0.0111989, -0.204891, 0.115575, 0.0594161, 0.111218, -0.0878857, 0.0559656, 0.459512, 0.0938268, 0.0749486, 0.0217323, 0.0512973, -0.089135, 0.0190074, -0.111546, 0.00665524, 0.0238527, -0.02909, 0.213832, -0.153509, 0.380727, -0.00529788, -0.0265024}, {-0.0487652, -0.103966, -0.313944, -0.129672, 0.0236099, 0.202051, -0.208132, 0.00759942, -0.359561, -0.145343, 0.116384, 0.0452664, 0.113607, 0.0824735, 0.28636, 0.248104, 0.072037, 0.287453, -0.167324, 0.00254754, -0.122497, 0.0589913, -0.155444, -0.145846, -0.12646, 0.0772887, -0.257052, -0.0887415, -0.189689, -0.0769422, -0.309231, 0.12941, 0.153024, -0.307332, -0.290902, 0.235725, -0.261411, 0.0769242, -0.162389, -0.130837, -0.175274, 0.0402901, 0.112364, -0.00686819, -0.280675, 0.0148391, -0.101283, 0.120148, 0.139272, 0.0045265, -0.389346, 0.0663492, -0.609298, 0.0391518, 0.0139055, -0.254971, -0.0197721, 0.209106, 0.111153, 0.10705, 0.0576565, -0.141903, 0.118735, -0.115264, 0.106415, 0.216824, -0.106786, -0.00497141, -0.104486, -0.206486, -0.086541, -0.0639871, -0.12244, 0.11913, -0.853989, -0.315047, 0.0636311, 0.0526387, -0.216557, 0.156228, 0.130486, 0.0972959, -0.0622391, 0.184022, 0.405375, 0.294395, 0.114093, -0.0405592, -0.0320267, -0.103819, -0.0762282, -0.424339, -0.00452047, 0.104759, -0.12743, -0.076729, -0.268197, 0.4181, -0.0572207, -0.2383, -0.0935819, -0.0902424, -0.385739, -0.128463, -0.0487607, 0.279292, -0.115564, -0.0969018, -0.0717886, -0.0585731, 0.185389, 0.178055, 0.0105313, 0.223373, 0.246104, 0.464331, 0.0977512, 0.0906907, -0.111102, 0.0241301, -0.0325123, -0.0871367, -0.197606, -0.0647363, -0.132975, -0.0801944, -0.0526944, -0.107436, -0.23447, -0.0508337, -0.189181, 0.00834486, 0.0121075, -0.251695, 0.0087815, 0.337583, -0.186917, 0.0574953, -0.305559, -0.215687, -0.169788, 0.0705312, 0.217544, 0.103973, -0.0994446, 0.118964, -0.116556, 0.10911, 0.0536238, -0.0676119, -0.104092, 0.0380136, -0.834381, -0.0549228, -0.0112122, 0.0637726, -0.0109425, 0.15269, 0.00402116, 0.112417, -0.0222509, -0.0436271, 0.187436, -0.168234, 0.119919, 0.0888334, -0.0951715, -0.358043, 0.0171857, -0.169311, 0.0209735, -0.178182, 0.0648724, -0.0185675, -0.882779, -0.148068, 0.146298, 0.118982, -0.13118, 0.0788449, 0.0479394, 0.148416, 0.0746071, 0.115823, 0.39829, 0.586736, 0.252751, -0.0685569, -0.117694, -0.08511, -0.165004, -0.348837, 0.142896, 0.227337, -0.0186961, 0.0939954, -0.076603, 0.363358, -0.200646, -0.208542, 0.0169477, -0.187965, -0.210307, 0.103245, -0.0109122, 0.219273, 0.198335, -0.148123, 0.315734, -0.157532, 0.123462, 0.120748, 0.0364292, 0.0861795, 0.0566079, 0.405294, 0.222243, -0.104471, -0.180739, 0.122171, -0.203824, -0.123141, -0.172573, -0.0581063, 0.0184594, -0.0887841, 0.0152053, -0.0106593, -0.101717, -0.0761902, -0.129382, 0.0712297, -0.133, -0.179991, 0.12112, 0.0560372, -0.0992998, -0.0145114, -0.18684, -0.414572, -0.0290466, 0.0402363, 0.293196, -0.0516822, -0.0161325, 0.163822, -0.0159318, 0.123844, 0.0465081, 0.137071, 0.0888396, -0.0414205, -0.300464, 0.0597841, 0.0197106, 0.0248021, 0.279971, 0.178985, 0.0778232, 0.0374878, 0.0224525, -0.0614277, -0.0125907, -0.116749, 0.226229, 0.104717, -0.172497, -0.0704628, -0.0570939, -0.0707875, -0.0376913, -0.179983, -0.000784294, -0.128586, -1.253, -0.0379829, -0.0255192, 0.165085, 0.087267, 0.0788774, 0.0871714, 0.0920358, 0.0544183, 0.185434, 0.0775694, 0.454062, 0.259755, -0.0183034, -0.0553598, -0.101726, -0.108865, -0.258494, 0.0253176, 0.0129509, -0.108606, 0.138769, -0.0192719, 0.263816, -0.167317, -0.00874796, -0.0660198, -0.0241686, -0.132444, 0.265888, 0.0544628, -0.206582, -0.0303533, -0.17241, 0.314428, -0.26954, -0.0253072, 2.15773e-05, -0.15021, -0.0410597, -0.0357882, 0.285728, 0.262383, -0.144807, -0.118244, 0.165923, 0.0337411, -0.067118, -0.0558405, 0.0847253, 0.16452, -0.122204, 0.0509536, 0.107929, -0.0901213, -0.0125785, -0.0290394, 0.188785, 0.0408613, -0.0185357, 0.0255877, -0.0596241, 0.0647676, -0.0117009, 0.0243176, -0.196395, -0.0205482, -0.0727528, 0.113466, -0.167434, -0.100921, 0.1109, -0.0937479, -0.018157, -0.0266012, 0.013329, 0.238658, -0.0936161, 0.183356, -0.181381, 0.0572459, -0.00393809, 0.310871, 0.0602655, 0.236815, 0.0640451, 0.0492512, 0.075675, -0.0331234, -0.244399, 0.101065, -0.0378034, 0.194953, -0.223874, -0.080893, -0.137435, 0.224899, -0.0301004, -0.0472261, -0.0884124, -1.21749, 0.0187012, -0.0904975, 0.0693164, 0.442573, 0.101826, 0.188816, 0.266947, 0.0278161, 0.19709, -0.0417618, 0.657735, 0.329395, -0.0150923, -0.0565108, 0.122358, -0.0574612, -0.110544, -0.0131889, 0.0909163, -0.279716, 0.0324552, -0.0542557, 0.0850831, -0.203361, 0.00313836, -0.0780355, 0.00386369, -0.193016, 0.210862, -0.0936057, -0.516824, -0.00980148, -0.181748, 0.0242227, -0.193475, -0.317215, 0.0934024, -0.0272665, -0.142797, 0.110582, 0.110887, 0.128265, -0.00491746, -0.13423, 0.128002, -0.0558616, 0.0536736, 0.0415358, -0.053926, -0.247924, -0.0998574, 0.0326463, -0.0691023, 0.0101145, 0.0409728, 0.165432, 0.108643, 0.041989, 0.155572, 0.148057, -0.0265273, -0.0790087, 0.0564163, 0.0841455, 0.194743, 0.0711968, -0.0345232, 0.0468342, 0.0219148, -0.0258534, -0.0997957, -0.27055, 0.214593, -0.0358271, 0.0134342, 0.225116, 0.0224722, 0.0944416, -0.0783378, -0.027266, -0.0460446, -0.0421007, 0.102059, 0.00744219, -0.00927897, -0.140475, 0.149814, 0.174242, -0.183211, -0.0124821, -0.14945, 0.415075, -0.316925, 0.0433041, -0.271707, 0.00940544, 0.023955, -0.0177719, -0.00279092, -0.782758, 0.0921019, 0.155815, 0.071648, 0.343404, 0.0311283, 0.226935, 0.213131, -0.0094213, 0.07833, 0.025675, 0.448647, 0.205477, 0.00458187, -0.297317, -0.0058884, -0.0342656, 0.195752, 0.0564189, 0.108644, -0.183341, 0.0202051, -0.056133, 0.120789, -0.124845, 0.0647988, -0.0490961, -0.0103487, -0.0858455, 0.10501, -0.00921195, -0.654911, 0.0500101, -0.140659, 0.000982641, -0.0813221, -0.153915, -0.0958495, -0.0105235, 0.0622459, 0.0193462, -0.131113, 0.217852, 0.054844, -0.116008, -0.037687, 0.0871876, -0.0191418, -0.00916818, -0.305857, -0.100936, -0.30679, 0.0303546, -0.0404206, -0.027021, 0.0735658, 0.211722, 0.233786, 0.126705, 0.0305238, 0.0804555, 0.0844921, -0.0676139, 0.134463, 0.211033, 0.407763, 0.027663, -0.18824, -0.00332776, 0.0388714, -0.103907, -0.075367, -0.0486271, -0.0504207, 0.113577, -0.0922173, 0.114633, 0.045055, 0.242855, -0.172009, 0.0312485, 0.155627, 0.134247, 0.295391, 0.065345, 9.78832e-05, -0.186119, 0.160761, 0.106636, 0.0992007, -0.029424, 0.0546435, 0.544645, -0.3968, -0.0193204, -0.267087, 0.126965, -0.0695469, 0.0532535, -0.0703222, -0.454332, 0.111901, 0.147037, 0.14648, 0.514384, -0.036643, 0.257464, 0.19431, 0.0504916, -0.0640265, -0.156849, 0.150645, 0.319143, -0.0461528, -0.200221, 0.0190244, -0.0791573, 0.259316, 0.201646, 0.134105, -0.217942, -0.00392672, 0.142375, 0.0170745, -0.0574059, -0.178405, -0.0208078, -0.233378, 0.126133, 0.155301, -0.0156519, -0.24908, -0.0177294, -0.00233374, 0.116622, -0.0104413, 0.0869135, 0.0737747, 0.140346, -0.0374405, -0.127504, -0.501207, 0.199435, 0.025487, -0.040885, 0.151864, 0.170616, -0.120158, 0.0182994, -0.22171, -0.163234, -0.290669, 0.0264386, -0.0287755, 0.104463, -0.0119373, 0.161046, -0.0762938, 0.157175, 0.121184, 0.17722, 0.040767, -0.189392, -0.0789048, 0.0766869, 0.489054, -0.0554987, -0.0409374, 0.0815744, -0.163968, 0.0373784, -0.0585225, 0.129646, -0.0296346, -0.00383653, -0.0211334, 0.150478, -0.0985558, 0.134588, -0.195025, 0.07827, -0.0766477, 0.0379474, 0.208931, -0.027175, -0.109021, -0.123808, 0.42675, 0.201686, -0.0100566, 0.179788, 0.182848, 0.327424, -0.648795, -0.102986, -0.271731, -0.0622929, -0.0835341, -0.0858177, -0.0894755, -0.576741, 0.0390214, -0.0266045, 0.0291076, 0.321078, -0.0292922, 0.102114, 0.179937, 0.100752, -0.0845347, -0.330496, 0.0572461, 0.225756, 0.0553086, -0.0405027, 0.0124242, 0.0909335, 0.118104, 0.152005, 0.0935858, -0.0385699, 0.0797387, -0.0270395, -0.0251436, -0.0952798, -0.0435245, 0.0294201, -0.263403, 0.0558937, 0.0905237, 0.0178677, -0.0398641, 0.121945, 0.0900856, -0.00191179, 0.0502059, 0.161284, 0.221914, 0.00954063, -0.134281, -0.239287, -0.662576, 0.157988, -0.0182573, -0.200576, 0.0997876, -0.223111, -0.540003, -0.0318352, -0.0750393, 0.0238558, 0.0132384, -0.0852997, -0.0571032, 0.127056, 0.0444881, -0.00356465, 0.0210667, 0.133252, 0.0678886, -0.0443784, 0.00736093, 0.0844199, -0.106713, 0.0153549, 0.627214, 0.0519031, -0.27545, 0.0485581, -0.168111, -0.174079, -0.238742, 0.149987, -0.112102, 0.242892, 0.10683, 0.155938, -0.0755511, -0.0393049, -0.0371017, 0.010203, -0.155345, -0.176155, 0.109623, 0.0582746, 0.0155182, 0.106592, 0.265772, 0.00730356, 0.162173, 0.0690367, -0.0638263, 0.272201, -1.32655, -0.0570038, -0.0920222, -0.141596, 0.0891581, -0.131731, -0.00257232, -0.456188, -0.205888, 0.0466852, 0.00720629, 0.216316, -0.148758, 0.249644, 0.214255, 0.0893464, 0.0646529}, {-0.282575, -0.270123, -0.0799704, -0.00970933, -0.0627947, 0.0865546, 0.0471605, 0.0818274, -0.0751012, 0.27716, -0.204215, -0.0478124, -0.0784072, -0.0699882, -0.162745, -0.127791, 0.00823502, -0.26196, 0.018691, 0.0305762, 0.00306186, 0.0283938, -0.0213753, -0.072157, 0.17784, 0.00191335, -0.0389501, -0.0647165, -0.104202, -0.0466858, -0.204548, -0.48263, 0.129559, -0.0467023, -0.0155969, 0.0738489, -0.184733, -0.427417, 0.19598, -0.180693, 0.213164, -0.206939, -0.218967, -0.12806, 0.0861507, -0.078779, 0.130425, 0.08814, 0.122565, 0.242115, -0.1653, 0.0399581, -0.152845, 0.0466797, 0.0964743, 0.313486, 0.0124059, -0.351661, 0.0689599, -0.0422845, -0.119575, -0.39456, -0.147544, -0.105388, 0.0775473, -0.00250774, -0.160039, -0.126752, -0.103963, -0.26257, -0.04009, -0.0783355, -0.105869, -0.0314892, 0.145458, 0.170126, -0.0612176, 0.0567368, 0.121858, -0.0832706, -0.218746, -0.0111658, 0.224849, -1.29054, -0.224003, 0.00707417, -0.0291019, -0.0138868, -0.0590339, 0.152855, -0.5237, 0.0382578, -0.0603988, 0.137538, 0.156225, -0.188475, 0.0874226, 0.279523, 0.15337, 0.074881, -0.363619, -0.55132, 0.177494, 0.050856, -0.0111699, -0.0345643, 0.0448533, -0.0462113, -0.15051, 0.24194, -0.101119, -0.233599, -0.190922, 0.271819, -0.171769, 0.0070681, -0.0595831, 0.0394408, -0.135485, 0.293113, -0.0953754, 0.321248, -0.00212292, 0.127661, -0.00370678, 0.119003, 0.132521, 0.00149623, -0.0985263, -0.0125575, -0.0016454, -0.404987, 0.0480128, 0.105155, 0.364346, -0.00457548, -0.0230025, -0.615073, 0.293802, -0.163555, -0.0332583, 0.225893, -0.249853, -0.12851, -0.0170634, 0.061201, -0.0575268, 0.205411, 0.0734248, 0.105107, -0.198759, 0.0277961, -0.15705, -0.00132461, 0.0934386, 0.323455, -0.128808, -0.341302, -0.0809006, -0.0365563, 0.115385, -0.041211, -0.313977, -0.0032703, -0.340054, 0.0177135, -0.0662269, -0.0326267, -0.0276661, -0.302202, -0.198042, -0.161958, -0.0593649, -0.380707, 0.0870556, 0.104588, 0.0706182, 0.165615, 0.158455, -0.0351091, -0.137385, -0.102023, 0.26882, -1.26964, -0.101729, 0.0130695, -0.0226855, 0.0755474, -0.274095, -0.114789, -0.567675, 0.110326, -0.116697, 0.141203, 0.156051, -0.184476, -0.0917443, 0.128579, 0.161033, 0.0452397, -0.674045, -0.561978, 0.0691119, 0.0654698, -0.147404, 0.112775, -0.0368066, -0.0447069, -0.150478, 0.24796, -0.129772, -0.105061, 0.0387729, 0.0425597, -0.0294725, -0.0907271, -0.0777436, 0.125318, 0.085024, 0.386911, -0.0317846, 0.252445, 0.0487891, 0.120756, -0.153043, 0.0425997, 0.115486, 0.0461331, 0.0289644, 0.0790493, -0.0155657, -0.419867, 0.114523, -0.0593312, 0.240752, 0.0467001, 0.0484917, -0.578314, 0.356794, -0.0447855, -0.01286, 0.303389, -0.267805, -0.0164981, 0.167804, 1.02285e-05, -0.000434136, 0.126005, 0.058434, 0.116068, -0.169004, 0.112226, 0.10873, -0.0532407, 0.0761656, 0.273282, 0.128304, 0.0342572, -0.00223066, -0.0808446, -0.0774928, -0.103017, -0.207083, 0.12439, -0.29556, 0.150108, -0.14007, 0.0179571, -0.184446, -0.107952, -0.295055, -0.270549, 0.0307702, -0.302963, 0.207668, 0.0987421, 0.244077, 0.240822, 0.115419, -0.0365785, -0.197986, 0.0168571, 0.0625004, -0.946578, 0.141439, 0.283815, 0.28067, -0.140499, -0.453956, 0.0783498, -0.453075, 0.179881, -0.274381, 0.106785, 0.0910611, -0.193079, -0.0377549, -0.294785, 0.226685, 0.231357, -0.848919, -0.487424, 0.411932, 0.0707763, 0.0783683, -0.119489, 0.0642586, 0.0371216, -0.059296, 0.270876, 0.046701, -0.0926567, 0.076767, 0.0989483, -0.0232863, 0.154008, -0.0111303, 0.339459, 0.0689291, 0.627631, 0.152792, 0.135253, 0.189541, -0.0639092, -0.395069, 0.134347, 0.0537871, -0.0363065, 0.0826558, 0.188016, -0.173684, -0.368737, -0.474298, -0.382271, -0.231095, -0.198183, 0.140579, -0.291364, 0.825172, -0.0484173, -0.276358, 0.0934086, -0.673349, -0.0547999, -0.138512, -0.0329444, 0.0182669, 0.430364, 0.309645, 0.0959161, -0.529946, 0.167313, -0.173176, -0.136079, 0.16522, 0.0315051, 0.0876948, -0.181566, 0.130369, -0.207478, 0.129094, 0.0755571, -0.335682, 0.169317, -0.22669, 0.346855, 0.17142, -0.0846075, -0.372631, -0.154396, 0.174384, -0.409085, 0.228392, -0.464586, 0.0920616, 0.281962, -0.0789086, 0.35062, -0.0289413, 0.216099, -0.539245, -0.172113, 0.227776, -0.65472, -0.11177, -0.0494269, -0.0329356, 4.14401e-05, -0.182798, 0.195403, -0.0897184, -0.0106111, 0.0374746, 0.152029, 0.00322594, -0.0456199, 0.0179291, 0.0779884, 0.299851, -0.0033373, -0.132018, -0.0242694, -0.2306, -0.0650021, 0.233836, -0.0750734, -0.12508, 0.142984, 0.276001, 0.0779281, 0.186875, -0.0252053, 0.152169, 0.0067056, 0.193092, 0.020986, 0.0628367, -0.115739, 0.188585, -0.193511, -0.102302, 0.191661, 0.144736, -0.185074, -0.0361637, 0.223602, 0.165738, -0.112947, 0.00632242, -0.0532842, 0.217399, -0.0686884, 0.195531, 0.180449, 0.202298, 0.0704877, -0.0255818, 0.000656339, -0.130574, -0.256346, -0.074194, 0.101628, 0.0787845, -0.20514, 0.199837, 0.0110347, 0.0201874, -0.00204012, -0.0496387, 0.196714, 0.134746, 0.105806, -0.0975627, 0.0198227, -0.111839, -0.121084, -0.106324, -0.041966, 0.060251, 0.202313, 0.111744, -0.0313552, -0.139231, -0.136762, 0.113316, -0.025926, 0.230249, -0.0775622, 0.130634, -0.145505, -0.176715, -0.120919, -0.103659, -0.100045, -0.161867, -0.17664, 0.327987, -0.0123306, 0.194209, -0.0443782, -0.0839319, -0.0607588, -0.0627058, -0.0821215, -0.0856768, -0.0165944, -0.0828685, -0.0338407, -0.0659105, 0.058444, -0.0309006, 0.0342219, -0.0236001, 0.028606, 0.0538974, -0.0215069, 0.000446964, -0.00644804, 0.100537, 0.101153, -0.0621512, -0.00996703, -0.162596, 0.0159266, 0.131159, 0.0377511, -0.0655155, 0.0959678, 0.0102812, 0.0831829, 0.0539513, -0.0782274, 0.0528106, 0.0991292, 0.0396178, -0.0318502, -0.0322336, -0.0344901, -0.0453779, -0.0359655, 0.0427678, 0.0298997, -0.025322, -0.0965202, 0.0326198, 0.132727, 0.070758, -0.0637395, 0.163981, -0.00131175, 0.0480389, -0.0149027, 0.101099, -0.0478191, -0.0383618, 0.05191, 0.0857227, -0.0298911, -0.0398129, -0.088428, -0.0289924, 0.0859397, -0.0339547, -0.129481, -0.0298225, -0.0313272, -0.0248746, -0.00277335, -0.00638767, 0.0893964, 0.109218, 0.0425767, 0.0993478, 0.0156395, 0.0765176, 0.0241179, -0.00569823, -0.0642376, -0.0128346, 0.0123762, 0.0027919, 0.103706, -0.0437574, -0.0709197, 0.107554, -0.0507851, 0.0811402, -0.0394842, -0.0737902, -0.0184126, -0.0527252, -0.082068, -0.0653677, -0.0176444, -0.0753796, -0.101569, 0.0419852, -0.111911, 0.00711031, -0.112825, 0.00946923, -0.0701786, -0.0171525, 0.0547966, 0.0265351, -0.0854452, -0.00595384, -0.0454659, -0.0927195, -0.0427876, -0.0566186, -0.0583579, 0.065812, -0.0219377, 0.0286567, 0.0450188, 0.0218738, -0.0481798, -0.00304002, -0.0237344, -0.0789937, -0.0969177, -0.107129, 0.0560103, 0.0971747, -0.048661, -0.089521, 0.0354816, 0.070015, -0.0519128, -0.0100443, 0.0554392, 0.0163382, 0.0389981, -0.0715023, -0.101436, -0.00765297, 0.0723785, 0.0188286, 0.0151104, -0.068177, 0.0755506, 0.0257979, -0.0443451, -0.0498238, 0.0386791, 0.0505803, 0.0761866, 0.0167831, -0.0312147, 0.095489, 0.0506248, -0.00910494, -0.0420398, 0.10654, 0.0808396, 0.0322306, -0.0475383, -0.0199229, -0.106479, -0.0479963, 0.0326808, -0.0259957, -0.10357, -0.0448503, -0.0763641, 0.030932, -0.0519625, 0.0543562, 0.0137028, 0.0950838, 0.0819924, -0.0385175, -0.0328557, -0.0354668, 0.0435562, -0.00552694, 0.0410229, 0.0397955, 0.0222684, 0.0865997, 0.0327875, -0.0804268, 0.00445995, 0.049682, 0.0191994, -0.0383448, -0.0536903, 0.0321334, 0.0339505, -0.0867086, -0.0620403, 0.0536032, 0.00329115, 0.0757413, -0.067447, 0.0886534, 0.0165903, -0.0191179, -0.0154893, 0.052142, 0.0307854, -0.00599574, 0.0503463, -0.045438, -0.01463, -0.00749139, -0.032136, -0.0191843, -0.0295643, -0.0111969, -0.072836, -0.0817019, 0.104666, -0.0392451, -0.0989379, -0.0327695, -0.0368842, 0.0435774, -0.0137248, -0.0464469, -0.0525186, -0.0901239, 0.030925, -0.0462093, 0.0622386, -0.0735275, -0.107296, 0.0129733, -0.0751188, -0.0448774, -0.0226835, 0.0033435, -0.0179816, -0.0660401, 0.0385547, -0.0483038, -0.02594, 0.0430444, -0.0926896, -0.0791709, 0.0525803, 0.0761315, 0.0371672, -0.0128677, -0.0495796, 0.0492173, -0.0654357, -0.00319065, 0.0516286, 0.111713, -0.0711772, 0.0268177, 0.0102985, 0.0810716, -0.0575148, -0.010569, -0.0676557, 0.0468408, -0.11187, -0.0629857, 0.0935024, -0.0369551, -0.0242826, -0.0202767, -0.0624593, 0.0338558, 0.0307909, -0.000741318, -0.0461193, -0.00464576, 0.0208971, 0.0594303, 0.0458447, -0.050199, -0.053993, 0.0552676, 0.0777111, -0.0806895, 0.0618319, -0.0285543, 0.0448674, 0.0722728, 0.0629606, 0.0386965, -0.0506322, 0.0282152, -0.107009, -0.0506753, 0.00593313, 0.0540205, -0.00515264, -0.0793834, 0.0179713, -0.0267348, 0.0704057, -0.0289993, 0.0801681, 0.0671276, 0.0335188, 0.0213442, -0.0350648, -0.0452966, -0.0698237}, {0.0687666, -0.0293192, -0.0540605, -0.0331521, -0.00497842, -0.0320765, 0.01563, -0.0212957, 0.0394616, 0.0312817, 0.145232, -0.0642722, 0.013977, -0.0417949, 0.077374, -0.0812973, -0.0378202, 0.0424267, -0.0360235, 0.0145482, 0.073258, -0.0342527, 0.0787617, 0.0501098, 0.0818064, -0.101276, 0.145212, -0.0304048, 0.127099, -0.0146166, 0.0397455, 0.142806, -0.0710076, 0.0911993, 0.030384, -0.0851473, -0.0274639, 0.0735554, 0.0189773, -0.0782044, -0.101794, 0.171281, 0.0810752, 0.0117722, -0.0375475, 0.00661491, 0.0541945, 0.0245892, 0.113006, 0.0112753, 0.00946373, 0.0436843, -0.0262312, 0.0207623, -0.0956296, 0.0295593, -0.0386419, 0.0966011, 0.0625454, -0.0306465, -0.00170698, -0.025199, 0.108093, 0.0466627, -0.151978, -0.0538991, 0.0378456, 0.0690609, 0.0874605, 0.0390141, 0.0356629, 0.0379786, -0.139269, -0.030483, -0.0312187, 0.0404968, 0.140517, -0.0522587, -0.0487553, -0.0973328, 0.123252, -0.0728361, -0.0210018, 0.0436899, 0.0751031, -0.10254, -0.0410631, -0.168701, 0.0293372, 0.0118492, 0.0143738, 0.00268293, 0.0720917, -0.0922533, 0.0156199, 0.096474, -0.0580115, 0.0914755, 0.0505841, -0.222678, 0.11961, -0.115512, -0.0424976, -0.0490837, 0.0412457, 0.0202077, 0.00210522, 0.0669271, -0.0489676, 0.0672902, 0.0363567, 0.0608418, 0.107767, -0.0445321, 0.172554, -0.110125, -0.0866831, 0.105004, -0.144056, 0.0283249, 0.0961927, 0.0158919, 0.0671644, -0.0362835, 0.0662986, -0.0281014, 0.180432, -0.0407611, 0.00360532, -0.0657085, 0.23144, 0.127301, 0.0276442, 0.0631544, 0.0183908, -0.13358, -0.0319766, 0.0395219, 0.00575257, 0.0795163, -0.0587037, 0.257994, 0.259368, 0.0728564, 0.0354025, 0.00217984, 0.0228196, 0.0515797, 0.23175, 0.0967521, 0.116384, -0.0235824, -0.0595598, 0.0795658, 0.0191381, 0.00178184, -0.192522, 0.115849, 0.0893045, -0.0197189, 0.179903, -0.047576, 0.0452868, 0.026181, -0.085976, 0.0435753, 0.157047, 0.207322, -0.00657791, 0.00460267, 0.0133083, -0.0704709, -0.0557452, 0.0295671, 0.0205017, 0.0858525, 0.141486, -0.0547109, -0.0957365, -0.11953, -0.0105594, -0.068262, 0.126115, -0.0904895, -0.0158322, -0.0755074, -0.133472, -0.144571, 0.000805076, -0.14443, 0.0818684, -0.0887333, 0.176626, -0.0985942, 0.0907155, 0.159927, 0.0353353, 0.0161759, -0.0310988, -0.236003, 0.161568, -0.106885, -0.107804, -0.0238441, -0.0498231, -0.102092, -0.149141, 0.000227394, -0.100503, 0.18643, 0.0319182, -0.079076, 0.101852, -0.23663, 0.353739, -0.181914, -0.0181143, 0.115762, -0.204206, -0.0628288, -0.116371, -0.053728, -0.24555, 0.137975, 0.149823, -0.11483, -0.0116003, 0.0763168, 0.139534, 0.00580203, 0.107528, 0.0508693, 0.0666196, -0.105556, 0.077283, -0.0552124, 0.189254, 0.211074, 0.114622, 0.236382, -0.0669013, 0.344485, 0.403639, 0.189344, -0.10411, 0.147554, -0.068964, 0.0465772, 0.18749, 0.257939, 0.171837, 0.0180303, -0.0392862, 0.398769, 0.0958534, 0.0889421, -0.0479043, 0.0240354, -0.00121007, -0.0218365, -0.0140397, -0.0280945, 0.0483466, -0.145321, -0.179056, -0.0591908, 0.10501, 0.063466, 0.189072, -0.0068169, 0.116164, -0.167264, -0.127214, 0.0672816, 0.150941, 0.100488, 0.0848719, -0.0587992, -0.125259, -0.044576, -0.102611, -0.0613704, 0.0720092, -0.263165, 0.103893, 0.175105, -0.131043, -0.149838, 0.0432263, 0.0110923, 0.246797, -0.194046, 0.154098, -0.0118249, 0.203547, 0.314159, 0.000884465, 0.23654, -0.103377, -0.0938496, 0.00126085, -0.0947446, -0.275996, 0.115458, -0.00552967, -0.1696, -0.0991574, -0.0107585, -0.169111, 0.195702, 0.0416681, -0.20937, -0.0049186, -0.218856, 0.313083, -0.216219, 0.153043, 0.144418, -0.0337284, 0.0363283, 0.00579257, 0.0179535, -0.230768, 0.0791821, 0.437345, -0.147731, 0.0776462, 0.18577, 0.21154, 0.00928111, 0.18703, 0.145922, 0.0636404, -0.114042, 0.221598, -0.0122359, 0.273166, 0.192705, 0.0992559, 0.200839, -0.172787, 0.264855, 0.317881, 0.176976, -0.223885, 0.340785, 0.0524157, 0.199378, 0.208778, -0.0326199, 0.189265, -0.0169677, -0.105091, 0.390839, -0.00175088, -0.164553, 0.00567256, 0.0100917, -0.00605244, 0.0339231, -0.109193, 0.0310498, 0.13069, -0.364583, -0.249018, 0.0560508, 0.244186, 0.0987372, 0.257913, -0.0986702, 0.117251, -0.398693, -0.266084, 0.281139, 0.125237, 0.13195, 0.234823, -0.176833, -0.121197, 0.0154716, 0.00971757, -0.0356846, 0.0363377, -0.253132, 0.163275, 0.105488, -0.0742473, -0.264828, 0.0380773, -0.0151815, -0.0145991, -0.193092, 0.0806636, 0.158219, 0.386402, 0.361099, -0.0193688, 0.405721, 0.000362482, 0.20469, -0.0612155, 0.341643, -0.359044, 0.0893534, -0.25236, -0.254813, 0.199478, 0.00489229, -0.227522, -0.0225956, -0.314827, 0.0914073, -1.49992, 0.164103, -0.140386, -0.0688543, 0.219928, 0.110346, -0.195216, -0.0156257, 0.191991, 0.304174, 0.390206, 0.313416, -0.221478, 0.0659264, -0.270246, 0.00160783, -0.238753, 0.0434589, -0.133249, -0.0371883, -0.0307041, -0.013268, 0.172268, -0.198879, 0.346814, 0.188919, 0.108673, 0.932476, -0.316214, 0.134546, -0.43987, -0.28695, -0.253117, -0.153845, 0.0514729, 0.12513, 0.0184502, -0.0562763, -0.162315, 0.126553, -0.0214456, 0.330055, 0.189167, -0.123465, -0.0111184, -0.141123, 0.235374, -0.0861923, 0.116608, -0.00967268, -0.408111, -0.255366, -0.0721025, 0.060144, 0.0747251, -0.319403, 0.324997, -0.125132, -0.0565649, 0.0908214, -0.0576954, -0.347767, 0.124913, 0.166073, -0.802453, -0.331554, -0.573694, 0.134999, -0.0431912, -0.0367927, -0.227174, -0.197316, -0.0533714, 0.570737, -0.00198169, 0.164424, 0.466823, -0.00941339, -0.291904, 0.00437502, -0.0391455, -0.184629, 0.37763, 0.0342411, 0.293648, 0.104099, -0.16126, 0.0592314, -0.0399551, 0.213761, -0.36848, 0.0682472, -0.0887136, 0.0251967, 0.0939402, -0.12811, -0.267407, -0.143182, 0.1103, -0.0140149, -1.29447, -0.182081, -0.0351982, -0.122739, -0.0750517, 0.173228, 0.0771324, -0.0671431, 0.161231, 0.154548, 0.331614, 0.271459, 0.0795183, 0.136813, -0.370303, 0.0301991, -0.390982, 0.201992, -0.333372, 0.0534351, 0.0486797, 0.015202, 0.0692723, 0.171111, 0.373119, 0.335114, -0.0398775, 0.56114, -0.115528, 0.0700303, -0.126939, -0.298652, -0.43436, -0.199191, 0.120487, 0.131372, -0.133149, 0.033526, -0.0860614, 0.252634, -0.0356522, 0.0499561, 0.255772, -0.0430527, -0.0565971, 0.136682, 0.167271, 0.326378, -0.0968152, -0.0720298, -0.33204, -0.112188, -0.0800685, 0.0854122, 0.0139837, -0.360814, 0.00257044, 0.031734, -0.0206478, 0.00246249, 0.0231925, -0.451215, -0.192168, 0.0821259, -0.842637, -0.327652, 0.0117033, 0.034134, -0.151534, 0.0512408, 0.0245239, 0.0848401, 0.196094, 0.382254, 0.199815, 0.0788211, -0.00463231, -0.109792, -0.461634, 0.122536, 0.0942861, -0.269315, 0.307639, 0.0625224, -0.0710897, -0.00428712, -0.408789, 0.0461474, 0.16792, 0.467596, -0.387084, -0.051013, -0.103027, -0.194095, -0.114654, -0.334801, -0.110219, -0.0372959, 0.0695006, -0.288416, -0.996158, -0.0918032, -0.0428305, -0.13456, 0.117155, 0.212986, -0.0425454, -0.0999101, 0.194637, 0.114103, 0.100265, 0.190441, 0.163881, -0.173209, -0.334164, -0.0578085, -0.293256, 0.244058, -0.112105, 0.232421, -0.0283291, -0.00250918, 0.187307, 0.168312, 0.352558, 0.227778, -0.130898, 0.389256, 0.0832225, 0.099218, -0.168261, -0.107814, -0.232081, -0.12172, -0.0592982, 0.159129, -0.0684328, -0.0875028, 0.310668, 0.0737621, 0.0803831, 0.0903789, 0.0187539, -0.0922282, 0.234733, 0.0166113, 0.26118, 0.151914, -0.0600341, -0.0530507, -0.227452, -0.0982958, -0.235865, -0.0525433, 0.0485982, -0.15238, 0.121122, 0.0167117, 0.0252847, 0.0168231, 0.0409323, -0.384006, -0.092355, 0.0869546, -0.20773, -0.254806, -0.162427, -0.205685, 0.025489, -0.0548338, -0.118715, -0.0115226, 0.273231, 0.27692, 0.137676, 0.207549, 0.196274, -0.00805873, -0.113461, -0.0665858, 0.00716375, -0.199524, 0.0609631, 0.127691, -0.321713, 0.0241694, -0.0860337, -0.0557288, 0.0917227, 0.595175, -0.516309, -0.0665519, -0.0759663, -0.267854, 0.0110502, -0.202366, 0.081248, 0.00667021, -0.173504, -0.098282, -0.583871, 0.219572, 0.105761, 0.0142753, 0.00257665, 0.0569819, 0.109211, -0.0111078, 0.0213407, 0.0283373, -0.147498, -0.0904318, 0.121652, -0.0292652, -0.291733, -0.0746796, -0.129485, 0.454085, -0.0298052, 0.139096, -0.0492978, -0.0679509, 0.242102, -0.087903, 0.259851, -0.120899, -0.00830219, 0.439009, 0.156782, -0.116571, -0.399613, -0.207079, -0.118004, 0.21166, 0.0371766, 0.083859, -0.0680532, -0.00216602, 0.454734, 0.0969066, 0.12573, 0.00593119, -0.135298, -0.0390851, 0.0645943, -0.083858, 0.111363, 0.0771171, 0.155849, -0.0824677, -0.129567, -0.0236479, -0.157359, 0.0829251, 0.0973365, -0.0873607, 0.0758385, 0.0140513, -0.0739227, -0.0971173, 0.105223, -0.192126, 0.184919, 0.0800382, -0.101587, -0.156886, -0.0667939, 0.0100398, -0.0833165, 0.0927625, -0.0518859, -0.242329}, {0.173556, 0.100207, 0.0896131, 0.552936, 0.0457642, 0.127374, -0.0485673, -0.322834, -0.159066, 0.0462931, 0.179109, 0.214073, -0.084255, 0.0378521, -0.0855285, -0.135925, 0.0621431, 0.403133, -0.684825, 0.186976, -0.0637806, -0.14785, -0.129195, -0.260637, -0.0117183, -0.0333364, -0.064405, -0.0121136, -0.353609, 0.115332, 0.0352981, -0.0319835, 0.158537, 0.231933, 0.0119548, 0.0152456, 0.0327644, 0.18645, -0.343154, -0.0890953, -0.0383373, 0.024037, -0.253279, -0.00395663, 0.169426, 0.55145, -0.206796, 0.152793, 0.0316889, -0.22095, 0.286738, -0.00680303, 0.311806, -0.332226, 0.0349297, 0.355118, 0.100624, -0.0720185, -0.329921, -0.172279, -0.245428, 0.352655, 0.0178423, -0.128799, -0.020033, -0.0422649, 0.316336, 0.165599, 0.152109, 0.0785834, -0.189853, -0.0207585, -0.185699, 0.040739, 0.15299, 0.142144, 0.0777581, 0.000555357, -0.082312, 0.0630874, 0.00609844, 0.227151, 0.0572058, -0.123851, 0.117397, 0.0848943, -0.0871632, -0.241546, -0.00573211, -0.12348, 0.177805, 0.0649031, -0.0453194, -0.0698285, 0.105768, 0.0176581, -0.0729345, 0.102255, -0.0930034, -0.0690561, 0.485215, -0.0136908, 0.139015, 0.583373, 0.032462, 0.149464, 0.0948909, -0.108465, -0.0528043, -0.0867805, -0.0144452, 0.188734, 0.109399, 0.267245, -0.264391, -0.103726, 0.0661675, 0.0352639, -0.266041, 0.0713029, -0.023478, -0.216578, -0.00606256, -0.199293, -0.0373446, 0.127989, 0.1091, 0.00201556, -0.18441, 0.290932, -0.0185908, -0.078114, 0.0483612, 0.0409271, -0.0954313, -0.0272275, -0.0767844, 0.0642084, -0.549439, -0.101485, -0.127426, -0.0457451, -0.214682, 0.0163935, 0.113028, 0.66509, -0.168684, 0.168552, -0.0409111, -0.0543133, 0.317112, 0.0388835, 0.367703, -0.185027, 0.0638073, 0.209322, 0.209969, -0.00663646, -0.0374638, 0.0133062, 0.0238351, 0.318262, 0.0301861, -0.156732, 0.0450163, -0.169744, 0.121618, 0.0793277, 0.047048, -0.0422171, -0.252983, -0.128855, 0.0612571, -0.0305888, 0.049176, 0.133063, 0.0531508, 0.0472516, 0.0185328, 0.0737409, 0.0942635, 0.11914, -0.154825, -0.185018, 0.0235407, 0.223164, -0.108734, -0.0986532, -0.044906, -0.0429037, 0.130224, 0.251113, 0.0775672, -0.0497736, 0.166594, -0.13503, -0.0472913, 0.11128, -0.192162, 0.0793894, 0.35187, 0.0680965, 0.0826006, 0.63135, 0.0749161, 0.0952104, -0.114914, -0.0702776, -0.0441777, 0.0134137, -0.0965982, 0.0135721, -0.0394385, 0.0232243, -0.22873, 0.0304732, 0.010298, 0.000840392, -0.120831, 0.100749, -0.0486759, -0.22941, 0.0105775, -0.357419, 0.00868886, -0.0889396, 0.314653, -0.126758, 0.0834007, 0.215988, -0.119082, -0.0758769, 0.090118, 0.0597261, -0.0970362, -0.0682034, -0.0755455, 0.213785, -0.147261, -0.117513, -0.136084, -0.205972, -0.350113, -0.0360362, -0.0889463, 0.590531, -0.0177828, 0.153594, 0.0350528, -0.0717183, 0.0618195, 0.0340044, 0.167965, -0.23011, -0.177802, 0.119161, -0.0353807, 0.0546301, -0.0703466, -0.129443, 0.0363517, 0.208065, 0.0211012, -0.0707118, 0.08215, -0.108362, -0.134071, 0.0558198, -0.166575, -0.0625479, -0.285337, 0.033064, -0.0868467, -0.1126, 0.0106098, 0.0778214, 0.139329, -0.0485829, -0.161631, -0.115507, -0.120313, 0.151526, 0.0223402, 0.0453564, 0.0338855, 0.11533, -0.150647, -0.0260692, 0.0445961, 0.119171, 0.217679, 0.244961, -0.128693, 0.0289365, 0.0607652, 0.118956, -0.142013, 0.154887, -0.165219, 0.14721, 0.106324, -0.0388166, -0.00402258, 0.448827, 0.100659, -0.0137591, -0.0933982, 0.132381, 0.203706, 0.0777004, -0.00274096, 0.111347, 0.0702228, 0.000588543, -0.253268, -0.0952321, -0.111651, 0.0678375, -0.295006, 0.144933, -0.216423, -0.141466, -0.117611, -0.287817, 0.0749536, -0.0757104, 0.196508, 0.0178252, 0.0809658, -0.0437152, -0.275667, -0.0804505, 0.0672712, -0.0535893, 0.0581882, -0.0947565, 0.055748, 0.127811, 0.0608797, -0.188912, -0.225, 0.0108279, -0.138007, -0.131944, -0.0852221, 0.380329, 0.0174615, -0.0494272, -0.0591628, -0.18153, -0.0784012, 0.0248172, 0.0474841, -0.0375311, -0.146862, -0.102148, -0.26161, 0.149791, 0.0607439, -0.0985985, -0.0830469, 0.147636, 0.134042, 0.224417, 0.159501, -0.0896612, 0.0084269, -0.0870012, -0.15815, -0.0113656, -0.26802, -0.206533, 0.050201, -0.0261568, -0.0895605, 0.0653635, -0.0524415, 0.0275537, -0.196952, 0.0751665, 0.0911675, -0.161763, -0.167031, 0.0850268, -0.0286689, 0.12719, -0.0702892, -0.0923224, -0.032354, 0.133916, 0.14453, -0.137473, -0.210941, -0.13187, -0.00539741, -0.116392, 0.0442845, 0.0252885, -0.139953, 0.20109, -0.275937, 0.0307058, 0.0293339, -0.0194732, 0.120653, 0.106749, -0.0692634, 0.376829, -0.0478497, 0.111502, -0.176359, -0.00394029, 0.184753, -0.0154764, -0.232876, -0.101833, 0.00319894, -0.185773, -0.0331792, 0.0641239, -0.0406148, 0.0232034, -0.635188, -0.378823, 0.155957, -0.120868, 0.147285, 0.118285, 0.167061, 0.124869, -0.233175, 0.0872274, 0.181768, -0.0480083, -0.0340839, -0.0316949, 0.138341, -0.0830589, 0.0902219, -0.019683, 0.0571869, 0.037057, -0.16734, -0.0368433, -0.17766, 0.474255, 0.0542633, 0.0755831, -0.060063, -0.216071, -0.129788, 0.0589038, 0.0297331, 0.0462394, -0.0213083, -0.0865169, -0.196295, -0.0361313, 0.269416, -0.0229666, 0.163641, 0.259166, 0.201107, 0.396327, -0.0813634, 0.0669704, -0.0420146, -0.047487, -0.0777164, -0.0277929, -0.29103, -0.230943, 0.107659, 0.0435769, -0.0926077, 0.122018, -0.168801, -0.0368561, -0.244715, 0.0165896, 0.120936, -0.274078, -0.282742, 0.121567, -0.109742, 0.200516, -0.0992683, -0.0727161, -0.109202, 0.248362, 0.0924323, -0.0794226, -0.073807, 0.00639455, -0.00878161, 0.020199, 0.0265842, 0.0195375, 0.000879031, 0.337006, -0.722002, 0.00780626, -0.0425851, -0.129097, 0.0715256, 0.242292, 0.00618631, 0.15639, 0.13266, 0.0420125, -0.0443078, -0.253648, 0.140564, 0.0634613, -0.108041, 0.0261876, 0.0633481, -0.350982, -0.0979995, -0.0346104, -0.0507054, -0.0639115, -0.794102, -0.154251, 0.247641, -0.114397, 0.0261094, 0.00670504, 0.14025, 0.0664283, -0.0274458, 0.156616, 0.267755, 0.24364, 0.0731697, 0.0283337, 0.0578529, -0.127261, 0.0674649, -0.164487, 0.285966, 0.168758, -0.0530147, -0.131074, -0.103079, 0.43195, -0.0281456, -0.115366, -0.0452531, -0.216226, -0.227155, 0.0462455, 0.113615, 0.0259831, -0.0362885, -0.166167, -0.136836, -0.050518, 0.164107, 0.149467, 0.156825, 0.10447, -0.0119634, 0.378623, 0.0623296, -0.107056, -0.0562446, -0.0950938, -0.0859009, -0.117194, -0.401133, -0.15226, 0.0756841, -0.241439, -0.0699122, -0.0311975, -0.248328, -0.0500993, -0.155174, 0.201788, 0.0928615, -0.477489, -0.200182, 0.152187, -0.0582972, 0.112035, -0.111727, -0.200499, -0.161731, 0.21163, 0.24195, -0.0615409, -0.17285, 0.113598, -0.177993, 0.0975246, 0.0449256, -0.117015, 0.179047, 0.101853, -0.603077, 0.00324037, 0.0194349, -0.18637, 0.0733977, 0.108779, 0.183983, 0.0133752, 0.0453377, 0.0848195, 0.0418191, -0.144875, 0.232327, -0.151129, -0.163433, -0.0753624, -0.00182025, -0.207748, -0.02586, -0.114054, 0.0607086, 0.0582291, -0.850639, 0.0185967, 0.159304, -0.11976, 0.127015, 0.0135555, 0.11494, 0.0837636, 0.168427, 0.15235, 0.264555, 0.259271, 0.237012, 0.0337624, -0.0124553, -0.170923, -0.0565383, -0.151567, 0.301185, 0.250117, -0.106236, 0.0988422, -0.141989, 0.229457, -0.216251, -0.088871, 0.0147964, -0.114478, -0.087198, 0.181744, 0.0119217, -0.012501, -0.0441036, -0.184062, 0.0661867, -0.191389, 0.000906697, 0.104068, 0.034649, -0.0771062, 0.0219365, 0.399127, 0.0406988, 0.0364023, -0.189561, 0.0875558, 0.00394617, -0.117897, -0.131064, 0.0033693, 0.107092, -0.197983, 0.0561837, 0.0575041, -0.188643, 0.0493529, -0.264253, 0.144851, -0.0346449, -0.359606, -0.00817985, -0.166507, -0.0319159, 0.0962819, 0.0525333, -0.289062, -0.15585, 0.134307, -0.0370169, -0.126893, -0.0440859, -0.015936, 0.0875797, -0.139651, 0.113677, -0.128476, 0.325203, -0.0920687, -0.0447949, -0.0890427, 0.0374586, -0.105668, 0.306146, -0.0355169, 0.0319148, 0.106155, 0.0718096, -0.100264, -0.00524319, 0.0193138, 0.300097, -0.167895, -0.0438286, -0.151248, 0.0190372, -0.290229, -0.00527237, -0.0693099, -0.12639, -0.0625334, -1.11255, -0.154754, 0.0165791, -0.0972925, 0.376108, -0.0624387, 0.207837, 0.0737695, 0.120889, 0.059141, 0.13862, 0.407113, 0.140273, 0.0526266, -0.0359925, -0.158959, 0.0291552, -0.0796715, 0.13421, 0.0997342, -0.175508, -0.0255276, -0.0377432, 0.0348419, -0.249936, 0.0104464, 0.0432268, -0.0877123, 0.0387293, 0.406029, -0.081709, -0.0815569, -0.114672, -0.329054, 0.0975074, -0.22789, -0.0593453, 0.0858721, -0.0303044, -0.150072, 0.0708251, 0.189364, 0.240507, 0.215154, -0.0435523, 0.0370696, -0.0521564, 0.121103, 0.0503349, -0.167437, 0.0217864, -0.152611, 0.10792, 0.0689928, -0.0495691, 0.0105585, -0.144878, 0.252739, -0.144258, -0.0699844, 0.122816, -0.13453}, {0.0059877, -0.0109292, 0.0933814, -0.278873, 0.00985373, -0.017055, -0.047091, -0.193406, -0.107125, 0.142585, 0.06715, -0.0562631, -0.20677, -0.0324006, 0.180259, -0.112686, 0.340241, -0.166086, -0.0900325, -0.0817312, 0.346463, 0.101083, 0.112327, 0.139666, 0.0589593, 0.0990652, -0.0179922, 0.0850652, 0.11164, -0.177412, 0.131616, -0.194291, -0.0111101, -0.250672, 0.0488999, 0.0528981, -0.220532, -0.115576, -0.748518, -0.116509, -0.122297, -0.137759, 0.379144, 0.153181, 0.167896, 0.0769296, 0.113055, 0.0817706, 0.322434, 0.480123, 0.280781, -0.0637512, -0.0499033, -0.233105, -0.184777, -0.0953917, -0.0975967, 0.0751279, -0.177622, 0.104662, -0.154471, -0.00275228, -0.266917, 0.178964, -0.0783817, -0.0769586, -0.0155977, 0.174192, 0.117747, -0.312372, -0.0604844, -0.14907, 0.10153, -0.241145, -0.23109, -0.0485824, -0.0172787, -0.149804, 0.0961271, 0.0995457, 0.10825, 0.0961349, -0.0486156, -0.0166222, -0.022722, 0.238089, 0.186956, -0.0505417, -0.164461, -0.238916, 0.117447, 0.0881471, 0.164322, -0.0261221, 0.0920959, 0.254339, -0.0231679, 0.0655619, 0.123836, 0.0357268, -0.08125, -0.167319, 0.0928804, 0.135117, 0.0679176, -0.0894853, -0.0261678, -0.0854187, 0.039776, 0.0475655, 0.0403625, 0.0668565, -0.113767, -0.0362063, 0.142613, -0.00176782, 0.186, -0.242313, 0.0839504, -0.0894592, 0.266724, 0.264297, 0.277581, 0.0461683, 0.0536059, 0.183774, 0.0752272, 0.0206445, 0.00584735, -0.0855507, 0.388226, -0.220194, 0.107429, -0.241962, 0.12172, -0.0128216, -0.0297214, -0.0785716, -0.449222, 0.0635993, -0.0702449, 0.114215, 0.479877, 0.0739014, 0.275824, 0.225807, -0.0663701, 0.121525, 0.0405339, 0.439623, 0.0176462, -0.0907433, -0.155286, -0.0808914, -0.102936, 0.136783, 0.00761621, 0.10829, -0.138575, -0.0778644, -0.0585704, -0.077866, -0.0896519, -0.0374201, -0.0221368, -0.0609053, -0.0976832, 0.206374, 0.0386385, -0.480601, 0.0996298, -0.151604, 0.237887, -0.225564, -0.045454, 0.00563116, 0.0751527, -0.189476, -0.020801, -0.0469598, 0.0271214, 0.00829369, -0.0627419, 0.0485335, 0.0689642, -0.0246554, 0.085102, -0.0619833, -0.0768994, -0.0552786, 0.0838677, 0.0935721, -0.0171484, -0.0106732, -0.315671, 0.142629, 0.0428911, 0.0786091, -0.147403, 0.0659346, 0.0494092, -0.132066, 0.221176, 0.246167, 0.181543, -0.107627, 0.0469603, 0.0309871, -0.0903797, -0.232297, -0.00144174, -0.0864098, -0.14595, 0.06412, 0.089963, -0.0487849, 0.206023, -0.0484275, 0.125114, 0.039942, 0.220396, 0.0850435, 0.143367, 0.151112, 0.0819709, 0.252335, 0.19926, 0.102079, 0.184384, -0.0369052, 0.468917, -0.459688, -0.0466905, -0.112082, 0.0211619, 0.00670727, 0.0869306, -0.0590673, -0.175905, 0.0280027, -0.101078, 0.146962, 0.390653, -0.165869, 0.168129, 0.139589, -0.0691266, 0.0590081, -0.238155, 0.441638, -0.0695962, 0.0547181, -0.107353, 0.0548001, -0.247049, 0.150123, 0.0517237, 0.126235, -0.138138, 0.0119179, 0.0104654, 0.0510833, -0.0941345, -0.003127, -0.0403104, -0.136114, 0.0539109, 0.231516, -0.0684595, -0.195369, 0.0175316, -0.0688603, 0.0295267, -0.193411, 0.112549, 0.0950133, 0.148151, -0.0747797, -0.0419223, -0.171259, 0.0442673, -0.188113, -0.230574, 0.0998485, -0.0649563, -0.329804, 0.0484953, -0.0482057, 0.177353, -0.149673, -0.0600309, -0.0651908, 0.0557448, -0.0499442, -0.472688, 0.247972, -0.0369383, 0.0480233, -0.271127, -0.0750593, 0.0866024, 0.0796168, 0.305214, 0.487652, 0.153084, -0.269939, -0.0154656, -0.224297, -0.214749, -0.146288, -0.129022, -0.0988767, -0.0283634, 0.0234878, 0.156247, -0.0989877, 0.325754, -0.141383, 0.0168419, -0.0223642, 0.187934, 0.0976716, 0.0317369, -0.0368005, 0.100009, 0.128074, 0.0628816, 0.240031, 0.009844, 0.0944441, 0.338681, -0.558079, 0.0685015, -0.257725, 0.0785073, -0.12677, -0.0547166, -0.036323, -0.128883, -0.204633, -0.205406, -0.0433493, 0.267326, -0.0734879, 0.0840252, 0.176762, 0.116596, 0.0908687, -0.366367, 0.0972219, 0.142803, -0.0881773, -0.160509, 0.122635, -0.327134, -0.0151472, -0.0753636, 0.133503, -0.283709, 0.047539, -0.0039403, -0.0339841, 0.0678906, -0.0389235, 0.0260237, -0.348282, 0.147819, 0.316628, -0.046415, -0.00604116, -0.124052, 0.0655898, 0.0402307, -0.148753, 0.121458, 0.0928991, 0.086489, 0.00752266, 0.0265906, -0.370667, 0.171342, -0.0646811, 0.0432151, -0.0629373, -0.190677, -0.576734, 0.0852576, -0.0930006, 0.0731619, -0.182064, 0.0101777, -0.172486, 0.0418486, 0.0731656, -0.37798, 0.233792, -0.025258, 0.0600603, -0.14174, -0.11211, 0.0792398, -0.05989, 0.134257, 0.405845, 0.116813, -0.355114, -0.162545, -0.0516628, -0.121361, -0.34355, -0.0962386, -0.0613123, 0.115846, 0.121381, 0.0721914, -0.0953654, 0.168616, -0.328523, -0.0589595, -0.139959, -0.00861896, 0.0407125, -0.00140459, -0.0539449, -0.00163248, 0.197249, 0.218199, 0.234018, 0.0349918, -0.116524, 0.191166, -1.08302, 0.0675926, -0.107156, 0.00544499, -0.122557, -0.329952, 0.109473, -0.402623, -0.14261, -0.200644, -0.156714, 0.118123, -0.093376, -0.0484803, 0.127416, 0.0419234, 0.330872, -0.167243, -0.238251, 0.0255844, 0.0305981, -0.0286361, 0.00986801, -0.0409233, -0.0510348, -0.00630951, 0.189623, -0.220706, -0.0813059, -0.00651195, -0.0929571, 0.0109116, 0.143294, -0.0247477, -0.115764, 0.0965115, 0.186863, 0.145052, 0.246911, -0.136683, 0.0022071, 0.0149106, -0.0437769, -0.0799877, -0.0968345, -0.162615, -0.0701087, -0.16332, -0.639688, 0.074401, 0.0106939, 0.0488641, 0.00755818, -0.0157682, -0.514751, 0.100196, 0.00894191, -0.0149328, -0.0629147, -0.282082, -0.0740347, -0.00410104, 0.055655, -0.295048, 0.238139, 0.0298229, 0.328075, -0.0717216, -0.309292, 0.141685, -0.0777472, -0.0519556, 0.374519, 0.214782, -0.454805, -0.278197, 0.00271449, -0.103923, -0.283128, -0.311437, -0.094367, 0.0425663, 0.0639731, -0.222665, -0.150091, -0.0326474, -0.339889, 0.0378761, -0.0828285, -0.034288, -0.244619, -0.0812745, -0.0917308, -0.122261, 0.317202, 0.260258, 0.0410375, -0.171326, -0.0721661, 0.0935442, -1.0668, -0.125721, -0.245997, -0.111864, -0.106072, -0.118356, -0.106561, -0.193431, -0.00810349, -0.0861562, -0.172325, -0.0123544, -0.511046, -0.0701927, 0.192288, 0.408429, 0.0642396, -0.281905, -0.260906, -0.00626448, -0.0842863, -0.106578, -0.0696746, 0.108868, -0.0674071, -0.0532984, 0.136499, -0.167536, -0.0209032, -0.164639, -0.0192781, 0.12083, 0.286837, -0.0533482, -0.157024, -0.103254, 0.165892, -0.0232608, 0.308745, -0.0312926, 0.0327144, -0.034854, 0.153813, 0.0553164, -0.0934647, -0.127594, -0.223192, -0.0026947, -0.64937, 0.148361, -0.138081, 0.314477, 0.15627, 0.244435, -0.366592, 0.0732007, 0.00458842, 0.0328769, -0.02651, -0.307961, -0.040614, 0.0979709, 0.0546899, -0.588342, 0.29114, 0.166703, 0.187443, -0.179007, -0.153158, 0.0636696, -0.107914, -0.053641, 0.572272, -0.00618341, -0.507122, -0.368132, 0.0631851, -0.0345534, -0.14418, -0.20191, -0.0541396, 0.194128, -0.0591981, 0.0330028, -0.228253, 0.0406504, -0.187871, -0.115804, -0.209983, -0.0954763, -0.165531, 0.0198333, 0.0398181, -0.0254702, 0.278232, 0.0658829, 0.169077, -0.0793373, -0.00735107, -0.06783, -0.842007, -0.0725999, -0.0266593, 0.132445, 0.00180602, -0.302165, -0.198273, -0.0302166, -0.0576492, 0.0556885, 0.0534405, 0.103748, -0.385667, -0.0805913, 0.110712, -0.0429943, 0.0383266, -0.773867, -0.330875, -0.0414246, 0.0210003, -0.176415, -0.189021, 0.229441, 0.194592, -0.300846, 0.0833348, -0.120792, -0.00974439, -0.10911, -0.207702, 0.0413742, 0.355768, -0.0698322, 0.104344, -0.0215069, 0.0652195, -0.0981777, -0.00259681, -0.0146041, 0.157773, -0.111562, 0.0626452, 0.121087, -0.0938632, -0.164343, -0.213788, 0.0312699, -0.827835, 0.168552, -0.397022, 0.19136, 0.152083, 0.182449, -0.282983, 0.169976, 0.258594, 0.0711862, 0.0691611, -0.249531, 0.221523, -0.0560994, -0.0643172, -0.291466, 0.141707, 0.0710443, 0.0953826, -0.0108177, -0.219357, 0.0955115, -0.0967379, 0.181054, 0.506925, 0.0795255, -0.158942, -0.270637, 0.0179877, -0.166373, -0.0990076, -0.0832908, 0.291201, -0.104905, 0.113875, -0.0957943, -0.316693, 0.00671564, -0.00738293, 0.0163711, -0.359985, -0.119923, 0.174377, 0.175746, 0.186122, -0.019362, 0.430268, 0.0776083, -0.123952, 0.00939926, -0.0243957, 0.172242, -0.463064, -0.0547452, 0.214285, 0.0857347, 0.145601, -0.4612, 0.167213, -0.0503617, -0.0330966, -0.0578645, 0.0478349, 0.00275884, -0.151737, -0.0269956, -0.0810259, -0.0880081, 0.154392, -0.937243, 0.019002, 0.153081, -0.0593986, 0.0227077, 0.0134537, 0.363066, 0.23932, -0.0554325, 0.0729894, -0.125541, 0.128466, -0.117605, 0.0891032, 0.19353, 0.424691, -0.0709259, 0.213182, 0.0541471, 0.194309, 0.13454, -0.428188, 0.0899896, 0.117838, -0.599481, 0.166828, -0.256172, -0.218116, -0.282472, -0.00935696, 0.121152, -1.21639, -0.213063, -0.0522239, -0.187932, 0.0476869}, {-0.10312, 0.0929038, 0.107397, 0.215104, -0.349531, -0.162319, -0.22065, -0.0115759, -0.433192, 0.0304985, 0.182776, 0.479806, -0.0582906, 0.0821376, -0.0992265, -0.143071, -0.0579355, -0.226278, 0.158196, 0.234562, 0.420503, -0.303768, -0.0210939, -0.291231, -0.109245, -0.223876, -0.0851567, 0.298739, -0.132942, 0.123474, -0.246421, -0.510466, -0.129731, 0.293747, 0.00403779, -0.347901, 0.0643304, -0.354853, 0.159978, 0.0543163, 0.176657, 0.50373, 0.28866, -0.0475156, -0.0547292, -0.235103, 0.234039, -0.286935, -0.11083, -0.119088, -0.0991881, -0.0139966, -0.0665818, 0.149247, 0.0510629, -0.133003, -0.00843782, 0.226142, 0.245595, -0.0113826, 0.168719, -0.00347158, 0.178343, -0.0945236, -0.11565, 0.00531927, -0.0876274, -0.0327518, 0.147495, -0.053118, -0.106094, 0.000527516, 0.0735089, -0.0816005, 0.134691, 0.0395982, 0.141907, -0.0103146, 0.13161, 0.128442, -0.0652485, 0.0487547, 0.243799, -0.217612, -0.17874, 0.113358, 0.104271, -0.0965154, -0.0179997, 0.144389, 0.230582, -0.0522172, 0.0303811, 0.0162294, 0.125665, -0.0806244, 0.0209132, 0.18748, 0.12904, -0.0237428, -0.26509, 0.0773169, -0.0948477, -0.110203, -0.155262, 0.0986702, -0.00786694, -0.0117878, 0.176404, 0.0493428, 0.139467, 0.0535082, -0.0206551, 0.0220436, 0.114304, -0.0519841, -0.165516, 0.0312015, -0.0583768, -0.212553, -0.152798, -0.0159226, 0.0313455, 0.0630218, 0.10721, -0.0222811, -0.0140878, -0.113096, 0.208223, 7.01897e-05, 0.156797, -0.144066, 0.128436, -0.0276167, -0.0271502, -0.0495527, 0.00569713, -0.103145, -0.0108161, 0.0209074, 0.205921, 0.021473, 0.144478, -0.0345134, -0.0140324, 0.0527982, -0.0476544, -0.00619776, -0.0164562, -0.0704959, 0.0612225, -0.0766354, -0.0616028, 0.0785556, 0.0541903, 0.0084534, 0.0466323, 0.0761519, 0.0421138, -0.058923, -0.0130657, 0.0852125, 0.0749604, -0.048101, 0.0424159, 0.0687377, -0.0958844, 0.0406881, 0.000693961, 0.0307539, -0.0462549, -0.0293046, 0.00967402, 0.0325785, 0.0187678, 0.00684057, 0.105331, 0.11182, 0.0439549, -0.0606376, 0.0479656, -0.037637, -0.017099, -0.0377014, -0.0188333, 0.111942, -0.0488365, -0.044469, -0.0789082, 0.0350381, 0.00757531, -0.076268, 0.0461624, -0.0425056, 0.108574, -0.0679403, 0.0182019, 0.00911579, 0.0600533, 0.00703861, 0.011174, 0.0634926, 0.0257972, 0.0383035, -0.0705114, -0.0079981, 0.00535473, 0.01001, 0.0189668, -0.0805393, 0.0242765, 0.0608676, -0.0325688, 0.0482042, 0.0300566, 0.00846417, -0.0141109, -0.014463, -0.0194147, 0.0284713, 0.0675878, -0.0414449, 0.0280593, -0.0329686, 0.0402446, -0.0206366, 0.0347965, 0.0268063, 0.0376566, -0.0743063, 0.109821, 0.0826645, -0.0118893, -0.0488816, -0.0462244, 0.0607681, -0.0356766, 0.0354972, -0.0824077, -0.0670919, 0.0400118, 0.019441, 0.0487561, -0.0497866, -0.0975853, -0.0953344, 0.0229341, 0.0608658, -0.0603824, -0.073096, -0.0122366, 0.0665254, -0.0595735, 0.038429, 0.0799235, 0.0506724, 0.00849911, 0.0317078, 0.0892685, -0.0296267, -0.101119, 0.0327641, 0.0286186, -0.090258, -0.0331315, -0.0713365, 0.0331085, -0.0243891, 0.0257264, -0.0321786, -0.0799717, -0.0836705, 0.00816204, 0.0554137, 0.089132, -0.0249142, 0.0309978, -0.0662915, 0.0420067, -0.048067, 0.0806015, -0.0291281, 0.0126756, -0.0932158, 0.0603439, 0.00317957, -0.00389524, -0.0569189, 0.0426138, 0.0789285, -0.0177051, 0.0375993, 0.0795794, -0.0504519, 0.0403604, 0.0585658, 0.000685578, 0.0150069, 0.0537659, -0.0718379, -0.0219743, -0.0365441, 0.037238, -0.099087, 0.0773571, 0.031945, 0.0123033, 0.00684083, -0.0364679, -0.0696714, 0.0573101, -0.0463829, 0.0694887, 0.0839262, -0.0469183, -0.0360034, 0.017306, 0.0739304, -0.0444168, -0.0316844, 0.0704525, -0.0236244, -0.0255253, -0.0528246, -0.0227801, 0.0656871, -0.0145472, 0.0494736, 0.0212014, -0.00929922, 0.0148312, -0.00785453, 0.0868193, 0.0288385, -0.0314015, -0.0520118, 0.0252749, -0.0271021, -0.0287154, -0.0117387, -0.011181, 0.0667723, 0.0613787, -0.0125553, -0.0615429, 0.0120718, 0.0086848, -0.0738707, 0.0035825, -0.0213003, -0.0453549, -0.0202524, -0.0153764, 0.0797256, -0.056002, -0.0301788, -0.0371614, 0.0769688, 0.0222555, -0.0744324, 0.0129799, -0.0765585, -0.0305047, -0.0769518, -0.051003, 0.0260487, -0.0973039, 0.01557, -0.0250522, 0.021187, 0.0590589, -0.0833557, 0.00274124, -0.0244395, 0.00613267, -0.0634792, -0.0404064, 0.0669224, 0.0530119, -0.0880902, -0.00889834, -0.071557, 0.0800183, 0.0461999, 0.068195, 0.0161646, -0.0561949, -0.010151, -0.00175106, -0.0189437, -0.0458546, 0.07648, 0.0317919, -0.0170072, -0.0368734, 0.038642, -0.0303011, -0.0247705, 0.0792126, -0.02681, -0.0495484, 0.0708646, 0.0655081, -0.0552659, 0.076503, -0.039031, -0.0336524, -0.0410911, 0.0795978, -0.0604141, -0.0269798, -0.0678306, 0.0149463, -0.0350809, 0.0723367, 0.0250522, -0.0672553, -0.0507759, 0.0458882, 0.0168101, -0.03137, 0.0819845, 0.0319319, 0.0540656, -0.019285, 0.0435581, 0.0476335, -0.0727715, -0.0698255, -0.0244131, -0.0382467, 0.000433702, -0.0103156, -0.0323572, 0.0580582, -0.0173359, 0.0315533, -0.0558346, 0.004456, 0.0544535, -0.0403643, -0.0181295, -0.059969, 0.0321624, -0.00929883, -0.0796988, -0.0583965, -0.0172033, 0.0906098, -0.154311, 0.0503113, -0.0743201, 0.0511539, 0.00588683, 0.0226377, 0.0886707, -0.012415, 0.100717, -0.000134847, -0.0539255, 0.108945, -0.0278436, 0.131529, -0.115977, -0.0827781, 0.0728256, -0.0363628, -0.0236793, 0.0193418, 0.0376463, 0.0302436, -0.038835, 0.169232, -0.0883638, 0.15173, -0.0754592, -0.0240277, -0.0255801, 0.0241758, 0.103657, -0.0178297, -0.000961581, 0.110495, -0.0676782, 0.0542261, 0.0818163, 0.0351859, -0.0756895, -0.112523, 0.156717, 0.160537, 0.0689992, -0.023897, -0.0201601, -0.0584012, 0.0241101, 0.152727, 0.133838, 0.0909211, -0.0619159, -0.0795002, 0.0807557, 0.0211767, -0.0695905, -0.046632, 0.0277797, 0.0991072, 0.075492, 0.152218, 0.01776, 0.0564897, -0.06935, -0.0932565, 0.0275714, 0.0379509, 0.239238, -0.00750818, 0.0929708, 0.0236249, -0.0734735, -0.0622542, 0.0369696, 0.0532869, 0.0780551, 0.000987742, -0.117723, -0.050226, -0.0393141, 0.0502626, -0.0573194, 0.0384064, -0.0256083, 0.051767, -0.105813, -0.0227097, -0.242552, 0.00203597, -0.0371379, -0.0378943, -0.0512196, 0.0936904, 0.0694649, -0.0208413, 0.13985, 0.0474095, -0.00857254, 0.0428251, -0.121259, 0.10365, -0.128334, 0.0319505, -0.0570549, 0.109174, 0.021353, -0.0118124, 0.118752, 0.023285, 0.0417349, -0.0313012, 0.0311482, 0.0447513, -0.0373883, 0.249687, -0.1858, -0.0951279, 0.0753688, -0.141926, -0.0102613, 0.0344135, 0.0602497, 0.0283816, 0.0667678, 0.192855, -0.0399991, 0.0892927, -0.0455888, 0.0495277, -0.0966916, 0.10474, 0.0611005, -0.00350361, 0.030072, 0.0735687, -0.160535, -0.00793585, -0.0123783, 0.0501926, 0.00140477, -0.121521, 0.277178, 0.124068, 0.0265569, -0.0438233, 0.0650203, 0.114439, -0.0956737, 0.241641, 0.167852, 0.0135884, -0.0770043, -0.0225018, 0.195228, -0.00715737, -0.0141283, -0.0744726, 0.0521865, -0.0379378, 0.010677, -0.00453618, 0.0138484, 0.179455, 0.0100359, -0.130854, 0.00506216, 0.0768383, 0.126317, 0.130167, -0.0180057, -0.0523058, 0.00619481, 0.00399882, -0.0356207, 0.0976371, 0.188682, 0.138455, -0.00999863, -0.0577103, -0.144994, -0.0362928, -0.157282, -0.0316396, -0.0276215, 0.0728422, -0.0316507, -0.120521, -0.243507, -0.0472157, -0.169239, 0.0519887, -0.173875, 0.0323093, 0.0558718, -0.0254838, 0.167574, -0.0430289, 0.0221984, 0.0382426, -0.109463, 0.188237, -0.120544, -0.0803505, -0.198863, -0.00959863, -0.0391702, -0.151064, 0.141088, -0.0155294, 0.18126, -0.0743499, -0.0433557, 0.010336, -0.134912, 0.217222, -0.272846, 0.0970087, 0.102802, -0.15345, -0.0754811, -0.104117, 0.0250518, -0.187121, 0.152766, 0.24539, -0.18069, 0.00117832, 0.0871256, 0.215918, -0.042208, 0.0373315, -0.000235096, -0.0395469, -0.0231782, 0.130807, -0.184516, -0.0139127, 0.0399213, 0.0846978, -0.0259671, -0.0846885, 0.267518, 0.226667, 0.198333, -0.0888584, 0.0542668, -0.0728924, -0.0319317, 0.149961, 0.323403, 0.0660174, 0.0184425, 0.0692311, 0.29248, -0.0198537, 0.0277093, 0.0426098, -0.0924469, -0.0747449, -0.0346027, -0.0495379, 0.0765458, -0.0153629, -0.0741314, -0.285732, 0.0128879, 0.144838, 0.0307363, 0.221505, -0.00957149, 0.141698, -0.0857509, -0.084609, -0.00873729, 0.136199, 0.145237, 0.234079, 0.030409, -0.146784, -0.0384334, -0.0257921, -0.0984167, -0.0483605, -0.107716, 0.160432, 0.283373, -0.126552, -0.242484, 0.110523, -0.0449553, 0.189086, -0.12106, 0.19721, 0.0325383, 0.132538, 0.264653, -0.0153489, 0.0719921, 0.024343, 0.109284, 0.226186, -0.135113, -0.222856, -0.0180955, 0.0383411, -0.112802, -0.140743, -0.107251, -0.183122, 0.22509, -0.00467276, -0.0866778, -0.0406004, -0.237007, 0.412062, -0.421549, 0.208385, 0.132953, -0.269688, -0.0222849, -0.0301371, 0.159923, -0.195396, 0.199632, 0.322092, -0.119636, 0.0676897, 0.132306, 0.294231, -0.201388, 0.158987, -0.0808352, -0.051664, -0.0913713, 0.201578, -0.183543}, {0.0979326, 0.116147, 0.198772, 0.157603, -0.116741, 0.222374, 0.305592, 0.0414948, -0.209147, 0.190201, 0.0911041, 0.176872, 0.0461711, 0.118454, 0.286305, -0.00367422, -0.146411, 0.454607, 0.00366479, 0.0262809, -0.00344317, -0.0911475, -0.00239333, -0.0263137, -0.0493912, -0.00671126, 0.000521022, -0.322996, -0.375275, 0.179446, 0.10328, 0.179171, 0.223945, -0.177585, 0.126636, -0.312683, -0.128493, 0.207045, -0.0372976, 0.222516, 0.238276, -0.164472, -0.26351, 0.00958505, -0.0135246, -0.0962196, 0.00180766, -0.273818, 0.29276, 0.170192, -0.0348239, -0.349089, -0.113402, 0.0538245, 0.0505354, -0.0761334, 0.226146, 0.183408, 0.411807, 0.418623, -0.00976389, 0.358461, -0.0855129, 0.182852, -0.23274, -0.0408272, -0.22562, 0.0660106, -0.228855, -0.197663, 0.345717, 0.172279, -0.187811, 0.0331587, 0.0287336, 0.0821121, -1.22815, 0.151152, -0.19145, 0.181289, 0.187991, 0.161208, -0.256629, 0.0674268, 0.0166996, 0.231704, -0.0130516, 0.192231, -0.157688, -0.103763, -0.373894, 0.0288871, -0.16273, -0.14422, -0.14272, -0.101309, -0.0131195, -0.117679, 0.144879, -0.103103, 0.292389, 0.174144, 0.0491218, 0.738946, -0.00168642, 0.531037, -0.397222, -0.412676, -0.135402, 0.0837163, 0.190663, 0.246408, -0.311893, -0.0249719, -0.280908, 0.277994, 0.0738039, 0.315448, 0.160122, -0.319029, 0.0425815, -0.51024, 0.0298633, -0.112042, -0.0733349, -0.0751307, -0.413298, -0.0439125, 0.130881, 0.0335662, 0.0283002, -0.284686, -0.0991915, -0.12408, -0.425333, -0.251726, 0.0980215, -0.67873, 0.202366, 0.0983068, -0.815391, 0.00797501, -0.512695, -0.255036, 0.0678426, -0.0739839, -0.382907, -0.0941516, -0.230773, 0.50049, 0.179454, -0.215797, 0.0686362, 0.0957583, -0.517, 0.243976, -0.015514, -0.132164, 0.525712, 0.316475, 0.246109, -0.0259461, -0.491447, 0.200787, 0.00118998, 0.177642, -0.355554, -0.156475, -0.135102, -0.00363745, 0.13888, -0.171562, -0.0318743, -0.042773, -0.0372456, -0.0770639, -0.956372, -0.114664, -0.00339746, -0.0355176, 0.0436962, 0.214044, -0.26128, -0.0561628, -0.0144734, 0.0889315, 0.0178976, -0.0321827, -0.0755063, -0.0245834, -0.28997, 0.216733, -0.37033, 0.0596384, -0.174059, 0.114766, -0.0431458, -0.112159, 0.187365, -0.00918604, 0.419465, 0.283543, 0.0621869, 0.654976, 0.0303514, -0.0490511, -0.30098, -0.161088, 0.114405, 0.0583265, -0.0246481, 0.153078, -0.190851, -0.0491957, 0.0929512, 0.181787, 0.0313449, -0.0993492, 0.0330033, -0.2396, 0.292764, -0.148629, 0.178667, 0.171022, 0.24698, 0.0181608, -0.753089, -0.233136, -0.338182, -0.0729948, 0.188374, -0.2618, -0.0132839, -0.127374, -0.167408, -0.0856315, 0.0091774, -0.964165, -0.0149942, 0.155113, -0.691253, -0.219309, -0.229679, 0.0236546, 0.0857058, -0.123926, -0.146313, -0.020872, 0.135108, 0.411335, 0.125493, 0.0885669, 0.198717, -0.117383, -0.222534, 0.0790404, -0.114776, 0.0957657, 0.212586, 0.243466, 0.334926, 0.197156, -0.362071, -0.131196, 0.0738124, 0.404322, -0.388198, 0.0125072, 0.0170569, -0.217961, 0.239287, -0.40555, 0.107619, -0.151431, -0.13931, -0.0657362, -1.464, 0.0855461, -0.150353, -0.00675805, 0.170764, 0.125557, -0.0794997, 0.0617502, 0.334022, 0.0222152, -0.136188, 0.302064, 0.0645265, -0.144866, -0.406851, 0.139714, -0.120901, 0.343991, -0.0326335, -0.00685938, 0.0178103, -0.0940086, 0.263607, 0.132339, 0.542312, 0.419897, -0.176089, 0.216647, -0.0720719, -0.300576, -0.316334, 0.033938, -0.197342, -0.0837147, -0.102388, 0.0437299, 0.0872829, -0.0763212, 0.365231, 0.262991, 0.139659, -0.148176, -0.0169747, -0.318031, 0.291921, -0.0994567, 0.0168705, 0.0769458, -0.0347105, -0.00489582, -0.555036, -0.0855829, -0.0571279, 0.109028, 0.159168, -0.0922212, 0.120363, 0.011096, -0.0351399, -0.0869904, 0.1286, -0.589264, -0.240913, 0.116914, -0.741685, -0.167652, -0.108704, -0.28542, -0.17725, -0.0474708, 0.0292664, 0.0516613, 0.267066, 0.447177, 0.100131, 0.279267, 0.275415, -0.0605351, -0.0961813, -0.0917631, -0.188375, -0.223818, 0.0432178, 0.164777, -0.00754978, -0.0150019, -0.304895, -0.0748661, -0.155027, 0.40076, -0.491209, -0.0536395, 0.0529844, -0.277072, 0.158928, -0.328541, -0.0441008, -0.211708, -0.136351, -0.138109, -0.973607, 0.268717, -0.0417808, 0.0342086, 0.077733, 0.091706, 0.0376278, 0.0294814, 0.0932256, 0.268134, -0.135735, 0.0183073, 0.178864, 0.0381696, -0.278794, -0.0601353, 0.0677316, 0.617145, -0.0840815, 0.108497, -0.0200771, -0.0104547, 0.210603, -0.0990731, 0.365086, 0.109585, -0.0539866, 0.378144, -0.0662139, -0.296926, -0.496792, -0.0998202, -0.129814, -0.0154333, 0.154874, 0.153184, 0.338033, -0.0271025, 0.424391, 0.162219, 0.117136, 0.131435, -0.191029, -0.0205494, -0.0552304, 0.0611687, 0.243543, 0.0759387, 0.113534, 0.00189547, -0.258501, 0.0661866, 0.0316435, 0.235448, 0.150552, -0.0790978, 0.19825, -0.0164424, 0.0687111, -0.0144748, 0.0232865, -0.376955, -0.0913801, -0.0163282, -0.440349, -0.0583602, -0.0806756, 0.00430019, -0.272997, 0.188533, 0.126512, 0.00270629, 0.475557, -0.0304393, 0.146988, 0.577362, 0.135969, -0.0309826, -0.0734924, -0.0725309, -0.102038, -0.212729, 0.123752, 0.0791395, -0.242197, -0.0467982, -0.211489, -0.129562, -0.0773403, 0.232237, -0.54778, 0.00165678, -0.116532, -0.276822, 0.10688, -0.15831, -0.0448592, 0.0179278, -0.149876, -0.00530714, -0.648334, 0.103843, -0.112019, 0.0288373, -0.0373081, -0.00203567, 0.00159827, 0.0290155, 0.218484, 0.0825912, -0.376366, -0.0847999, 0.00240067, -0.0528853, -0.461324, -0.070345, 0.250147, 0.513721, -0.132444, 0.0453409, 0.0225508, -0.0588371, 0.0438405, -0.0536317, 0.261305, -0.27577, 0.0269024, 0.348429, 0.0043351, 0.00997419, -0.379152, -0.197259, -0.291766, 0.190093, 0.0478553, -0.14459, 0.243858, -0.320171, 0.297176, 0.00880142, 0.19397, -0.0653612, -0.446576, 0.0230977, -0.120163, 0.111809, 0.023113, 0.268887, 0.0478979, 0.031158, -0.0713816, 0.149595, 0.145452, 0.25132, 0.0880033, -0.0331666, 0.110923, 0.231446, 0.139001, 0.0199261, 0.039703, -0.379546, -0.0575917, -0.0329802, -0.18536, -0.104087, 0.00420334, 0.039252, -0.0369322, 0.0397449, 0.0361798, 0.103539, 0.42003, -0.113107, 0.16825, 0.622451, -0.185823, -0.00153303, -0.0968562, -0.217936, 0.135572, -0.165644, 0.00304094, -0.0364801, -0.00780587, 0.00812116, -0.240484, -0.102484, 0.0722406, 0.137717, -0.570927, -0.0397405, -0.000343448, -0.202933, 0.173015, -0.103071, 0.00930726, 0.0585075, -0.0243758, 0.0682915, -0.642413, 0.110713, 0.166003, -0.292529, 0.133011, -0.136697, -0.0783723, -0.0429832, 0.0370825, 0.00119305, -0.436002, -0.219941, -0.0389286, -0.194016, -0.334502, -0.00564003, 0.217866, 0.513781, -0.17224, 0.0689602, 0.0459055, -0.0805835, 0.0087839, 0.0946869, 0.375714, -0.17672, -0.108516, 0.336861, 0.168599, -0.0107592, -0.338664, -0.0167517, -0.194416, 0.334062, 0.0808901, 0.000865967, 0.184816, -0.153378, 0.110138, 0.149462, 0.152809, -0.166344, -0.412402, -0.0453103, 0.164237, 0.22517, -0.0225826, 0.299434, 0.0244691, -0.00699338, -0.00836709, 0.138257, 0.0138217, 0.0500241, -0.0644934, -0.120829, 0.110538, 0.280121, 0.0127148, -0.0472527, -0.0452452, -0.292675, 0.124897, 0.17313, -0.081517, -0.0746464, 0.0621538, -0.22522, -0.269587, 0.0128344, 0.0431688, 0.252192, 0.269613, -0.000276514, 0.0635455, 0.756036, -0.0089137, -0.00922986, -0.152551, -0.141191, 0.0921538, -0.0411932, -0.102899, -0.143091, 0.0106627, 0.00460284, -0.0909634, -0.13269, -0.0909841, 0.0213412, -0.565549, 0.0594308, 0.0181992, -0.148514, 0.0438782, -0.195892, -0.0758343, -0.148544, 0.152642, -0.213502, -0.193746, 0.153724, 0.196372, -0.120571, 0.163946, -0.0421961, 0.148938, 0.0221801, -0.0042935, 0.155311, -0.205387, -0.280787, -0.224419, -0.156061, -0.529443, 0.152132, -0.094699, 0.508641, -0.0176601, -0.00437876, -0.0241772, -0.137927, -0.0705712, 0.243585, 0.365711, -0.271954, -0.163308, 0.0934549, 0.115161, 0.069882, -0.337387, 0.00398774, -0.211708, 0.514806, 0.151448, -0.0615586, 0.13507, -0.032419, -0.0104042, 0.0526271, -0.0308931, -0.159088, -0.238287, 0.00448408, 0.0415072, 0.0545456, 0.0586923, 0.202777, 0.0418777, -0.0405966, -0.0168965, 0.0810443, 0.0597955, 0.0403771, 0.127309, -0.0392392, 0.152684, 0.0829449, -0.249037, 0.0319402, 0.0632639, 0.142354, 0.122273, 0.0846599, -0.100391, -0.100942, 0.0902253, 0.113317, -0.336056, 0.0370344, 0.0778174, 0.0768732, -0.154738, 0.0121869, -0.0683486, 0.749354, 0.154712, 0.0627462, 0.135574, 0.150613, -0.0514485, 0.029911, -0.148868, 0.162871, 0.161771, 0.120944, -0.127917, -0.0745666, -0.208133, 0.0193344, -0.409243, -0.0266309, -0.0088399, -0.202292, -0.0491192, -0.169076, 0.031512, 0.0246166, 0.120247, -0.0796635, 0.315927, 0.100094, 0.114655, -0.0238395, 0.105116, -0.147661, 0.13616, 0.0304802}, {0.0904236, 0.179083, 0.0710388, -0.0737301, -0.00619982, -0.121601, -0.177084, 0.091466, -0.0771182, 0.393477, -0.0151826, 0.0314095, -0.0195422, -0.281556, -0.278303, 0.0842638, 0.078274, -0.023242, -0.130427, -0.160985, -0.129333, -0.130046, -0.376273, 0.0924527, 0.0119161, 0.267436, 0.13587, 0.175364, -0.0681985, -0.155957, 0.0256498, -0.0404182, -0.160328, -0.107589, -0.474358, -0.233611, -0.0342789, 0.11884, -0.159187, 0.0297454, -0.0233987, 0.0201865, -0.16453, 0.190988, 0.0158088, -0.0957078, 0.0682097, 0.0319928, 0.0714883, 0.0110527, 0.00765738, 0.0858561, -0.108292, 0.275683, 0.158359, 0.190626, -0.120621, -0.118999, 0.0893388, 0.145444, -0.0501492, 0.0900831, 0.177114, 0.0446728, -0.623799, 0.017515, -0.054527, 0.487436, -0.0169027, 0.146666, 0.0581467, 0.231454, 0.074821, -0.0339383, -0.143793, 0.263224, 0.115791, 0.0908987, 0.0459459, -0.11166, -0.0745664, -0.279657, -0.238766, 0.0178284, 0.121483, -0.0585598, -0.341935, 0.00243465, -0.0854479, 0.0697423, 0.118317, 0.246011, 0.258759, -0.0132987, -0.128026, 0.13374, 0.197295, -0.0864567, -0.00941778, -0.00364272, -0.129307, 0.0692527, -0.0298619, -0.18684, -0.00359831, 0.134807, -0.134644, -0.044488, -0.193563, 0.419561, -0.017159, 0.0768359, 0.0204195, -0.283945, -0.358664, 0.185612, 0.230676, 0.0432915, 0.0336072, -0.197938, -0.161536, -0.114194, -0.167331, 0.201677, 0.0309727, 0.27041, 0.178865, 0.305945, -0.0848845, -0.0196833, -0.162539, 0.0123556, -0.218098, 0.0693255, -0.599417, -0.107308, 0.162133, 0.00333413, -0.25863, 0.0484772, -0.295378, -0.0509287, -0.257073, 0.201984, 0.102813, -0.232797, -0.176584, 0.110603, -0.0491753, -0.0211122, -0.129283, -0.0344557, -0.0780751, 0.21012, 0.137786, -0.15793, -0.055256, -0.106721, 0.0477984, 0.0391996, -0.0340889, 0.00659124, 0.257745, 0.151486, -0.694772, 0.045513, -0.134997, 0.0404725, -0.0378749, 0.0841855, 0.122707, 0.0788041, 0.165467, -0.171141, -0.183129, -0.0172944, 0.0374452, 0.128639, -0.0249813, -0.096577, 0.047671, -0.334523, -0.185212, -0.142985, 0.0807793, 0.153646, -0.641484, -0.0585371, 0.0736012, 0.0575526, 0.270422, 0.138216, 0.300369, 0.0925115, -0.00149563, 0.209931, 0.300265, 0.127011, 0.154384, -0.0812803, -0.28213, -0.0722122, 0.0807023, -0.188999, 0.140551, 0.134596, -0.145456, -0.161726, -0.265865, 0.203087, -0.074604, -0.0677492, -0.0594006, -0.113725, -0.410149, 0.220657, 0.0606772, -0.0907938, 0.0129647, -0.0165768, -0.0321385, -0.0188278, -0.209745, 0.0804633, 0.0539138, 0.0531675, 0.0911587, 0.300931, 0.0121708, 0.100734, -0.115574, -0.024021, -0.0602041, -0.0690128, -0.320609, -0.128857, 0.337272, -0.15565, 0.0336125, 0.106002, -0.0753491, -0.0475301, -0.265668, 0.186382, 0.0863985, -0.477478, -0.0438413, 0.232949, -0.256683, -0.045107, -0.120444, -0.0305896, -0.0832966, 0.133041, 0.0712567, -0.115476, 0.153764, 0.110601, 0.254199, 0.277359, 0.134307, -0.0371996, 0.305185, 0.0160461, -0.36888, -0.056248, -0.0184162, -0.00770618, 0.185025, 0.0497449, 0.106797, 0.164612, 0.0637761, 0.0288314, 0.0753892, -0.116041, 0.14035, -0.0177558, 0.00950296, -0.0171126, 0.038603, -0.393572, 0.0865068, -0.0863681, 0.143035, 0.134464, -0.591737, 0.0262398, 0.0858518, 0.0355516, 0.226481, 0.0877229, 0.35655, 0.0482736, 0.00462369, 0.189409, 0.334212, 0.122158, 0.0943538, -0.0162941, -0.131699, -0.297408, -0.0126473, -0.210101, 0.328447, 0.202111, -0.154616, -0.0498433, -0.24749, 0.113058, 0.0733599, 0.0764735, -0.0409613, -0.0501501, -0.2971, 0.373375, 0.0445368, -0.288282, -0.0861177, -0.128509, 0.136532, -0.238342, -0.111832, 0.0611836, 0.140514, 0.085226, 0.000948639, 0.397297, 0.150009, 0.0696985, -0.0424502, 0.0740278, 0.0190376, -0.20147, -0.082645, 0.0797023, 0.0774866, -0.017581, -0.119114, -0.14455, -0.18848, 0.053381, -0.200555, 0.233876, -0.0906805, -0.322022, -0.175291, 0.0387806, -0.0923967, -0.00237157, 0.00276009, -0.0749391, -0.0753971, -0.0145824, 0.00487984, -0.010051, 0.192708, 0.0950159, 0.135673, 0.107062, 0.0516774, 0.0570285, 0.488957, -0.012061, 0.0842165, -0.266863, -0.0786892, -0.277703, 0.0539543, 0.017433, -0.00243867, 0.242345, 0.0504519, -0.0820898, 0.0375054, 0.142009, 0.0966337, 0.0181091, 0.178664, -0.386103, 0.0208147, -0.358891, 0.0532024, 0.116575, -0.08644, 0.10905, -0.58625, -0.0389302, 0.0795091, 0.0717429, 0.464132, 0.265105, 0.314559, -0.0635326, 0.109986, 0.097358, 0.256159, 0.172042, -0.158034, -0.0269309, -0.180449, -0.180866, -0.0254522, -0.294056, 0.163702, 0.0988912, -0.171808, 0.0989255, -0.246831, 0.0530134, 0.151196, 0.248699, 0.0348303, -0.0849309, -0.127824, 0.347319, 0.252291, -0.0867206, -0.101314, -0.142413, 0.0663616, -0.318871, -0.0886072, 0.0683002, 0.0333778, -0.00426752, -0.156656, 0.139049, 0.226306, -0.0576232, 0.013251, 0.0364859, 0.0346568, -0.0830894, 0.082621, -0.18311, -0.0063494, -0.146265, -0.0439248, -0.043782, -0.287557, -0.0257458, -0.633183, 0.264944, -0.156131, -0.153324, -0.070392, 0.0166346, -0.0530644, 0.0307763, 0.183558, -0.309797, 0.0234587, -0.264259, -0.224543, -0.138896, -0.0200852, -0.0220603, -0.154519, -0.00943859, -0.141714, 0.0672625, 0.320363, -0.125713, 0.315067, -0.101665, -0.0994746, -0.211534, 0.131839, 0.168487, 0.0611634, 0.174184, 0.101774, -0.0322618, 0.0822639, 0.0408283, 0.0163444, 0.0237058, 0.264678, -0.295314, 0.0909135, -0.411698, 0.235399, 0.0801974, -0.0632283, -0.0565996, -0.361162, 0.0126504, 0.0848379, -0.0686117, 0.587778, 0.00465552, 0.285399, -0.142839, -0.089387, 0.0872683, 0.341692, 0.274248, 0.0749027, -0.0838122, -0.348936, -0.0627413, -0.0458566, -0.403776, 0.0941513, 0.22377, -0.371231, 0.0591786, -0.206973, -0.00198894, 0.252496, 0.176272, -0.064041, -0.131983, 0.0935528, 0.160478, 0.0486879, -0.26777, 0.0414938, 0.0339149, 0.175263, -0.314216, -0.107607, -0.0259325, 0.0304848, -0.0793268, 0.048604, 0.0637493, 0.127637, -0.268067, 0.039618, 0.0415767, 0.00338124, -0.36758, -0.0942032, 0.00721905, -0.0112796, -0.0718201, -0.152337, 0.0209868, -0.174466, -0.0535438, -0.535994, 0.193856, 0.00430172, -0.0835248, 0.0256838, 0.175436, 0.0017573, 0.0295839, 0.151586, -0.254687, 0.171231, -0.128372, -0.072056, -0.0731861, -0.0131772, -0.0280391, -0.0881245, 0.0431326, -0.240613, -0.113813, 0.185785, -0.0917424, 0.240012, -0.16468, 0.0841233, -0.205428, 0.265385, 0.338366, 0.196949, 0.230708, -0.0152613, -0.0413578, 0.177865, 0.0718154, 0.141208, -0.104547, 0.31785, -0.0965429, -0.0361331, -0.486889, 0.155402, 0.0450883, -0.142192, 0.000549029, -0.252152, 0.150443, -0.0690076, 0.00961736, 0.437304, -0.0950524, -0.0129684, 0.00465956, -0.0223144, 0.0755899, 0.233438, 0.484246, -0.12466, -0.00387963, -0.0809792, -0.0776684, 0.00434574, -0.0867105, -0.0371192, 0.0419084, -0.206195, 0.00782919, 0.0174667, -0.111783, 0.375668, -0.0104485, -0.000959854, 0.019809, 0.0151669, 0.163521, 0.0622604, -0.219212, -0.112065, 0.06411, 0.182025, -0.0933315, 0.100812, -0.118429, 0.00424653, -0.0377933, 0.17052, -0.0421483, 0.119101, -0.041823, -0.101921, 0.0347702, 0.0413296, -0.410972, -0.0404823, 0.103342, -0.0649616, -0.0105181, -0.0888129, 0.024134, -0.0498817, -0.0161957, -0.632861, 0.282041, -0.0738078, -0.0804746, -0.0633814, 0.0893668, 0.114299, 0.079888, 0.143934, -0.122326, 0.0284718, -0.222739, 0.0150637, 0.138389, -0.122704, -0.108213, -0.0769589, -0.185392, -0.281161, -0.0567385, 0.105691, -0.123135, 0.222117, 0.0920192, 0.121116, -0.276826, 0.251738, 0.0533934, 0.0450546, 0.0910546, 0.0125164, -0.0943656, 0.180295, 0.158247, 0.092443, -0.221849, 0.275302, -0.420936, -0.157654, -0.334582, 0.02862, 0.0153417, -0.00873248, 0.0383863, -0.321254, -0.01262, -0.177677, 0.0647239, 0.348015, -0.0681478, 0.049207, -0.0112228, 0.0339063, 0.244855, -0.0203696, 0.426986, 0.0346046, -0.0104717, -0.0580433, -0.0170186, -0.105162, -0.151566, -0.0728322, 0.084836, -0.0935679, -0.0823682, 0.0581035, 0.0614326, 0.181941, 0.111397, -0.0287921, -0.144814, 0.118475, 0.155102, -0.251114, -0.0449088, -0.164834, 0.208847, 0.266332, -0.243375, 0.180691, 0.0538782, 0.0255902, 0.0377061, -0.0170925, -0.376951, 0.0490115, -0.0330633, -0.241263, -0.128989, -0.014909, -0.154243, 0.0435458, -0.0503154, -0.0957246, -0.0804514, -0.187898, -0.00215712, 0.051905, -0.0745234, -0.62966, 0.347502, 0.0412663, 0.120339, -0.0812226, -0.0559155, -0.0223655, -0.048433, 0.0697916, 0.0498925, -0.0674777, -0.24065, 0.176905, -0.00246445, -0.0272668, -0.13657, -0.148387, 0.110272, -0.0620315, -0.0660374, -0.181479, 0.14349, 0.138246, -0.134563, 0.0467561, -0.202511, 0.302584, -0.0735267, 0.0100888, -0.0672215, -0.00184378, 0.0353204, 0.260465, 0.0218995, -0.034418, -0.272515, 0.385871, -0.490526, 0.0420773, -0.0376743, 0.177241, -0.000352022}, {-0.195208, -0.026743, -0.479748, -0.039763, -0.139074, -0.0331113, 0.0746178, -0.214677, 0.0326988, 0.163914, 0.136964, 0.175561, -0.0902752, 0.263587, 0.0706216, -0.00381609, -0.0469355, 0.173896, -0.221084, -0.0436422, -0.303412, 0.0318696, -0.0514211, 0.00409301, -0.00995162, -0.00376566, 0.0385073, 0.191467, 0.00156115, -0.0906181, 0.1783, 0.13083, -0.0594544, -0.0317578, -0.165085, 0.205097, 0.0773191, -0.0601095, 0.140902, 0.146288, -0.108286, 0.00628764, -0.17843, -0.676276, 0.196262, 0.246335, 0.140396, -0.0797113, -0.0911543, -0.174366, 0.193746, -0.0908455, -0.176459, -0.124913, 0.00556086, 0.0356733, 0.155892, -0.0471604, -0.568242, 0.310896, -0.0804972, 0.085113, 0.113288, -0.26232, 0.00633779, 0.00996599, 0.120058, 0.233952, -0.105398, -0.497731, -0.0496024, 0.237194, -0.0280925, 0.00411866, -0.0443859, -0.00460434, -0.0467911, -0.0408334, -0.423885, -0.157515, 0.143353, -0.205602, -0.00811099, -0.135321, 0.0660982, 0.245262, -0.0594448, -0.0358663, -0.194192, 0.109551, 0.222587, 0.145979, -0.270988, -0.182781, 0.221356, -0.640553, 0.0668441, 0.0464541, 0.226832, 0.00389197, -0.269437, -0.0100379, -0.306571, -0.110377, -0.210687, -0.0896992, 0.0167246, -0.22246, -0.0752081, 0.208338, 0.173922, 0.0597172, -0.352234, 0.107162, -0.101686, -0.0235769, 0.0655123, -0.00695867, -0.140219, -0.0719016, -0.232701, 0.0348012, -0.11512, 0.0537342, 0.0998314, 0.000465537, 0.0253061, 0.169106, -0.00652102, -0.00238408, 0.108151, 0.132487, 0.0713937, 0.0311355, 0.0236341, 0.213136, -0.100426, 0.0457269, 0.121054, 0.204781, 0.15616, -0.101856, -0.0257152, -0.422189, 0.246201, -0.000628765, 0.0526378, -0.0223657, 0.0734911, -0.199261, -0.0986389, -0.0693271, 0.00844239, -0.226488, 0.00375783, -0.137439, -0.0520114, 0.0445634, -0.765859, 0.276092, 0.0950754, 0.289956, 0.0813999, -0.187056, 0.178248, -0.128411, 0.276408, 0.269864, -0.0414142, -0.456015, -0.0656615, 0.17794, -0.0474471, -0.0387339, -0.0653352, -0.139275, -0.0790425, 0.00701626, -0.120959, -0.260036, 0.0876086, -0.277309, -0.0321081, -0.443291, -0.154294, -0.0409803, -0.0609573, -0.355652, 0.0722657, 0.114555, 0.250954, 0.202154, -0.314754, -0.206613, 0.173635, -1.0463, -0.113207, -0.00882891, 0.134402, -0.190164, -0.218008, -0.0491059, -0.19573, -0.0869758, -0.192939, -0.0159059, 0.0444116, -0.655699, 0.137268, 0.0483346, 0.423747, 0.167194, -0.481996, 0.0636178, 0.304727, -0.0708386, -0.28992, -0.0519517, -0.0563473, 0.0762575, -0.219856, -0.0808472, -0.31103, -0.06674, -0.0199685, 0.0570341, 0.216161, 0.360676, -0.0575681, 0.0827927, 0.000514004, 0.209698, -0.0997294, 0.158238, -0.070609, 0.111325, 0.0149136, -0.0584979, -0.113327, 0.078465, -0.0530752, -0.546726, 0.298713, -0.908772, 0.204123, -0.086392, -0.0803956, 0.233714, 0.0435517, -0.0397967, -0.150426, 0.099959, 0.0363708, -0.183906, 0.217539, 0.115014, 0.100305, 0.0567078, -0.576536, 0.371839, -0.058129, 0.241883, -0.0471737, -0.119069, 0.12433, -0.216078, 0.0345018, 0.236441, -0.16843, -0.405836, -0.0699459, 0.115862, -0.139949, 0.0621714, 0.0986778, 0.0682604, 0.269876, 0.245828, 0.150002, -0.117493, 0.0292508, -0.314267, 0.0807678, -0.437688, -0.0762834, 0.32702, -0.0792499, -0.0567573, 0.0435498, 0.400269, 0.321182, 0.0959695, -0.041746, -0.117726, 0.134496, -0.703739, -0.310241, 0.187555, 0.19043, 0.116795, -0.0477317, 0.09916, -0.100945, -0.0592503, -0.307836, 0.151595, -0.0131382, -0.496768, 0.0162329, 0.0181509, 0.23691, -0.158532, -1.14702, 0.211545, 0.109975, -0.082297, -0.169221, 0.0837269, 0.238543, 0.36793, -0.0296646, -0.263193, 0.130326, -0.00349595, -0.280551, 0.0077672, -0.0205241, 0.615886, 0.0701884, -0.0680738, 0.122254, 0.149945, -0.163031, 0.0832833, -0.220227, 0.152671, -0.084249, 0.0249266, 0.0713616, -0.162009, -0.166429, -0.458453, 0.532215, -0.901886, 0.310188, 0.110359, 0.121357, 0.228397, -0.019221, -0.23945, -0.0336971, 0.449961, -0.0197324, -0.0287727, 0.293641, 0.0163446, -0.17993, -0.0289153, -0.446636, 0.487797, -0.0639944, 0.122606, -0.179561, -0.311292, 0.0519074, -0.213179, 0.174583, 0.588968, 0.14971, -0.442999, -0.000588214, 0.113814, -0.0646495, -0.111892, -0.0397888, 0.113412, 0.167794, 0.108589, -0.00950218, -0.281726, -0.208316, -0.127, -0.150301, -0.492284, -0.157932, -0.0215281, -0.0196223, -0.140081, 0.107216, 0.368524, 0.259471, 0.00161446, 0.148954, -0.13053, 0.15298, -0.527825, 0.0117424, -0.0533472, -0.190416, 0.12742, -0.159427, 0.405203, -0.0639347, 0.0582042, -0.351134, 0.224244, -0.157542, -0.140301, 0.00150139, -0.00108925, 0.165904, -0.0455361, -0.902007, 0.00345113, -0.172331, 0.0274746, -0.101648, 0.222101, 0.238762, 0.341361, 0.322394, -0.498423, 0.278164, 0.280104, -0.334625, -0.058752, 0.276207, 0.134542, 0.0424551, 0.0442418, 0.202957, -0.180215, 0.0781468, -0.142928, -0.096207, 0.0509526, -0.274065, 0.36371, -0.0816213, -0.0849105, 0.0547234, -0.43683, 0.427341, -0.805432, 0.125423, -0.0891985, 0.195895, 0.290914, -0.190574, 0.160319, -0.181002, 0.412543, -0.153205, 0.100049, -0.0408009, 0.00173235, -0.235142, 0.0411621, -0.199059, 0.298623, -0.208832, 0.324481, -0.0896433, 0.0372126, 0.0579862, -0.247313, 0.18493, 0.492531, 0.369271, -0.417811, 0.0978368, -0.264301, -0.15246, -0.290618, -0.581029, 0.193737, 0.2007, 0.0371752, -0.165819, -0.377543, 0.0747522, 0.160266, -0.45958, -0.500083, 0.256955, -0.281878, 0.0246301, 0.425678, 0.446817, 0.215547, 0.331168, 0.0422081, 0.187636, -0.210541, 0.0971782, -0.327774, 0.00606086, -0.0415834, -0.0899643, 0.0105574, -0.00764602, 0.0907848, 0.000996022, -0.134367, 0.0605182, 0.226987, 0.20935, -0.0945665, 0.172531, 0.0165822, 0.200308, -0.106289, -0.0942863, 0.0107537, -0.0973827, 0.0387575, 0.1725, -0.135879, -0.136507, -0.0324056, 0.145568, -0.0867818, 0.109644, -0.0582677, 0.140532, 0.0508839, 0.0289775, -0.0226931, -0.0419943, -0.0427616, 0.103867, -0.157456, -0.0760317, 0.121276, 0.0478771, -0.0627012, -0.0764092, 0.170739, 0.153383, -0.0884415, 0.0784513, -0.0702796, 0.0337937, 0.000791025, 0.0635323, 0.147129, 0.209196, -0.0191875, -0.101448, 0.148767, -0.00592843, -0.215611, -0.11473, 0.084419, -0.0767352, -0.0171925, 0.199856, 0.0180174, 0.0499414, 0.176048, 0.0212598, 0.0822766, 0.11815, 0.061021, -0.131883, 0.0143452, 0.00124653, -0.153374, -0.198424, -0.0231657, -0.0279377, 0.194634, 0.120898, -0.0228447, -0.0617253, -0.044775, 0.131871, -0.0922578, 0.205093, -0.0284801, 0.0998075, -0.0415649, -0.0576261, -0.0485146, 0.00765896, -0.0984498, -0.118352, 0.0150813, 0.127372, 0.146424, 0.172284, 0.0115278, -0.00713577, -0.0565013, 0.0674589, 0.0378548, -0.0322596, -0.0431543, -0.0235077, -0.0349471, 0.0128616, 0.133513, 0.0138271, 0.00292785, 0.0558648, 0.100319, 0.0833176, -0.0281565, -0.0109266, -0.0143106, 0.13648, 0.0553257, -0.028115, 0.0393386, -0.108354, 0.0287883, 0.0661875, -0.0102011, 0.000775127, -0.00515491, 0.142903, 0.0815667, 0.0639055, -0.0801499, 0.0547951, -0.0621896, 0.127223, 0.0393576, 0.017349, -0.0596881, 0.0400535, 0.0179162, -0.0455906, 0.0768782, 0.0367533, -0.0683806, -0.000476107, 0.198044, 0.164759, -0.0808549, 0.12111, -0.0504287, 0.0352901, -0.125206, -0.0968962, 0.150386, 0.00654124, -0.085222, -0.0179656, -0.085514, -0.0689646, -0.0754346, -0.0782342, 0.0808751, 0.0753062, -0.0789376, 0.0383251, -0.0463194, -0.0339172, 0.0201537, 0.0165912, 0.017491, 0.0296176, 0.0361847, 0.0428842, 0.0467958, 0.0773733, -0.0949104, -0.0463856, -0.0435845, -0.0679204, -0.0209278, -0.0155359, -0.0438882, -0.0436467, -0.0405507, 0.0687736, -0.0452698, 0.101138, 0.0652262, 0.119552, -0.0832065, -0.0314576, 0.0278115, -0.104149, -0.0850137, -0.0248547, -0.0748034, 0.134841, 0.0269507, 0.0266841, 0.0448194, -0.0535887, -0.0858352, 0.0682104, -0.0556701, 0.0362913, -0.0570806, -0.0417677, 0.0574666, -0.0112678, 0.0556619, 0.0538847, 0.0322337, 0.0317926, -0.0320326, -0.0605819, -0.0253628, -0.0967704, 0.0548478, -0.0181923, -0.0145695, -0.0740374, 0.0271172, -0.110081, -0.0708218, 0.0787535, 0.0735333, -0.108664, -0.0217799, -0.0245906, -0.0557074, -0.040878, -0.0614757, 0.0518289, 0.0748516, -0.0497932, -0.101945, 0.0303823, -0.030222, 0.0867171, -0.0188216, -0.0333295, 0.0428105, 0.0937086, -0.0908916, -0.0779707, 0.0508837, 0.00851865, -0.0516187, 0.0875742, 0.00754157, -0.0376733, -0.0408084, 0.0445762, 0.00716344, -0.0366866, 0.0256694, -0.0489586, 0.0156637, 0.00184823, -0.0175133, -0.0361776, 0.0366, 0.0154601, 0.0264283, -0.0520427, -0.0771392, -0.0996473, 0.125947, 0.111571, -0.0414474, 0.0199952, 0.0544405, -0.0590355, 0.0179488, 0.0591267, -0.0267661, -0.0673126, -0.0558634, -0.038174, -0.00711611, -0.0151622, 0.0350239, -0.0389814, -0.0302123, 0.0386563, -0.0657448, 0.00896244, 0.0184048, 0.0474244, -0.0144377, -0.015589, 0.0211984}, {0.0414191, 0.0740356, 0.0283422, 0.0277043, -0.020002, -0.0567209, 0.0731483, -0.0116183, -0.0951734, 0.0109366, -0.00617093, -0.0317161, -0.0692549, -0.0769913, 0.0485949, -0.0601031, 0.0107315, 0.0546436, -0.00122249, 0.0681239, -0.0175626, 0.0526897, 0.0125654, 0.0205521, -0.0134274, 0.0304472, -0.00592896, -0.0762443, 0.0343839, -0.0430606, -0.0143962, -0.0118748, 0.0537834, 0.0459236, -0.0622173, 0.0242851, 0.0621856, -0.0768293, -0.0748453, 0.0708807, -0.00148313, 0.0504991, 0.0395931, 0.04286, 0.0226857, -0.0813514, 0.0909371, 0.0219686, -0.0494777, 0.0939937, -0.0481384, -0.0416861, -0.0840683, 0.0369276, -0.0200331, 0.00723457, -0.0396243, 0.0667611, 0.0071425, 0.0495997, -0.0347376, 0.0404034, 0.014853, -0.0480927, 0.0309426, 0.0175114, 0.0187312, -0.089269, -0.00242709, 0.05727, -0.0347419, 0.0373042, 0.0931458, 0.0343477, -0.0118164, -0.0796223, -0.0116543, -0.0654649, 0.0541465, -0.0378821, -0.0406212, 0.0543706, -0.0709774, -0.0485228, -0.0355628, 0.0541238, 0.0763301, -0.000819096, 0.0467135, 0.00228432, 0.00370285, -0.0512217, -0.0523919, 0.0565678, 0.0484081, -0.0745907, 0.0506419, 0.0501658, 0.028185, 0.0575701, -0.0419321, 0.0394798, 0.0696194, 0.0497174, -0.00465157, -0.0674136, 0.0790613, 0.00769696, 0.0023608, 0.0418321, 0.025247, -0.0077323, 0.0571974, -0.0413091, -0.0331246, -0.0127822, 0.0907344, 0.0170837, -0.0274528, 0.0829752, -0.0338894, 0.0207529, -0.0130094, 0.0246834, 0.093145, -0.0572202, 0.135199, -0.150558, -0.0813219, 0.108134, -0.028351, -0.0420655, 0.157171, 0.0115633, -0.107397, -0.0048907, 0.127387, -0.0818601, 0.233698, -0.161259, 0.119147, -0.0541799, 0.017092, 0.0500054, 0.0304115, 0.0241144, 0.145737, -0.160981, 0.012251, -0.0613524, 0.0226747, 0.00880708, -0.00199088, 0.161675, 0.136145, 0.0992148, 0.0642818, 0.0732789, 0.123085, -0.0273236, 0.201816, 0.0866609, -0.0382713, -0.0173697, 0.0401927, 0.184378, -0.077897, -0.0908404, -0.0105877, 0.112486, -0.11423, 0.0388449, 0.0164045, -0.0627239, 0.0500442, -0.0268505, -0.165774, -0.100146, 0.161074, 0.126942, 0.0475576, -0.0253067, -0.0615975, -0.129023, -0.16104, -0.0042564, 0.0421443, 0.106262, 0.108903, -0.0866916, -0.0184419, 0.0390331, 0.152217, -0.121737, 0.114393, -0.0284622, 0.134718, -0.0281351, 0.0181652, -0.2302, -0.0660124, -0.0450839, 0.0533029, -0.00246366, 0.0566149, -0.027768, -0.0345818, 0.0571543, 0.0582294, -0.00591944, -0.0599757, -0.187447, 0.0596856, -0.0827244, -0.0514469, -0.0125887, 0.0937587, 0.0210932, -0.0643664, 0.100799, 0.0423892, -0.0589196, -0.161227, -0.118968, -0.0119625, 0.0314779, 0.15695, -0.226478, 0.0639225, 0.124812, -0.0597517, -0.0606467, 0.0301378, -0.0503948, -0.106409, 0.167843, 0.265053, -0.0179874, 0.230619, -0.0679571, 0.154539, -0.110913, 0.0934428, 0.111453, 0.0369185, 0.0780538, 0.258483, -0.168688, 0.0736187, -0.104662, 0.104889, 0.00906078, -0.0868507, 0.178147, 0.0675448, 0.0932152, 0.0693163, 0.118998, 0.142785, -0.0470958, 0.0539161, 0.05055, -0.0589224, 0.0627227, 0.194105, 0.227688, -0.0565732, -0.019888, -0.0211988, 0.0622516, -0.126806, -0.0644946, -0.0756539, -0.048173, 0.0216354, 0.0516909, -0.15429, -0.0335005, 0.122621, 0.0473049, 0.0699278, -0.00910747, 0.00189831, -0.0819388, -0.0943278, -0.00206162, 0.073864, 0.109561, 0.0854454, -0.0942227, -0.141417, -0.0277732, 0.0893013, -0.151101, -0.0424655, -0.106801, -0.0195097, 0.13341, 0.00033381, -0.206752, 0.0236286, -0.17673, 0.0964725, -0.0273278, 0.144581, 0.0327099, 0.0531196, 0.101504, 0.049569, 0.0386297, 0.0404452, 0.0271795, 0.196829, -0.166163, -0.104103, -0.0323044, -0.0203303, -0.0231717, -0.00234952, 0.141618, -0.145664, 0.157914, -0.119086, -0.119356, -0.0392184, -0.210421, 0.19778, -0.338272, 0.171353, 0.0124104, -0.176175, 0.0592575, -0.0732795, -0.0565143, -0.201629, 0.221434, 0.194199, -0.0818166, 0.017612, 0.0321508, 0.281508, -0.0814016, 0.130618, -0.0310581, -0.0262663, -0.0849328, 0.287724, -0.172124, -0.0725703, -0.024471, 0.00572927, 0.035933, -0.00911843, 0.298511, 0.20622, 0.125026, -0.109194, 0.180026, -0.0224038, -0.0667798, 0.00358497, 0.0852028, 0.0523975, 0.0711479, 0.114676, 0.365741, 0.0378363, 0.0270031, 0.0558526, -0.214248, -0.106795, -0.0681891, -0.213328, -0.00901204, -0.100414, -0.0464606, -0.139985, 0.0109577, 0.0653505, 0.0355776, 0.242528, 0.10886, 0.00964145, -0.107699, -0.00958848, 0.0990274, 0.0678299, 0.0995304, 0.121539, -0.00537499, -0.0906068, -0.0563518, -0.0814583, -0.196931, -0.0583556, -0.200407, 0.159293, 0.227403, -0.127444, -0.158945, 0.0695588, 0.0409452, 0.125759, -0.177148, 0.0846123, 0.0760803, 0.0675023, 0.203935, -0.102497, 0.0734462, -0.0917423, 0.113098, 0.174101, -0.228336, -0.251692, -0.0651744, -0.0388697, 0.0738028, -0.251318, -0.0615282, -0.0930824, 0.271454, -0.0415934, -0.0829817, -0.00677912, -0.191804, 0.404948, -0.42189, 0.134919, 0.0194258, -0.231547, 0.0468211, -0.147901, 0.144222, -0.32007, 0.224461, 0.34512, -0.0592551, 0.122307, 0.152393, 0.218313, -0.27098, 0.101599, -0.0797364, -0.0468235, -0.111875, 0.328678, -0.271238, -0.00159918, 0.149206, 0.0273978, -0.129608, -0.198569, 0.292336, 0.232513, 0.0714047, -0.165636, 0.201082, 0.0481746, 0.190854, 0.0654141, 0.24461, 0.232888, 0.0479121, 0.0746281, 0.490562, 0.0782427, -0.0253279, -0.0256579, -0.0805916, -0.129653, -0.00368528, -0.137929, 0.0638382, 0.0292015, -0.145, -0.310569, 0.181604, 0.241101, 0.021833, 0.167589, 0.077036, 0.083948, -0.296906, -0.0579057, 0.165158, -0.137723, 0.112313, 0.326217, -0.15337, -0.286078, -0.172635, -0.138272, -0.0618811, 0.0863614, -0.199428, 0.260696, 0.325398, -0.163404, -0.363451, 0.0239969, 0.075351, 0.0524605, -0.0697929, 0.312334, 0.0848913, 0.307648, 0.478342, -0.0647417, 0.255335, -0.0527538, 0.137288, -0.136155, -0.278536, -0.110216, -0.367108, -0.267235, -0.315825, 0.739423, 0.208186, -0.191963, 0.201966, -0.147034, 0.0355691, -0.65013, 0.199913, -0.0395333, 0.489608, 0.0539792, -0.0595844, -0.647795, -0.0593447, 0.226084, 0.123842, -0.00619181, -0.00736084, -0.0176299, -0.0993591, -0.511529, -0.461575, -0.378053, -0.178793, -0.256134, -0.424544, 0.0109477, 0.0190307, 0.160728, -0.0401434, 0.369227, 0.50136, 0.130593, 0.259706, -0.205511, 0.515589, -0.177011, -0.3654, -0.0804384, -0.293968, 0.120407, -0.063377, -0.241222, 0.123191, 0.0245549, 0.23598, 0.114083, 0.308789, 0.0891939, 0.111006, 0.143684, -0.748488, 0.126321, -0.479303, -0.332139, 0.0349713, -0.500179, 0.442094, 0.23765, 0.454924, 0.0216326, -0.216957, 0.20518, -0.0840649, -0.378902, -0.147073, 0.096677, -0.681893, 0.10401, -0.0190877, -0.585087, 0.410064, -0.382834, -0.256155, 0.195216, 0.373542, -0.156472, 0.609043, -0.247625, 0.400567, -0.338266, -0.337041, -0.224626, -0.213603, -0.573678, 0.330018, -0.0715276, -0.0263091, 0.362459, 0.113775, -0.00212309, 0.0471279, -0.92191, 0.252008, -0.0543267, -0.183158, -0.282097, 0.0124927, -0.259409, -0.116343, 0.334677, 0.0306287, 0.0836952, 0.0524197, -0.0654667, 0.16877, -0.797558, 0.0758747, -0.22964, 0.330917, 0.213419, 0.230771, -0.449391, 0.0626378, -0.277312, 0.126355, -0.122238, -0.247871, -0.0530244, -0.248157, -0.528185, 0.0657384, -0.585866, 0.175849, -0.365932, -0.0634166, 0.0288606, -0.17998, 0.282316, 0.171323, 0.291616, 0.543149, 0.0264169, 0.658276, -0.400387, -0.0293188, -0.0209558, -0.101053, 0.108508, -0.105701, -0.173272, 0.0357894, -0.0325602, -0.0462602, 0.139072, 0.463973, 0.136641, -0.106046, -0.162896, 0.101353, 0.0117474, -0.497336, 0.154764, 0.0484316, 0.00529958, -0.0801103, -0.874701, -0.101764, 0.0335256, 0.0213838, -0.290629, 0.0148002, 0.26791, -0.187349, -0.299082, -0.281614, 0.031547, -0.802424, 0.0670447, 0.0562575, -0.651383, 0.0744544, -0.463007, 0.0533635, -0.0231787, 0.25587, -0.202844, 0.113233, -0.0888112, 0.266012, -0.0222663, -0.0491549, -0.196244, -0.0264765, 0.11092, 0.135369, -0.136507, 0.290561, 0.158169, 0.0955046, 0.24013, 0.23635, -0.732247, -0.082434, 0.0607715, -0.0772162, -0.389646, 0.151829, 0.166085, 0.159486, 0.438888, -0.0550011, 0.273489, 0.122126, -0.074395, -0.257514, -1.62373, 0.130615, -0.0375701, 0.126639, 0.145271, 0.334286, -0.27669, -0.0878865, 0.060931, -0.0192336, -0.574421, -0.208205, -0.211113, -0.138575, -0.398918, 0.22956, -0.378942, 0.365981, -0.2213, -0.143367, -0.0498831, -0.164437, 0.34356, 0.00218251, 0.406516, 0.385861, 0.181024, 0.199471, 0.0523872, -0.2053, -0.0759513, 0.0268154, -0.0769661, -0.205732, -0.119735, 0.0219052, -0.0579941, -0.12864, 0.43564, 0.397825, 0.531193, 0.0619579, 0.111488, 0.0993795, 0.0662666, -0.194166, 0.0465252, 0.264434, -0.0320646, 0.0728728, -0.776582, -0.0463972, 0.154576, -0.017231, -0.0960276, 0.0285193, 0.0711974, 0.103996, -0.193069, -0.324366}, {0.0190254, -0.644567, -0.190436, 0.0514669, -1.02362, -0.132434, -0.260225, 0.00785617, 0.010971, 0.162547, -0.0844134, 0.194313, 0.360354, 0.215994, 0.147006, -0.0898036, 0.188733, 0.0094477, 0.233182, 0.112767, -0.0346835, -0.227146, 0.107446, 0.109819, 0.105649, -0.0424865, -0.392764, 0.0162869, -0.209577, -0.230283, -0.0048379, -0.129564, 0.114564, 0.112638, 0.529068, -0.535803, 0.151899, -0.0495466, 0.0961011, -0.38892, -1.54172, 0.203694, 0.101657, 0.0263843, -0.0352635, 0.19832, 0.291477, -0.0521085, 0.211124, 0.164449, -0.658181, -0.191826, -0.142395, 0.0865768, -0.448796, 0.0374553, 0.0419291, 0.394991, 0.111827, -0.0624868, -0.0112465, -0.27264, 0.198958, -0.0166982, 0.378518, -0.00649373, 0.240828, 0.152181, -0.0295729, -0.04758, -0.281166, 0.0162831, -0.0329692, -0.236721, 0.194641, 0.0081749, 0.374535, -0.106859, 0.484567, 0.375967, 0.320027, -0.00268682, -0.0484344, -0.0232442, -0.215374, -0.0973528, 0.103205, 0.291567, -0.133126, 0.00225183, -0.384159, 0.111673, 0.0437341, 0.107456, 0.0855782, -0.267673, 0.152981, 0.117353, -0.363646, -0.198392, -0.0197952, -0.569243, -0.297655, 0.0772038, -1.00085, -0.0624367, -0.0815138, -0.0910043, -0.129145, 0.304289, -0.0344596, -0.0813405, 0.413716, -0.0071841, 0.142232, 0.120495, 0.316366, 0.0458292, 0.198702, -0.000683779, 0.170891, -0.133078, 0.104051, -0.000374884, 0.0323907, -0.156542, -0.242237, -0.105535, -0.143569, 0.0138441, -0.434661, 0.0292697, 0.0011873, -0.160712, 0.454194, -0.562058, 0.049925, -0.127254, -0.0818927, -0.39332, -1.14847, 0.149088, -0.106473, 0.0444304, -0.234951, 0.0889209, -0.000275796, -0.0317991, 0.310706, 0.0596712, -0.884004, -0.127296, -0.258828, 0.0541464, -0.391616, 0.196972, 0.0806407, 0.398188, 0.0648352, -0.0622827, 0.0152255, -0.157174, 0.181723, -0.0350382, 0.19193, -0.421971, 0.225656, 0.288277, -0.0197124, -0.00311629, -0.491046, 0.0457862, 0.0825824, -0.0633622, 0.0688131, 0.00762027, 0.0216849, -0.168261, 0.496384, 0.389961, 0.216666, -0.125026, -0.392653, 0.295151, 0.156472, -0.133044, 0.0287801, 0.258466, -0.132455, 0.0536454, -0.401589, 0.135639, 0.228339, 0.154647, 0.0662855, 0.0388288, -0.0485285, 0.19413, -0.234055, -0.0901719, 0.0890328, -0.579607, -0.338359, 0.167668, -0.557595, -0.21589, 0.149052, -0.216524, -0.142123, -0.0149841, -0.0227667, 0.210243, 0.121683, -0.116944, 0.135531, 0.472912, 0.209771, -0.0878695, 0.210968, 0.0514831, 0.0919817, 0.046268, -0.211274, 0.0669999, 0.224749, 0.162315, -0.192206, -0.0505331, -0.178605, -0.0558338, -0.929527, -0.121748, -0.0767732, -0.00146199, 0.234881, -0.485903, 0.291833, -0.142863, -0.131231, -0.389749, -0.924505, 0.0728461, 0.108415, -0.16542, -0.0128963, 0.0410712, -0.0136759, 0.0149138, 0.224962, 0.0765252, -0.685353, -0.115003, -0.209146, -0.130027, -0.227068, 0.0973701, 0.0664394, 0.226741, 0.0353165, -0.124728, 0.0124044, 0.114074, 0.250038, 0.108765, 0.263054, -0.257328, 0.0623587, 0.256719, -0.163955, -0.0271215, -0.398464, 0.265644, -0.0514063, 0.194607, -0.0881947, -0.0777811, -0.371515, -0.207224, 0.414858, 0.234759, 0.29125, -0.283763, -0.474053, 0.173034, 0.0735999, 0.138746, 0.169409, 0.302174, -0.0287342, -0.0785932, -0.0445512, 0.109445, -0.0414027, 0.173582, 0.0805705, -0.00509914, -0.161806, 0.249307, -0.0728794, 0.0267535, 0.132857, -0.271705, -0.102402, 0.229451, -0.31736, -0.100352, 0.185446, -0.252737, -0.0932496, -0.0222734, 0.0736226, 0.513818, -0.148493, -0.0794007, -0.21161, 0.656214, 0.179158, 0.0191426, -0.166679, 0.0344319, -0.0508041, 0.132266, -0.215414, 0.0438877, 0.212814, -0.0203884, -0.0204117, 0.0599922, -0.0795139, -0.117314, -0.937982, -0.059896, 0.0231833, -0.0787183, -0.0230971, -0.473901, 0.318269, 0.00856077, 0.0358179, -0.319304, -0.399401, 0.148892, 0.128108, -0.135982, 0.14845, -0.0290292, 0.115797, 0.00587225, 0.0559046, 0.148686, -0.328296, -0.1321, -0.0508432, -0.297511, -0.0932518, 0.327684, -0.197606, 0.295276, -0.0722364, 0.00861695, -0.0873043, 0.0278162, -0.138287, 0.275218, 0.194169, -0.0553579, -0.110555, 0.195241, -0.0950054, 0.145539, -0.309365, 0.19697, -0.00865136, 0.0853918, -0.128591, 0.0935186, -0.322553, -0.0430059, 0.269565, 0.0428093, 0.0199281, -0.175267, -0.368742, 0.152925, -0.179782, 0.0232461, 0.11587, 0.222016, 0.0488735, 0.0614219, -0.127997, 0.0831704, -0.110229, 0.029282, 0.0928755, -0.0508575, -0.287599, -0.10585, -0.0622566, -0.11854, 0.0450866, -0.0255848, 0.106289, 0.350805, -0.205732, -0.0362961, 0.143176, -0.0397161, -0.165493, 0.188469, -0.00151419, 0.329274, -0.552064, -0.235869, -0.27858, 0.801367, 0.0919578, 0.213245, -0.0404082, -0.065663, -0.093285, 0.151729, 0.0137093, 0.144684, 0.327042, 0.0309299, -0.0825347, 0.181713, -0.050583, -0.340669, -0.686742, -0.0570875, -0.129896, -0.267933, 0.00903123, -0.511375, 0.363141, 0.341836, 0.294988, -0.0245583, 0.109712, -0.0255752, -0.292649, 0.163823, 0.0286222, -0.0998432, 0.00484458, -0.0232057, 0.0429629, 0.127198, 0.12618, -0.215051, -0.0769724, -0.138276, -0.240738, 0.269335, -0.277095, 0.339804, -0.0788101, -0.0756593, 0.0227761, -0.23099, -0.29894, 0.429734, 0.128139, -0.0473099, 0.0216486, 0.205076, -0.0918619, 0.193414, -0.157026, 0.237997, 0.00791665, 0.30802, 0.0163129, 0.22787, 0.0126073, 0.144345, 0.142827, 0.0122761, -0.14822, 0.0156325, -0.318173, -0.0869809, -0.221469, -0.134893, -0.00986938, 0.179427, 0.068576, -0.020278, -0.392789, 0.0861113, 0.158533, -0.035386, -0.00977196, 0.0353651, -0.0522252, -0.161952, -0.0824133, -0.0374221, -0.0750664, 0.102361, 0.0769067, 0.078473, 0.0285157, -0.0345029, 0.160657, -0.131942, -0.33587, 0.160243, 0.0964825, 0.211476, -0.80055, 0.0342507, -0.167268, 0.729044, -0.106921, -0.0490266, -0.0254324, 0.109518, -0.02804, 0.103396, -0.0236431, 0.333704, 0.166228, 0.0699504, -0.133363, 0.0028626, -0.160493, -0.41155, -0.468684, -0.0494605, -0.161641, -0.0867008, -0.0260619, -0.303105, 0.186726, 0.0710024, 0.195998, -0.125644, 0.307129, 0.0722529, -0.240981, 0.15607, 0.310733, -0.0535972, -0.00203925, -0.0264054, -0.216552, 0.129759, 0.16559, -0.115599, -0.0110276, -0.0408247, -0.00675416, 0.283757, -0.213275, 0.325332, 0.130766, 0.185101, -0.044047, -0.235648, -0.233666, 0.237254, 0.0115627, -0.283129, 0.319851, 0.170195, -0.0192898, -0.121331, -0.234441, 0.204519, 0.201553, 0.17244, 0.222126, 0.290135, 0.110587, 0.0949004, 0.177634, -0.0878872, -0.226729, -0.349074, -0.358455, -0.0506405, -0.180637, -0.15067, -0.0834665, 0.00618727, -0.0537412, -0.0687037, -0.335198, 0.0422021, 0.154543, -0.376217, 0.157727, 0.159406, -0.0686487, -0.16631, -0.301456, -0.0312271, -0.136956, 0.0478685, -0.0632761, 0.21132, 0.326553, -0.0882886, 0.22844, -0.0108947, 0.0100568, 0.0597214, 0.134727, 0.0943093, -0.887825, 0.0671556, -0.202462, 0.556644, 0.199092, 0.174508, 0.0539954, -0.0119533, 0.0370346, -0.119863, 0.141862, 0.0906236, 0.178459, 0.028227, 0.033729, 0.0706625, -0.2042, -0.492953, -0.0322805, -0.0247449, -0.064542, -0.0625794, -0.371688, -0.0704739, 0.251654, 0.0271677, 0.333348, 0.0630193, 0.291307, -0.092525, -0.012075, 0.0166385, 0.388395, 0.14513, -0.00306042, -0.0365462, -0.179619, 0.0416387, 0.184852, -0.108745, -0.112501, 0.165763, 0.0449707, 0.377373, -0.297874, 0.162734, 0.208947, 0.230372, -0.0900761, -0.0620496, -0.251174, 0.142358, 0.118301, -0.239384, 0.199707, 0.115795, -0.0457645, -0.0957871, -0.281888, 0.18166, 0.0944353, 0.103527, 0.047226, 0.39192, 0.224174, 0.248209, 0.238522, -0.187839, -0.175344, -0.435769, -0.318897, -0.26096, 0.0235729, -0.280958, 0.148733, 0.0285836, -0.114247, -0.0429878, -0.180792, 0.114364, 0.118751, -0.574999, 0.0969358, 0.352998, -0.168548, -0.0883433, -0.239534, -0.0445827, -0.157674, 0.00897438, 0.0619891, -0.0646606, 0.149193, -0.0351458, 0.36214, 0.146456, 0.165254, -0.0258462, 0.203548, -0.0315219, -0.558657, -0.102489, -0.188043, 0.113, 0.123615, 0.325351, 0.153606, 0.116149, 0.0727089, -0.0916829, 0.345528, 0.0705696, 0.114138, -0.00440464, -0.00466044, 0.0476196, -0.221172, -0.435484, 0.283322, -0.0294613, 0.200591, 0.0185525, -0.581172, 0.0248335, 0.187034, -0.108577, 0.395706, 0.0525792, 0.0995486, -0.266833, -0.0733829, 0.0538657, 0.32294, 0.349973, -0.0208975, 0.046825, -0.184812, -0.226649, 0.0376586, -0.28492, 0.0512781, 0.291542, -0.314878, 0.289235, -0.121814, 0.0280745, 0.209899, 0.257621, -0.06258, -0.0575417, -0.212105, 0.602674, 0.291112, -0.288444, -0.0147434, 0.103395, 0.260858, -0.152636, -0.26149, 0.0633969, -0.0783084, 0.0686282, -0.0271429, 0.249272, -0.0215069, 0.141633, 0.152329, -0.141266, 0.00415622, -0.386268, -0.121392, -0.0219698}, {0.0712257, -0.20742, 0.0563941, 0.0265157, -0.142948, -0.0819816, -0.411384, 0.128265, 0.319349, -0.454125, -0.297018, 0.244592, -0.115546, 0.14242, 0.0222453, -0.215321, -0.224802, -0.0176626, -0.0595425, -0.223148, 0.0108184, 0.261204, 0.209708, 0.162683, -0.12043, -0.103059, 0.48799, 0.0429052, -0.0701468, -0.324968, -0.206332, -0.202196, 0.0513534, 0.025784, -0.00317752, 0.164154, -0.0228098, -0.172831, 0.196153, -0.0167257, 0.128802, 0.0746177, 0.107724, -0.0439409, -0.122346, -0.513049, 0.0312964, -0.277578, -0.0647963, 0.139215, -0.709293, 0.0181885, -0.00291248, -0.19661, 0.585353, -0.201252, 0.18767, -0.290367, 0.39958, 0.0271375, 0.237524, 0.582977, -0.120155, 0.00435393, -0.166519, -0.202953, -0.185773, -0.507653, -0.110671, 0.170248, -0.298266, 0.290226, -0.236956, -0.163738, 0.188312, 0.342267, -0.0813793, -0.0706748, 0.244586, 0.566266, 0.0173453, -0.352058, -0.345419, 0.119592, 0.396637, -0.390561, -0.0787805, 0.244581, -0.0604441, -0.0428818, -0.052029, -0.071563, -0.0137701, -0.0869472, 0.154726, -0.034336, 0.0609136, -0.439009, -0.0980867, -0.0467228, 0.0255017, -0.28459, 0.157657, -0.235535, -0.195347, -0.0294693, -0.691462, 0.146907, 0.294232, -0.223115, 0.003843, 0.315243, -0.137554, 0.0973369, 0.118385, -0.512247, -0.225227, -0.00980542, -0.162411, -0.222752, 0.127784, 0.22882, -0.0688046, 0.268708, -0.152742, -0.240341, 0.247452, -0.0292349, 0.0462077, -0.451354, -0.410233, -0.32648, 0.00179853, -0.068748, -0.0731032, 0.164648, -0.068297, -0.0659246, 0.292799, -0.100897, 0.336988, 0.150452, 0.489072, -0.328382, 0.152727, -0.237891, -0.141099, -0.214983, -0.0703145, 0.143983, -0.523042, 0.111998, -0.10541, -0.13596, 0.541164, -0.202634, 0.069109, -0.238247, 0.139049, -0.031267, 0.32658, 0.750452, -0.019082, 0.0387866, -0.346072, -0.159089, -0.182424, -0.747855, -0.190442, 0.247998, -0.265561, 0.124321, -0.161885, -0.111549, 0.14551, 0.309497, 0.0537139, -0.308865, -0.0345362, 0.487886, -0.106912, -0.27574, -0.30962, 0.2733, 0.397568, -0.420428, 0.0126498, 0.217682, 0.0500286, 0.0182779, 0.0247392, -0.146035, 0.143724, -0.272725, 0.114072, -0.16248, 0.0111076, -0.531253, -0.0595826, -0.111701, 0.260643, -0.240113, 0.202971, -0.0429675, -0.0369486, 0.00808308, -0.491739, 0.219023, 0.0796409, -0.314581, 0.0886531, 0.155439, -0.0245479, -0.0684967, -0.196207, -0.481527, 0.00559524, -0.0349643, 0.0233228, -0.279122, -0.128705, 0.0577581, -0.0675067, 0.224446, -0.188819, -0.123365, 0.165585, -0.142181, 0.101674, -0.236781, -0.270091, -0.403276, 0.113014, 0.143998, 0.00914624, -0.0122529, 0.0642377, -0.106575, 0.170922, -0.0173001, 0.230661, 0.0314744, 0.481039, -0.603189, 0.0889576, -0.267573, -0.0842895, -0.412679, -0.0397287, 0.365048, -0.39011, 0.266138, -0.126733, -0.001387, 0.672448, -0.343829, -0.24723, -0.137684, -0.047514, -0.0395784, -0.0832905, 0.485328, -0.00100436, -0.0543346, -0.243139, 0.0723468, -0.301749, -0.326953, -0.204868, 0.203836, -0.471576, 0.11451, -0.170958, -0.0457587, -0.00347651, 0.417222, 0.022006, -0.38361, -0.274114, 0.349157, -0.177938, -0.356318, -0.113969, 0.150679, 0.393311, -0.156887, 0.225451, 0.31551, 0.201796, -0.0584385, -0.0854497, -0.310346, 0.0954914, -0.0648315, 0.0815488, -0.0494137, 0.210431, -0.767102, -0.0973168, -0.370809, 0.110999, 0.104389, 0.00432619, 0.159351, -0.0757869, 0.0430498, -0.646083, 0.509501, 0.215397, -0.0520911, -0.189525, -0.0632651, -0.0803977, -0.228339, -0.13075, -0.264012, -0.0662771, -0.248485, 0.0952272, 0.0124428, 0.226292, 0.19264, -0.0594995, -0.230466, -0.309222, -0.227881, 0.0801938, -0.0335093, 0.122051, -0.0528837, -0.062424, -0.564674, 0.0696658, 0.101876, -0.128818, -0.00379539, 0.0629872, 0.179672, 0.105201, 0.143163, -0.0325056, -0.207969, 0.519365, -0.737465, -0.25984, -0.272021, 0.172994, -0.394537, -0.187851, 0.135421, -0.758853, -0.0249489, -0.175673, -0.037822, 0.421242, -0.389205, -0.193963, -0.14038, -0.228408, 0.167353, -0.391824, 0.30616, 0.254275, 0.0163061, 0.0336505, 0.0773138, -0.323787, -0.163095, -0.382308, 0.231503, -0.249241, 0.129599, -0.258976, 0.176084, 0.0895, 0.299499, -0.0887333, -0.295113, -0.20791, 0.460245, -0.134768, -0.0674065, -0.097611, 0.289571, 0.262443, -0.236389, 0.226959, 0.370362, 0.293411, -0.138171, -0.298403, -0.355482, 0.408416, -0.22592, -0.172129, 0.0465041, -0.0380261, -1.04616, 0.0316183, -0.289808, 0.0383398, 0.00631665, -0.155961, 0.0572722, -0.0516257, 0.0741027, -0.828643, 0.231843, -0.0202262, 7.13367e-05, -0.082822, -0.230715, -0.0666478, -0.196205, 0.0489704, 0.093042, -0.0910114, -0.196537, 0.429565, 0.141295, 0.274639, 0.431571, 0.0520976, 0.308122, 0.0911325, -0.228326, -0.0970348, 0.045986, 0.201644, -0.210242, -0.123379, -0.390791, -0.161164, 0.181079, 0.0484684, -0.0606538, 0.135322, 0.299236, 0.044745, 0.170378, 0.0322287, -0.312831, 0.513512, -0.58627, 0.161597, -0.116443, 0.269901, 0.0119255, 0.0637725, 0.21101, -0.91788, -0.102167, -0.470116, -0.064556, 0.0885393, -0.524225, 0.00408619, 0.0981286, -0.099011, -0.0969711, -0.574911, 0.199989, -0.19132, 0.024062, 0.138195, 0.569417, -0.471911, 0.110935, -0.607, 0.0800273, -0.138261, 0.0264944, -0.290225, -0.137636, 0.0597863, 0.248666, 0.0696586, -0.111942, -0.0882573, 0.435085, -0.0649588, 0.119469, -0.0435446, 0.205628, 0.0630878, -0.304927, 0.207487, 0.490053, -0.0448987, -0.109242, -0.385308, -0.375184, 0.452361, -0.0183823, -0.00602798, -0.128297, 0.119307, -0.578882, -0.0161733, -0.286862, -0.00241188, -0.112112, 0.0428393, -0.00962559, -0.170978, -0.0776736, -0.754531, 0.127544, -0.0174552, 0.102323, 0.20457, -0.454818, 0.0956232, 0.143438, 0.252505, 0.224164, 0.00997809, -0.262021, -0.0272531, -0.164812, 0.232777, 0.327613, 0.143611, 0.330738, 0.10231, -0.0427244, -0.284835, 0.0114068, 0.0235043, -0.248257, -0.122412, -0.259348, -0.0384574, 0.219985, -0.128938, -0.0426378, 0.0751066, -0.0748954, 0.313558, 0.0140508, 0.0826625, -0.0849641, 0.549407, -0.744823, -0.044622, 0.028219, 0.0870338, 0.179167, 0.0468286, 0.0994612, -0.27027, 0.101164, -0.119462, -0.257042, -0.0469393, -0.797701, -0.00423394, 0.0402225, 0.122929, -0.114916, -0.828816, 0.256203, -0.0974295, 0.0467683, 0.0521949, 0.271484, -0.530895, 0.227908, -0.191209, -0.247989, -0.035354, 0.102687, -0.513965, -0.0271466, 0.0239836, 0.159771, 0.0338035, -0.113291, -0.0947563, 0.302705, -0.346626, 0.230595, 0.318193, 0.186013, 0.156592, -0.28212, 0.377655, 0.347578, 0.376597, -0.254412, -0.0419732, -0.157407, 0.350391, 0.0637336, 0.00831282, 0.0673873, -0.175596, -0.167971, -0.0993891, 0.0915845, 0.0555811, 0.0283345, 0.209659, -0.0782651, -0.205663, 0.0361013, -0.937357, -0.0218757, 0.254344, 0.1714, 0.38026, -0.196054, -0.0493729, 0.141741, 0.0134914, 0.451044, -0.0201721, -0.293164, -0.283166, -0.214906, 0.010158, 0.150857, 0.263625, 0.113591, 0.311351, -0.0663774, 0.0412355, -0.150631, -0.187399, -0.133929, -0.269484, -0.47803, 0.12626, 0.254123, 0.125258, -0.0349356, 0.158376, 0.0177319, 0.268226, 0.255957, 0.0282134, -0.11735, 0.168832, -1.28117, -0.175886, -0.0297614, 0.00550359, 0.172523, -0.427235, 0.0373857, -0.416722, -0.0247896, -0.250314, -0.0509468, -0.162049, -0.632883, 0.0763164, -0.0456712, 0.220791, 0.0529282, -0.41446, 0.261583, 0.0930443, 0.0570499, -0.371479, -0.0863311, -0.341314, 0.388134, -0.012166, -0.300151, -0.247068, 0.0174548, -0.340749, 0.379062, 0.201378, 0.353339, 0.00543415, -0.239492, -0.0123983, 0.474035, -0.34782, 0.0424649, -0.274081, 0.0183828, -0.297354, -0.259736, 0.0953452, 0.186307, 0.159043, -0.170392, -0.124342, -0.557447, 0.408351, 0.0745979, 0.212504, 0.278663, -0.128594, -0.219414, -0.474225, -0.00279507, -0.0224834, -0.0190821, 0.509389, 0.060716, -0.19967, 0.0348863, -0.904594, 0.164756, 0.0630504, 0.214233, 0.083643, -0.126161, 0.156966, 0.0494786, 0.063521, 0.352627, -0.0480084, -0.4459, -0.313452, 0.136851, -0.0509705, 0.0934112, 0.247107, 0.0413952, 0.470613, 0.275513, 0.280573, 0.175114, -0.336825, -0.268862, -0.127922, -0.138261, 0.297074, -0.139473, 0.164725, 0.247496, 0.283016, 0.0677819, 0.248373, 0.117402, 0.0800809, -0.174323, 0.062487, -0.88137, -0.250916, -0.215608, -0.0499767, 0.062168, -0.288789, 0.218404, -0.334503, -0.151107, -0.447858, 0.0401691, -0.22868, -0.417209, 0.000316547, -0.235701, 0.0241661, -0.158578, -0.693193, 0.42476, -0.170911, 0.071117, -0.228301, -0.0481093, -0.0505197, 0.535736, 0.0409858, -0.320449, 0.0941878, 0.144389, -0.700335, 0.151053, -0.13372, 0.410073, -0.0245678, -0.247354, -0.0425755, 0.34422, -0.480849, -0.112667, -0.178993, -0.0864123}, {-0.236847, 0.0172949, 0.213127, 0.0851403, 0.0334269, -0.382289, 0.0792406, -0.59886, 0.354927, 0.414743, 0.313322, 0.148331, -0.257676, -0.385713, -0.241799, 0.297929, 0.0573526, 0.125139, 0.547432, -0.0443336, -0.362141, 0.0507312, -0.281885, 0.272919, -0.0196024, 0.319244, -0.228273, -0.232899, 0.152692, -0.4627, 0.273863, 0.711664, 0.506538, -0.372646, -0.242055, 0.0999289, -0.0375902, 0.102597, -0.142475, 0.191469, 0.303564, 0.0985975, 0.130357, 0.183484, -0.432145, -0.196573, -0.482816, -0.263446, 0.153108, -0.0111325, -0.0238847, 0.0118859, 0.125948, 0.100536, 0.114159, -0.121442, 0.319735, -0.184127, -0.118885, -0.754445, -0.274958, -0.258615, -0.0365886, -0.0504014, 0.364947, 0.188601, -0.268564, -0.218813, -0.218817, 0.260381, -0.0573401, -0.200935, -0.24361, -0.443652, -0.0887503, -0.0842019, -0.668859, 0.221312, -0.344334, -0.0775908, 0.120611, 0.0283297, 0.104421, 0.222475, 0.306695, -0.246389, 0.195172, 0.330176, -0.514579, -0.547057, 0.207652, 0.35241, 0.0741759, -0.0456318, 0.00121583, -0.0928132, -0.068374, -0.106556, 0.0335466, 0.104038, 0.318559, 0.366915, 0.0721671, 0.0286273, 0.0403909, -0.416432, 0.239112, -0.55235, 0.155948, 0.195503, 0.301991, 0.10475, -0.113418, -0.378601, -0.116919, 0.441841, -0.0638326, 0.300702, -0.334847, 0.402987, -0.101128, -0.0523909, -0.378166, 0.216262, -0.143048, 0.574196, -0.0625951, 0.456143, -0.17757, -0.0876467, 0.168003, 0.719858, 0.215363, -0.495072, -0.383344, -0.186402, -0.150918, -0.182877, -0.391273, 0.143877, 0.281664, -0.0146302, -0.0040783, -0.152644, 0.0293452, -0.0961489, -0.31199, -0.546458, 0.259759, -0.180534, -0.0901848, 0.562741, 0.50386, 0.0843499, 0.0578459, -0.3762, 0.151416, 0.063369, -0.0793939, -0.177277, -0.0782865, -0.117429, 0.0287854, -0.0152037, -0.0808816, 0.0840433, 0.0155273, -0.0751047, 0.0322029, 0.198663, 0.0877737, -0.10921, 0.107051, -0.00682733, 0.150161, 3.11223e-05, -0.122137, 0.0821511, -0.140607, 0.0268106, 0.277041, -0.0196547, -0.170365, 0.0990138, 0.0866238, -0.137707, 0.109421, -0.0255274, 0.0584005, -0.111674, 0.153031, -0.012839, 0.0524702, 0.0661914, 0.170737, -0.156945, -0.0857218, 0.10805, 0.125408, -0.0588726, -0.0155692, 0.182119, 0.186187, -0.0383523, 0.0937222, -0.00315578, 0.0621987, -0.101611, 0.059514, 0.0343921, 0.0778687, 0.0514292, -0.0828088, 0.122138, -0.0614155, -0.223197, -0.0381795, 0.112471, -0.0470975, -0.086707, 0.0888165, -0.0018586, 0.0345388, 0.159835, 0.0152863, 0.126491, 0.138606, 0.0379305, -0.0463728, 0.0135996, -0.0269566, -0.162701, -0.111842, -0.0188394, 0.113136, 0.151817, 0.196857, 0.0104874, -0.104513, -0.0494949, 0.178727, -0.0851136, 0.239156, -0.120393, 0.106259, -0.0697973, 0.0619996, -0.0112685, -0.0974259, -0.0172722, -0.156591, 0.010411, 0.159006, 0.156353, 0.0756523, 0.000597982, -0.13164, -0.0819519, -0.000929796, 0.0166315, -0.0859734, -0.104635, -0.119528, 0.0272715, -0.056489, 0.0805755, 0.0484566, 0.0936124, -0.0519379, 0.0913509, 0.00542181, 0.0110563, -0.0564336, -0.0274459, 0.104061, -0.0170433, -0.102449, 0.0443541, -0.111237, -0.0237212, 0.142314, -0.0582658, -0.156816, 0.0672277, 0.114976, 0.00222478, -0.00816572, 0.00179516, 0.108843, -0.0194817, 0.0141588, 0.0819237, 0.0461351, -0.0918776, 0.147807, -0.0279973, -0.000237985, 0.015525, 0.0684667, -0.150695, 0.0487205, 0.234455, 0.0418059, -0.13583, 0.118726, -0.0181761, 0.0639527, -0.0847671, 0.0746864, 0.149695, 0.00971608, 0.0242715, 0.034598, 0.00885329, -0.0439604, -0.0646586, -0.0844473, 0.0296036, -0.0389403, -0.0660042, 0.00977805, -0.0730035, 0.0793583, 0.032749, 0.047158, 0.0629126, 0.164252, -0.00668764, 0.0301739, 0.0322055, -0.0492671, -0.0209819, -0.107675, -0.0320197, 0.0559789, 0.00539974, 0.00604104, 0.0370182, -0.0388479, -0.0980998, 0.178592, -0.100412, 0.13583, -0.0549098, 0.0556102, -0.0611003, 0.03464, -0.105839, -0.124669, -0.14638, -0.00722437, -0.100228, 0.114407, 0.00846915, 0.0849513, -0.0805682, -0.0598902, -0.0247233, 0.0178231, -0.0556241, 0.0412738, 0.0309002, 0.0569401, -0.00213488, -0.094941, -0.0249003, -0.0151274, -0.0162809, -0.0734325, 0.0329746, 0.020813, 0.00447037, 0.00342921, 0.0689425, 0.0147639, -0.0734032, -0.0175248, -0.0518131, 0.0128257, 0.0356119, -0.0128726, 0.0522599, -0.0414151, -0.0364846, 0.0631933, -0.0421849, 0.0132309, 0.0244258, 0.0351834, -0.0146414, -0.0107467, -0.00549502, -0.0357476, -0.050607, 0.0796716, -0.0533188, 0.0296774, 0.0177857, 0.0761276, 0.00892804, -0.0369215, 0.116464, 0.0534524, 0.0474568, -0.0194961, 0.0112522, 0.0806393, -0.0160126, -0.0949395, 0.0648645, 0.0989764, 0.0486755, -0.0681118, -0.073789, -0.0618833, -0.00857956, 0.0313605, 0.0459307, 0.0645167, -0.0619177, 0.0274553, -0.040166, -0.0751776, -0.0242646, -0.0345424, -0.0270808, 0.114029, -0.0572683, -0.0323427, -0.0223266, 0.00968075, -0.0594221, 0.0229035, -0.113965, -0.0137561, -0.0380159, 0.0744239, -0.0501305, 0.016188, -0.0875693, 0.0695551, 0.0602767, 0.0589762, -0.0112051, 0.0322849, -0.0845456, -0.083657, 0.000715908, -0.0433405, -0.0058738, 0.0534197, 0.0636305, 0.00768213, -0.0221356, 0.0400128, 0.00787024, -0.106564, -0.0734784, -0.0675532, 0.063789, 0.0304085, -0.00257976, -0.0309382, -0.0505054, -0.0892688, -0.0307721, 0.0308595, -0.0540493, 0.0722602, -0.0224008, 0.0573094, -0.0792283, -0.00634366, -0.0124004, 0.00071649, 0.0521234, -0.017738, -0.0345578, -0.0759009, -0.00439175, -0.0589537, 0.0229522, -0.0155686, -0.0139819, 0.0601536, 0.0784908, -0.0422536, 0.00640582, -0.0259462, 0.0384817, 0.0636114, -0.0866534, 0.0119957, 0.0297926, 0.043457, 0.0171908, -0.0344589, 0.0059038, -0.00962752, -0.016701, -0.0209847, 0.0501573, 0.0190151, 0.0723456, -0.0207238, -0.0539129, -0.0346484, -0.0347267, 0.0637299, 0.0621774, -0.00173608, -0.0551404, -0.0423017, 0.0578549, 0.0354834, -0.0384994, -0.0566715, -0.0697622, -0.0123329, 0.0633347, 0.0853353, 0.00457368, -0.0445639, 0.0750732, -0.0676437, 0.0577723, -0.0181189, 0.0500202, 0.0621017, 0.0280677, -0.0143411, 0.0570623, -0.0404002, -0.0685775, -0.00315406, 0.0703062, -0.0212842, -0.0473691, -0.0709648, 0.0753115, 0.0678276, -0.0043804, -0.0418296, 0.0495354, -0.000527914, 0.0602838, -0.0721466, -0.00783615, -0.0428342, -0.0368127, 0.0151526, 0.0148628, 0.047717, 0.0092586, 0.00724897, 0.0684985, -0.0637356, -0.00656225, 0.0318533, 0.030923, 0.0863112, -0.115338, 0.0220196, -0.0931917, 0.104172, 0.0233946, 0.0038194, 0.114436, 0.0018419, 0.00426194, -0.165772, 0.027035, 0.0161519, -0.0241239, 0.203554, -0.222639, 0.0171506, 0.119332, -0.0510784, -0.0404452, 0.0203168, -0.0961186, -0.162894, 0.0313412, 0.107075, 0.00543467, 0.149882, -0.112695, 0.0679545, 0.00179347, 0.0365697, 0.122682, -0.0123843, 0.149243, 0.112613, -0.104056, -0.0380854, -0.184522, 0.0596151, 0.0503439, -0.107359, 0.111711, 0.0605459, 0.0198886, -0.0744919, 0.0263855, 0.0148586, 0.0244408, 0.188776, -0.0212914, 0.0270051, -0.0674116, 0.190113, 0.17818, -0.0741476, -0.113801, -0.152866, -0.0698978, -0.114116, -0.0879939, -0.0567141, -0.0577898, 0.102145, 0.0146337, -0.177023, -0.0900031, 0.00712034, 0.213749, 0.0452371, 0.00787301, -0.0399575, -0.0525909, -0.00325134, -0.0385038, 0.107856, 0.0614955, 0.126652, -0.149226, -0.121061, 0.039576, 0.0221219, -0.188302, 0.0158938, -0.0298672, 0.0297171, 0.0324714, 0.004113, -0.217079, -0.0603533, -0.166288, 0.0740636, -0.0841488, -0.00834295, 0.0581908, 0.0199996, 0.0416265, -0.093651, -0.117724, -0.0763853, -0.0503853, 0.0428685, -0.18259, 0.0607135, -0.0713413, 0.0635255, -0.0255484, 0.0720627, 0.175901, -0.013322, -0.0531041, -0.150527, 0.0187635, -0.0440803, -0.0166431, 0.198103, -0.204139, -0.0416704, -0.0407379, -0.186497, -0.0248358, 0.0289546, -0.0115535, -0.0779059, 0.132198, 0.285028, -0.00546986, 0.324978, -0.180576, 0.120431, -0.0513829, 0.0991256, 0.0529472, -0.0106773, 0.0729905, 0.291547, -0.0332947, -0.0311762, -0.15316, 0.115394, 0.0773739, -0.0939043, 0.140392, 0.0932461, -0.0386079, -0.0354292, 0.0795499, 0.0615707, 0.0539844, 0.162911, 0.0641878, -0.0013574, -0.0820256, 0.11196, 0.275928, 0.0506069, -0.138559, -0.129805, -0.129315, -0.252983, -0.114414, -0.0849767, -0.06896, 0.0541731, 0.00504696, -0.166768, -0.0352549, -0.000716331, 0.168467, 0.0557163, 0.0118654, -0.164471, -0.0439112, 0.00887871, 0.104027, 0.0399686, 0.166155, 0.163288, -0.0411392, -0.0424525, 0.0579177, 0.0586507, -0.0582256, -0.0309552, -0.0177843, 0.0929497, 0.0767673, -0.0148369, -0.168899, -0.0872905, -0.0566801, 0.0566736, 0.0473591, 0.128974, -0.0450749, 0.00639405, 0.192815, -0.0175564, 0.00795282, -0.0649515, 0.107546, 0.119904, -0.180652, -0.0525383, -0.00548903, 0.152229, 0.00269992, 0.0948715, 0.126072, -0.0117342, -0.00675055, -0.178387, -0.142632, 0.0399127, 0.0102551, 0.175768, -0.246188, 0.0576755, -0.0488363, -0.0735053, 0.0179477, 0.00636367, -0.0130525, -0.140518, 0.209448}, {0.212984, 0.0752388, 0.140513, -0.145525, 0.245249, -0.133044, 0.111938, -0.000804642, -0.00451359, 0.0459393, 0.236145, -0.0610788, -0.0322134, -0.0217613, 0.0203624, -0.0792014, -0.0364899, 0.248548, 0.0794174, 0.0167741, 0.00264228, 0.152714, 0.144182, -0.0391045, 0.110807, 0.0237796, 0.058629, -0.0331866, 0.181599, 0.262028, 0.0142716, -0.0671023, -0.0496009, -0.110637, -0.264732, -0.16332, -0.131907, 0.0608125, 0.11726, 0.0241583, -0.0993016, 0.0589442, 0.101914, -0.0281257, 0.0830199, 0.076909, -0.0867204, -0.105939, -0.0507323, 0.0567087, 0.0236531, 0.0975056, 0.171544, -0.0620744, -0.19587, -0.0773464, 0.0206814, -0.15209, -0.011462, -0.0244062, 0.127216, 0.131234, 0.00191522, -0.177597, -0.0112623, -0.12068, -0.0605995, 0.0260025, 0.142833, 0.0626507, 0.0202813, 0.259448, -0.075966, 0.000723444, -0.127068, 0.209239, 0.174166, -0.119352, -0.261593, -0.170155, 0.0379345, 0.0403127, -0.0741594, 0.00223143, -0.125472, 0.285975, -0.0128859, -0.120395, -0.0080795, -0.0726147, 0.278039, -0.342417, 0.0759838, 0.0244334, -0.22882, 0.0682819, -0.0785873, 0.163966, -0.162032, 0.195522, 0.176028, 0.0726131, 0.0287237, -0.0054973, 0.187956, -0.180001, 0.0835532, -0.0832248, -0.0648631, -0.140237, 0.269014, -0.0890164, -0.0750119, 0.0424031, 0.0734827, -0.217417, -0.00905105, 0.221443, 0.184774, 0.0428187, -0.0422498, 0.133978, 0.124555, 0.104317, 0.0884247, 0.0980611, -0.0393639, 0.0164342, 0.260404, 0.29542, 0.124949, -0.0250724, -0.0494373, -0.0370844, -0.142723, -0.160897, -0.022841, -0.0491345, 0.0691922, 0.0299362, -0.0976321, 0.0408951, 0.19532, -0.199748, 0.140181, 0.131558, 0.0418153, -0.162533, -0.131131, 0.178118, -0.10772, -0.00134958, 0.187391, -0.148031, -0.210484, -0.134937, -0.167279, -0.0914946, -0.0429759, -0.0162357, 0.194003, 0.215527, -0.0764717, -0.154215, 0.0670577, 0.0706616, 0.104718, -0.0478139, 0.079724, -0.0818504, 0.125909, 0.293815, -0.0377939, 0.124784, -0.0484973, 0.132592, -0.00295499, -0.160388, -0.201848, -0.0422497, 0.0364641, -0.0140924, -0.232175, 0.00158977, -0.00179014, 0.0577812, 0.0488056, -0.159837, 0.0150458, -0.0443249, 0.237264, -0.426706, 0.1121, -0.0663824, -0.237441, -0.0673527, 0.0919647, 0.208913, -0.214186, 0.0906537, 0.18041, 0.104681, 0.104048, -0.0540668, 0.280581, -0.20107, 0.127308, -0.17725, 0.0567349, -0.126075, 0.267538, -0.25112, -0.0840033, 0.155652, 0.0468017, -0.118386, -0.0432648, 0.402027, 0.146303, 0.0177762, -0.24877, 0.192647, 0.211588, 0.0521009, 0.0110522, 0.0653316, 0.103296, 0.0434899, 0.125174, 0.306789, 0.165089, -0.106563, -0.21979, 0.0520546, -0.0486568, -0.116283, 0.0856515, -0.0271161, 0.0220991, -0.0570856, -0.118072, 0.207423, 0.275144, 0.0270991, 0.0973248, 0.0684638, -0.107471, -0.279028, -0.0877004, 0.166564, -0.0854521, 0.204592, 0.214623, -0.281983, -0.279343, -0.118694, -0.130508, -0.0447004, 0.132465, -0.302175, 0.238247, 0.220489, -0.0460227, -0.396443, -0.153289, -0.0275737, -0.0441025, -0.240287, 0.119144, 0.0274887, 0.167689, 0.291124, -0.096469, 0.260234, -0.00328778, 0.147299, -0.0667529, -0.164917, -0.124419, 0.0975562, 0.0629984, 0.0524152, -0.202241, -0.177355, -0.0134995, -0.0812938, 0.1796, -0.204617, 0.127912, -0.0231839, 0.305497, -0.477414, -0.161106, -0.00548124, -0.178667, -0.00121012, 0.163451, 0.133828, 0.0561149, 0.0385633, 0.327886, 0.0719071, 0.00516367, 0.00852807, 0.120397, -0.290632, 0.0320176, -0.0538143, -0.0336031, -0.00791498, 0.0779271, -0.241014, -0.0142319, 0.322363, 0.134567, -0.0708734, 0.0693592, 0.172248, 0.085754, -0.163855, -0.152209, 0.0873647, 0.274564, 0.278646, -0.0493221, 0.0289272, 0.254405, 0.0861584, -0.218882, 0.0623425, 0.0818447, -0.0190576, -0.091345, 0.139249, 0.060268, 0.101167, 0.324911, 0.0401688, 0.056725, -0.224981, -0.100219, 0.288316, 0.106718, 0.0161344, 0.139888, 0.00253521, -0.0265482, -0.0913238, -0.186715, 0.180938, -0.134337, 0.273687, 0.125903, -0.25189, -0.182827, -0.0610501, -0.107357, 0.0130902, 0.262694, -0.274377, 0.214254, 0.213107, -0.0590988, -0.361261, -0.158756, 0.0623545, -0.188158, -0.209608, 0.0982372, 0.124246, 0.341253, 0.207886, 0.0478631, 0.219197, -0.0875176, -0.00144143, -0.00928894, -0.119235, -0.005654, 0.127535, -0.058928, -0.211704, -0.0112006, -0.0095963, 0.0265712, -0.108279, -0.236603, -0.263207, -0.13874, -0.0620417, 0.192747, -0.340973, 0.0887123, 0.108203, -0.233069, 0.0228814, 0.0397517, 0.0972278, 0.225511, 0.0945391, 0.223811, -0.0105153, -0.0313966, 0.057317, 0.190252, -0.266376, 0.0805417, -0.0472776, 0.00451656, -0.0586539, 0.156612, -0.194717, -0.116581, 0.389581, 0.182031, 0.00619979, 0.0873529, -0.00603754, -0.00143985, -0.0371142, 0.119629, -0.0227119, 0.30191, 0.317263, -0.271307, -0.104134, 0.0872384, 0.038484, -0.0388631, 0.106835, 0.124695, 0.0554845, -0.268459, -0.175943, -0.221949, -0.0810866, -0.144994, -0.000741079, 0.101518, -0.174668, -0.0199804, 0.0641445, 0.0337962, 0.0586625, -0.0918441, -0.13179, 0.133088, 0.0364584, -0.0737082, 0.0306729, -0.198535, 0.218488, 0.220353, -0.256673, -0.152088, 0.0445315, -0.0604435, 0.025434, -0.125287, -0.123703, 0.262691, 0.327356, 0.201723, -0.180035, -0.193902, -0.0184126, -0.25339, -0.146294, -0.0259733, 0.00936837, 0.0673203, 0.25849, 0.0217241, 0.377002, 0.154998, 0.208619, -0.0353851, -0.051646, -0.133157, 0.130655, 0.0369583, -0.171224, -0.0522019, -0.0429912, 0.041144, 0.115868, -0.304098, -0.293842, -0.092108, 0.113888, 0.0557785, -0.216712, 0.223451, 0.099168, -0.115379, 0.0617479, 0.0464436, 0.0818777, 0.240845, 0.207897, 0.21882, -0.105608, 0.0168316, 0.046496, 0.0667561, -0.130667, 0.109703, -0.024774, -0.0123974, 0.0636876, 0.157882, 0.053658, -0.0438881, 0.292739, 0.159443, -0.0507976, 0.1182, -0.0344493, 0.0384389, -0.0198589, 0.186948, 0.0422624, 0.201471, 0.170813, -0.277343, -0.172539, -0.0245385, -0.0668451, 0.0965839, 0.114018, 0.175486, -0.0532376, -0.193654, -0.292611, -0.283211, -0.103749, -0.230836, 0.0324388, -0.0188907, -0.0387949, -0.0825161, -0.00951663, 0.115411, -0.0609374, -0.189462, -0.203151, 0.10307, 0.141257, 0.03049, 0.182134, -0.165199, 0.111195, 0.137363, -0.15427, -0.142819, -0.00561622, 0.0482497, -0.0310302, -0.200205, -0.185811, 0.0954781, 0.255555, 0.072873, -0.151204, -0.233005, 0.00347148, -0.13065, -0.184804, -0.0413852, -0.0559067, -0.0136499, 0.273133, 0.0864644, 0.363524, 0.127541, 0.296144, -0.0205122, -0.207608, -0.176872, 0.100279, 0.0276214, -0.164726, 0.10802, 0.0231857, 0.0300089, 0.111685, -0.184409, -0.106837, -0.185539, 0.143367, 0.0485827, -0.0880001, 0.189574, 0.0150169, -0.16693, 0.0469833, -0.0101175, 0.33531, 0.133133, 0.172466, 0.204444, -0.181501, 0.0056464, 0.154412, 0.0606175, -0.168884, 0.110569, -0.0197542, -0.0253231, 0.114179, 0.0533024, -0.100738, -0.0302869, 0.21441, 0.0847744, -0.0516762, 0.0735998, 0.000331161, 0.134855, 0.160823, 0.117663, 0.0126638, -0.000602844, 0.159201, -0.12692, -0.0996848, 0.117762, -0.00489692, 0.138919, 0.143119, 0.0334104, -0.0499453, -0.0338891, -0.262326, -0.222059, -0.193313, -0.287877, 0.035694, -0.0936035, -0.026952, -0.165493, 0.0275245, 0.15843, 0.0335198, -0.0715457, -0.116344, 0.241088, 0.13434, -0.03184, 0.207491, -0.176727, 0.10905, 0.124621, -0.116099, -0.21682, -0.027477, 0.0382473, 0.0114347, -0.2197, -0.0466789, 0.213193, 0.294835, 0.0598038, -0.12933, -0.0261136, 0.0419788, -0.0654188, -0.0165222, -0.0753322, -0.0436117, -0.0943677, 0.318783, 0.0079154, 0.290012, 0.11248, 0.322832, 0.0383563, -0.0859403, -0.0809804, 0.107604, -0.0270412, -0.265187, 0.0733111, -0.0733529, 0.0150599, 0.140594, -0.151729, -0.1932, -0.209631, 0.159708, 0.202245, -0.121901, 0.213176, 0.114653, -0.215764, 0.000409581, -0.040762, 0.189465, 0.100696, 0.180517, 0.195922, -0.227428, 0.136781, 0.18151, 0.0500521, -0.182856, 0.10604, 0.0763764, -0.0587689, 0.205153, 0.0924942, -0.140001, 0.0309588, 0.296253, -0.0293222, 0.0166266, 0.110123, 0.0618249, 0.103447, 0.158864, 0.186907, 0.145801, 0.0376954, 0.181159, -0.00440721, -0.0104594, -0.00106951, 0.00365984, 0.120124, 0.27031, 0.00971625, -0.118201, -0.11838, -0.178638, -0.188333, -0.00885016, -0.260265, 0.015027, -0.0553726, -0.0334257, -0.162344, -0.00368876, 0.130762, 0.0840469, -0.0147937, -0.223028, 0.264384, 0.00803309, 0.00677213, 0.175721, -0.218323, 0.0614357, 0.10762, -0.0963792, -0.214485, 0.110463, 0.0595208, 0.0155548, -0.152424, -0.117184, 0.170226, 0.311478, 0.100599, -0.285016, -0.131372, -0.00410483, -0.0962146, -0.0307027, 0.0692257, -0.0753154, -0.0298364, 0.315695, -0.0239984, 0.413045, 0.0944047, 0.269077, -0.00112574, -0.196668, -0.0852812, 0.099706, -0.0186907, -0.229947, 0.0336107, -0.0705103}, {-0.00606084, 0.078958, -0.322015, -0.199103, -0.117183, 0.103098, 0.165618, -0.180861, 0.0480027, 0.12927, -0.313157, -0.0589357, -0.173014, 0.157658, 0.273916, 0.184197, 0.345668, -0.230613, 0.136174, 0.0451001, -0.0789632, -0.215079, 0.174775, 0.114292, -0.0216385, 0.187509, 0.0528895, -0.0400216, -0.0565575, 0.234571, 0.0167526, -0.0618514, -0.0399884, 0.0670836, 0.272719, 0.0354062, 0.229248, 0.202036, 0.0741077, 0.161234, -0.066469, -0.06002, 0.0850127, 0.0718003, 0.0615797, 0.197916, 0.0459295, 0.0153992, -0.0960002, -0.0426492, -0.0941267, -0.0654609, -0.361556, 0.0584377, -0.0576694, -0.149796, -0.182379, -0.0416165, 0.045055, -0.0667909, -0.0271147, -0.24507, 0.206531, -0.00736013, -0.131277, 0.164535, -0.181493, 0.231294, -0.0756066, 0.00856987, -0.231768, 0.0625327, 0.244314, 0.095626, -0.183202, 0.0895436, 0.200916, 0.223699, -0.062959, -0.305809, -0.0563775, -0.165531, -0.0609986, -0.146911, 0.0202415, -0.156865, -0.0526289, 0.335192, 0.0321212, 0.32264, -0.0115044, 0.0823539, 0.120111, -0.258933, -0.0996079, -0.0724334, 0.0606778, -0.185897, -0.0137639, -0.131369, -0.103261, -0.000761955, -0.125021, -0.24961, -0.0881746, 0.0455038, 0.320832, -0.0719643, -0.0890453, 0.134076, -0.165106, -0.0797239, -0.19061, 0.248131, 0.374441, 0.177227, 0.405256, -0.355059, 0.234671, 0.019925, -0.143839, -0.140375, 0.413249, 0.177885, 0.0167123, 0.291154, -3.2544e-06, -0.086961, 0.165269, 0.18476, -0.0140194, -0.0757329, -0.0816908, 0.0979474, 0.356086, 0.0702327, 0.107141, 0.160422, 0.147084, 0.119642, 0.125671, -0.00229964, 0.0869044, -0.0624211, 0.0196995, 0.132107, -0.125299, 0.047257, -0.316824, 0.219026, -0.0284821, -0.0110462, -0.202181, -0.0613734, 0.052687, -0.169949, -0.272636, 0.0910136, 0.00866575, 0.0671203, 0.0631483, -0.152917, 0.294854, -0.174814, -0.0926881, 0.218619, -0.122285, 0.262875, -0.239432, -0.0576777, -0.181878, 0.123242, 0.272341, 0.167807, -0.0354065, 0.0259538, 0.0749387, 0.0533961, -0.200894, -0.335741, 0.0478498, -0.193931, -0.167653, -0.0308811, 0.11429, -0.086154, 0.0033313, 0.131629, -0.0428481, 0.277337, -0.121112, -0.104288, 0.031534, -0.237698, -0.174874, -0.0516367, 0.122714, -0.149689, -0.0460253, -0.167567, -0.0102036, 0.226441, -0.0660119, -0.303255, -0.208939, 0.0449825, 0.458737, -0.00152586, -0.0483337, 0.118608, -0.196271, -0.0706487, -0.113118, 0.138006, 0.217908, 0.0650113, 0.577618, -0.27333, 0.198655, -0.00430485, -0.174945, -0.0683452, 0.49872, 0.0898, 0.0375279, 0.143138, 0.0228546, -0.0897187, -0.0138111, 0.216747, 0.0536346, -0.0632475, -0.055317, -0.049724, 0.51157, 0.172859, 0.01889, 0.12891, 0.213252, 0.1056, 0.1688, -0.0241469, 0.276243, -0.0241765, -0.0634417, 0.255304, -0.291946, 0.104884, -0.399653, 0.278786, -0.0348362, -0.0103726, -0.130141, -0.0246768, 0.0229988, -0.18581, -0.277613, 0.0592562, -0.0483295, 0.158153, -0.0207892, -0.174491, 0.290858, -0.0543589, -0.259711, 0.189686, -0.00953605, 0.319392, -0.198085, -0.0646657, -0.176035, 0.112632, 0.305421, 0.174515, 0.209787, 0.0312298, 0.181549, 0.0107684, -0.174183, -0.324433, 0.0493461, -0.17661, -0.238024, 0.0414511, 0.220252, -0.105917, 0.0958728, 0.126201, 0.0352477, 0.177898, -0.168455, -0.0223158, -0.0275944, -0.146224, -0.15003, 0.00131893, -0.120209, -0.188993, 0.0560544, -0.132336, -0.0472657, 0.137254, 0.108607, -0.357799, -0.116947, -0.0263216, 0.629466, -0.077862, -0.136424, 0.0965762, -0.196031, -0.0497905, -0.181771, 0.1484, 0.0662106, 0.0662673, 0.487211, -0.474045, 0.406364, 0.0486341, -0.111395, -0.0381143, 0.479095, 0.0629471, 0.0546585, 0.261692, 0.0815773, -0.242486, -0.0930725, 0.20944, -0.0766294, 0.00921732, -0.258296, 0.0735996, 0.534252, 0.182002, 0.0191794, 0.202619, 0.321048, 0.165768, 0.308342, 0.0887829, 0.298901, -0.0339963, -0.161634, 0.356327, -0.304126, 0.0673351, -0.322153, 0.362117, -0.00703223, -0.0323669, -0.119697, 0.0808927, 0.1446, -0.0955038, -0.419069, -0.00205948, 0.0381648, 0.370457, -0.0231533, -0.0809292, 0.225684, -0.218117, -0.120565, 0.117455, 0.0242829, 0.305423, -0.194291, -0.236458, -0.142097, 0.126826, 0.339638, 0.148322, 0.294294, -0.0993736, 0.499371, -0.094184, -0.156024, -0.482038, 0.107911, -0.273291, -0.222051, -0.144657, 0.22124, -0.0990566, 0.0541982, 0.255598, -0.0174228, 0.17305, -0.210795, 0.0139156, -0.10238, -0.198603, -0.201526, 0.0258011, -0.0805254, -0.0972774, 0.00139768, -0.216026, 0.0995067, 0.0709103, 0.0620214, -0.422952, -0.182413, 0.0566438, 0.493081, -0.145458, -0.23803, 0.0208243, -0.307435, 0.0595031, -0.194938, 0.109277, 0.0765514, 0.0894478, 0.516882, -0.449817, 0.373231, 0.0476494, -0.140819, -0.136158, 0.543715, 0.126856, -0.00985375, 0.137574, 0.304391, -0.281144, -0.162233, 0.30321, 0.0620843, -0.164171, -0.403046, 0.191404, 0.324821, 0.259147, 0.12082, 0.188153, 0.433155, 0.213171, 0.116026, 0.0403489, 0.26615, 0.0476104, -0.244393, 0.40364, -0.295025, 0.0283827, -0.332193, 0.223991, -0.0991337, -0.0573261, -0.0739308, 0.009583, -0.0218677, -0.116926, -0.393936, 0.224301, 0.0347491, 0.514926, 0.0470441, -0.0172631, 0.214185, -0.179159, -0.0823609, 0.224254, -0.202432, 0.335025, -0.186369, -0.105833, -0.187054, 0.0707952, 0.271008, 0.0456981, 0.297211, -0.187416, 0.537665, 0.101064, -0.327552, -0.401148, -0.0461177, -0.100468, -0.32434, -0.189866, 0.096888, -0.0623107, 0.0536639, 0.257906, -0.136235, 0.230289, -0.253565, -0.11237, 0.00286643, -0.157729, -0.165428, -0.159199, -0.115416, -0.0454947, -0.0463653, -0.354148, 0.0288253, 0.177624, 0.161621, -0.343493, -0.150134, 0.122614, 0.539956, -0.433299, -0.256806, -0.0968362, -0.393193, 0.00470576, 0.0507497, -0.0159044, -0.027621, -0.146695, 0.54195, -0.452052, 0.283275, 0.0572378, 0.0158402, -0.137568, 0.456349, -0.0530276, 0.0526591, 0.277616, 0.450867, -0.599533, -0.292261, 0.266745, 0.245517, -0.182, -0.481042, 0.248333, 0.333275, 0.2148, -0.0232978, 0.115516, 0.416203, 0.302604, 0.0886288, 0.148745, 0.241004, 0.0532356, -0.44662, 0.388777, -0.133963, -0.0386509, -0.223746, 0.205032, -0.00877746, -0.0850692, 0.0567277, -0.0688024, -0.0701065, -0.113918, -0.492654, 0.244254, 0.20608, 0.522843, 0.085214, 0.183838, -0.015588, -0.108308, -0.202947, 0.0655394, -0.0972057, 0.363885, -0.0727626, -0.148468, -0.369709, 0.0871371, 0.301636, -0.0732165, 0.405041, -0.358998, 0.519663, 0.158495, -0.327247, -0.605922, -0.126552, -0.101673, -0.371935, -0.141192, 0.23684, 0.0786339, 0.336809, 0.445186, -0.0343681, 0.272274, -0.303089, -0.211709, -0.0486077, -0.231938, -0.0302093, -0.149684, -0.221661, 0.0691511, -0.0403225, -0.251009, 0.00487627, 0.147976, 0.193315, -0.414154, -0.250617, 0.139638, 0.593157, -0.318662, -0.239324, -0.108652, -0.271048, 0.0629995, 0.149685, 0.0322371, -0.0633599, -0.158782, 0.242308, -0.229866, 0.402101, -0.0324578, -0.0964854, -0.101975, 0.374655, 0.00513195, 0.0240068, 0.137189, 0.329095, -0.403812, -0.198501, 0.0036069, 0.130712, -0.215141, -0.151671, 0.30958, 0.348163, 0.177621, -0.031494, 0.00642657, 0.398819, 0.181858, -0.0193593, 0.354726, 0.122324, -0.0178711, -0.233985, 0.0669118, -0.160547, -0.0921161, -0.129626, 0.229702, 0.0157021, -0.122334, 0.12626, 0.0146971, -0.18688, -0.0650226, -0.162315, 0.272455, 0.18439, 0.406892, -0.0172622, 0.267596, -0.322864, -0.023539, -0.250638, 0.0559329, 0.0895556, 0.289491, 0.0723054, -0.157034, -0.229957, -0.0820115, 0.145938, -0.143883, 0.338346, -0.256012, 0.554713, 0.121275, -0.420729, -0.428377, -0.223913, -0.232719, -0.330099, -0.0584636, 0.282286, 0.104152, 0.252285, 0.166059, 0.105394, 0.170024, -0.227556, -0.276375, 0.0494719, -0.0827367, -0.0894672, -0.0636207, -0.0903436, 0.121054, -9.94091e-05, -0.101339, -0.0987033, 0.127702, 0.243064, -0.22262, -0.0625908, -0.0744967, 0.258517, -0.321627, -0.0964639, -0.227732, -0.242221, 0.0119208, 0.279622, 0.0478935, 0.0206774, -0.303728, 0.10111, -0.0113521, 0.241549, -0.0176657, -0.0987469, 0.03688, 0.251307, -0.0564644, 0.0398795, 0.087888, 0.229487, -0.355821, -0.093657, 0.110102, 0.194143, -0.175449, 0.01653, 0.135754, 0.289691, -0.0234728, -0.06525, -0.0379285, 0.214178, 0.174199, 0.0278379, 0.161846, 0.0634119, 0.0906957, -0.233066, -0.0360946, -0.0849567, -0.161157, 0.0451352, 0.244174, -0.0917089, -0.118982, 0.154233, -0.0596238, -0.102855, 0.101521, -0.158631, 0.0859279, 0.192183, 0.199102, -0.0512291, 0.239878, -0.29082, -0.133127, -0.228938, 0.0948099, 0.13995, 0.129963, 0.163276, -0.271097, -0.264529, 0.0201588, -0.04901, -0.105853, 0.205974, -0.150432, 0.281245, 0.0368115, -0.257134, -0.252386, -0.210474, -0.196914, -0.257694, -0.0276225}, {0.162673, 0.193412, 0.274064, 0.0836269, 0.0211466, 0.124881, -0.024084, -0.202133, -0.0532922, -0.241858, -0.0349633, -0.0352393, -0.0885611, 0.167093, 0.0623983, -0.153515, -0.0507606, 0.0318921, 0.282426, -0.130854, -0.000963321, 0.0144201, 0.27759, -0.243315, -0.115932, -0.25039, -0.388821, -0.0232089, 0.27154, -0.0317461, -0.093761, -0.245612, -0.0186514, 0.0433907, 0.158989, -0.131572, 0.0694388, -0.0974279, 0.299015, -0.0974786, -0.0154574, 0.168435, 0.213632, -0.341681, -0.0207388, 0.145519, 0.129192, -0.0990144, -0.0766294, 0.151837, 0.349539, 0.0850568, -0.0432583, 0.090758, 0.213304, 0.178941, 0.036128, 0.169599, 0.206536, 0.139714, -0.261734, 0.0976091, -0.103406, -0.129407, -0.0627013, 0.220268, -0.0491779, -0.117903, 0.194195, -0.0688383, -0.0905527, 0.0447787, -0.115471, 0.130237, 0.178332, 0.0134952, 0.00886958, 0.190567, -0.312588, -0.154881, -0.156828, 0.0898055, -0.00319368, 0.157311, 0.251282, -0.160615, -0.23561, -0.0551856, 0.0328215, -0.0844364, 0.143767, -0.174098, 0.278488, 0.0236653, -0.26717, -0.147095, -0.264576, -0.208713, -0.160999, 0.0634955, 0.297292, 0.174286, 0.27102, 0.253317, 0.00910923, 0.162741, 0.0116579, -0.264284, -0.0622696, -0.248176, -0.0866903, -0.0964938, -0.0276949, 0.0914801, 0.0301041, -0.133658, 0.0709229, 0.107801, 0.270369, -0.122143, -0.0571185, 0.0162627, 0.35982, -0.23263, -0.0953249, 0.0231847, -0.274755, 0.06553, 0.118779, 0.0781877, -0.0369634, 0.034451, 0.169395, -0.0597549, 0.130035, 0.0271544, 0.133851, -0.126054, 0.162827, -0.064532, -0.00582597, 0.0257101, 0.314835, -0.284491, -0.060542, 0.0665903, 0.135874, -0.03701, -0.0599534, 0.239676, 0.401284, -0.029208, 0.0303116, -0.0660733, 0.126734, 0.0399061, 0.0975305, 0.321432, 0.161724, -0.0497727, -0.332528, 0.198815, -0.0499151, 0.00584069, -0.000538716, 0.181852, 0.0872238, 0.061302, 0.0973736, -0.0708363, -0.118483, 0.0788653, -0.0468487, 0.094332, 0.295486, 0.0328516, 0.0784204, 0.235106, -0.280986, -0.253374, -0.211975, -0.0543038, -0.0891151, 0.261759, 0.0334641, -0.166651, -0.104707, -0.201211, 0.0144118, -0.00270146, 0.123805, -0.306134, 0.390436, -0.0394008, -0.139035, -0.0737656, -0.115646, -0.102186, -0.0779092, -0.0522794, 0.220756, 0.00931889, 0.255655, 0.267693, -0.0169404, 0.039054, -0.209972, 0.0115056, -0.092754, -0.280322, -0.17861, -0.0830109, -0.202001, 0.17296, 0.0231238, -0.373272, -0.0998746, 0.115769, 0.433975, -0.0695634, 0.0571252, -0.0492145, 0.392671, -0.387845, -0.0804343, 0.0875303, -0.36031, -0.0442505, 0.235859, -0.061155, -0.173301, 0.208706, 0.390817, -0.256346, 0.247386, -0.102661, 0.251668, -0.0981271, 0.248693, -0.140287, 0.0430367, -0.0493123, 0.455809, -0.374419, -0.22863, 0.0771407, 0.0618014, -0.189874, -0.133268, 0.40007, 0.416749, 0.0542699, -0.104879, -0.0152129, 0.304235, 0.0187206, 0.232509, 0.390873, 0.310301, -0.0515697, -0.357875, 0.231149, -0.157366, -0.193426, -0.0562169, 0.159873, 0.213546, 0.11106, 0.313763, 0.061277, -0.092294, -0.015906, -0.189849, 0.209095, 0.269989, 0.00785425, 0.0503029, 0.311122, -0.377015, -0.388235, -0.244902, 0.0539755, -0.0201754, 0.256669, 0.284456, -0.284576, -0.117084, -0.203496, 0.0447335, 0.0189317, 0.159272, -0.342049, 0.437614, -0.114355, -0.119808, -0.102515, -0.0841174, -0.219895, 0.0871313, -0.0332557, 0.481403, 0.16961, 0.263584, 0.233172, -0.119183, 0.0766147, -0.210587, -0.0555678, -0.0139822, -0.27355, -0.152779, -0.00483615, -0.419721, 0.0329524, 0.00114809, -0.321973, -0.168559, 0.180002, 0.561315, -0.174454, 0.0337345, -0.0712694, 0.504847, -0.433405, -0.0651143, -0.0444566, -0.529351, 0.0557357, 0.387264, -0.139423, -0.336285, 0.277266, 0.429905, -0.197599, 0.357874, 0.0490814, 0.373586, -0.182086, 0.406449, -0.0726825, 0.041103, 0.0135899, 0.62497, -0.470294, -0.257611, 0.0840121, -0.0511594, -0.227429, -0.226143, 0.51044, 0.563621, -0.0280121, -0.123183, 0.0943819, 0.370165, -0.030849, 0.166928, 0.305929, 0.339206, -0.0643842, -0.452125, 0.175287, -0.0555549, -0.260323, -0.098152, 0.203897, 0.199715, -0.158429, 0.254595, 0.0523644, 0.0196058, -0.161829, -0.0747888, 0.245317, 0.310625, 0.0402585, -0.125401, 0.23206, -0.423062, -0.546274, -0.297739, 0.0139109, 0.0689029, 0.234237, 0.278152, -0.298115, -0.0135992, -0.108475, 0.11951, 0.0118514, 0.372623, -0.348305, 0.468382, -0.245099, -0.241824, -0.161287, -0.0272337, -0.0872194, 0.13077, -0.035923, 0.438994, 0.234367, 0.267957, 0.265922, -0.12864, 0.0279968, -0.260216, -0.0303628, -0.122716, -0.237385, -0.0707202, -0.00710615, -0.213549, 0.0824533, -0.0601253, -0.265366, -0.145925, 0.171594, 0.410013, -0.165856, 0.110923, -0.0654786, 0.346734, -0.306416, -0.0173686, 0.125441, -0.246112, -0.0498008, 0.270826, -0.155093, -0.306826, 0.125355, 0.267109, -0.16785, 0.43896, 0.00527713, 0.323592, -0.195993, 0.314024, 0.0482943, -0.0492822, 0.118734, 0.423125, -0.223847, -0.132401, 0.258903, 0.117254, -0.266247, -0.0251154, 0.294152, 0.281966, -0.0118102, -7.96518e-05, -0.0554823, 0.176189, -0.0524491, 0.207376, 0.117843, 0.311282, 0.0358169, -0.406437, 0.165031, -0.140207, -0.266083, -0.177788, 0.247211, 0.0169328, -0.0666403, 0.185168, -0.0632106, 0.0494645, -0.14126, -0.0388824, 0.167481, 0.197102, 0.0468969, -0.115089, 0.135026, -0.370561, -0.395639, -0.244447, -0.036353, 0.0619583, 0.310169, 0.256906, -0.241721, -0.0942698, -0.188331, 0.100366, 0.0617628, 0.180709, -0.160032, 0.365715, -0.163485, -0.153777, -0.031075, -0.141942, -0.0334281, -0.0257765, -0.102746, 0.385717, 0.250866, 0.180217, 0.162664, -0.0441537, -0.0796214, -0.0707417, -0.0648573, -0.11574, -0.0468418, -0.0507155, -0.126603, -0.0915842, 0.040713, -0.0709774, -0.109828, 0.0454008, 0.256188, 0.247082, 0.000346087, 0.162951, -0.120402, 0.202934, -0.21793, -0.0428125, 0.129543, -0.0426105, 0.0575281, 0.22715, -0.122304, -0.189852, 0.0173122, 0.158917, -0.0889197, 0.173361, -0.06768, 0.181167, -0.143739, 0.0465828, 0.100086, 0.0189971, 0.0973757, 0.190996, -0.257783, -0.0747578, 0.247964, 0.0377751, -0.10785, 0.00039382, 0.247163, 0.137274, -0.0101065, -0.0075875, -0.00508453, 0.165202, -0.00380889, 0.117658, 0.12383, 0.243686, -0.0507355, -0.243238, 0.205228, -0.127327, -0.182739, -0.182541, 0.190854, 0.0159691, -0.0197639, 0.243031, 0.00362884, 0.153479, 0.0483408, -0.0596253, 0.0894579, 0.176905, 0.103399, -0.115843, 0.00432529, -0.179574, -0.197648, -0.133319, 0.00865262, 0.127188, 0.161068, 0.169876, -0.0720217, -0.0969629, -0.119502, 0.175595, 0.0221065, 0.228835, -0.21392, 0.170818, -0.180332, 0.0576859, -0.102341, -0.0207767, -0.106998, -0.149799, -0.0910908, 0.272428, 0.188534, 0.219335, 0.0503554, -0.0772787, -0.0295613, 0.0599077, 0.0802469, -0.108472, -0.120519, -0.100523, 0.0227472, -0.0451728, 0.0100925, 0.0393747, -0.0240468, -0.0646342, 0.0566573, 0.188017, -0.0795456, 0.10494, -0.0727924, 0.160657, -0.0629172, -0.112753, 0.072786, -0.101345, -0.0241672, 0.185549, -0.0397955, -0.152551, -0.0142694, 0.115394, -0.0197716, 0.0675244, 0.00432557, 0.0510067, -0.0960559, 0.120078, 0.123064, -0.0155896, 0.0902287, 0.137187, -0.17334, -0.0655298, 0.0624578, 0.123918, -0.171181, 0.0474789, 0.143725, 0.0523372, 0.0243393, 0.0883605, -0.0409602, 0.0356689, 0.0328504, 0.100314, 0.0478712, 0.132269, 0.0660828, -0.161886, 0.0254882, -0.143817, -0.106172, -0.157019, 0.0530016, -0.0653754, 0.00564836, 0.0838555, -0.0217834, 0.0857816, 0.15973, 0.0130582, 0.00403698, 0.160113, 0.056398, -0.100423, -0.0700021, -0.015058, -0.0319749, -0.1859, -0.0640175, 0.0132719, 0.0926109, 0.14189, -0.00261362, -0.0456035, -0.0570555, 0.104394, -0.103912, 0.166472, -0.12084, 0.13908, 0.000941668, 0.0135733, -0.11893, -0.0929312, 0.00335085, -0.145275, -0.0538699, 0.234073, 0.00787388, 0.123501, -0.00755223, -0.0842938, 0.0978409, 0.00845198, 0.0312952, 0.01907, -0.092341, -0.0108056, -0.075387, -0.067205, -0.00315054, -0.0375872, -0.0120372, -0.0317451, 0.0213951, 0.129421, 0.025782, 0.0956739, -0.107306, 0.112204, -0.102574, -0.0170069, -0.00296342, -0.0346514, -0.0699453, 0.0474448, -0.0556634, -0.0283912, -0.0212419, 0.0140069, -0.101454, -0.0298131, 0.055275, 0.0789, -0.0140537, -0.0176147, 0.0203968, -0.049878, -0.0371966, 0.105997, -0.0806333, -0.00963952, 0.14018, 0.0901546, -0.0355274, -0.0176691, 0.0414817, 0.0814487, -0.0298538, -0.0179499, 0.0485308, 0.00399069, 0.00756513, 0.0492534, 0.108559, 0.0280627, 0.0768352, -0.10359, 0.0920824, -0.0596594, -0.0462465, 0.0140464, 0.0651815, -0.12781, 0.013867, 0.0294288, -0.0642231, 0.0778179, 0.0822164, 0.0944722, 0.0569161, 0.103304, -0.0510076, -0.0784375, -0.0337275, -0.0687622, -0.108048, -0.127684, 0.0233965, 0.0579324, 0.115492}, {0.0793087, -0.0718093, -0.0816213, -0.112736, 0.0747359, -0.0257099, 0.13723, 0.000869597, 0.003329, -0.0561321, 0.108698, -0.0380364, -7.0292e-05, -0.135909, -0.0763244, 0.00271063, 0.0537983, 0.100191, 0.109622, 0.0442068, 0.0262809, -0.0573152, 0.00223532, -0.000527255, 0.0152163, 0.0447447, -0.0108178, 0.0588958, -0.0449494, 0.0905035, 0.0113253, 0.0361645, 0.0152474, -0.0471198, -0.0326547, -0.00534541, 0.0161577, 0.0535467, 0.0229745, -0.0654782, 0.0257019, -0.0650699, -0.0541299, -0.0431425, 0.0464615, 0.00564946, -0.0733044, 0.0435213, 0.0214818, -0.0299697, -0.0198002, 0.0334682, 0.0623413, 0.0280264, -0.0233174, -0.0406416, -0.0553448, -0.0134215, -0.00119255, 0.0397159, -0.0174238, 0.000929977, -0.0359843, 0.0132424, -0.0368373, 0.0649695, 0.0622972, 0.0634457, 0.105199, -0.0804915, 0.0773841, 0.00132739, -0.0438573, 0.0525306, -0.0429891, 0.0520841, 0.00501408, -0.0768303, 0.025242, -0.0546854, 0.0322153, -0.019443, -0.00350431, -0.0928826, 0.0828867, 0.0678895, -0.019673, 0.0774086, -0.0677489, 0.033877, 0.0995903, -0.080462, -0.0179151, -0.0420661, 0.00282278, -0.0306813, -0.024832, -0.0794751, 0.0169401, 0.022593, 0.0363412, 0.0549157, -0.0911382, -0.0789163, -0.077162, 0.0218093, -0.0341685, -0.033659, -0.0537732, -0.101802, 0.0236039, -0.00826405, -0.0535429, 0.0481885, -0.0474843, 0.0586324, 0.0450422, 0.0900699, -0.0619939, -0.0172231, 0.0295992, -0.072063, 0.0414204, 0.0107428, -0.0304852, 0.00544797, -0.064787, 0.0246301, -0.0298872, 0.0284682, 0.0609638, 0.00936614, -0.0492677, 0.0368311, 0.105941, -0.0955676, 0.0442076, -0.0323741, 0.0493891, 0.0299498, -0.0787257, -0.0991465, 0.00785006, 0.0108896, -0.024055, 0.0153073, 0.0517916, 0.0210842, 0.000832917, -0.000608653, -0.0040615, -0.0556113, 0.0127578, -0.0515988, -0.0274661, -0.0131434, 0.0452503, 0.0145071, 0.0569788, -0.0679972, -0.0130073, -0.0354204, -0.00590251, -0.0501378, -0.0153661, -0.0169449, 0.10542, 0.0627656, 0.084065, 0.0439685, 0.0516464, -0.0618094, 0.0739222, 0.0542092, 0.0890471, 0.00383209, -0.0617329, -0.0142751, 0.050464, 0.0254116, -0.0349165, -0.0143478, -0.0848457, -0.0596703, 0.0557689, -0.03309, -0.103723, 0.0402504, 0.011492, 0.0824756, 0.0396177, -0.0805187, 0.00697839, 0.0318219, 0.0689485, -0.0674491, 0.026463, 0.0716486, -0.0695214, 0.0034014, 0.0314365, -0.0837794, 0.0216139, 0.0724798, -0.0533106, 0.0461496, 0.0754265, -0.090107, 0.0112045, -0.0251234, -0.0785893, -0.0478318, 0.0451019, 0.0559933, 0.0221723, 0.0709098, -0.0443369, 0.0252552, -0.0699194, -0.0142625, -0.0650765, 0.00284734, -0.0262127, -0.0281373, 0.0296217, -0.153152, 0.0849563, 0.0891415, 0.0142123, -0.0985021, 0.0981497, 0.118766, -0.0672696, -0.0309841, -0.104006, 0.0399709, 0.0249624, 0.0537862, 0.0681869, -0.243928, 0.155247, -0.0781111, -0.0822224, -0.0391414, 0.00286653, -0.00825791, -0.0994918, 0.164964, 0.0981351, -0.0495667, 0.14826, -0.0481764, 0.23614, -0.0250538, -0.0461263, 0.114451, -0.0316894, 0.0550863, 0.206412, -0.013568, -0.0182914, -0.0992755, 0.101953, -0.0327355, -0.0401666, 0.0631332, -0.0927246, -0.0606234, -0.0214855, 0.103999, -0.0417545, 0.0932021, -0.0383798, -5.51503e-05, 0.017457, 0.0726528, 0.0884841, 0.239886, 0.0816439, -0.114644, -0.0854158, -0.171359, -0.196115, -0.188939, -0.138549, -0.0655739, -0.0146395, 0.00151334, 0.0343348, 0.0113072, 0.0515433, 0.10115, 0.00998118, -0.0350858, -0.0447533, -0.0720073, -0.0217867, 0.0539761, 0.0822085, 0.095424, 0.0993229, 0.0342507, -0.117614, 0.0298884, -0.0192229, -0.0467015, -0.0389965, -0.0619939, 0.113533, 0.205323, 0.193903, 0.00650709, 0.0505759, -0.069571, -0.0624787, 0.0783821, -0.0339912, -0.0327489, -0.00060106, 0.11129, -0.0369008, -0.0866023, 0.0024227, 0.248096, -0.00101079, -0.127945, 0.0360707, -0.0607566, 0.0851022, -0.0511295, 0.138589, 0.16394, -0.0656907, 0.0436136, -0.202227, -0.0752009, -0.0795, -0.0142192, 0.0573796, -0.254675, 0.0201173, 0.0144204, -0.0839265, 0.0150463, 0.118946, -0.0984208, -0.137705, 0.154259, 0.165521, -0.0135598, 0.237349, -0.0210094, 0.285864, -0.0011898, 0.00493999, 0.06291, 0.0446546, 0.111695, 0.209156, -0.118568, -0.0468233, -0.173651, 0.0108687, -0.0566861, -0.0394392, 0.155154, -0.10787, -0.0233386, -0.0782357, 0.0879835, 0.0804469, -0.016725, -0.0013386, -0.0929035, -0.0808791, -0.071863, 0.193825, 0.151538, -0.0300056, -0.112189, 0.0314482, -0.125961, -0.238187, -0.217238, -0.191644, -0.00929417, -0.0524743, 0.065813, -0.0618063, 0.0110608, 0.0970451, 0.0129783, -0.0920995, -0.0122053, -0.123104, -0.132261, 0.0663661, -0.0466281, 0.0202512, 0.0394197, 0.257798, -0.109965, -0.14694, 0.0773198, -0.0831723, -0.0791174, -0.101171, 0.00442306, 0.0139444, 0.0721995, 0.0641949, 0.0316806, -0.018895, -0.121667, -0.0594442, -0.0765127, 0.0347858, 0.0339163, -0.056162, 0.028542, -0.113042, -0.0530849, -0.0858367, 0.247353, 0.0853595, -0.15298, 0.021086, 0.0701645, 0.0871128, -0.00182794, -0.00265685, 0.0336782, -0.00447701, 0.084603, -0.100305, -0.0582659, -0.106005, -0.00451166, 0.0863313, -0.197375, 0.0525209, -0.0809451, -0.20094, 0.0781797, 0.0242621, -0.0913955, -0.0874997, 0.266086, 0.218065, -0.0912159, 0.21923, -0.101053, 0.292365, -0.0144209, 0.0664379, 0.129319, 0.0224632, 0.0509111, 0.181486, -0.116934, -0.0975956, -0.169487, 0.134054, -0.0382206, -0.0580014, 0.204942, 0.0639066, 0.019007, 0.0473726, 0.103415, 0.0365154, -0.0838143, -0.0458523, 0.0609597, 0.00594962, 0.022808, 0.170769, 0.131654, 0.0310481, -0.0409773, -0.0789272, -0.00379925, -0.227984, -0.134595, -0.143518, 0.0219167, 0.0181895, 0.0914965, -0.0824305, 0.0655684, 0.135163, -0.0718573, 0.107504, -0.051433, -0.145382, -0.161191, -0.0724503, 0.0771207, -0.00678515, 0.0537194, 0.159086, -0.0723746, -0.168024, 0.0126361, -0.105654, -0.0953218, -0.0028857, -0.119453, 0.0190383, 0.20266, 0.109327, -0.109209, -0.1216, -0.007246, 0.0047754, 0.010033, 0.0491161, 0.0318963, 0.0345033, 0.196499, 0.0188016, 0.0248023, -0.0594954, 0.227515, 0.16013, -0.150321, -0.0870405, 0.0250732, 0.146464, -0.0684676, 0.0171061, 0.0136667, -0.0105572, 0.11542, -0.172833, -0.0496776, -0.109584, -0.156421, 0.13062, -0.304758, 0.180262, -0.0529347, -0.142718, -0.0468731, -0.0266801, 0.114931, -0.183403, 0.21247, 0.191179, 0.0310671, 0.117167, 0.0292096, 0.270652, -0.0615113, 0.125388, 0.050023, 0.0569695, 0.0725427, 0.236563, -0.0323812, 0.0102795, 0.000955613, 0.0809473, 0.00731938, -0.111149, 0.212921, 0.00502038, 0.0189999, -0.00679947, 0.120075, 0.0291883, 0.029214, -0.0592672, 0.0715123, 0.0229297, -0.0190847, 0.198994, 0.246018, 0.0367443, -0.154449, -0.158515, -0.0889593, -0.119866, -0.173986, -0.221889, -0.0459187, 0.00862412, 0.107331, 0.0165044, 0.126496, 0.151243, -0.167564, 0.0401526, -0.0692891, 0.0153314, -0.0988961, -0.0639653, 0.14304, -0.0692882, -0.0635705, 0.208153, -0.146655, -0.226738, 0.00864426, -0.111741, -0.122647, -0.0813849, -0.120056, 0.118436, 0.219799, 0.109843, 0.0140271, 0.0652652, -0.0351666, -0.0404998, -0.151127, 0.0216052, -0.0661761, -0.0365797, 0.201079, -0.0592225, -0.00855003, -0.122486, 0.152821, 0.0529475, -0.044239, -0.204873, 0.0193317, -0.0650923, 0.0563727, -0.14024, 0.1224, -0.0453179, 0.155013, -0.026272, -0.137602, -0.0488205, -0.0995467, 0.134457, -0.296463, 0.191285, 0.0246994, -0.135667, -0.0681582, 0.113103, 0.0415023, -0.123382, 0.302191, 0.108752, 0.107813, 0.0813725, -0.0285748, 0.18265, -0.11694, 0.111663, -0.108429, -0.0673128, -0.0689502, 0.174433, -0.0348691, -0.147474, 0.16338, -0.0248904, -0.0647025, -0.0442439, 0.277301, 0.231863, -0.103353, 0.0747029, 0.0402613, 0.118552, 0.00797826, -0.00915897, 0.0109878, -0.0289608, 0.0135537, 0.176159, 0.142518, 0.0241388, -0.0398975, -0.147754, 0.02677, -0.0226464, -0.0760703, 0.120997, -0.00568233, 0.0437604, -0.117026, 0.125218, 0.157508, 0.273211, -0.216774, 0.102425, 0.00926854, -0.0070206, -0.12476, -0.11228, 6.10008e-05, 0.0190077, -0.00771135, 0.255789, -0.164075, -0.242095, -0.0886514, -0.072811, -0.1188, 0.015865, -0.152756, 0.237782, 0.116351, -0.0283034, -0.218469, -0.0346922, -0.0344213, -0.12341, -0.068454, 0.0652256, -0.0667426, 0.0933411, 0.228034, 0.0896389, 0.146661, -0.0776064, 0.133864, -0.0647309, -0.144102, -0.0400723, 0.0458314, -0.117606, -0.0487417, -0.0965642, -0.0624293, -0.101869, -0.0744046, 0.135257, -0.241178, 0.0469717, -0.101591, 0.158689, -0.303413, -0.144529, 0.1544, -0.138933, 0.0603472, 0.0629115, 0.0141369, 0.0842412, 0.0914281, 0.0852146, 0.0816904, 0.0572081, 0.0898717, 0.0642334, -0.150878, 0.134715, 0.0246227, 0.0082453, -0.0282337, 0.0251098, -0.0782958, -0.0283496, 0.19096, 0.168251, -0.101136, 0.000475402, 0.303883, 0.207768, 0.0250062, -0.0336972, -0.0283083, 0.164544, -0.0230108, 0.0636131, 0.0467068, 0.0738878, 0.0237134, -0.00710608, -0.100302, 0.0357805, -0.0987855, -0.169551, 0.0755671, -0.00518487, -0.0478395}, {0.332641, -0.0687101, 0.119824, 0.00195884, 0.114847, 0.20876, 0.331206, -0.0244139, -0.0391933, -0.0139169, -0.0974321, -0.0921386, -0.254381, 0.0643449, -0.0749459, 0.207412, 0.107577, -0.0642709, -0.120718, -0.0728946, -0.0515671, -0.0947237, 0.0785831, -0.159881, 0.0768596, 0.0468659, 0.0473937, -0.146949, -0.100128, 0.00485982, -0.0983776, -0.113586, 0.169579, -0.0972553, 0.0492368, 0.0564036, 0.0608886, 0.155179, 0.0300019, -0.0160314, -0.116599, -0.00149712, -0.0451344, 0.182708, -0.0919855, -0.113139, -0.0118156, 0.0175223, 0.0322674, -0.0685685, -0.177478, -0.175667, -0.0021545, -0.00221408, 0.175519, -0.242994, 0.107108, 0.163538, -0.220586, -0.0581246, 0.158779, 0.103527, 0.213378, 0.210671, 0.127406, 0.0534754, 0.0966612, 0.183698, 0.220118, -0.176204, 0.03995, -0.0561949, 0.0448368, -0.00645332, 0.205183, -0.174779, -0.10589, 0.158364, 0.132575, -0.0776727, -0.0172558, 0.14735, 0.20147, -0.136809, 0.171397, -0.0915766, 0.0755248, 0.125227, -0.106309, 0.0135045, 0.0420272, 0.0555961, 0.212487, 0.0997144, -0.00796695, -0.158124, -0.0889645, -0.102185, -0.234787, -0.144438, -0.0530245, 0.0555076, -0.0636807, -0.125148, 0.000308451, -0.0427161, 0.181265, -4.6652e-05, -0.0599218, -0.0511714, 0.117999, -0.00629949, -0.128501, 0.158485, 0.0131028, 0.120686, 0.175357, -0.116023, -0.140828, -0.0295321, -0.141549, -0.150979, -0.194117, -0.0371258, 0.0529209, 0.315489, 0.224486, -0.160904, -0.129681, -0.0791899, -0.0694512, -0.13887, 0.0871811, 0.00446904, -0.00522744, 0.164609, -0.00128256, 0.271077, 0.212067, 0.128755, -0.0852051, -0.0613237, 0.0859993, 0.129959, -0.0341621, -0.0829373, 0.0297335, -0.0447747, -0.0168117, 0.0860362, -0.151258, -0.151548, -0.0317852, -0.0207452, 0.0852308, -0.20794, 0.211692, 0.196957, -0.225147, 0.072503, 0.106728, 0.0731564, 0.121868, 0.254101, 0.154748, -0.0369233, 0.0133284, 0.130557, 0.274694, -0.136606, 0.038856, 0.0302037, -0.00902546, -0.0479418, 0.133997, -0.102075, -0.027703, 0.264948, 0.139063, 0.0125061, 0.0125161, 0.0380441, 0.105634, 0.00939603, 0.22873, -0.0499028, 0.00223899, 0.264815, -0.215858, -0.120696, 0.0206866, -0.0613432, 0.188437, 0.216336, 0.0640695, -0.208815, 0.016882, -0.170538, -0.16369, -0.266677, -0.169285, 0.043687, -0.106615, -0.101719, -0.0571794, -0.110825, 0.120166, -0.126302, -0.171867, -0.0685919, 0.19166, 0.0418859, -0.0876209, 0.0554834, -0.0557179, 0.212528, 0.240583, -0.316209, -0.0832779, -0.105948, -0.115336, -0.1075, -0.192653, -0.214747, 0.0479633, 0.339925, 0.214205, -0.20792, -0.00639766, 0.0752824, -0.0319064, -0.126078, -0.0428613, -0.0741208, -0.0993688, 0.141143, 0.00748, 0.373131, 0.288359, 0.270473, 0.0597437, -0.0888231, -0.0128388, 0.119899, 0.0968606, -0.115816, 0.0472675, -0.093634, -0.0935464, 0.228961, -0.0843459, -0.252522, 0.0294325, -0.0307705, 0.0937856, -0.129487, 0.247468, 0.0178413, -0.252055, -0.0241243, -0.0276176, 0.295788, 0.172161, 0.255859, 0.205317, -0.043122, 0.0651618, 0.234682, 0.0982216, -0.0871079, -0.00196999, 0.041469, -0.0450631, 0.0384598, 0.0853848, -0.055596, -0.138102, 0.255, 0.0119698, 0.142118, -0.07237, 0.147954, 0.195181, -0.0116768, 0.27002, 0.00891982, 0.00483233, 0.246243, -0.20634, -0.00379093, 0.0897784, -0.0834848, 0.164977, 0.264661, 0.0592462, -0.180292, -0.0492656, -0.208537, -0.310839, -0.181808, -0.270001, 0.0262402, -0.0757407, -0.0857715, -0.19302, -0.145479, 0.117402, 0.0543437, -0.176581, -0.10237, 0.285014, 0.0215104, 0.0939207, 0.22376, -0.22003, 0.0996665, 0.198842, -0.206592, -0.165612, -0.107617, 0.0220915, -0.0971833, -0.0963956, -0.100829, 0.161424, 0.269321, 0.193559, -0.082323, -0.0280752, 0.0769527, 0.115891, -0.0613443, -0.0183107, -0.101227, -0.0474005, 0.217434, -0.0194386, 0.281116, 0.131578, 0.350846, 0.00272584, -0.175246, -0.00344664, 0.115399, 0.0708217, -0.0691166, 0.134115, -0.152108, -0.070955, 0.14601, -0.0953222, -0.198637, 0.0543805, 0.0320219, 0.0984643, -0.233552, 0.218721, -0.00213167, -0.119048, -0.0683658, -0.059809, 0.288724, 0.0862978, 0.165265, 0.152712, -0.0741322, -0.0249198, 0.172919, 0.176154, -0.151613, 0.0747484, -0.0140738, -0.0134361, 0.0934804, 0.133981, -0.0194896, -0.00744339, 0.149101, 0.110681, 0.0270612, 0.0405213, 0.0876674, 0.0354013, 0.0198617, 0.229384, 0.103183, 0.0333794, 0.214122, -0.139032, -0.0344117, 0.069962, -0.0490666, 0.168211, 0.260246, 0.133786, -0.0676889, 0.0271806, -0.215102, -0.306852, -0.174466, -0.154593, 0.0611693, -0.073485, -0.0586167, -0.208291, -0.0762797, 0.155065, 0.0589549, -0.101044, -0.163328, 0.245304, 0.0214126, 0.0495531, 0.204347, -0.189345, 0.171907, 0.246455, -0.206541, -0.122224, -0.088619, -0.021562, -0.130798, -0.0932483, -0.146735, 0.199964, 0.195694, 0.248294, -0.236607, -0.0348257, -0.0134233, 0.0171975, -0.100687, -0.0619323, -0.0310673, -0.0677922, 0.310556, -0.04442, 0.200055, 0.286581, 0.205199, 0.000178483, -0.2136, -0.0577329, 0.0420874, -0.0212409, -0.276372, 0.0453933, -0.109703, -0.0298358, 0.0578869, -0.124267, -0.158636, -0.0442833, -0.0831074, 0.117042, -0.195087, 0.159757, -0.0326382, -0.132488, 0.0782025, -0.0595597, 0.177067, 0.16539, 0.323889, 0.245702, -0.0915737, 0.0215353, 0.109089, 0.225556, -0.114512, 0.0821909, 0.0819375, 0.0506389, 0.126714, 0.109989, -0.122481, 0.0094449, 0.106047, 0.0998655, 0.0993599, -0.0206183, -0.0101871, 0.0870845, 0.0512865, 0.104344, 0.0976656, 0.0418279, 0.153718, -0.120438, -0.0393338, -0.0135227, 0.0662465, 0.141643, 0.187918, 0.00835931, 0.0789968, 0.00915002, -0.135673, -0.140447, -0.0423607, -0.26432, 0.04212, -0.069482, -0.121755, -0.066015, -0.118764, 0.103763, 0.0421603, -0.0893085, -0.117819, 0.251106, -0.0347646, 0.0228813, 0.228814, -0.116279, 0.188208, 0.118788, -0.175924, -0.241397, 0.0513057, -0.0174287, -0.0693292, -0.19916, 0.00107993, 0.0660473, 0.197756, 0.08543, -0.176431, -0.122865, -0.0301341, 0.0175829, -0.0972456, -0.0189411, -0.136297, -0.137463, 0.197431, -0.0819838, 0.192806, 0.176883, 0.277306, -0.00035184, -0.0834214, -0.137984, 0.0592267, 0.123119, -0.118194, -0.0164582, -0.131113, -0.0870125, -0.0249016, -0.0161194, -0.0639822, 0.0247451, -0.0309454, 0.167532, -0.0403288, -0.0660262, -0.00628876, -0.0974151, -0.00349737, -0.245589, 0.16454, 0.0869256, 0.00693993, 0.255743, 0.0137617, -0.0728348, 0.256628, 0.120013, -0.151305, 0.174931, -0.0201787, -0.0587679, 0.0407964, -0.0695426, 0.128856, 0.117242, 0.127997, 0.0234396, 0.17664, -0.0215288, -0.00520388, 0.119056, 0.0355619, -0.0650698, 0.13742, 0.0760721, 0.0637218, 0.0214337, -0.0421453, 0.0811363, 0.0573807, 0.0187238, 0.17386, -0.00442578, 0.172589, -0.0526332, 0.0416616, 0.0949221, 0.126486, -0.0536566, -0.018229, 0.086492, -0.121071, -0.13793, 0.0173363, 0.122151, -0.00701089, 0.076774, -0.207115, 0.224563, -0.0755955, -0.0360754, 0.19649, -0.168301, 0.0267388, -0.0154096, -0.120501, -0.116562, 0.0352466, 0.0885101, 0.0115948, -0.0693187, -0.0211127, 0.0309877, 0.174217, 0.0206971, -0.169591, -0.0829519, 0.0441975, 0.169381, -0.0362878, -0.0485478, -0.00219758, -0.132067, 0.141992, 0.0595154, 0.0778337, -0.0693959, -0.00276446, -0.0998046, 0.00209051, -0.100138, 0.111763, -0.0356408, -0.212159, -0.0540357, -0.143054, -0.0272808, 0.0166601, -0.0294186, -0.23846, -0.00533632, -0.155084, 0.199392, -0.14004, 0.0339829, 0.103592, -0.0463171, 0.073543, -0.0721337, 0.150905, 0.113748, 0.0291408, 0.215022, -0.0634091, -0.00653872, 0.140715, 0.0929447, -0.107508, 0.167422, -0.0121357, -0.0484082, 0.0477148, -0.0925727, -0.0530302, 0.0503437, 0.211811, 0.018744, 0.148476, -0.0104619, 0.0152567, 0.119244, 0.046351, 0.0561614, 0.136482, 0.0688266, 0.107148, 0.0504133, -0.140317, 0.041634, -0.00396106, -0.048545, 0.0699575, -0.0573504, 0.0131888, -0.0774869, 0.16699, -0.0773473, 0.081909, 0.00435651, -0.00943217, 0.0937566, -0.193143, -0.0241885, -0.0613232, 0.0581738, -0.000185881, 0.12172, -0.0488062, 0.121388, -0.0829603, 0.024864, 0.144485, -0.0514711, 0.0830583, -0.0754654, -0.111164, -0.0601812, 0.0299847, -0.0724591, 0.0429179, 0.0903786, -0.0234581, 0.0243458, 0.00616622, -0.0336339, -0.174261, -0.0382283, -0.0627091, -0.00224813, -0.0196817, -0.0303906, 0.00824406, 0.0573912, -0.0267601, -0.0764232, 0.136562, 0.0580324, 0.0511559, -0.00919298, -0.121646, -0.0192784, 0.0742787, 0.00376174, -0.134202, -0.0380936, -0.153849, 0.00626889, 0.0391531, 0.017847, -0.23006, -0.0179268, -0.0322594, 0.266931, -0.0825773, -0.0352129, 0.0103576, -0.000490254, 0.0799896, -0.0884804, 0.174202, 0.00269747, -0.00432867, 0.33629, -0.0931446, 0.0386594, 0.11094, 0.0394511, -0.105151, 0.317199, -0.0207778, -0.0521766, 0.0488256, 0.0541447, -0.0333986, 0.000266416, 0.153278, -0.0136785, 0.120664, -0.0705082, -0.0748671, 0.272051, 0.107008}, {-0.0668649, 0.0216743, 0.116588, 0.195004, 0.102766, 0.0378759, 0.0442215, -0.0360392, -0.100082, 0.17506, -0.121095, 0.030337, -0.163571, 0.120594, -0.0173539, 0.179223, -0.109491, 0.0646513, 0.0743227, -0.124934, -0.157418, -0.045928, -0.0128819, 0.0563006, 0.0362915, 0.0404556, 0.208378, -0.162943, 0.0607752, 0.257041, -0.0853569, 0.0794088, -0.106355, -0.214583, -0.102488, 0.0100122, 0.0785389, -0.076995, 0.069693, -0.101157, 0.244057, 0.0306549, -0.00642068, -0.211827, -0.0727163, -0.0471314, 0.0364279, 0.0268527, -0.08469, 0.061732, -0.0434185, 0.00147858, 0.024561, 0.0363854, -0.015705, 0.110262, -0.051157, -0.0848, -0.0359652, 0.0716157, 0.0594587, -0.163539, 0.0054713, -0.192097, 0.0449875, 0.228464, 0.188588, -0.195377, 0.0439874, -0.0823264, 0.193505, -0.129401, 0.0233654, 0.0221806, 0.00365965, 0.0231933, -0.0314233, 0.157013, -0.0406147, 0.142987, 0.295783, -0.254694, 0.0205779, 0.137219, 0.111782, -0.108667, 0.183097, 0.105755, 0.0744192, -0.0181729, 0.0638723, -0.0254778, -0.120283, 0.170556, -0.0374742, 0.0193913, -0.144114, 0.00989124, 0.304318, 0.132587, -0.0307817, 0.0277539, 0.10203, 0.113705, 0.0171186, -0.0839079, 0.217103, 0.00524305, -0.193913, 0.11597, -0.129482, 0.0397199, -0.0694528, 0.0711755, -0.0547493, 0.102262, -0.00989592, -0.0158894, 0.0750393, -0.191903, -0.139798, -0.0248069, -0.0488273, 0.188301, 0.0423322, -0.0608413, 0.17635, -0.0190126, 0.0291949, 0.104702, -0.11624, 0.0552286, 0.00472545, -0.283886, -0.0407229, -0.050327, 0.0825638, -0.0485936, 0.0192748, -0.11185, 0.268363, 0.0362616, -0.049955, -0.147801, 0.100498, -0.0557355, -0.0339948, -0.0811009, 0.00210856, -0.00784941, 0.0739925, 0.109756, 0.0393523, 0.123748, -0.135455, 0.0802397, -0.178673, -0.0859052, 0.0231147, 0.0703055, -0.0115187, -0.0640563, 0.0492794, -0.264826, 0.0448831, 0.167897, 0.160114, -0.221525, -0.0458527, -0.10584, 0.246799, -0.17143, 0.0154952, 0.0169815, -0.0556771, -0.0450108, -0.126915, 0.0746942, 0.0815556, -0.0314885, 0.0904289, -0.204325, 0.038672, 0.0772295, -0.0490231, -0.132411, 0.343722, 0.100354, -0.0519354, -0.0316029, 0.0925186, -0.103225, 0.032458, 0.0808563, 0.157871, 0.0280185, -0.169001, 0.0361736, 0.222754, 0.0295851, -0.0332991, 0.00600684, 0.0838732, 0.260184, 0.068093, -0.003311, 0.166756, 0.0363817, -0.0907249, 0.201644, -0.048056, -0.0546953, 0.00199847, 0.177592, -0.0295304, 0.039449, -0.161356, -0.02793, 0.0767632, -0.0956094, 0.04105, -0.0579981, -0.00696933, 0.278786, 0.0750798, 0.107394, 0.0680216, 0.0302185, -0.0143078, 0.199325, -0.0544732, 0.0409952, 0.0670056, -0.134763, -0.148718, 0.000648992, 0.0750255, -0.151955, 0.0920017, -0.140289, 0.334799, 0.11469, -0.11541, -0.00836286, 0.106231, -0.114996, -0.0536889, -0.0366854, 0.0855391, -0.110679, -0.00284578, 0.157901, -0.0518034, 0.0478061, -0.104993, 0.0160586, 0.0174518, -0.171307, -0.0498932, -0.0636583, -0.0565747, -0.0142552, -0.0474992, -0.0991225, -0.0303619, 0.156168, 0.211203, -0.137964, -0.119706, -0.137839, 0.161272, -0.171485, -0.0247902, -0.131722, -0.271186, -0.0412135, 0.168999, -0.0542987, 0.0653475, -0.247144, -0.0865782, -0.0191236, 0.0482375, -0.000267632, -0.0406092, -0.0202946, 0.277265, 0.0266186, 0.0363536, 0.0944873, 0.141345, -0.251106, 0.0224802, 0.0451022, 0.192124, -0.113022, 0.0171071, 0.0329253, 0.266714, 0.0438435, -0.0640559, -0.0156175, 0.0290035, 0.232504, -0.0974651, 0.185621, -0.0154666, 0.138154, -0.15535, 0.0665265, -0.0862275, -0.142123, -0.0735241, 0.0894347, 0.0194766, 0.0821403, -0.00979724, -0.0731658, -0.0348866, -0.00416265, -0.0317189, 0.0780304, 0.144262, 0.143585, 0.129474, 0.258726, -0.194782, -0.0010529, -0.0725256, 0.0196543, 0.0520464, 0.080884, 0.124042, -0.189927, -0.232189, -0.100356, -0.110244, -0.0762608, -0.0100322, -0.145392, 0.208135, 0.148226, -0.18716, -0.181433, -0.181019, -0.108948, -0.0336105, -0.0313254, 0.215784, 0.0719306, 0.19957, 0.124155, 0.0535348, 0.148907, -0.0554094, -0.129114, -0.000615373, -0.129437, -0.0112019, -0.0440146, -0.000252495, 0.0177183, -0.00576887, -0.137028, -0.0199173, 0.160025, 0.238574, -0.0984782, -0.0807655, -0.0345743, 0.116301, -0.222408, -0.0682003, -0.119159, -0.264778, -0.0759272, 0.162482, 0.00840652, -0.0527105, -0.374939, -0.0912292, 0.047088, 0.136965, -0.0143055, -0.0737891, 0.0817722, 0.140729, 0.066289, -0.0473797, 0.077903, 0.201898, -0.261719, 0.0795878, 0.0836955, 0.154431, 0.00211974, -0.101842, 0.00722978, 0.271012, 0.020355, -0.124544, -0.0450189, 0.137619, 0.187162, 0.0178172, 0.0509894, 0.0309589, 0.0105884, -0.254379, 0.0966051, 0.0452774, -0.187959, -0.0499564, 0.113387, -0.0635598, -0.0334963, 0.10609, -0.0325323, -0.113019, 0.158876, -0.0132065, 0.0806875, 0.143562, 0.0259742, -0.00802157, 0.217175, -0.19786, -0.108683, -0.146895, 0.0107452, 0.101184, 0.117093, 0.214508, -0.288423, -0.204505, -0.146775, 0.00312916, -0.0678517, 0.0299805, -0.200423, 0.217144, 0.00623882, -0.282895, -0.264767, -0.231214, -0.294672, -0.175168, 0.0819655, 0.176745, 0.0689644, 0.163003, 0.0797385, -0.0470473, 0.198517, 0.068746, -0.247844, 0.0579347, -0.12026, 0.00874838, -0.107508, -0.0948903, 0.0943214, 0.016695, -0.0493634, 0.0253611, 0.0225256, 0.250784, -0.0973664, -0.0653455, -0.0936096, 0.264251, -0.331738, -0.0199158, -0.179977, -0.253325, 0.0207871, 0.144851, 0.0473987, -0.0931773, -0.323182, -0.0258133, 0.0728748, 0.0909942, -0.0201654, 0.0476271, 0.010129, 0.15872, 0.0782353, -0.0779323, 0.198422, 0.192002, -0.257895, -0.027278, 0.0833267, 0.0797619, -0.104653, -0.123696, 0.101091, 0.170683, 0.0904055, -0.0944049, 0.0848416, 0.0361867, 0.193065, 0.0347643, 0.199782, 0.144199, 0.0683943, -0.144321, 0.0818778, -0.0761478, -0.0981107, 0.0686832, 0.1764, -0.0612185, -0.12978, 0.132533, 0.0779853, -0.0693581, 0.0823929, -0.00271136, 0.209685, 0.291829, 0.0705557, -0.0344254, 0.11986, -0.195473, -0.0372581, -0.172624, 0.118421, 0.00115286, 0.155689, 0.203908, -0.266849, -0.256796, -0.0347208, -0.00882159, -0.027794, 0.0430007, -0.239104, 0.238828, -0.0115373, -0.265222, -0.201406, -0.241958, -0.260669, -0.0809043, -0.0542816, 0.209217, 0.150586, 0.268685, 0.175533, -0.076873, 0.0563821, 0.019575, -0.14454, 0.0775034, -0.0229793, 0.0229596, -0.0550054, 0.05758, 0.172082, -0.00821244, -0.0564291, 0.0443235, 0.0341932, 0.23405, -0.0402802, -0.0904786, 0.0369617, 0.202192, -0.161423, -0.108586, -0.00825988, -0.0968061, -0.0675721, -0.0143852, 0.0110855, -0.125351, -0.123125, 0.0251371, -0.030647, 0.0400267, 0.0201343, -0.00530424, -0.047008, 0.100872, -0.0197892, -0.0476957, -0.00766711, 0.157899, -0.138718, 0.000912841, 0.0364404, 0.112143, 0.0445746, 0.0707343, 0.0176704, 0.202464, -0.0214054, 0.0494524, 0.00466543, 0.193629, 0.146809, 0.0405036, 0.21079, 0.170231, -0.0216346, -0.128464, 0.015025, -0.0368037, 0.0656988, 0.0717245, 0.171974, 0.0554726, 0.0248173, -0.0363645, -0.00832003, -0.0237538, 0.154238, 0.118985, -0.0139886, 0.141242, 0.104534, 0.0137659, 0.158332, -0.0133241, 0.0205018, -0.0289897, 0.0922827, 0.0193372, 0.163276, 0.00677282, -0.089038, -0.0183302, -0.0762757, -0.0335716, -0.00872685, 0.0640696, -0.135714, 0.273382, 0.0524853, -0.140529, 0.0206592, -0.0676921, -0.105911, -0.0904822, 0.0234183, 0.134486, 0.0269026, -0.00268047, 0.125484, 0.0524176, 0.114524, -0.065326, 0.020934, -0.0595951, -0.101994, 0.061338, 0.0347472, 0.0434255, 0.187084, 0.0195517, -0.102464, -0.028069, 0.0430887, 0.123725, -0.104182, 0.0224935, -0.0628651, 0.13782, -0.212226, 0.0257075, 0.00437822, -0.134557, 0.0145465, 0.0967207, -0.106855, -0.104542, -0.00816604, 0.0654737, -0.0729606, 0.0326431, 0.056775, 0.100293, -0.105366, 0.115889, 0.016758, -0.016886, 0.0583707, 0.0987715, -0.0763711, -0.0417535, -0.0436332, 0.109984, -0.0280903, -0.0504069, 0.0981156, 0.182753, 0.0642227, -0.0605851, -0.0816804, 0.0635881, 0.0559639, 0.0154516, 0.15831, 0.149536, 0.013929, -0.109273, 0.0217742, -0.0646202, -0.0414897, 0.00428601, -0.0043639, 0.0417282, -0.104965, 0.0208535, -0.0555586, -0.00854692, -0.0629418, -0.103265, 0.0138461, 0.0142593, -0.0311212, 0.00942435, 0.121049, -0.0953507, -0.103571, 0.00461015, 0.0778136, -0.0652015, 0.112422, 0.00630002, -0.0583234, 0.079068, 0.00556618, 0.0690488, -0.0334352, 0.106848, -0.108749, 0.147893, -0.122889, -0.0285971, -0.0618279, -0.106205, -0.0229142, -0.0343207, 0.0509043, 0.0465486, 0.0456511, 0.148954, 0.069393, -0.00904726, 0.0412757, -0.0868138, -0.0777219, -0.0159743, -0.0791047, 0.0200234, 0.0429411, -0.0497356, 0.0831294, -0.0525622, -0.165343, 0.0538534, 0.170451, 0.127508, -0.125138, -0.0369925, -0.126984, 0.172398, -0.218923, 0.00249986, 0.0213524, -0.187488, 0.00656744, 0.146941, -0.0756328, -0.104202, 0.0308388, 0.198565, -0.148368, 0.0739511, -0.0243952}, {0.124196, -0.0704779, 0.0848859, 0.0200856, -0.0712512, 0.0738374, 0.140255, -0.251212, -0.0653073, -0.000201258, 0.0511844, -0.00126253, -0.0523254, 0.148483, 0.135591, -0.0103246, -0.0532685, 0.0751782, 0.0925335, -0.0443293, 0.162609, 0.137348, 0.109304, 0.0580197, -0.1664, 0.0879068, -0.0562651, -0.0404149, -0.0201334, 0.103295, 0.00966966, -0.130367, 0.0887939, -0.0572096, 0.066992, -0.00452936, 0.0163448, 0.0936394, 0.141935, -0.0018692, -0.0322826, -0.0365128, 0.036459, -0.157437, -0.0153514, 0.0657353, 0.0655375, 0.128456, 0.106731, -0.0480072, -0.043644, -0.0929095, -0.0465205, -0.066027, 0.0607721, -0.0590352, 0.201815, -0.130327, 0.0197112, 0.0123842, -0.0314633, 0.00980638, -0.0123091, 0.0372017, 0.122826, 0.0283757, 0.169587, 0.0513874, -0.0344915, 0.00936111, -0.0312667, -0.0344028, -0.0563684, -0.0500602, -0.0671594, 0.0236038, -0.122174, 0.0482301, -0.0284163, -0.0569133, 0.0334962, 0.142796, 0.0622979, -0.0104978, 0.0984773, -0.0739887, 0.0322841, -0.0565496, -0.0936803, -0.0463458, -0.0623674, -0.0610367, 0.0568928, -0.057221, -0.113472, 0.0455578, 0.000880984, -0.0232552, 0.0359829, -0.0030258, 0.0840238, -0.131566, 0.0657173, 0.139093, -0.0370309, -0.00518832, 0.0331969, -0.128095, -0.121826, 0.0557213, -0.0196294, -0.0517332, -0.0781477, 0.0120887, 0.125662, -0.0454649, 0.0188463, 0.06312, 0.0448401, 0.034684, 0.0326766, 0.0465015, 0.0881282, -0.0378967, -0.112701, 0.0272617, -0.0497362, -0.0756637, -0.0750375, -0.0156176, -0.139653, -0.0920369, 0.108733, -0.00747128, 0.0527545, 0.0843949, 0.00112793, 0.028379, 0.119228, -0.0155032, 0.00355685, -0.041087, -0.0776168, -0.0619524, -0.156417, 0.0389746, 0.100868, 0.0639648, 0.0692723, -0.0236274, -0.0741085, -0.0465813, 0.104682, -0.0682286, 0.145818, -0.0916568, 0.120328, -0.122198, -0.0178018, 0.00568182, -0.0394358, -0.0425048, -0.0131772, -0.0593021, 0.0918878, 0.136101, 0.207117, 0.0162575, -0.0985832, 0.00230111, 0.0423004, 0.00443776, 0.0365206, -0.0781181, -0.0653608, -0.0813165, -0.0319305, -0.0170577, 0.0400326, 0.0325812, -0.0436165, 0.104469, 0.0994654, -0.0706846, 0.046832, -0.0113022, 0.0598639, -0.0152118, -0.0916507, -0.041, -0.0391741, -0.0593745, 0.116571, 0.00269887, -0.0886394, 0.0324683, 0.014974, -0.0472641, -0.0117151, -0.0270956, 0.0724215, -0.122062, 0.0709314, 0.051793, -0.0231732, 0.0924956, 0.00817823, -0.0552226, -0.0757953, 0.0678748, 0.04835, -0.017182, -0.0326482, 0.0906318, 0.0323501, 0.0249466, -0.00340105, 0.0755503, 0.0130872, -0.0175118, 0.0417256, 0.0357784, 0.00771083, -0.0540508, -0.0942085, 0.0572932, -0.0146549, -0.195117, -0.0570454, 0.0179988, -0.0457331, -0.0882831, 0.0496051, 0.0394161, 0.0262072, 0.0785754, -0.0393713, 0.102589, 0.110929, -0.0799279, -0.156464, -0.00655735, -0.138024, -0.0128634, -0.0765581, 0.0576282, 0.0232737, 0.143388, 0.155384, -0.00463971, -0.0578949, -0.0122858, 0.0192599, -0.0655167, 0.11682, -0.0978044, 0.103668, -0.145605, -0.0210496, 0.0271747, -0.0568054, -0.000477126, -0.116233, -0.00753199, 0.0126262, 0.0361062, 0.166455, 0.00478206, -0.0326279, 0.072104, 0.0499966, -0.0728743, -0.0823821, -0.0497649, -0.0765926, -0.0355852, 0.0695951, 0.0379197, 0.0501226, -0.0222217, 0.0764553, 0.0531825, 0.0771437, -0.11322, -0.0102537, -0.0613435, -0.00263214, -0.0980256, -0.0211961, -0.060358, -0.0578439, 0.015916, 0.00374672, -0.107664, -0.0535591, -0.0162578, 0.0299128, -0.06354, -0.0333605, -0.0798573, 0.0762605, -0.126952, 0.103192, 0.127761, -0.000573553, 0.112687, 0.120317, -0.048537, -0.0510854, 0.120106, -0.0198342, 0.00811351, 0.0426026, 0.0519267, 0.00827304, 0.0310893, -0.0442282, 0.0391059, 0.0115564, -0.0110345, 0.0983298, 0.0189702, 0.0297199, -0.0588643, -0.139694, 0.0270705, -0.0694521, -0.110163, -0.0182853, 0.0245643, -0.164506, -0.101704, 0.110481, 0.0301741, -0.0158771, -0.0439035, -0.00592483, 0.0989613, 0.0984996, 0.0038329, -0.0912992, -0.124016, -0.0591564, -0.108481, -0.011019, 0.0951168, 0.102172, 0.145163, 0.0802036, -0.111892, -0.0982142, -0.0772811, 0.0439171, -0.0395366, 0.0420419, -0.143472, 0.0150661, 0.0263519, 0.104623, 0.0360473, -0.0282449, -0.0673285, 0.00481919, -0.0604703, 0.0685756, 0.0638846, 0.107818, -0.078008, -0.0153679, 0.0128034, 0.0635822, 0.013184, -0.0681561, -0.104359, 0.00849921, 0.0351441, -0.0358151, 0.120116, 0.0183551, 0.0623303, -0.0216178, 0.162986, 0.131703, -0.106217, -0.00121247, -0.051098, 0.039857, -0.054207, -0.0437513, 0.0484347, -0.116497, 0.0450553, -0.0146183, 0.036873, -0.0883911, -0.0376991, 0.0780974, -0.101282, -0.00800298, -0.0788955, 0.100414, -0.0719492, 0.0142249, 0.0612742, 0.076753, -0.0321365, -0.0272677, 0.00577427, -0.0143094, 0.0858328, -0.0191605, -0.0462048, 0.0420852, -0.0109085, 0.00833896, 0.0268069, 0.0801676, -0.0380472, 0.0872298, -0.0177549, 0.103479, 0.131226, 0.102065, -0.0518674, -0.0790359, 0.0678327, -0.0186913, -0.0401939, -0.100702, 0.138903, -0.0548014, 0.00474067, 0.0958249, -0.0680049, 0.0735854, -0.0417167, -0.0771102, 0.133095, -0.0306129, 0.0543885, 0.0485543, -0.0529407, -0.0162413, -0.0990369, 0.0348984, -0.0349215, -0.0513796, 0.105086, 0.105329, -0.125681, -0.114426, -0.099712, -0.0286053, -0.0946082, 0.0844605, -0.139171, 0.086229, -0.10137, 0.0957327, -0.0981942, -0.0367596, 0.0177246, 0.030829, -0.026845, -0.0333792, 0.0868875, 0.022388, -0.0376946, 0.00849393, -0.0291339, 0.0154731, 0.0731752, -0.0412235, -0.0707539, -0.0702813, 0.0212665, 0.0394099, 0.00014155, 0.0579898, -0.0412322, -0.0322659, 0.0735252, 0.0396141, -0.0303828, -0.0990578, 0.0177968, 0.0379517, -0.115325, 0.0539758, -0.0458264, -0.0814205, -0.0269576, 0.0536923, -0.0301298, -0.106864, -0.0189572, 0.0567232, 0.0369544, 0.0363197, -0.0636476, -0.0145187, 0.000479721, 0.0772545, -0.0213002, -0.0321384, -0.0351984, -0.0139784, -0.0573333, -0.0711817, 0.0458099, -0.0126672, 0.0250159, -0.0321509, 0.0503785, 0.00417501, 0.0355585, -0.00315213, 0.0406209, 0.0154058, 0.065952, -0.0108119, 0.0568328, 0.089919, -0.0725841, 0.0162614, 0.00202731, 0.0100899, -0.0752565, 0.00613713, -0.000179179, -0.0235658, 0.0330482, 0.0907124, 0.0244996, -0.0161558, -0.0137259, 0.0236233, -0.00438553, 0.0896472, 0.0130588, -0.0168411, -0.0703704, 0.0555724, -0.0284447, 0.000778057, 0.0247951, -0.0510727, -0.0223547, -0.0382301, -0.0819501, 0.0654208, -0.0697521, 0.0433533, -0.00605005, -0.0214298, 0.00157582, -0.00578543, -0.0361783, 0.0451174, -0.0368056, -0.0441608, 0.0311084, -0.0351074, -0.0751813, 0.105159, 0.0818203, 0.0897602, -0.0556261, -0.0836301, -0.013891, -0.00870058, 0.00177245, -0.00228782, -0.078272, -0.0659439, 0.0176296, -0.107016, -0.00648519, 0.00141987, -0.0425545, 0.0675967, 0.0612002, -0.00406298, -0.0229325, 0.0412483, 0.0292367, -0.0436942, 0.0159116, -0.0380702, -0.105642, -0.0904396, -0.0240669, 0.0624104, -0.0622282, 0.00161068, 0.0191722, 0.0865944, 0.0627483, -0.0418021, 0.0259486, 0.0795225, 0.0563939, 0.0743036, -0.0937676, -0.0381669, 0.0617948, -0.0394527, -0.0730091, -0.027535, 0.105421, -0.0113715, -0.0302676, 0.0268765, 0.00312958, 0.0442097, 0.049627, -0.0628163, -0.0284164, -0.0309268, -0.00801933, 0.023099, 0.00679252, 0.110993, 0.0302655, -0.0339017, -0.0625639, -0.0608545, -0.00329732, -0.0242956, 0.0464168, -0.0877301, -0.085702, 0.07283, 0.00296552, -0.032519, -0.0372366, -0.0135485, 0.0312415, 0.0877514, -0.0171657, -0.00140272, -0.0629714, 0.0618689, 0.0455418, -0.0566099, 0.0293626, -0.00288143, -0.00584148, -0.0388069, 0.0334773, 0.0554697, -0.0580833, -0.0293585, 0.0028053, -0.0191916, -0.0738473, 0.0264677, -0.00573721, 0.0168259, -0.0303252, -0.0536633, 0.0566316, -0.0178641, -0.0404176, 0.0945143, 0.0778169, 0.0734319, -0.0369324, -0.0800029, 0.0730824, 0.0236953, -0.0787478, 0.0227607, -0.117777, -0.0191867, 0.0103269, 0.0219242, -0.136171, 0.107562, 0.135659, 0.0310553, -0.00992749, -0.177268, 0.0264701, -0.026513, 0.0811949, -0.0463385, -0.230524, 0.156536, -0.129967, -0.0591801, -0.00175815, 0.0739607, 0.0328222, -0.117879, 0.193936, 0.099434, -0.0463446, 0.14403, -0.0558771, 0.238239, 0.0487952, -0.0222895, 0.0708714, -0.0590158, 0.0543756, 0.257506, -0.00109068, -0.000500393, -0.119715, 0.11034, -0.0549063, 0.00115569, 0.0251095, -0.0411458, -0.0989568, 0.0801079, 0.0063313, -0.0327288, 0.0553933, -0.0913895, -0.00411813, 0.000918545, 0.0272306, 0.149178, 0.101414, 0.00415418, -0.0132412, 0.0742841, -0.144074, -0.209006, -0.161982, -0.151656, -0.0673529, -0.0610716, -0.0216185, -0.0734889, 0.0112684, 0.0217239, 0.0505153, 0.0109631, 0.0757926, -0.143105, 0.0213444, 0.0217989, 0.00090271, 0.0581111, 0.0406525, 0.155922, 0.0172205, -0.0726901, 0.0194912, -0.0395865, -0.109299, -0.0220785, -0.108239, 0.0424858, 0.107931, 0.0592206, -0.0213171, -0.0113737, -0.00736331, -0.0218647, -0.0330219, 0.00709894, -0.0769221, -0.0237412, 0.0362632, -0.018449, -0.0900957, 0.0560028, 0.230172, -0.0133166, -0.128964, 0.0558124, 0.0281529, -0.0145612, -0.0926058, 0.0528628, 0.16956, -0.0300388, -0.0673018, -0.125389, -0.0267049}, {0.0153041, -0.0813565, 0.0405362, -0.270633, 0.0542183, -0.139277, -0.145385, -0.0170847, 0.0373413, -0.0466633, -0.074797, 0.173735, 0.182601, -0.073601, 0.191066, -0.0381891, 0.227227, -0.0530613, 0.0587278, 0.0485565, -0.037497, 0.0767757, 0.234224, -0.124471, -0.0685306, -0.0344098, 0.124893, 0.0251589, -0.0403986, 0.0893197, -0.0676392, 0.031338, 0.0182013, 0.0810563, 0.0823882, 0.0660163, -0.00225621, -0.0164694, 0.0189365, 0.0777762, 0.140972, 0.125284, -0.00873077, 0.011401, -0.076385, -0.0992975, -0.148107, -0.123854, -0.182476, 0.0722432, -0.0660471, 0.0228838, 0.0523168, -0.0175894, 0.0364345, -0.055058, -0.0718084, -0.0584617, -0.155453, -0.0766058, -0.0793239, -0.0145184, -0.00533419, 0.0704543, 0.117039, -0.103165, -0.140245, -0.019056, -0.0442944, -0.0871725, -0.116502, -0.127281, 0.00992366, 0.0764964, 0.0926792, -0.0626021, -0.110469, -0.120918, -0.0331033, 0.0405398, 0.00756407, -0.0350876, 0.0247393, 0.0671317, 0.0399756, 0.0134336, 0.0207972, 0.21417, 0.0722757, -0.0478532, -0.00131584, -0.0415969, 0.0740609, -0.05203, 0.0145011, 0.0374999, 0.0152435, 0.0444448, -0.130828, -0.0548313, -0.0857159, -0.116847, 0.136481, -0.280077, 0.0875083, -0.000176175, -0.0435136, 0.00684029, 0.110978, -0.0535908, -0.101435, 0.162354, 0.209865, 0.035943, 0.207545, -0.0166575, 0.229445, -0.121086, 0.0988123, 0.127992, -0.0289521, 0.0388781, 0.205677, -0.0194925, -0.111261, -0.022875, 0.0755193, -0.016606, -0.0934893, 0.0339836, -0.000164747, -0.0577752, 0.0573271, 0.111747, 0.0351377, 0.0193003, -0.0469765, -0.0223812, -0.040224, -0.0740326, 0.179624, 0.0902711, 0.0517414, -0.0447242, -0.0799015, -0.111481, -0.143424, -0.139613, -0.162023, 0.0359252, -0.0408796, 0.0510616, 0.0883877, 0.0610009, 0.042107, -0.059428, -0.0880972, -0.0984315, -0.0986529, -0.102589, -0.0447195, -0.0570435, -0.0611254, -0.0564011, 0.222215, 0.00290769, -0.0595083, 0.0517219, -0.00753859, -0.130737, -0.0854758, -0.103301, 0.0549257, 0.171711, 0.0649071, -0.0392114, -0.112061, -0.120006, -0.0512711, 0.0568088, 0.0102635, 0.077726, -0.0361986, 0.0547744, 0.0223782, -0.0571045, -0.0687406, 0.260349, 0.0801018, -0.0870024, -0.0104008, 0.0468837, -0.0330269, 0.020498, 0.0774784, 0.119129, -0.0654915, 0.0119155, -0.156063, 0.0125307, 0.0252843, -0.0636021, 0.00888496, -0.22633, 0.0787488, -0.0541096, -0.163644, -0.0420891, 0.0189596, 0.00929348, -0.144423, 0.1522, 0.0729476, -0.0205092, 0.0690582, 0.0471425, 0.0813136, -0.11935, -0.00585005, 0.046003, 0.00811495, 0.0012115, 0.111738, -0.135482, -0.0044222, 0.0358385, 0.106694, 0.0263314, -0.0905693, 0.0594183, -0.000356615, -0.0410381, 0.141738, 0.111284, 0.149647, 0.103026, -0.00155463, 0.0374179, -0.0167192, 0.0346198, 0.193933, 0.16847, -0.037222, -0.0672426, -0.0391758, -0.113514, -0.133676, -0.0366804, -0.236213, -0.0665108, 0.0358297, 0.0542048, 0.02304, 0.0344636, -0.0616264, 0.0322939, 0.0386721, -0.0866059, -0.0186922, -0.0746714, 0.017307, 0.0566718, -0.0772434, -0.0234661, 0.231764, -0.106627, -0.118666, 0.0205478, 0.00646825, -0.0439105, -0.0748705, -0.174995, 0.0760883, 0.0554332, 0.0730542, -0.0712254, -0.0961655, -0.0762916, -0.0782513, 0.0401184, 0.0140984, -0.0336221, -0.00438868, 0.0633593, 0.0582118, 0.0583009, -0.109994, 0.0906028, -0.047417, -0.0719277, -0.0442163, 0.0714179, 0.0434427, 0.0893621, -0.0434532, 0.000345486, 0.0570725, -0.0600982, -0.0323358, -0.104608, 0.00272885, -0.0330348, 0.202985, -0.0564031, 0.0348762, 0.0856758, -0.0439303, 0.00325775, 0.00229622, 0.059861, -0.0103119, 0.127531, 0.0379914, -0.0133411, 0.110655, 0.114825, 0.0764602, -0.148206, 0.0406137, -0.0497628, -0.0269379, -0.0364212, 0.0672029, -0.089741, -0.109693, 0.073982, 0.123796, 0.0409456, -0.0623649, 0.143957, 0.18291, -0.00926681, 0.0990136, 0.0415973, 0.125135, 0.0641111, 0.0867052, 0.0266107, 0.0645605, -0.0468467, 0.0496963, 0.0842035, -0.0247473, -0.119114, -0.0753083, 0.109772, 0.0454111, -0.0640659, -0.0501745, -0.0771133, 0.110521, -0.0504621, 0.0370308, 0.0199648, 0.0746867, 0.0128323, -0.000301338, -0.0584528, -0.042544, -0.0903081, -0.101125, -0.0524012, -0.0110702, 0.095008, 0.110799, -0.0764974, -0.0518558, -0.138528, 0.0392432, -0.0775447, 0.0688808, -0.155581, 0.0421134, 0.0753095, -0.0163065, -0.118644, 0.0444606, -0.0923574, 0.00557313, -0.0777272, 0.142167, -0.0802566, -0.0760008, -0.0115866, 0.0556674, 0.0218281, 0.0333887, 0.144748, -0.0754562, -0.0760429, -0.0459805, -0.0740768, 0.000271936, 0.0419836, -0.0221112, -0.071289, 0.0168649, -0.0607957, 0.0133328, -0.095528, 0.121829, -0.0874111, 0.118229, -0.0698952, -0.0640744, 0.225442, -0.0353985, -0.0477934, 0.0113953, 0.135949, 0.00702003, 0.00405064, 0.0644234, 0.114751, -0.00500613, 0.153478, 0.09252, -0.136757, 0.0459289, -0.0242567, -0.0413056, -0.0113452, -0.0503559, -0.0684974, 0.0189122, 0.223414, 0.182323, -0.0235882, -0.0622043, 0.144079, 0.299913, 0.0165868, 0.0515809, -0.0146829, 0.208118, -0.110455, 0.0176947, 0.0119442, 0.0636389, 0.0831145, -0.0565046, -0.0668942, -0.0289185, -0.227405, -0.0580961, 0.0389742, 0.121147, 0.167896, 0.202886, 0.0761207, -0.00122812, -0.0101809, 0.135782, 0.151033, 0.0526438, -0.0811577, -0.029935, -0.0467481, 0.014499, 0.0427446, -0.129172, 0.0256729, -0.097404, 0.119385, 0.0860718, -0.0671911, -0.11881, -0.126625, 0.0781903, -0.0912411, 0.138538, -0.0411479, 0.160441, -0.00993993, 0.10123, -0.140839, -0.110538, -0.0732329, -0.0335408, 0.0103374, 0.152636, -0.0603752, 0.0364071, -0.0756451, 0.0402842, 0.12096, -0.0750361, -0.00741946, -0.0412845, -0.0884013, 0.0311563, 0.00237856, 0.0227286, -0.0918208, -0.0275761, 0.0939819, -0.0224373, -0.0764194, -0.23525, -0.255237, 0.0305284, -0.0363038, 0.073853, -0.27158, 0.0846168, 0.171414, -0.166144, 0.0579595, 0.0883049, 0.140861, 0.070262, 0.143925, 0.132634, 0.129982, 0.1037, 0.0288494, 0.118173, -0.0817505, 0.100831, -0.0251885, -0.00347916, 0.0343732, 0.0936237, -0.100224, -0.083285, 0.190935, 0.0983, -0.145729, -0.0476105, 0.100682, 0.0890904, 0.0147934, 0.127886, 0.0071133, 0.0609595, 0.0107163, -0.0854122, -0.0570731, -0.12225, 0.0678445, 0.32699, 0.0338831, 0.060661, -0.093681, -0.0691246, -0.0492903, -0.0697973, -0.154893, 0.0146053, 0.0155957, -0.0540376, -0.113096, 0.0660446, 0.102963, 0.0502842, -0.117726, -0.13201, -0.0508193, -0.00620142, 0.0486744, -0.102521, -0.0481275, -0.0726292, 0.109014, 0.214522, -0.147273, -0.190188, 0.0571013, -0.0853871, -0.107383, -0.0972616, -0.0361666, -0.0211122, 0.148163, 0.047934, -0.141378, -0.0356452, 0.0810201, 0.0154827, -0.124783, 0.0188322, -0.0484258, -0.152575, 0.151035, 0.0314064, 0.230149, 0.167742, 0.0809036, 0.0412126, -0.0388831, 0.0739449, 0.0161103, -0.0229241, 0.047113, -0.0103884, 0.051999, 0.05939, 0.0503946, -0.196854, -0.208226, 0.0291353, 0.0208808, 0.0873764, -0.203523, 0.259254, 0.134476, -0.163452, 5.25638e-05, 0.0715966, 0.116957, 0.130103, 0.221419, -0.0184014, 0.0283405, -0.00936805, 0.0748077, 0.260236, -0.138515, 0.0454096, -0.0146429, -0.0605827, -0.0706366, 0.111649, -0.112719, -0.0958098, 0.206739, 0.0955394, -0.198572, 0.0254811, 0.144958, 0.0834753, -0.0487349, 0.201959, -0.110858, 0.10649, 0.196272, -0.226117, 0.00496463, -0.00346451, -0.0288114, 0.322671, 0.253411, -0.0105522, -0.185918, -0.108997, -0.16825, -0.144127, -0.186881, -0.261178, -0.058546, -0.168646, -0.0612206, -0.0483464, -0.0385278, 0.228279, -0.112111, -0.150715, -0.0158983, 0.0471829, 0.0856741, 0.0709016, -0.0291624, -0.0578208, 0.0488889, 0.110762, -0.208218, -0.149798, -0.101196, 0.0143499, -0.0168158, -0.103033, -0.0924184, 0.170026, 0.30104, 0.120335, -0.161008, 0.0409266, -0.0217703, -0.051663, -0.146516, 0.12638, -0.158406, -0.194431, 0.21742, 0.0320468, 0.3141, 0.177757, 0.193479, 0.107492, -0.0330429, 0.0514033, 0.00767562, -0.0587441, -0.0589191, 0.0758478, -0.00988355, -0.0498206, 0.0754121, -0.152152, -0.23313, -0.0743313, 0.11752, 0.0608725, -0.227128, 0.279823, 0.137402, -0.283817, 0.0428917, -0.00373937, 0.288153, -0.0142598, 0.233127, 0.0556546, -0.0438119, -0.0324971, 0.186144, 0.135307, -0.137178, -0.00398925, 0.018141, 0.00110556, 0.0167004, 0.150314, -0.122081, -0.158915, 0.0481634, 0.0908356, -0.0500914, 0.0251947, 0.25905, 0.0283286, -0.00781997, 0.154138, 0.013943, 0.106722, 0.125939, -0.216068, 0.0632869, -0.10712, -0.0815332, 0.34674, 0.222877, 0.067949, -0.0319514, 0.010147, -0.247108, -0.171434, -0.146044, -0.217414, -0.011269, -0.0613899, 0.0889914, -0.0630555, -0.021074, 0.217434, 0.0216601, -0.0564166, -0.0677084, 0.0942095, -0.0112074, 0.0574758, 0.116686, -0.196676, 0.141923, 0.184938, -0.0292619, -0.193117, -0.0936383, 0.00779704, -0.140374, -0.226472, -0.0421926, 0.157298, 0.299176, 0.119207, -0.168047, -0.0032591, 0.0971031, 0.146939, -0.0399725, 0.0170998, -0.0147279, -0.176431, 0.246474}, {-0.0493139, 0.170291, 0.28313, 0.19725, 0.0738228, -0.0899025, -0.00568812, -0.0147544, -0.014988, -0.0357938, 0.0712798, 0.0843059, 0.0351196, 0.112753, -0.134948, -0.126026, 0.0128502, 0.132417, 0.0924818, -0.17614, 0.246325, 0.0661189, -0.3069, 0.00909562, -0.00199119, 0.295597, 0.111162, 0.228727, 0.158966, 0.0121272, 0.0440968, 0.224583, 0.118526, -0.0952985, 0.152122, 0.0495613, 0.0339484, -0.0836191, 0.185927, -0.188872, -0.197019, 0.0626096, -0.0290258, -0.0225922, -0.000908197, 0.116373, 0.02282, -0.0444203, 0.224045, -0.0289961, 0.0497027, 0.0574221, -0.216133, 0.0347649, 0.0203532, -0.0799796, 0.232962, 0.198113, 0.0418773, -0.0787895, 0.000196355, -0.181704, -0.246227, -0.238869, -0.234489, -0.0175843, -0.00412394, 0.018655, -0.0787281, -0.0291718, 0.175048, 0.0712508, -0.187332, 0.0307529, 0.0282709, 0.0429373, 0.0221802, 0.096775, -0.197541, 0.11951, 0.123148, -0.132881, -0.261837, -0.0835819, -0.0431785, -0.106622, -0.139679, -0.025672, 0.164827, 0.225745, 0.122614, -0.133216, -0.0179445, 0.0728694, 0.0640479, -0.0707243, 0.0304304, -0.0199454, -0.125662, 0.19396, -0.0768893, 0.119353, 0.23561, 0.303696, 0.0924236, -0.128721, -0.102021, -0.0343191, 0.0236443, -0.149888, -0.0472055, -0.0373207, -0.0292817, 0.040163, -0.134244, -0.16438, -0.0863082, 0.0783888, 0.194166, -0.239548, 0.232045, 0.12394, -0.311366, 0.0196019, -0.0307516, 0.245059, 0.0821927, 0.227199, 0.0373388, 0.0803504, 0.145995, 0.117894, 0.202262, -0.188037, 0.158176, -0.0810711, 0.0197989, 0.048259, 0.0487585, -0.116985, -0.0760159, 0.00185917, 0.0148789, -0.0145358, 0.0391401, 0.253014, -0.0257092, 0.0629856, 0.295512, 0.0641339, -0.0151771, 0.181916, -0.0487441, 0.100286, -0.040591, 0.0630808, 0.310121, 0.35546, 0.0403301, -0.0245225, 0.0818759, -0.222455, -0.173508, -0.0270667, -0.236394, 0.0551024, -0.00561441, 0.017532, 0.0481427, 0.0184139, 0.231103, -0.0161222, -0.129758, 0.024717, 0.200129, -0.0713844, -0.0155093, 0.184975, -0.235046, 0.151121, 0.191969, -0.0635377, -0.294874, 0.012768, 0.113849, -0.0886872, -0.121154, 0.0949923, 0.152414, 0.265757, 0.129361, -0.086232, -0.00970212, 0.0691294, 0.12046, 0.0226586, 0.00302518, -0.20337, -0.240305, 0.205682, -0.0594086, 0.142162, 0.220772, 0.304106, 0.104882, -0.0557456, -0.074427, 0.0188325, -0.0605198, 0.0543539, 0.0142008, -0.0607834, 0.0365692, -0.0784611, -0.0382565, -0.0729231, -0.0635692, -0.104848, 0.0947497, -0.197191, 0.0610292, -0.0248777, -0.197834, 0.0748898, -0.184328, 0.176219, -0.031997, 0.175632, 0.0863107, 0.0433382, 0.0774651, 0.0799667, 0.120781, -0.130076, 0.0837034, -0.0582362, 0.03613, 0.0839014, -0.0713011, 0.0464967, 0.0473876, -0.0136701, -0.0524473, -0.0232949, -0.091342, 0.140534, -0.0523164, 0.0553865, 0.130577, -0.0690486, 0.0530206, -0.0165769, -0.0762888, 0.0746094, -0.0815239, 0.0651884, 0.138709, 0.038697, -0.0561254, 0.103787, 0.0503524, -0.0438752, 0.0871896, 0.173757, 0.00756785, 0.0261082, 0.00734264, 0.0782353, -0.0475941, 0.0463338, 0.108134, -0.0930002, 0.0428864, -0.0824611, 0.112263, 0.0137923, 0.0755639, 0.0830355, -0.16816, 0.0293517, -0.102466, -0.0706557, -0.153069, -0.0777377, -0.0571836, 0.0317836, 0.030586, 0.147766, -0.0322977, 0.0816277, -0.0316525, -0.0273604, -0.0355559, 0.0421115, 0.02485, -0.00120087, 0.0023917, -0.0647814, -0.096966, 0.0984978, -0.0575358, 0.0342722, 0.0441083, 0.0186943, 0.0908698, -0.127444, -0.125803, -0.02815, -0.0205286, -0.0122187, -0.0441289, -0.0799707, 0.0647882, -0.0375068, 0.0223367, 0.0291238, 0.0211141, -0.0145468, 0.00817956, -0.0752491, -0.00624972, 0.0513437, 0.0130031, -0.0618646, -0.024926, 0.187426, -0.00779805, 0.026625, -0.0122626, 0.00638222, 0.0503433, 0.139267, 0.104758, -0.138155, 0.039239, -0.00567377, -0.0111785, 0.0588194, 0.0203893, 0.0428771, 0.0356337, -0.0297426, -0.0617138, -0.00558753, -0.107752, 0.0356622, 0.135242, 0.023229, 0.0357437, -0.0135803, 0.101757, -0.00377582, 0.05826, -0.000935612, 0.0543231, 0.0788978, 0.0271064, 0.139533, -0.019591, 0.0687137, -0.0252286, -0.0740052, 0.0987606, 0.120597, -0.0190816, 0.0625356, 0.111173, 0.0543249, 0.0155322, 0.107913, -0.0182276, -0.0284119, 0.0668633, -0.0156844, 0.14002, -0.00784704, -0.00904194, 0.00507531, 0.00832514, -0.0917497, -0.0106452, -0.0689119, -0.100042, -0.0933366, 0.00377372, -0.0781695, -0.00816974, -0.0161519, 0.0128517, 0.00567075, -0.0591789, -0.0812747, -0.0269533, 0.0681179, 0.140354, 0.0100616, 0.0129403, -0.0901477, -0.0621031, -0.0839952, -0.0931689, 0.0259506, 0.0774287, 0.110146, -0.0515299, -0.0677948, -0.0509178, 0.0030124, -0.0395731, 0.0255595, -9.68393e-05, -0.0595543, 0.0302243, 0.0940039, 0.0689343, -0.0712521, -0.0202488, -0.0537592, 0.0433464, -0.158559, 0.0048994, 0.163163, -0.0863432, 0.080833, -0.139488, 0.0442196, 0.0574216, 0.0637142, 0.0890286, 0.0144545, -0.0312372, 0.135853, 0.0297782, -0.147802, 0.00824702, 0.0230711, -0.00395774, 0.0383927, -0.0265324, 0.115755, -0.0158048, 0.105878, 0.0626129, -0.0346724, -0.0394742, 0.049075, 0.0193797, -0.00131863, 0.09963, -0.0443083, -0.0697985, -0.0826264, 0.0986006, -0.0304396, -0.0605786, -0.0586407, 0.167582, 0.127313, -0.0817976, 0.138076, -0.0193935, -0.0868816, 0.022533, 0.0886753, -0.0335615, -0.0821711, 0.147691, -0.0676389, 0.0273107, -0.0102182, 0.0842875, -0.012988, 0.0149542, 0.0361896, -0.0275859, -0.0492592, -0.0116712, 0.107908, -0.0291199, -0.00811004, -0.0340436, -0.159323, -0.0264548, -0.0648232, 0.0370848, 0.0289627, 0.0874657, 0.132103, -0.0292354, -0.0172187, -0.0648948, -0.145675, -0.056867, -0.0217392, 0.103014, -0.0276944, 0.0852727, -0.0598939, -0.12578, 0.0588072, 0.0276099, 0.0615155, -0.0821491, 0.119384, -0.0284685, -0.0393255, -0.0699341, -0.0818065, 0.0150841, 0.0329213, -0.00297927, -0.0956841, 0.0591738, -0.0321251, -0.0365416, -0.0926892, 0.000281657, -0.134363, 0.0499247, -0.123866, 0.0105877, 0.0383651, -0.109043, 0.0431118, -0.109822, 0.0611307, -0.0192846, 0.0469696, 0.00139243, -0.0829219, 0.0296601, 0.110808, 0.0500237, -0.129828, 0.0289713, -0.0656156, 0.0228779, -0.0357619, -0.0917999, -0.00420562, 0.0620748, 0.0299591, 0.0692556, -0.0112611, 0.000903821, 0.0481813, 0.0195801, 0.0785166, 0.0899927, 0.0839548, -0.0651738, -0.0689985, 0.0209505, 0.0217966, 0.0176098, -0.00774091, 0.132888, 0.118281, 0.0401559, 0.0312898, -0.00600385, 0.0149874, -0.0313439, -0.00515378, -0.109969, 0.0731513, 0.0233168, -0.0488387, 0.0370533, 0.0158754, 0.0842091, 0.0672451, 0.137054, 0.0347259, -0.0105186, -0.085231, -0.00427069, 0.0687073, -0.130123, -0.116263, -0.0960549, 0.00998668, -0.0841827, -0.0950397, -0.0688949, -0.0676585, 0.0432269, 0.0208708, -0.0292474, 0.00597496, -0.0369453, -0.11165, 0.0655338, -0.0479495, 0.0359495, -0.0595568, 0.0574478, -0.0555595, -0.000806319, 0.0410113, -0.0722919, -0.00992798, -0.0416012, -0.000324394, -0.0672089, 0.0462603, -0.0862699, 0.0166441, -0.072041, 0.0425916, -0.112705, -0.101825, -0.0272771, 0.0778917, 0.0735921, 0.0121467, -0.0156465, -0.0162365, 0.091638, -0.0180216, -0.060282, 0.147726, -0.0755225, 0.054027, -0.0721142, -0.0341951, 0.0232664, -0.143651, -0.0826039, 0.0575776, -0.00355282, 0.0847203, -0.100827, -0.0144557, 0.229449, 0.113173, -0.052639, 0.00998232, 0.0563555, 0.0486373, 0.0307142, 0.0279815, 0.121391, 0.0273475, -0.0622185, -0.0402138, 0.205144, 0.0909628, 0.0712203, -0.0617178, 0.0168132, 0.0829786, 0.0522957, 0.142542, 0.088519, -0.0638241, 0.124595, 0.0513673, -0.0450543, 0.0279378, 0.00279724, 0.104854, 0.0570674, -0.02628, -0.156272, -0.0455338, 0.0197502, 0.176051, 0.127539, 0.0545559, 0.0384282, 0.0668786, 0.144964, 0.123708, 0.0803999, 0.0760268, -0.00500774, 0.112972, 0.0431157, -0.0312538, -0.00539931, -0.157547, -0.13066, -0.0254503, 0.00526044, -0.0932408, -0.0321997, 0.0181462, 0.0315412, 0.0741415, -0.240524, -0.131667, 0.0167329, -0.0577836, 0.00641904, -0.0390244, 0.0595337, -0.127194, 0.082353, 0.0650086, 0.0335619, 0.0282337, 0.00859357, 0.0442071, -0.0707343, 0.018004, -0.0265791, -0.118866, 0.0348536, -0.0278378, -0.0555801, -0.00148979, 0.0337138, 0.145156, 0.181731, 0.0546591, -0.153632, -0.00230141, 0.0564235, -0.0421978, -0.00416409, 0.0829828, -0.056766, 0.0742711, -0.0492026, 0.0673126, 0.0428288, -0.0411383, -0.0266203, 0.117322, 0.00128435, -0.0617482, -0.139352, 0.0278234, 0.259071, -0.022936, 0.0341176, 0.0614864, 0.062443, -0.134606, 0.069112, 0.0916438, 0.159335, -0.0341639, 0.0638196, 0.0424423, 0.187615, 0.00513545, 0.115971, -0.0472723, -0.0447326, 0.0686972, -0.079623, 0.0615466, 0.0454337, 0.0618897, 0.0248263, 0.0390426, 0.0951999, 0.0310271, 0.10818, 0.0752704, -0.0761249, 0.135273, -0.0399993, -0.0621519, -0.00170132, 0.166694, 0.0451087, 0.0779226, -0.0311228, 0.0591612, 0.10785, 0.122839, -0.0106661, -0.0469684, -0.0282603, 0.03371, -0.0662887, -0.00643618, 0.0221733, -0.103071, -0.0136287, -0.0272205}, {-0.019749, -0.0415672, -0.0418586, 0.0182384, 0.209053, 0.149282, -0.120079, 0.004011, -0.0239584, -0.0986688, -0.0884762, -0.00406856, 0.0317866, -0.159182, 0.0270035, -0.0376549, -0.0274551, -0.0324063, -0.00258045, 0.013924, 0.0207513, -0.123943, -0.0706286, -0.11028, 0.0695736, 0.059646, -0.0554756, -0.0836859, 0.0546783, 0.112331, 0.162181, 0.0270306, 0.000434379, -0.0563313, 0.08467, -0.0659427, 0.0253847, -0.0341611, -0.0887653, 0.062676, -0.0185593, 0.0776873, -0.0149628, -0.136772, -0.079955, 0.0595308, 0.0358486, -0.0245894, 0.00257152, -0.0169507, 0.234812, 0.084939, 0.0403899, -0.0278483, 0.125754, -0.133934, 0.0590357, 0.154122, 0.194306, -0.0384128, 0.00219841, -0.00710953, 0.227241, -0.034359, 0.099939, -0.0220433, 0.103069, -0.0388771, -0.00985292, 0.0881948, 0.039919, 0.00878646, 0.113598, 0.0441695, 0.0192494, -0.0285952, 0.100267, 0.0950842, 0.0451305, -0.0194255, -0.131056, -0.0819173, -0.0888298, 0.159252, 0.219353, 0.123165, 0.102501, 0.13827, 0.0519766, 0.160901, -0.121803, -0.0904495, -0.0947629, 0.0569116, 0.0184282, 0.0108994, 0.0279836, -0.082175, -0.090569, -0.0890428, -0.107656, -0.139329, 0.0255282, 0.0381664, 0.0812172, 0.0609644, -0.272446, -0.120386, 0.0206167, -0.0924331, -0.0469836, -0.0950064, 0.0353329, -0.146767, 0.0274132, 0.00594784, 0.0321128, -0.0885287, -0.0727595, -0.0569899, 0.025774, -0.0319012, 0.0882183, -0.00471803, -0.0171661, 0.138164, 0.0682435, -0.0541885, -0.0614012, 0.0863094, 0.221798, -0.0971842, -0.00420206, -0.0228705, 0.0928944, -0.0737908, -0.0228907, -0.00219051, -0.207642, 0.0331629, 0.0748341, 0.104804, -0.100358, -0.237314, -0.0878292, 0.0450851, 0.139511, -0.0335602, 0.0170825, 0.0268707, 0.189948, -0.0698861, 0.0469408, 0.00937184, 0.12389, -0.150584, 0.00976224, 0.0895855, 0.211098, 0.066022, 0.0597395, -0.0881511, 0.125714, 0.0729636, -0.00586991, -0.0778485, 0.0270798, 0.0963348, -0.0678388, 0.118574, -0.000519234, -0.0262633, -0.0456715, -0.0114973, 0.067145, 0.0763791, 0.117804, 0.103507, -0.0468506, 0.00922048, -0.10743, 0.0717231, -0.0370494, 0.134524, 0.0965837, 0.033679, -0.0145504, 0.0573861, 0.0475706, 0.113327, -0.0228568, 0.0166348, -0.0535695, 0.110115, -0.0245498, 0.0389687, 0.00527836, -0.0530442, -0.104175, -0.118443, -0.137987, -0.0953641, 0.00642054, -0.116321, 0.19326, 0.0989026, -0.0852176, -0.0451923, -0.0121562, -0.0955313, -0.104739, 0.0812058, 0.138445, -0.04771, 0.0189045, 0.090512, 0.081802, -0.0715879, -0.113806, 0.014376, -0.0215821, -0.0618668, 0.0438603, 0.072837, -0.00916812, 0.0625903, -0.0136278, -0.0950767, 0.0148173, 0.00911528, 0.141732, 0.035492, -0.0371281, 0.0211052, 0.141654, -0.0350358, 0.0447546, 0.00840854, -0.165753, -0.0443087, -0.0133927, -0.0450201, -0.0618543, -0.143086, 0.00574984, -0.0219395, 0.106811, -0.0252595, 0.0650808, -0.0776046, 0.082185, -0.0362805, 0.023472, -0.0314602, 0.120541, -0.129015, -0.0317991, 0.0402829, 0.156607, 0.021193, -0.0327382, 0.0380222, 0.0923644, -0.0118065, -0.0469544, -0.0072788, 0.0333695, -0.0550194, 0.00417758, 0.10033, 0.158719, 0.0792962, -0.0761157, 0.0101058, -0.0646372, 0.0590449, -0.0136427, 0.0813416, 0.0364513, 0.041511, -0.0272446, 0.0460705, -0.0155161, 0.0860627, 0.103193, -0.00967485, 0.127958, 0.0506387, -0.00350228, 0.046712, -0.063744, -0.00731842, -0.0534461, -0.00844426, 0.00887135, -0.00774861, 0.0452856, -0.18367, 0.0695144, -0.0036262, -0.116236, 0.0760264, -0.0537227, -0.112142, 0.0971064, 0.0403588, -0.0770975, 0.0702344, 0.0142404, -0.194052, -0.0420566, 0.037266, 0.0851099, -0.0962358, -0.0246922, -0.00742819, -0.00819159, 0.0695333, -0.0125951, -0.0101859, 0.0227059, -0.0609574, 0.0167675, 0.0253834, -0.030404, 0.157069, -0.0237743, -0.111626, -0.0200732, 0.0709093, 0.0994749, 0.0436776, -0.00702877, -0.081408, 0.0746833, -0.127579, 0.0307524, 0.0199826, -0.0251349, 0.0297999, 0.0809327, 0.00635718, -0.00354972, 0.0465042, 0.0500156, 0.0112199, 0.0769884, 0.0683917, 0.0996765, 0.0383914, 0.119049, -0.022206, -0.048418, -0.0625284, 0.13478, -0.10794, 0.00502276, -0.0989423, 0.0281257, -0.0621417, -0.0880333, 0.0768744, 0.111989, -0.0320324, -0.0447123, 0.0283706, 0.147572, 0.0453373, 0.0599303, 0.111952, 0.0290612, -0.0815882, 0.0116559, 0.062143, -0.00611968, -0.00918174, 0.0326894, -0.0135633, 0.0435132, 0.0135929, 0.109098, -0.0127363, 0.0324747, -0.0526521, -0.0669859, 0.0449043, 0.00752156, -0.0520278, -0.00712336, 0.104883, -0.0336586, -0.0391527, -0.0579655, 0.0865887, -0.0104818, 0.0198049, 0.0458568, -0.126887, 0.105338, 0.0794677, -0.0630351, 0.123423, 0.0644056, -0.148139, 0.137916, -0.0700273, 0.0315478, -0.0409154, -0.0502215, -0.046839, -0.0822422, 0.0832333, 0.0561251, -0.0304536, -0.0205162, 0.0425139, -0.065869, 0.0812427, 0.00264754, -0.0434397, 0.0710434, 0.022874, -0.0415825, 0.057544, -0.129575, 0.139663, 0.0444819, 0.0148804, -0.0537364, 0.00731424, 0.113193, -0.0240388, -0.0421593, 0.0251653, 0.065348, -0.010156, -0.0259156, 0.038058, -0.0934691, 0.021328, 0.0471471, 0.0473983, -0.105718, 0.0817115, 0.00989771, 0.0138013, 0.0214498, 0.051907, 0.0152624, 0.0362333, -0.00214851, -0.0487805, -0.0222688, -0.0607369, 0.0410249, -0.0303719, -0.0817964, 0.0496305, -0.0261621, 0.0571679, 0.050414, 0.030985, 0.0573775, -0.00588752, 0.0321629, 0.0777088, 0.0113329, 0.0405092, 0.047535, -0.0001849, 0.115396, -0.0767436, -0.078221, 0.0326144, -0.0417244, -0.103309, 0.00880997, -0.0140149, -0.0171606, -0.0397804, -0.0378073, -0.028296, -0.079003, -0.0548254, 0.0365186, -0.0254669, 0.0229383, 0.0615873, -0.0385129, 0.0282292, -0.00575419, -0.0700041, -0.101495, -0.00140234, 0.0354402, 0.0569143, 0.0106283, 0.0115673, 0.0550585, -0.0763599, 0.0641471, 0.0510704, -0.0243051, -0.0595151, 0.0697674, 0.0395126, 0.073538, -0.0474493, -0.00134383, -0.0264963, -0.0883012, -0.043505, 0.119929, 0.0799007, 0.0679699, 0.0716396, -0.0897755, -0.0480461, -0.0751729, -0.0501616, 0.0603827, 0.0234501, 0.00139857, -0.0810861, 0.0885131, -0.046173, 0.0797651, -0.0558707, 0.0393359, 0.0463856, 0.0367818, -0.0194334, 0.0440744, -0.10065, 0.0569723, -0.039264, -0.0110585, 0.0500655, -0.0170354, -0.016549, 0.0844146, 0.0432474, -0.0466663, -0.0073361, -0.0137714, -0.0985281, -0.029823, 0.0634367, 0.10735, -0.0949582, 0.0972187, -0.0278467, -0.0588968, -0.033062, -0.0753084, -0.0727506, 0.0243079, 0.133015, 0.0276925, -0.0240426, 0.00790091, 0.103083, 0.071759, 0.0380262, -0.0587381, -0.0228855, 0.0575415, 0.0679958, 0.100466, 0.0879779, -0.044992, 0.0584335, -0.0635803, -0.0237001, -0.0944732, -0.0508943, -0.0795156, 0.13264, -0.0188174, 0.0714977, 0.0231898, 0.02966, 0.0167948, -0.00520295, -0.0477564, 0.00915671, 0.0739625, -0.0688384, -0.017085, -0.0479892, 0.0120407, -0.0117243, 0.0213056, -0.0187769, 0.0179816, 0.0301938, -0.0296147, -0.00348286, -0.0511621, -0.056365, 0.0708927, -0.0973423, 0.0494131, -0.0695481, 0.0160199, -0.0444202, 0.0096608, -0.10171, 0.00104427, 0.00881909, -0.0674702, 0.002492, -0.0308873, 0.0837612, 0.0732319, -0.0922912, -0.0526341, 0.0950103, -0.046671, -0.018288, -0.0180172, -0.0519332, -0.0546977, 0.0542582, -0.0225533, 0.0958749, -0.0327444, -0.0570251, -0.00556677, 0.110625, 0.120137, 0.027139, 0.0990306, 0.00955371, -0.00314769, -0.129432, -0.0435591, 0.0386772, -0.0721598, -0.0388026, -0.00931252, 0.0529745, -0.10096, 0.0574053, 0.0676616, -0.0227797, 0.00533344, -0.0418337, 0.120193, -0.0788459, 0.0835484, 0.0275142, -0.0746832, -0.0527545, -0.0656873, -0.0962545, -0.0632212, 0.118546, 0.0356417, -0.0026017, -0.0529159, 0.0270665, 0.0418235, -0.0147345, -0.0769472, 0.0124647, 0.0258076, 0.0279255, 0.0220311, 0.0730469, 0.103061, 0.0658002, 0.0505538, 0.0669439, -0.086415, -0.0558875, 0.0487484, 0.0999387, -0.0185882, 0.0465641, -0.0763288, -0.0816732, 0.0858945, -0.0491797, -0.0287381, 0.0318208, 0.0961181, 0.000925439, 0.0490342, -0.0338969, -0.0756762, -0.106685, 0.0747318, 0.0781449, -0.0440075, 0.0374593, 0.029699, 0.0351589, -0.051129, 0.00645523, 0.0861488, -0.0772811, 0.0793061, -0.120003, 0.0629225, -0.039142, 0.0171254, -0.0234034, -0.121148, 0.00975829, -0.0820481, -0.00761624, 0.0270713, -0.0126471, 0.0336643, 0.0417397, -0.00495639, 0.0583091, 0.0596826, 0.063676, 0.0744883, -0.0308607, 0.0538145, 0.0642151, 0.0150574, 0.0353858, -0.0667, -0.000271457, 0.0521427, -0.00161816, 0.127112, -0.00144692, -0.0356306, -0.118568, 0.0412056, -0.0713719, 0.00239545, -0.0912862, -0.0212094, -0.0020358, 0.0602892, 0.00395055, 0.022257, 0.0737526, -0.0462426, -0.0326281, 0.0570058, -0.0663739, 0.107473, -0.0273007, 0.130001, 0.0191412, 0.0219143, -0.0573203, 0.0905224, -0.088086, -0.0555393, -0.0196332, 0.0590902, 0.000920674, -0.0177272, 0.0780065, -0.00599822, 0.0685277, -0.0480094, 0.0687459, 0.139993, -0.00978461, 0.0382329, 0.0649292, 0.113672, -0.0339575, -0.0679124, 0.00904302, -0.0529789, -0.0370523, 0.0258248, 0.0771237, -0.136468, 0.0117572, -0.0441139, -0.0514507, 0.0889019, 0.0502884}, {-0.0606849, -0.00385249, -0.0125905, -0.0480706, -0.0616916, 0.0235743, -0.0733437, 0.0132749, -0.0610992, 0.102897, -0.0761288, 0.0508819, 0.0700546, 0.0475102, -0.0848991, 0.0728197, 0.0505391, 0.0138115, 0.134229, -0.0411885, 0.00947744, -0.0683296, 0.073412, -0.0347496, -0.0830198, -0.112961, -0.0463161, 0.0581152, 0.0946006, 0.0628412, 0.13783, 0.0527068, 0.0158368, 0.0522438, -0.0124818, 0.0180127, 0.0667408, 0.0230719, -0.0290483, 0.0480843, 0.0605666, 0.120788, 0.081877, 0.0351395, -0.0759282, 0.0843475, 0.100466, -0.0698078, -0.0189711, -0.00374572, 0.0291371, -0.00825051, -0.0331994, -0.0862746, -0.153145, 0.0154782, 0.0268638, -0.0872916, -0.0403969, 0.0131478, 0.103742, -0.000102544, 0.0604006, 0.0485134, 0.00793062, -0.0426824, -0.0213731, 0.032327, 0.0274809, -0.0462605, 0.0940054, -0.116586, -0.117618, 0.133235, -0.0252989, -0.0537713, -0.0886144, 0.00699514, 0.052699, -0.0149874, 0.0174584, 0.0683795, 0.0135176, 0.070961, 0.154407, 0.0703515, 0.121484, -0.0628399, -0.0335683, -0.0731438, 0.0356058, -0.0663917, -0.095891, 0.124424, -0.0962099, -0.00405336, 0.00823024, -0.0520884, 0.0432436, 0.0543072, -0.0227466, -0.0130152, 0.0687513, 0.0277463, -0.0158967, 0.0250495, -0.0244818, -0.00264132, -0.00652172, 0.0547039, 0.0508776, 0.0154757, 0.0989251, -0.06241, -0.0932706, -0.0572662, 0.0364861, -0.117985, 0.152794, -0.0817328, 0.157845, -0.0926599, 0.109458, -0.0848409, -0.011194, 0.0125605, -0.0011473, 0.0870656, -0.0339723, 0.0775013, 0.068378, -0.0185113, 0.0353628, -0.0115221, -0.00313511, 0.0555889, -0.00814869, 0.0112326, -0.0262696, 0.0526207, 0.022728, 0.08886, 0.0453712, -0.0512526, 0.0352681, -0.0329722, 0.0471618, 0.032012, -0.0206544, -0.0230182, -0.0398718, 0.0103849, -0.0593126, 0.0218725, -0.0724737, -0.0697935, 0.0568942, -0.0588795, -0.0426086, -0.00181128, 0.0559168, 0.0060975, 0.0906536, -0.0108073, 0.000293516, -0.0228623, -0.0200615, 0.031328, -0.0344942, -0.024467, -0.00913438, 0.0419204, -0.0467223, 0.0834965, -0.0501103, 0.0529219, -0.0393776, -0.0375772, -0.0183393, -0.0627462, 0.000262667, 0.0433881, 0.104774, -0.0480095, 0.0595099, 0.0547495, -0.00108269, -0.0272719, -0.0773651, -0.0245858, 0.0782296, -0.0786156, -0.00248794, 0.0837518, -0.0808501, 0.0328676, 0.0440611, -0.0650233, -0.0775384, 0.0246747, 0.0109321, -0.0645253, 0.0317508, 0.0175345, -0.058167, 0.0790222, -0.00868548, 0.0281027, -0.0288334, -0.038329, -0.0534987, 0.106346, -0.0272133, -0.0313481, -0.0433786, -0.074353, -0.0769107, -0.0312024, -0.00728559, -0.108098, 0.0307486, -0.11164, 0.0166859, -0.0360741, -0.0193357, 0.0734759, 0.0337876, -0.0723478, 0.0855642, 0.0213821, -0.0474114, -0.0290085, 0.0238084, -0.0566989, 0.0498783, 0.0389457, -0.0116192, -0.0298612, -0.0363397, 0.0338621, -0.0203338, 0.0799401, -0.0372345, 0.07635, 0.0528273, 0.0422746, 0.0888995, 0.0148677, -0.0580403, -0.0535517, -0.00303864, -0.0552207, 0.0396266, 0.00584026, -0.0628038, 0.0423344, 0.032464, 0.0366404, 0.0496467, -0.0295504, 0.0130783, -0.0493608, 0.0891437, 0.0313413, 0.111282, 0.00862354, -0.0592782, 0.0199817, -0.0213557, -0.0212481, -0.0360728, 0.0394407, -0.0791498, 0.0517857, 0.021164, 0.00842354, -0.0475303, 0.103614, 0.0990999, 0.0104164, -0.0532851, 0.00480822, 0.0447731, -0.0129509, 0.0784648, -0.0326424, -0.000415408, -0.0308378, -0.0384908, -0.0275468, 0.022373, -0.0591398, -0.0293227, 0.0174641, -0.0811985, -0.0918308, 0.0865963, 0.0446334, -0.0313077, -0.0281928, -0.0645039, 0.0395002, 0.0939253, -0.0295753, 0.00836832, 0.0432093, -0.052179, 0.0133198, -0.0712219, 0.0195859, 0.0180969, 0.00144308, 0.0789995, 0.0351626, 0.00764864, -0.0303204, -0.0999838, 0.00420432, 0.0925571, -0.101542, 0.0556108, -0.109627, -0.0914517, 0.0333552, 0.0333724, -0.0158409, 0.0382037, 0.0217531, -0.0419972, 0.0481708, -0.0646612, 0.0125135, -0.0551335, 0.000555499, 0.0178671, -0.0300007, 0.0415309, -0.119167, -0.0762334, 0.0975898, 0.0259192, 0.0184825, 0.0296901, 0.0595005, -0.0149443, -0.0648439, -0.0871413, 0.00802142, -0.0187608, 0.0238781, 0.0449679, -0.11147, 0.0132361, 0.00493208, 0.0301055, -0.0105384, 0.0486417, -0.072268, -0.0211338, 0.185405, 0.0494492, -0.0286784, 0.151946, -0.0207008, 0.155558, 0.0224448, -0.00299741, 0.0392292, 0.00547975, -0.0201312, 0.11266, -0.0887189, -0.0991022, -0.0690507, 0.129409, -0.0300087, 0.000314824, 0.0509793, -0.011882, -0.0609777, 0.0460504, -0.0500445, 0.0629472, 0.0345416, 0.0269583, -0.00168626, -0.0866443, 0.0673506, 0.0628642, 0.0775542, 0.0820325, -0.0281522, 0.0536196, -0.115147, -0.144229, -0.0408311, -0.0600115, -0.0219156, -0.073836, 0.0912748, -0.0496431, 0.0226506, -0.0495511, -0.0143349, -0.0428469, -0.00464015, -0.116617, 0.0513036, -0.00881726, -0.066208, -0.0638459, 0.0516846, 0.0912363, 0.00821324, 0.0557138, 0.0558687, 0.00212898, 0.0108754, -0.0289977, -0.0361083, 0.0377334, 0.153066, 0.0697112, -0.0984123, -0.062347, 0.0137487, 0.0586557, 0.0345167, 0.00567039, 0.0143292, -0.0510108, 0.084701, -0.120828, -0.0681344, 0.0552605, 0.179934, 0.0865356, -0.113386, 0.0594009, 0.102582, 0.0214181, -0.0673863, 0.130297, 0.0756076, -0.0269532, 0.0125837, -0.177081, -0.0589217, 0.0555343, 0.0540999, 0.00976333, -0.104459, 0.106676, -0.0387739, -0.019357, -0.0161872, 0.0706707, -0.0420726, -0.11779, 0.0303817, 0.0185678, -0.038461, 0.0790045, -0.0429213, 0.0662309, -0.00977908, 0.033594, 0.0953686, 0.060133, -0.0179299, 0.121517, 0.0349803, -0.0545686, -0.146484, 0.115268, 0.0645497, -0.0895187, 0.0743713, -0.00338987, 0.0440464, 0.0146979, 0.0929099, 0.076447, 0.0740087, -0.0113497, -0.0421995, 0.0552469, 0.0543342, 0.118552, 0.147654, 0.0442958, 0.0520122, 0.013929, -0.0429774, -0.0839175, -0.0582534, -0.0677553, -0.049632, -0.04983, 0.0685131, 0.0704916, 0.0424125, 0.0740672, 0.0642559, -0.0553038, -0.0439338, -0.121189, -0.0670045, -0.0720324, -0.0850588, -0.0795479, 0.0303598, 0.179496, -0.0557999, -0.00688165, 0.0714288, 0.0495644, -0.0930869, -0.0413414, -0.127748, -0.00941658, 0.0852564, 0.0781679, 0.0382862, 0.0285245, 0.0149168, -0.0449302, -0.0752561, 0.0547111, -0.00243854, -0.0604406, 0.00602562, -0.0828495, 0.00522863, 0.00272801, 0.0796605, -0.0603882, -0.00632481, 0.0102672, -0.0356553, 0.0520172, -0.0212663, 0.12681, 0.0977983, 0.0730399, 0.0562158, -0.043481, -0.0629389, -0.0764317, -0.119176, 0.0386488, -0.120277, 0.0893703, 0.0151999, -0.126406, -0.0223867, 0.03617, 0.0404531, -0.0268397, 0.140217, 0.0806281, -0.0581855, 0.0504638, -0.0581175, 0.154814, -0.040634, -0.019432, 0.113046, 0.0314142, 0.0495978, 0.0332744, 0.00189223, 0.00529253, -0.0654524, -0.0128805, -0.0201836, 0.0235607, 0.0389988, 0.0684543, 0.00645122, 0.0612018, 0.0607442, 0.0586206, 0.0149878, 0.0539203, -0.00254742, -0.103253, 0.071044, 0.00946814, 0.0175383, -0.0542026, -0.0650329, -0.0377963, -0.0647051, -0.0407306, -0.135776, -0.174141, 0.00164069, -0.0603426, -0.0516867, 0.0197222, 0.0297907, -0.0213585, -0.0510918, -0.103222, -0.0461678, 0.00880896, -0.0290304, -0.050021, -0.0805792, -0.0722219, 0.0313869, 0.13392, -0.0728273, -0.0994234, 0.100512, 0.0213626, 0.0143859, 0.0307872, -0.111255, 0.0757727, 0.112032, 0.0815674, 0.00710604, -0.0448683, -0.109423, -0.0672781, -0.0271186, 0.0768202, 0.0226816, 0.0666352, -0.000921787, 0.0297194, 0.0237077, -0.0227635, 0.105493, 0.091829, -0.0140999, -0.133676, 0.095803, -0.0453147, 0.0929015, 0.0369388, 0.0836426, -0.0698586, -0.0113791, -0.0260959, -0.00474583, -0.0463881, -0.145288, 0.07586, -0.0782262, -0.0161441, -0.142617, -0.0454683, 0.0684868, -0.0633162, 0.131771, -0.0625088, 0.0567734, 0.024734, -0.0570696, 0.110012, 0.0160412, 0.0521726, -0.0306514, 0.107604, -0.0652735, -0.0499121, 0.0410168, 0.110691, 0.0236359, -0.113968, 0.00740444, 0.11756, 0.0582634, -0.0343653, 0.0907249, 0.0915196, -0.00367244, 0.148482, 0.054115, 0.0103458, 0.0433848, 0.0712898, -0.0155673, 0.00731222, 0.0133141, 0.0661303, 0.034973, 0.0391237, -0.144359, -0.0610399, 0.0440029, -0.145511, -0.0415617, -0.129145, -0.021072, -0.0103549, 0.0405985, -0.0263185, 0.0361826, 0.111845, -0.00302906, 0.0867826, -0.0944318, -0.0562198, 0.0269652, 0.00361072, -0.0498074, -0.0855673, 0.0201585, 0.0576274, 0.0131336, -0.0970503, -0.114748, -0.00891276, 0.0170387, 0.0555488, -0.0447865, 0.0768724, 0.0524617, -0.0120167, -0.0292184, -0.0523416, -0.101155, 0.0666334, 4.9239e-05, -0.0239278, -0.0849164, -0.0961058, 0.089026, -0.0308571, -0.0309405, -0.00643289, 0.0902206, -0.0775369, -0.0649427, -0.0271407, -0.00307132, -0.0183789, 0.0440166, -0.0273227, 0.0363625, 0.0500384, 0.0356674, 0.0603805, 0.0378867, -0.057433, -0.0216288, 0.112206, -0.0381755, -0.0324947, 0.0521734, -0.0336114, -0.0616364, 0.0216834, 0.162599, -0.0951802, -0.0201236, 0.0210065, 0.0278915, 0.0235064, 0.00348096, 0.0209965, 0.016602, -0.012792, -0.0757121, -0.062857, -0.0274162, 0.0432554, 0.0457327, -0.0112396, 0.057777, 0.133927, -0.0555235, -0.038901, 0.0605125, 0.0598535, -0.0415491, 0.054881, -0.0416793, 0.0910189, 0.0162642}, {-0.0421942, 0.0207709, -0.00367491, 0.0237999, -0.123065, 0.0601989, 0.0541631, -0.158028, -0.0127225, -0.00120351, 0.00734746, 0.110282, 0.00816821, -0.0240389, -0.0172202, 0.0656591, 0.00906667, 0.132905, 0.0669511, 0.0853961, -0.0228546, -0.0276808, 0.0965928, 0.00483366, 0.0448718, -0.0164823, -0.0351653, 0.0981094, -0.0548791, -0.0184676, -0.0202071, -0.145663, 0.0304515, 0.060781, 0.10172, -0.122187, 0.0442959, -0.0443346, -0.11649, -0.0091758, 0.0371588, -0.0129743, -0.0235638, -0.0325574, 0.04476, -0.0515998, -0.101913, 0.0227058, -0.0681728, -0.0879436, 0.0673584, 0.0869321, -0.0312939, -0.0890629, -0.0273383, 0.0406823, -0.0593962, 0.122706, -0.0357557, 0.0165866, 0.0491389, -0.00516909, 0.107368, -0.0671853, 0.0512785, 0.013539, 0.156181, 0.00839782, -0.0472303, 0.135147, -0.0144422, -0.0563654, 0.000604739, 0.0325099, -0.0583845, 0.0999654, 0.0402757, 0.0792307, -0.045055, 0.109858, 0.154117, 0.00238085, 0.0981186, -0.125892, -0.00371137, -0.0472503, -0.000794178, -0.101875, 0.0819694, 0.144774, 0.0342147, -0.0945524, -0.0664941, 0.0584458, 0.166261, 0.0356647, 0.0187685, -0.0842094, 0.031688, -0.108728, -0.00495023, -0.0423193, 0.123116, -0.0216632, 0.0381757, -0.0615273, -0.05728, -0.0240314, 0.0274002, -0.0208253, 0.194988, 0.093567, 0.0109132, -0.0679217, -0.0601245, -0.087119, 0.0764603, 0.117247, 0.0822593, 0.0621671, -0.0522346, 0.00784721, -0.0577262, 0.0131213, -0.0808285, 0.0532592, -0.0556244, 0.0942714, -0.00695135, -0.0192826, -0.0435583, -0.172053, 0.042878, -0.0561527, 0.0348639, -0.0770741, 0.142518, 0.0110921, -0.0501316, -0.0525401, -0.0662972, 0.0515331, -0.0223914, -0.0354395, 0.113919, -0.128086, 0.0346707, 0.0325596, -0.0216718, -0.0241551, 0.0602402, -0.0106692, 0.0248757, -0.101281, -0.077924, -0.00505318, 0.0173695, 0.133527, -0.0901652, 0.0266925, -0.022643, -0.144043, -0.11031, -0.0349794, 0.00400647, -0.0586999, 0.0593617, -0.168694, 0.0191016, -0.0273063, -0.0812631, -0.0295065, -0.0108096, 0.0972656, 0.0165744, 0.024893, 0.00264541, 0.149982, -0.0239685, 0.128434, 0.149397, -0.0692044, -0.00646083, -0.0756247, 0.0633663, -0.0510559, -0.0557564, -0.0533966, 0.0968489, 0.197959, 0.0730155, -0.0734825, -0.00772818, 0.016546, 0.175518, -0.0955883, 0.0743119, 0.0246058, 0.0437387, 0.0254577, -0.152207, -0.000122399, -0.0596608, -0.0349858, 0.118765, 0.114178, 0.081829, -0.0138408, -0.0528952, -0.0256696, 0.0827282, 0.029333, -0.0171648, 0.0226667, 0.0702984, 0.0112414, 0.00778503, -0.0230502, -0.0200033, -0.111256, 0.00270466, 0.0574999, -0.00189088, 0.140189, 0.00892943, 0.0119117, 0.0128909, 0.129556, 0.0430535, 0.0390986, -0.0519529, -0.0452412, -0.0832756, -0.0116369, -0.103244, -0.0873667, 0.000163871, 0.223139, -0.130867, -0.0479388, -0.0171371, -0.0296771, -0.0748495, -0.0367415, 0.106345, -0.150255, -0.198895, 0.157566, 0.0741912, 0.133209, 0.0801578, -0.00118643, -0.0123094, -0.0595081, -0.0148021, 0.0671651, -0.0926235, 0.00801977, -0.0311223, -0.0176491, -0.0190289, 0.0390093, -0.235591, -0.10385, 0.00927973, -0.0377279, 0.107599, -0.150852, 0.238039, 0.0544772, -0.26891, 0.0364977, 0.0627725, 0.164987, -0.00475068, 0.296064, 0.0493115, 0.10255, 0.0804871, 0.10212, 0.164959, -0.111424, 0.0692076, 0.0448261, 0.012128, 0.0291068, 0.249985, -0.01194, -0.0587094, 0.117788, 0.00561034, -0.0756181, 0.00818952, 0.0762824, 0.0615617, 0.00121542, 0.202517, -0.0504309, 0.0368198, 0.151178, -0.133412, -0.00993551, -0.0178579, 0.00882582, 0.339498, 0.170651, 0.0239189, -0.115005, -0.107365, -0.121804, -0.18062, -0.239945, -0.257446, -0.00723851, -0.195059, 0.0245958, 0.0185316, 0.0387222, 0.0526986, -0.0736204, -0.0875125, 0.0783067, 0.125315, 0.122303, -0.0200709, 0.0576566, -0.112847, 0.201711, 0.198349, -0.0537412, -0.241201, -0.178748, 0.0353725, -0.0585521, -0.251412, -0.0669481, 0.0355205, 0.294984, 0.134617, -0.15149, -0.0701741, 0.0190473, -0.0362992, -0.0650996, 0.0946974, -0.0821891, -0.164816, 0.165743, 0.0447316, 0.283443, 0.156999, 0.259671, -0.0343767, -0.0875726, 0.0775627, 0.0764736, 0.0476558, -0.0614676, -0.0361487, 0.00557149, 0.0278692, 0.15915, -0.129852, -0.0968504, 0.011139, -0.0207256, 0.0587219, -0.133201, 0.242978, -0.00810784, -0.147203, -0.0341686, 0.0538594, 0.118446, -0.00119928, 0.277844, -0.0364502, -0.00721227, 0.000200668, 0.120402, 0.166401, -0.196841, 0.0475404, 0.0182752, -0.00871325, -0.00809916, 0.188259, -0.0306137, -0.182549, -0.032249, 0.0477709, -2.39457e-05, -0.0755541, 0.171104, 0.0721428, -0.015779, 0.274801, -0.0089775, -0.00829549, 0.2252, -0.248172, 0.0418499, -0.0775625, -0.0533793, 0.282185, 0.169751, 0.0888172, -0.150483, -0.0736256, -0.211994, -0.22101, -0.157188, -0.273043, 0.0385618, -0.0971931, 0.030243, -0.0914077, 0.0617572, 0.170413, -0.11648, -0.0491573, 0.0299791, 0.144166, 0.0548906, -0.00106196, 0.108277, -0.201079, 0.0852036, 0.149629, -0.0818072, -0.19456, -0.086675, 0.0354869, -0.0476137, -0.126475, -0.0707788, 0.0935067, 0.271027, 0.176996, -0.0305496, 0.063624, -0.066479, 0.026073, -0.0451028, 0.0649674, -0.0951946, -0.208493, 0.123778, -0.10263, 0.217959, 0.228736, 0.316802, 0.113877, -0.0341538, 0.100288, -0.0251178, -0.0250554, 0.0356088, 0.0593951, -0.0141743, 0.0672298, 0.0362368, -0.148022, -0.251392, 0.0257292, 0.0663311, 0.0116176, -0.201205, 0.202656, 0.139901, -0.194769, 0.0201074, 0.00591492, 0.173808, 0.0984244, 0.194543, 0.0228722, -0.0718362, -0.0343289, 0.0838318, 0.170323, -0.0802549, -0.0636881, 0.0309183, 0.0105787, 0.0531089, 0.163173, -0.0488086, -0.171201, 0.0148448, 0.0576476, 0.000480255, -0.0447228, 0.120747, -0.018155, 0.041305, 0.162866, 0.0598059, 0.0535478, 0.120163, -0.155409, -0.0498999, -0.107595, 0.0444768, 0.361111, 0.14705, -0.038129, -0.0877664, -0.00608817, -0.209996, -0.224269, -0.216375, -0.170037, -0.0627643, -0.159352, 0.110402, -0.0178583, -0.103454, 0.119655, -0.103812, -0.0864557, 0.0673845, 0.0909562, -0.000761028, -0.0167439, 0.0719631, -0.195528, 0.057277, 0.249968, -0.00329826, -0.172326, -0.0050247, -0.0967546, -0.103506, -0.133946, 0.0362268, 0.119866, 0.287602, 0.120013, -0.17969, -0.0851152, 0.0387748, 0.109738, -0.0289525, 0.00350678, -0.102505, -0.237398, 0.173103, 0.0376139, 0.127728, 0.27101, 0.215756, 0.0849602, -0.0973678, 0.0847593, 0.0125594, -0.0650839, -0.042225, 0.0697613, -0.0220998, 0.0135119, 0.0927528, -0.171691, -0.0844479, -0.0723641, -0.00518406, 0.0139255, -0.166511, 0.230775, 0.0214714, -0.166559, 0.0266101, 0.0198691, 0.215204, 0.0322888, 0.331501, 0.081003, -0.0251051, 0.0471835, 0.114798, 0.137946, -0.0450485, 0.116355, 0.0126574, 0.00230729, -0.0118003, 0.195098, -0.118761, -0.0659005, -0.0119999, -0.00194995, -0.106959, 0.0563453, 0.129261, -0.0514812, 0.00229639, 0.204963, -0.0619147, -0.0364461, 0.139724, -0.199484, 0.027088, -0.0259205, 0.0357687, 0.302257, 0.169175, -0.0256432, 0.0372657, 0.0825608, -0.126671, -0.196362, -0.0701934, -0.0849039, 0.0676359, -0.14097, 0.108452, -0.0124582, -0.0396961, 0.0792307, -0.0373555, -0.00374838, -0.0228616, 0.0631041, -0.0964322, 0.0249939, 0.155021, -0.238732, 0.206044, 0.169036, 0.0431248, -0.191652, -0.00259812, -0.0376887, -0.156382, -0.1689, 0.0498858, 0.114238, 0.167547, 0.163864, -0.075934, -0.129654, 0.0245606, 0.0443005, 0.015825, 0.0128374, -0.0896545, -0.092787, 0.276118, 0.058765, 0.0953737, 0.123874, 0.273198, -0.027131, -0.151092, -0.0835499, -0.00331847, 0.0493079, -0.0308305, -0.00139937, 0.0377663, -0.0149906, 0.0597902, -0.0601522, 0.0137684, 0.00647691, -0.0344576, 0.00930111, -0.128288, 0.0703306, 0.0390263, -0.0790083, -0.00817904, -0.0579696, 0.170787, 0.00148727, 0.093986, 0.0311241, -0.0577531, 0.095408, 0.0290008, 0.000660878, -0.0411171, 0.0327464, 0.0105531, -0.00247706, 0.110028, -0.126698, 0.000222499, 0.0732062, 0.107985, 0.0547247, -0.02216, -0.058451, 0.207209, -0.0720306, 0.0191988, -0.0104053, 0.0319015, 0.0163171, -0.0381515, 0.0707429, -0.00561763, -0.0379217, -0.0502287, 0.0397021, 0.133181, 0.00114563, 0.0770229, 0.000325715, 0.023051, 0.0641936, 0.144322, -0.0208535, -0.0621176, 0.102777, -0.00413512, 0.0276622, 0.0211497, 0.147767, -0.101424, 0.123022, -0.079169, 0.109534, -0.0403843, 0.00804165, 0.143767, -0.0789177, -0.0609822, 0.00468521, -0.0721527, -0.140452, -0.0574155, 0.0873888, -0.0534405, -0.012029, -0.00856435, 0.0219716, 0.0410944, 0.00886143, -0.101699, -0.00530676, 0.160499, -0.0167978, -0.03655, 0.101, -0.0308218, -0.142621, -0.0117604, 0.0476182, -0.00953902, -0.0238624, 0.0625617, 0.0768739, -0.0468216, -0.0644924, 0.0596643, -0.0250768, -0.0409376, -0.0808333, -0.0660338, -0.0521556, -0.00403823, 0.0113949, 0.0431346, -0.0851392, -0.0764731, 0.098572, -0.104414, 0.0576323, 0.0312988, -0.00785765, 7.30678e-05, -0.151945, 0.173188, 0.0502669, 0.0526887, 0.0688393, -0.0923354, 0.0384008, 0.0722787, -0.00145764, -0.0694165, 0.0956905, 0.0376006}, {-0.0780454, 0.0941993, -0.105402, 0.0310888, -0.0144136, -0.0395394, -0.0414043, -0.0780263, 0.0525844, 0.0138915, 0.121167, 0.0407932, 0.167428, -0.0802059, 0.0379231, 0.00823393, 0.0551483, 0.0500129, -0.0295279, 0.00368515, 0.0852849, 0.0593334, -0.0793909, 0.0722447, -0.0604472, -0.00529485, 0.0592343, 0.0416652, -0.0454421, -0.0129241, 0.0476745, 0.0658837, 0.00124728, 0.0555742, 0.0226347, 0.0133353, 0.00929276, -0.0443697, 0.123481, 0.00973779, -0.0706678, -0.00961802, -0.067845, -0.0745006, -0.0904171, -0.0840572, -0.139294, 0.0144912, 0.0686542, 0.0601495, -0.0398027, 0.114174, -0.0560209, 0.00666634, -0.0163934, -0.090597, 0.0394414, 0.000175827, -0.0251352, -0.0205379, -0.0546576, 0.0122046, -0.05968, -0.0416402, -0.0677839, -0.0786478, 0.0676014, 0.0629401, 0.101086, -0.0475009, -0.0677537, -0.0371502, 0.0636682, -0.0386721, -0.0169236, -0.0973036, -0.0756209, 0.0819607, 0.0467058, -0.0639966, -0.111496, -0.0662661, 0.0904416, -0.130429, 0.125628, 0.127969, -0.0440131, -0.00733745, -0.0721906, 0.0525349, 0.0580551, 0.00969233, 0.0174256, -0.0835211, -0.000724629, 0.115687, -0.0305471, -0.0809602, 0.104678, -0.0627844, -0.00924373, 0.0899245, 0.00543752, 0.00181597, -0.0643248, 0.0581314, 0.0634819, -0.020435, -0.00445659, 0.0389192, -0.0185876, 0.0246406, 0.053251, 0.0398169, -0.0560959, -0.0798454, 0.138204, 0.0240859, 0.0074171, 0.0114777, 0.0692792, 0.0286399, 0.0645621, 0.103252, -0.102627, -0.0765215, 0.0760015, -0.00122985, -0.0920005, -0.0626509, 0.167647, 0.0507669, 0.0269925, 0.0885246, 0.147805, -0.0519832, 0.0742038, 0.0043499, -0.0103704, -0.0250052, -0.0921601, 0.0423786, -0.00517101, -0.0594385, -0.0746981, -0.0129711, -0.138823, -0.103522, 0.014867, -0.00636724, 0.0951722, 0.115311, 0.0126976, 0.0865631, -0.064187, -0.0376087, 0.0203671, 0.0796324, 0.0712163, -0.0106282, 0.0260532, -0.110742, -0.12347, -0.0389497, -0.118733, 0.00665542, -0.0506807, -0.0381266, 0.054911, -0.065105, -0.093453, 0.0342395, 0.0358291, 0.0352469, -0.0551739, -0.00691269, 0.0785741, -0.0350637, -0.045333, -0.0549453, 0.0138639, -0.130499, -0.0271977, -0.111404, 0.0465907, 0.122539, -0.128307, 0.0800641, 0.000888348, 0.0580772, -0.00640404, -0.043353, 0.0821197, 0.0257679, -0.0517971, 0.0959906, -0.0471997, -0.0818036, 0.0458955, -0.0347708, 0.0639798, 0.017125, 0.0205926, 0.119007, 0.0427254, 0.0525853, 0.0224894, -0.0319639, -0.0703261, 0.0505387, 0.100635, 0.0632901, 0.0231896, -0.0323774, -0.00974179, 0.0366271, 0.12026, -0.0508815, 0.037731, -0.0749015, 0.0689408, 0.0345142, -0.0444785, 0.0348364, -0.0980654, 0.0202876, 0.0314284, 0.00218216, -0.0849406, -0.0215453, -0.018815, -0.0606547, 0.0796203, 0.105299, 0.0212757, 0.0467703, 0.049771, 0.085116, 0.0329936, -0.0885099, -0.0609143, 0.034328, -0.095244, 0.00841078, 0.0127425, -0.0540761, 0.00405328, -0.0248832, -0.0797253, -0.00626136, -0.000720973, 0.0268771, 0.0556403, 0.07659, -0.140574, -0.134008, 0.022285, -0.0328653, 0.0561244, -0.0110268, -0.0335636, -0.17711, -0.0428136, -0.0367465, 0.0368024, -0.00344517, 0.0550636, 0.029391, -0.0387207, 0.0333815, 0.0561248, -0.109849, -0.0694819, -0.0323908, -0.0836133, -0.0435261, -0.00610261, 0.141431, 0.192273, 0.0027901, 0.0339038, -0.0855259, 0.117531, -0.0501957, 0.0306199, 0.0260882, -0.148659, -0.0391491, -0.0746537, 0.0514766, 0.0295402, -0.146586, -0.012198, 0.0391686, 0.0603359, 0.0839348, -0.118024, -0.00189716, 0.1178, 0.0167458, -0.0432589, 0.0886035, -0.00432937, 0.0321293, -0.00277823, 0.0294269, 0.123895, -0.0753764, 0.0402595, -0.0210742, 0.102939, 0.129282, 0.118319, 0.0745345, 0.034735, 0.0437855, 0.0556769, 0.0829442, 0.0646042, -0.0736181, 0.125056, 0.0783143, -0.0129364, 0.0690916, 0.104159, 0.00490807, 0.0159797, -0.00999724, -0.0386681, -0.0639126, 0.0205087, 0.0712433, 0.0708662, 0.0831583, -0.0306981, 0.0358848, 0.145663, 0.178694, 0.0281785, -0.105298, -0.0668547, 0.0735366, 0.0084155, -0.0241276, 0.0487662, -0.152106, -0.119571, -0.0895739, -0.143051, 0.0193296, 0.027298, 0.033492, 0.126126, 0.108918, -0.123584, 0.0118066, 0.0438942, -0.0538716, -0.0543897, 0.0281109, 0.0712787, -0.030095, -0.0231681, 0.0556098, -0.039353, -0.0553417, 0.0183376, -0.0281032, -0.0341682, -0.00465005, -0.0767289, 0.0367636, -0.00943496, 0.111426, -0.0807262, -0.0755614, -0.0223641, 0.110212, 0.216595, -0.056049, -0.0986506, -0.0709637, 0.198291, -0.0409134, -0.0535928, 0.145341, -0.189633, -0.00203766, -0.0756427, -0.00284619, -0.0374573, -0.183956, -0.134074, -0.0107069, 0.0132349, -0.0164994, -0.0907783, -0.0681534, 0.249947, 0.0862698, -0.0054727, -0.0436042, 0.14228, -0.0193821, 0.0255046, 0.00437405, 0.129817, 0.0301074, -0.0361042, -0.0517424, 0.17361, 0.0654335, 0.00554526, -0.0555926, 0.0153575, -0.0083603, -0.0438293, 0.0308571, 0.0464616, -0.0680621, 0.0685657, 0.0376195, 0.00490381, -0.0331475, 0.0404795, 0.136648, 0.0650145, 0.101403, -0.180322, 0.0355798, -0.0695329, 0.132848, 0.127284, 0.0447839, 0.0338019, -0.00797563, 0.0588964, 0.218474, -0.0197531, 0.0518819, 0.0486948, 0.0672804, -0.0694919, -0.0680753, 0.0903595, -0.210555, -0.145494, -0.129823, -0.118332, -0.0915933, 0.0470761, 0.0580647, 0.131577, 0.0823935, -0.229764, 0.0139027, -0.0728204, -0.117622, -0.0777631, 0.0211118, 0.0645714, -0.19722, 0.0679151, 0.0532928, 0.0273186, -0.0272389, -0.00366974, 0.0328219, -0.0386461, -0.0097827, 0.0131431, -0.106195, -0.0560058, 0.0850332, 0.0351611, -0.0875968, 0.053877, 0.143652, 0.124577, 0.0339102, -0.136384, -0.0132418, 0.0970071, -0.144976, 0.0551784, 0.0444465, -0.07579, -0.0277129, -0.0703045, -0.0150962, -0.0410093, -0.189284, -0.0129948, 0.140253, 0.1526, 0.0776522, -0.0171144, 0.0430086, 0.239099, 0.0801893, 0.0777862, 0.0572855, 0.184167, -0.00253953, 0.124529, 0.0374964, 0.0820271, -0.0422291, -0.0613048, 0.0501564, 0.22739, 0.0354897, 0.0731014, 0.0670985, 0.00475028, -0.00386711, -0.0494083, 0.0838979, 0.0528998, -0.0818137, 0.107545, 0.0354485, -0.0151361, 0.0844846, 0.0154144, 0.0677119, 0.017275, 0.111677, -0.189552, 0.00226861, 0.0428328, 0.0754084, 0.161055, -0.00593217, 0.0293763, 0.0124652, 0.0148182, 0.112504, -0.109785, -0.0579159, 0.0434766, 0.0204742, -0.0159465, -0.0741442, 0.0819606, -0.174958, -0.00193313, -0.0410729, -0.0500153, -0.033425, 0.0531789, 0.0916661, 0.08129, 0.0637141, -0.164136, -0.0351142, 0.00649987, -0.116556, 0.0182642, -0.0370466, 0.0902825, -0.0792249, 0.0497915, 0.0256953, 0.0474339, 0.00784701, -0.00662952, 0.0645617, 0.0745164, -0.0673689, 0.00545608, -0.0707442, -0.0901271, 0.12063, 0.0500412, -0.0866583, -0.0364549, 0.0818866, 0.204337, 0.0491714, -0.0481678, -0.0605669, 0.107297, -0.0713725, -0.0661279, 0.0546858, -0.0870521, -0.0400325, -0.0378062, 0.00514364, 0.0267351, -0.0802739, -0.121809, 0.0953465, 0.121576, -0.0422372, -0.0111626, 0.0362199, 0.184484, 0.0944638, -0.0517634, 0.0634608, 0.146691, -0.127821, 0.0986291, 0.131209, 0.062977, 0.0432515, 0.0626402, -0.0756731, 0.193963, 0.0680598, 0.044132, 0.0639534, 0.0689224, 0.110897, -0.00824355, 0.136938, 0.0820945, -0.0358459, 0.067101, 0.000507757, 0.0359677, -0.00412654, 0.0960857, 0.0709832, 0.00578184, 0.0797252, -0.150084, -0.0137737, -0.0548515, 0.130811, 0.144597, 0.0139488, 0.108114, 0.0962984, 0.0907044, 0.219243, 0.039713, -0.0031862, -0.0553856, 0.0752703, -0.0788156, 0.00618758, 0.024461, -0.135154, 0.00774003, -0.0402457, -0.0669248, 0.00993567, -0.062079, 0.0259533, 0.0964803, 0.0217536, -0.17522, 0.0386904, -0.106764, -0.0508833, 0.0187609, -0.0347381, 0.00922551, -0.159104, 0.0992523, -0.0128124, 0.0931808, -0.0397517, -0.0129676, -0.0460599, -0.0346247, 0.03495, -0.0685385, 0.0123892, 0.0231339, 0.0425, -0.0211339, 0.0379609, -0.0194296, 0.0223193, -0.00309433, -0.0550892, -0.0686188, 0.0723262, 0.101888, -0.0644807, -0.00486238, -0.0490221, -0.0522734, -0.0235819, -0.0587046, -0.00865367, 0.0146148, -0.0570974, -0.0184806, -0.000719878, 0.133569, 0.0548308, 0.0820211, 0.0367641, 0.0872264, -0.0184791, 0.0765321, -0.0511789, 0.0690684, -0.105507, -0.0279496, 0.0136524, 0.10904, -0.0801765, -0.0232065, 0.0388624, -0.00384846, -0.0898916, -0.0720447, -0.033159, 0.10894, 0.0619536, 0.0759287, 0.113674, 0.0038969, 0.062729, 0.0312277, 0.0302171, 0.0682647, 0.0967346, -0.00354134, 0.101755, -0.110354, -0.0275868, 0.0943203, -0.0767026, -0.0499658, 0.0270769, 0.0368753, -0.00089618, 0.0961064, 0.0430132, 0.0804686, 0.168102, -0.031448, 0.0120233, -0.0851487, 0.00412931, -0.0350597, 0.0277522, 0.0439628, -0.12009, -0.0537202, -0.00509344, -0.0511817, 0.0552628, 0.00741776, -0.0678077, 0.0937676, 0.0754602, -0.143863, -0.0699611, 0.0153976, -0.0326152, -0.0121913, -0.0755093, 0.0943632, -0.035367, -0.032653, 0.0790802, -0.0738152, 0.0564678, -0.0633382, 0.0151776, -0.0705846, -0.0580195, -0.0180099, -0.0781877, -0.0753119, 0.0463823, 0.0325538, -0.0597395, 0.049529, -0.057967, -0.00151742, -0.00543329, -0.0657937, -0.0766749, -0.019776, -0.058945}, {0.0421776, -0.0175512, -0.0109147, 0.0667753, -0.0467059, -0.0247241, -0.0726293, -0.00213522, 0.0893625, -0.0616342, -0.00630984, 0.0621656, 0.0586635, 0.072351, 0.00926624, -0.0801804, -0.0351157, -0.0639701, 0.0466269, 0.0168332, -0.0268236, -0.0627459, 0.00266106, 0.0393679, 0.0405956, -0.0139364, -0.00930654, -0.0192224, -0.0199078, 0.067236, 0.0909687, 0.0638622, 0.0123402, 0.0647359, -0.0323219, 0.0621063, 0.0271107, -0.00491878, -0.0591133, -0.0259266, -0.0775273, 0.0720671, -0.0301094, 0.012914, 0.00596956, -0.0579037, 0.00960814, -0.0109994, -0.0536676, -0.0425808, 0.0393419, 0.0380638, 0.0398007, -0.020293, -0.0636112, 0.0124058, -0.0136857, -0.0774808, 0.080877, -0.00719281, 0.0596627, 0.0430308, 0.0678186, 0.0352209, 0.0500978, 0.0778539, 0.017928, -0.0978317, 0.089279, -0.0221697, -0.0631025, 0.0690178, 0.00803439, -0.0567305, -0.020708, 0.0573356, 0.111786, -0.0756646, 0.0302644, -0.0331812, -0.0631795, 0.0342082, 0.0794275, -0.0167441, -0.0245114, 0.00427704, -0.0373378, 0.00587912, -0.0778463, 0.0184755, 0.0147773, -0.0554945, 0.0144205, 0.0589912, 0.00273553, 0.074624, 0.0399684, 0.000954077, 0.0657099, 0.0816656, 0.014821, -0.0526763, -0.0798441, -0.0234214, -0.0516184, 0.024139, -0.0535247, -0.044914, -0.0180053, -0.0742063, -0.0215129, -0.0415142, -0.0715629, -0.028283, -0.0341544, -0.0781813, -0.0111907, -0.0571324, -0.0382861, -0.0269788, 0.0795245, 0.0183248, -0.00423368, -0.0646814, -0.0430505, 0.0574864, -0.0691348, 0.0413962, 0.0341223, 0.0167546, 0.0219248, -0.0613046, 0.0803241, 0.0015878, 0.0260808, 0.0770395, 0.0402424, -0.0703774, 0.0644721, 0.00972671, -0.0182558, -0.0172822, 0.0643971, -0.00986642, -0.0707589, 0.068986, -0.0796669, -0.0141687, 0.0420247, -0.0114071, -0.0339231, 0.0268484, 0.0620048, -0.0462436, -0.0728826, -0.00463101, -0.0818049, 0.0132101, -0.0554951, -0.0263529, -0.0429893, 0.0261404, 0.0121224, 0.0346429, -0.0291164, -0.0104436, 0.0451141, -0.000788795, 0.0578429, -0.0294819, 0.0587025, 0.00690092, -0.0781742, 0.0345635, 0.0262891, -0.0347619, -0.0502895, 0.0738395, 0.0810648, 0.0592039, 0.0561514, 0.0388859, 0.038305, -0.0594433, 0.0523874, 0.00245979, 0.047704, -0.00634741, -0.0381914, 0.0989941, -0.0015948, -0.0774685, -0.079609, -0.0104869, 0.0371224, 0.0281625, 0.0515475, -0.0491954, -0.00464584, -0.03948, -0.0878498, -0.0132646, -0.00215701, -0.0041555, -0.0605071, 0.0607932, 0.0430651, -0.0251841, 0.0580803, -0.0312832, -0.0576491, -0.0773272, 0.00669402, -0.118821, 0.0890873, -0.0324505, 0.0162174, -0.0115775, -0.0683236, -0.118332, -0.0960772, 0.0757973, 0.043821, -0.0128771, 0.0581956, 0.0518765, 0.0835259, -0.0535795, -0.0292143, -0.0338567, 0.0811664, 0.0714634, 0.10011, -0.0085016, -0.039067, 0.022488, 0.035748, -0.0359486, 0.0535097, 0.0152281, -0.0611545, 0.0358182, -0.0951968, -0.0653669, 0.028701, -0.0392621, -0.00955104, -0.0505145, 0.0162211, -0.0347495, 0.0111593, -0.0281159, 0.0482815, 0.0535099, 0.0609439, -0.0162418, 0.00999848, 0.0103555, -0.0392378, -0.0770828, -0.0533806, -0.0446488, -0.0206857, -0.0206423, 0.0192216, -0.0524288, 0.0595496, -0.101629, -0.00692054, -0.00375325, -0.014554, 0.0425946, 0.0288031, -0.0440067, -0.062739, 0.0781988, 0.0843661, 0.0602582, 0.124983, -0.0133402, -0.014925, 0.0772634, 0.0353592, -0.0173922, 0.0443787, -0.0195994, 0.0393707, -0.0391264, 0.0907632, -0.0244442, 0.0233213, -0.0491154, -0.0630222, 0.0246456, 0.116751, -0.0677526, -0.0173411, 0.00377658, 0.0176753, -0.104806, -0.0461986, 0.0218101, 0.00222065, 0.00508353, 0.011911, -0.0482706, -0.10552, 0.0837296, 0.0949024, -0.0470867, -0.0650894, 0.0480751, 0.00291941, 0.013531, 0.0749228, 0.0676966, 0.0574334, 0.0385092, -0.00914096, -0.0905182, -0.0985398, 0.0156618, 0.0127832, -0.080951, -0.0194491, 0.0975491, 0.1136, 0.000570448, -0.0577301, 0.00439672, 0.0737174, 0.0395708, 0.0730714, 0.0541625, -0.00420789, -0.0585876, -0.0184383, 0.0373828, -0.0626908, 0.0396449, -0.104625, 0.0956158, -0.0664683, 0.0133522, 0.0555552, 0.0190712, 0.0591892, -0.0270981, 0.0176242, 0.0536307, 0.0972119, 0.0595743, 0.0751067, -0.0323331, 0.00693565, -0.0320282, -0.0207737, 0.0496014, -0.0507721, 0.0853999, 0.0104848, -0.0823536, -0.116489, 0.0597656, 0.077478, 0.00512221, 0.0464537, -0.0506762, 0.0016625, 0.0247108, 0.0634601, -0.0640907, 0.00513285, -0.02609, -0.0438043, -0.0500172, -0.047635, -0.025509, -0.0175924, -0.00802409, 0.00685511, 0.0380173, -0.0791786, 0.0101166, -0.0501066, 0.0374759, -0.0989131, -0.0714105, 0.0254246, 0.118433, -0.0801022, 0.0713257, -0.0153787, 0.0302845, 0.0886731, -0.0843084, -0.00135956, -0.033557, 0.0438359, -0.130448, -0.00203077, 0.0300528, -0.0384543, 0.0559877, -0.0206566, 0.00359992, 0.014975, 0.0928691, 0.0963418, 0.00891916, 0.0764075, 0.0587483, 0.143069, -0.113278, 0.0678355, -0.00986152, -0.0167764, -0.0187826, -0.00545841, -0.114446, -0.112233, 0.105849, 0.00434975, 0.0732747, -0.0343118, 0.0445949, 0.151405, -0.0491184, -0.0234645, -0.0395483, 0.0267772, 0.00863751, 0.0565559, 0.0127564, 0.0320509, 0.00536069, 0.0162241, -0.00580741, -0.0297296, 0.0120354, 0.00456759, 0.0495653, -0.102235, -0.0175863, 0.032983, -0.0482699, -0.0284467, 0.0868991, 0.00204019, 0.080161, 0.0803212, 0.0222327, 0.097057, -0.047961, -0.0721307, -0.125158, 0.0328102, 0.0452151, -0.0740742, -0.00473195, 0.0817791, -0.0507929, -0.115737, 0.0176663, -0.0368655, -0.112119, 0.15959, -0.0473735, 0.122244, 0.00794957, 0.113441, -0.0516881, -0.0869912, -0.0978563, 0.0574008, 0.0780789, -0.0350484, -0.0202911, 0.127364, 0.0487262, 0.00467632, 0.0459372, 0.0188461, -0.0752683, 0.0515907, -0.080398, -0.0873882, -0.0508267, -0.0879843, 0.0577417, 0.0740843, 0.0652817, -0.0597377, 0.101458, 0.0204671, -0.111993, -0.0103721, 0.00561784, 0.0139663, -0.0462011, -0.0658268, -0.00630651, -0.152505, 0.0465038, -0.0264716, -0.0155805, -0.0342227, -0.0103483, 0.116725, -0.0807154, -0.0526326, -0.0337455, 0.0678876, -0.0722005, 0.107189, 0.0742343, -0.0191546, -0.0305971, -0.0188249, -0.127542, 0.0172003, 0.143953, -0.0505156, -0.00874881, -0.0579011, 0.153826, 0.0378135, 0.0366756, 0.0608692, -0.080069, 0.0841037, -0.0279269, 0.040102, 0.101678, 0.110823, 0.0670671, -0.0707233, -0.0513727, -0.102442, -0.0328564, 0.0518006, 0.110329, -0.00750185, 0.0269004, -0.0233752, 0.0723032, -0.0457043, -0.0668156, -0.0710549, -0.0200748, 0.0957379, -0.0162513, 0.0347589, -0.0135337, 0.0354635, -0.0352234, -0.0643594, 0.0602165, 0.0574736, 0.038301, 0.0776258, -0.00293449, -0.119238, -0.021593, 0.0478699, -0.0669557, 0.108359, -0.114645, 0.146923, -0.0245465, 0.0624503, -0.018543, -0.0214832, -0.0796876, 0.0078959, 0.0420658, -0.00787103, -0.0341262, 0.0385896, -0.00368017, 0.049192, -0.0516553, 0.040635, 0.062662, 0.027765, 0.0135689, 0.0601371, 0.0181736, -0.0023653, 0.0148482, 0.0574577, 0.0272742, -0.0123662, 0.0534926, -0.0342389, 0.039702, -0.0209592, 0.0606742, 0.0709114, -0.0325984, 0.0638587, -0.0951997, -0.0319576, -7.43493e-05, 0.0863066, 0.0432215, -0.035068, -0.0744048, -0.00529222, 0.014349, -0.0496719, -0.0205103, -0.0263558, 0.0278064, -0.0720919, -0.0988778, 0.0357801, 0.0498754, 0.000475692, -0.055887, -0.0371927, 0.0241322, 0.049005, 0.0705703, -0.0277342, 0.00537944, 0.0179555, -0.0744183, 0.0395164, -0.0482681, 0.00717358, 0.0653301, -0.0455273, -0.0288019, 0.00768122, -0.0569971, -0.0171937, 0.0551853, -0.0066952, -0.100407, -0.0411805, 0.000762126, -0.0940965, -0.0609244, -0.0238771, -0.0600319, -0.0108006, 0.00797963, -0.0629919, 0.0646821, 0.0834812, -0.0325074, 0.0414107, -0.0527691, 0.0777676, -0.0541025, -0.0242901, 0.000356961, -0.0262437, 0.0722331, 0.0564949, -0.0185586, 0.0307391, 0.0806493, 0.0185218, -0.0373824, 0.087523, -0.0461501, 0.0295539, 0.0417995, -0.0272297, -0.0733152, -0.0256483, 0.0344753, 0.05754, 0.000138871, -0.0144917, 0.0273816, -0.00713633, -0.00255069, 0.0526823, 0.072521, -0.00269199, -0.0389634, -0.035086, 0.0391842, -0.0203743, 0.0165912, -0.11007, -0.0367493, -0.0823401, 0.0327748, -0.0423537, 0.10694, 0.0234098, -0.0722773, -0.0586247, 0.0574857, 0.0470815, -0.0681795, -0.0382774, 0.0546216, -0.0421918, 0.0801492, 0.0659332, 0.0158592, -0.0719956, -0.029068, -0.0346344, 0.0548596, 0.0409343, -0.0694611, 0.0671703, 0.0619193, 0.0374689, 0.0439974, -0.00322652, -0.0544561, 0.0335817, -0.0423155, -0.0312643, 0.000897401, -0.00894307, 0.0261992, -0.0985558, 0.112324, 0.0934832, 0.0347378, 0.0378979, 0.0712437, 0.0643719, -0.0446338, -0.0465072, 0.0155617, 0.0227711, -0.0403381, 0.000345998, -0.00354859, 0.031883, -0.0822698, -0.0491175, -0.0333585, 0.0546975, 0.053513, -0.0204114, 0.0552269, -0.0268613, 0.00567252, -0.00172655, 0.0235488, 0.0162704, 0.00238876, 0.0197546, 0.025481, -0.0530532, 0.0658319, 0.074533, 0.0821347, -0.0606446, 0.0577337, 0.0117654, -0.097506, 0.0235485, 0.0404025, -0.0337696, 0.0583049, -0.0113992, -0.0143064, 0.0119187, -0.0596169, 0.0604489, -0.0779858, 0.0552482, 0.0419276, -0.0695918, -0.0562952, -0.00410273, -0.00594008, -0.0613, 0.0542473, -0.0232304, -0.0193631, 0.0327956, -0.0342265}};;
    float lay2[26][100] = {{-0.0348534, 0.126007, -0.191911, -1.5148, 0.143212, 0.24641, 0.00338568, 0.279289, -0.000469201, -0.00945265, 0.407268, -0.396945, -0.089824, -0.992343, -0.509543, 0.344127, -0.693487, 0.0828193, -0.328522, 0.204833, -0.849623, -0.187816, -0.78253, -0.109913, 0.401031, 0.106545, -0.37779, -0.373828, 0.0124304, 0.226169, 0.203635, -0.0982753, 0.0831255, -0.286977, 0.163571, 0.475392, -0.705456, 0.0128147, -0.221957, -0.561226, 0.353851, -0.294907, 0.00754249, -0.740539, 0.370759, 0.27064, -0.0766579, 0.31566, -0.0790374, -0.252655, -0.147049, 0.238915, -0.535116, 0.0561361, 0.473636, -0.510542, 0.233993, 0.214011, 0.292529, -0.13932, -0.247171, 0.21737, -0.300062, 0.0369906, -0.137416, -0.306719, 0.0856164, -0.0657327, 0.217611, -0.168832, 0.323727, -0.0562982, 0.288287, -0.289749, -0.748029, 0.0929533, 0.181833, 0.122748, -0.220672, -0.0757632, -0.729953, 0.032389, 0.101802, 0.201516, -0.597474, -0.292177, -0.00902413, 0.32792, -0.231435, -0.285663, -0.612396, 0.194968, -0.206577, 0.248432, -0.455591, 0.071381, 0.536976, -0.311157, -0.904617, -0.546463}, {-0.494079, 0.582521, 0.335078, -0.955925, 0.0626904, 0.228372, 0.149468, -0.0629303, 0.0530946, -0.100159, 0.313575, 0.150816, -0.489175, -0.27573, -0.282954, -0.406957, 0.207871, 0.0174175, 0.0711876, 0.000711427, 0.201381, 0.212906, 0.10672, -0.482267, -0.242171, -0.870656, -0.725262, -0.341022, -0.301086, -0.0517485, -0.525399, 0.0157188, 0.0249682, -0.198161, -0.402743, -0.622742, -0.244208, -0.939398, -0.103445, -0.138556, 0.398611, 0.405017, 0.195327, -0.249981, 0.190102, -0.357946, -0.35152, -0.302716, -0.131793, 0.177366, 0.380633, 0.022648, -0.499203, 0.372279, 0.549717, 0.275032, -0.66715, -0.88807, 0.153503, -0.174397, -0.356671, 0.408977, -0.0422067, -0.417601, 0.44068, 0.242095, -1.32525, -0.470328, -0.516693, 0.15536, -0.103354, 0.396938, 0.206389, -1.24221, 0.568422, 0.14444, -0.514746, 0.529389, -0.120852, -0.450452, 0.454257, -0.450565, -0.138749, -0.31981, -0.749245, -0.0666571, -0.673375, -0.0477291, -0.587028, -0.330543, 0.0634688, -0.00356332, -0.0501964, -0.0328779, 0.198539, 0.406688, -0.659244, 0.17784, -0.296824, 0.100079}, {-0.282873, 0.360892, -0.569211, 0.320985, -0.0592675, 0.487002, 0.292089, 0.0466234, -0.296808, -0.381646, -0.0518498, 0.0118037, -0.197873, -0.569419, -0.506279, -0.472728, -0.064325, 0.228822, -0.285698, -0.368023, 0.50511, 0.131326, -0.108882, -0.613595, -0.390364, -0.04041, -0.0222051, -0.101496, 0.33928, 0.00519352, 0.277956, -0.189365, -0.547589, -0.499872, 0.446853, 0.226014, -0.333695, -0.705657, 0.49011, 0.537491, 0.618001, 0.631297, -0.196722, -0.0430058, 0.134354, -0.323287, -0.338677, -1.03199, -0.563863, 0.00375405, -0.404001, -0.21284, 0.219036, 0.0139955, -0.850886, -1.23904, -0.905467, -0.447987, -0.200336, 0.303369, 0.0551984, 0.119739, -0.175876, 0.135763, 0.0107884, -0.731504, 0.265374, 0.192557, -0.479669, 0.0760315, -0.487207, -0.410025, -0.585603, 0.261431, 0.188027, -0.136394, 0.0298975, -0.489027, 0.291931, -0.564136, -0.275631, -0.264334, 0.131107, -0.502601, 0.25348, -0.494571, -0.722553, 0.179099, -0.11526, 0.127551, 0.111558, -0.15544, -0.381694, -0.302233, 0.444393, 0.355591, -0.469112, -0.115547, -0.268682, 0.0579925}, {-0.168318, -0.0900561, -0.482968, -0.577226, 0.417598, 0.298348, -0.237936, -0.996035, -0.326735, 0.0564656, 0.368576, 0.0763737, -0.328389, -0.0239574, 0.387805, -0.025212, 0.0468939, -0.00477132, 0.0747641, -0.188054, -0.642074, 0.0688453, -0.300037, -0.103913, -0.708009, -0.458799, 0.409488, -0.0826752, 0.111368, -0.250675, -0.0217817, 0.0344814, 0.288477, 0.232224, 0.16479, -0.598185, -0.170221, 0.0665527, -0.541003, -0.274938, 0.329002, -0.306295, 0.37796, 0.0474471, 0.040172, -0.427381, 0.050214, -0.466147, -0.0710897, 0.47461, -1.63299, -0.417219, -0.28663, 0.513023, -0.713826, 0.258765, -0.42571, 0.0188442, -0.374318, 0.271563, -1.36644, -0.365522, -0.257326, 0.526652, 0.405595, -0.0930373, 0.269884, -0.0633713, -0.0266963, -0.355656, -0.0671255, -0.486944, -0.0319649, -0.119292, 0.0540424, 0.40943, -0.120956, -0.144176, 0.214206, 0.0574463, -0.00148239, 0.216731, 0.258588, 0.0265181, -0.710411, -0.577701, -0.938235, 0.0579175, -0.212963, -0.237653, -0.292061, -0.0265548, 0.139243, 0.177686, 0.205878, 0.13262, -0.0402864, -0.00527135, 0.51265, 0.0133963}, {-0.0708245, -0.326752, 0.0349776, -0.032817, 0.130653, -0.229779, -0.077192, -0.0529434, 0.0114789, -0.502529, 0.256101, 0.121497, 0.0969886, 0.17447, -0.147428, 0.229386, -0.64531, 0.136022, 0.201655, 0.268633, -0.0506433, -0.156378, -0.243248, -0.912547, -0.288433, -0.206005, -0.190213, 0.146354, -0.0641531, 0.0583391, 0.0882407, 0.51806, -0.245329, -0.265648, -0.242699, 0.0739602, 0.156745, -0.258407, 0.112831, 0.111644, -0.882525, 0.00171144, -0.097352, -0.61678, -0.143909, -0.726674, -0.146201, -0.225239, -0.291691, -0.0367873, 0.311826, -0.306285, 0.348942, 0.337439, -1.09882, 0.16551, -0.804931, -0.282136, 0.272528, 0.345656, -0.118934, -0.582524, 0.0173544, 0.0674888, 0.282511, 0.453905, -0.42953, -0.187531, -0.130251, 0.0405972, 0.0486888, 0.0880513, 0.00414316, -0.769905, -0.0503541, -0.0515976, -0.281937, 0.0743986, -0.0907616, 0.0535766, -0.046139, 0.0558126, 0.119421, -0.281761, 0.475893, -0.164831, 0.08453, -1.12865, 0.102967, -0.466155, 0.281546, 0.0401617, -0.24765, 0.0535421, 0.0385791, 0.12578, -0.159979, -0.157668, -0.10852, 0.0808665}, {-0.179845, -0.214914, 0.149758, -0.010414, -0.0280126, -0.0573975, 0.121077, -0.0111698, -0.102487, 0.0839067, 0.0778791, 0.0078791, -0.0981504, 0.0239459, -0.174313, -0.0789485, 0.00731091, -0.22421, -0.167582, -0.133105, 0.391007, 0.130827, -0.141005, 0.0198392, -0.0394837, 0.226904, 0.203471, -0.141629, -0.20219, -0.535226, -0.719521, -0.424146, 0.142778, -0.338306, -0.198372, 0.0755306, 0.170183, 0.27227, 0.169277, 0.0331385, -0.550266, -0.165202, -0.374519, -0.441854, -0.180854, 0.0448665, -0.304483, -0.198869, -0.58205, -0.0802325, -0.150449, 0.0298543, -0.681089, 0.463508, -0.975181, -0.770266, 0.413838, 0.350726, 0.251242, 0.356108, -0.526453, -0.388486, -0.724086, -0.340977, -0.465521, -0.579366, 0.279332, 0.0363611, -0.134861, -0.0998173, 0.0125712, -1.10456, 0.16662, 0.0225633, -0.245508, 0.135562, 0.262249, 0.0521297, -0.448151, 0.0424307, -0.610294, -0.437441, 0.14219, -0.00506204, 0.295401, 0.171593, -0.22308, -0.153997, -0.27303, 0.311958, -0.400809, -0.46927, 0.0828235, 0.199488, 0.130088, 0.155667, -0.309025, 0.165417, 0.0918823, -0.130207}, {-0.0910159, -0.411624, 0.0865307, 0.127829, 0.123802, 0.0865511, -0.0306198, -0.728364, 0.250196, 0.0753395, -0.0255212, 0.0965866, -0.273999, 0.3789, 0.188694, 0.28483, -0.0214453, -0.864005, 0.221049, -0.0102492, 0.269615, 0.00889545, -0.218277, 0.00499865, 0.318408, 0.20956, -0.0908601, 0.0713543, -0.302912, -0.178526, 0.157319, 0.179116, -0.665478, -0.134211, -0.569707, -0.92714, 0.122712, -0.0492753, 0.115137, 0.182448, -0.0979694, 0.348568, 0.0641619, -0.223507, 0.162749, 0.118535, -0.40865, -0.619815, -0.214331, -0.420053, -1.09676, 0.324438, 0.290905, -0.0984886, -0.183227, -0.249943, -0.217689, -0.568193, 0.0262803, 0.0725823, -0.0194934, 0.111933, -0.331415, -0.151908, -0.130506, 0.354233, -0.572042, 0.393829, 0.168237, 0.250938, 0.263459, 0.0133524, -0.634244, -0.123291, 0.0929055, 0.040426, 0.302568, -0.417506, -0.0165635, 0.23665, -0.0954756, 0.107912, -0.0809548, -0.0620722, -0.799428, -0.420177, -0.517737, 0.183926, 0.107111, -0.0873469, 0.0556325, 0.264122, 0.192873, 0.0222163, -0.16882, 0.0169055, -0.214144, -0.761488, 0.273619, -0.128529}, {-0.477831, -0.232593, -0.451488, -0.0171135, 0.189327, -1.1279, -0.117931, -0.109176, 0.58932, -0.485788, -0.0980126, 0.352255, 0.372708, 0.15131, -1.9815, -0.590689, -0.783405, -0.591462, -0.841231, -0.408721, 0.647497, 0.17059, -0.710847, -0.054388, -0.577261, 0.420418, -0.111461, -0.19239, 0.229485, 0.108158, -0.3419, 0.135343, -0.46152, -0.780379, -0.0406651, -0.389749, -0.667883, -0.350336, -0.0440831, -0.420141, 0.312822, 0.15316, 0.0915096, 0.202419, -0.171723, 0.186679, 0.259809, -0.258389, -0.629866, -0.282923, -0.313795, -0.256548, -0.377196, -0.127267, -1.0495, -0.420068, -0.0909358, 0.249792, 0.0321888, -0.849258, -0.0372865, -0.914099, 0.384153, 0.118363, -0.58702, -0.014229, -0.377741, -0.656477, 0.225746, -0.378952, 0.45279, -0.697122, 0.310991, -0.731125, 0.309034, -0.43386, 0.0670654, -0.127997, -0.0513757, 0.20738, 0.250885, 0.0532546, 0.738231, -0.815281, -0.612789, -0.834751, -0.0759888, -0.191348, -0.0309483, 0.112218, -0.467658, 0.292141, -0.0652515, -0.297366, -0.371696, 0.12621, -0.618772, 0.108549, -0.161922, 0.183586}, {-0.0921621, -0.0015029, -0.573648, -0.0555664, 0.222118, 0.152573, -0.229269, -0.174952, 0.225942, 0.349656, 0.14058, -0.258825, 0.143035, -0.916208, -0.00782119, 0.123567, -0.2108, 0.0181737, -0.851818, -0.872848, -0.0459582, -0.26292, 0.244165, 0.229195, 0.110181, -0.282596, -0.180095, -0.240726, -0.610858, -0.0700051, -0.13366, 0.0101688, 0.196834, 0.127698, 0.00125218, 0.0143281, -0.217474, 0.0423607, -0.100869, 0.0177813, 0.168892, 0.189341, -0.1625, -0.144859, 0.112588, -0.1275, 0.20189, 0.087548, 0.0781117, 0.157657, -0.203836, -0.0333173, -0.107059, 0.0874115, -0.103097, 0.0887093, 0.0187837, 0.153182, 0.106242, -0.839624, -0.142829, -1.13508, 0.119222, 0.0925051, -0.127427, 0.0258896, -0.0701268, 0.0952834, -0.294495, -0.607257, 0.00274492, -0.210722, 0.0480352, 0.341355, 0.21372, -0.0453485, -0.77537, 0.480141, 0.12524, 0.100438, -0.0271619, -0.210761, 0.54418, 0.0348149, 0.122475, -0.382155, 0.162105, 0.0599089, -0.348444, -0.147437, -0.423833, 0.0978634, -0.442222, 0.106284, 0.0789024, 0.478368, -0.560806, 0.130475, 0.00887884, 0.335642}, {-0.335575, -0.0279962, -0.63382, 0.343124, 0.0432191, -0.0823609, -0.0867784, -0.581117, 0.33135, 0.23194, -0.416208, 0.397918, -0.0276635, 0.286131, 0.0198055, -0.836505, 0.00193806, -0.0481286, 0.0361391, -0.0168712, 0.167083, 0.0759312, -0.0621818, -0.121945, 0.0334158, -0.387019, -0.0371962, 0.12875, 0.189103, -1.17159, 0.136669, -0.00922477, 0.0495705, 0.131853, -0.0752032, 0.0115079, -0.304028, 0.194081, -0.325425, 0.121823, -0.107018, -0.348105, -0.680786, -0.129586, 0.0622355, 0.187579, -0.0528242, 0.324542, -0.137305, -0.0400464, -0.647583, -0.173857, -1.04173, 0.0247, 0.123425, -0.209643, -0.13741, -0.631272, -0.133151, 0.391113, 0.170827, 0.156001, 0.107451, 0.157442, -0.784883, 0.0736906, -1.01521, -0.144903, 0.00264631, 0.330752, -0.14048, -0.0676556, 0.0674588, -0.198959, 0.434167, 0.304955, -0.241322, -0.166526, -0.223501, -0.160783, -0.343848, -0.132065, -0.212014, 0.0166658, 0.261258, -0.454214, -0.0970205, -0.865116, -0.222973, -0.50881, 0.0890678, -0.229835, -0.457579, 0.056828, -0.806577, -0.0934173, -0.779652, -0.0144032, -0.119996, 0.139663}, {0.0741884, 0.253205, -0.308579, -0.0893192, -0.311964, -0.36499, -0.0497974, -0.221821, -0.0824051, 0.485914, -0.254438, 0.45367, 0.840484, -0.219398, -0.831079, -0.148989, -0.069077, -0.0526326, 0.358782, 0.0236315, 0.0169625, -0.555136, 0.319174, 0.630769, -0.61764, -0.154299, -0.744196, -0.752225, 0.0577613, -1.24532, -0.755763, -0.623547, 0.479499, 0.42835, 0.176104, -0.367071, -0.785241, 0.125427, -0.455985, 0.287373, -0.158699, 0.231517, 0.092021, -0.0869857, -0.334795, -0.432453, 0.274715, 0.0701997, 0.10159, 0.145148, -0.0233062, -0.509494, -0.170972, 0.251644, 0.0986814, 0.392893, 0.21532, -0.0830781, -0.0211663, 0.332382, -0.0232153, -0.265612, 0.117708, -0.596427, -0.0816953, -0.797917, 0.204666, -0.141687, -0.364746, -0.179639, -0.220268, 0.0844564, -0.339016, 0.25119, 0.0159641, -0.513528, 0.290231, -0.283518, 0.0341613, 0.242533, -0.256449, -0.0272883, -0.0330097, 0.126791, 0.0815883, -0.245905, -0.169786, 0.142406, 0.235083, 0.178977, 0.00942281, -0.2981, 0.145956, 0.158562, -0.595367, -0.0724939, -0.132299, -0.39235, 0.101407, 0.066498}, {-0.357831, -0.137636, 0.281523, -0.0248849, 0.0648976, -0.00603597, -0.38675, -0.244728, 0.29006, 0.00500093, 0.00978544, -0.427394, -0.0618244, -0.121185, 0.226744, 0.0610778, 0.275275, -0.0757393, -0.0643899, -0.280906, -0.444034, 0.18925, -0.26061, -0.337634, -0.210002, -0.407506, -0.00918404, -0.0805396, 0.235594, 0.367384, 0.0374555, -0.328507, -0.406383, -0.111393, -0.081053, -0.301329, -0.537014, 0.275561, -0.0518887, 0.51831, -0.0223345, 0.527001, 0.16579, 0.377228, -0.715818, -0.319047, 0.264067, -0.539226, 0.0944641, -0.0169553, 0.373357, -0.840275, 0.376834, 0.188972, 0.649398, 0.0395016, -0.200171, -0.910274, 0.0755373, -0.295396, 0.154312, -0.685338, 0.174482, 0.238119, -0.810151, -1.50091, 0.0362287, -0.102113, 0.312801, 0.0292963, 0.16888, 0.0657041, 0.295433, -0.687881, 0.022449, -0.0155373, -0.293287, -0.00209934, 0.129079, 0.253309, 0.00595901, 0.469296, 0.152874, -0.56386, -0.0224071, 0.122934, -0.556217, -0.315314, 0.528949, -0.182837, -0.303565, -0.199277, -0.887544, -0.712179, 0.322812, -0.502961, 0.0591401, 0.0423146, 0.122495, 0.0879962}, {0.101768, -0.248948, 0.153022, -0.0991583, -0.256735, -0.481992, -0.35697, 0.0600481, -0.162353, 0.280513, 0.294119, 0.0485309, 0.215888, 0.0425355, 0.178819, -0.211259, -0.218349, -1.12456, -0.633595, -0.883416, -0.602835, -0.851565, 0.291559, -0.237014, -0.472553, -0.109208, -0.530404, -0.378681, 0.155482, 0.438727, -0.230535, 0.277881, -0.506665, -0.250346, -0.783719, 0.263103, -0.14812, 0.0884449, -0.110507, -1.06038, 0.118467, 0.225432, -0.131331, -0.120632, 0.0284913, -0.283668, 0.367673, -0.499585, 0.00922835, -0.179881, -0.0679163, -0.169289, -0.0446981, -0.0765849, 0.0637942, 0.371525, -0.624562, 0.340843, -0.344456, 0.130788, 0.591527, 0.139971, -0.474656, -0.521256, -0.222768, -0.250062, -0.0613113, 0.746587, 0.0829771, 0.0568409, 0.327149, -0.504773, -0.199193, -0.476407, 0.151678, 0.0875028, -0.0694284, -0.0730643, 0.108492, -0.148733, -0.339624, 0.214019, -0.197618, -0.918387, 0.412396, 0.377824, 0.398851, 0.137829, -0.22596, -0.09254, -0.691482, 0.250322, -0.69491, -0.0491311, -0.0233912, -0.0821613, -0.459953, 0.163774, -0.0248364, -0.479863}, {-0.276601, -0.394393, 0.175504, -0.141305, 0.0545259, 0.236678, 0.522065, -0.561696, 0.0333573, 0.103204, -0.0938302, 0.112663, -0.120746, -0.339603, 0.180243, -0.330858, 0.255075, -0.429586, 0.0753566, -0.779276, -0.246401, -0.34729, 0.327165, 0.15824, 0.516187, -0.203062, -0.0623157, -0.0696101, 0.0355629, 0.153828, 0.113867, 0.262169, 0.149443, -0.0184409, -0.581181, -0.397318, -0.178417, 0.174458, -0.21321, -0.214766, -0.236675, -0.259613, -0.20554, -0.243146, -0.418779, -0.0251851, -0.374789, -0.369665, -0.509948, -0.888573, -0.54881, -0.28968, -0.144838, 0.172675, -0.152464, -0.124379, -0.0727917, 0.10469, -0.293868, -0.104656, 0.0284646, -0.178407, 0.21793, -0.742391, 0.279416, -0.155325, 0.0727517, 0.0400234, 0.0581915, 0.188671, -0.252884, -0.157357, -0.0248378, 0.0662997, 0.106267, 0.0170745, -0.0459354, -0.137037, 0.0959557, 0.000630196, -0.268835, 0.0345634, -0.233449, 0.285595, -0.622359, -0.0154251, -0.438908, 0.161947, -0.0191873, -0.785912, -0.362327, 0.255766, -0.147578, 0.125927, -0.715911, -0.204064, -0.132348, 0.151491, -0.0523345, 0.197464}, {0.727012, -0.0652967, -0.0397446, -0.379717, -0.178739, -0.568775, -0.763677, -0.627264, -0.496903, 0.0293948, -0.233182, 0.311591, -0.9915, -0.424233, 0.0467259, 0.0583646, -0.388811, 0.201515, 0.153214, 0.498167, 0.5652, -0.0548907, -0.0265286, -0.427207, 0.221224, -0.0355519, 0.0148783, -0.153168, 0.401102, -0.321207, -0.483637, -0.316664, -0.437911, -0.116206, -0.884223, -0.215389, -0.570593, 0.40452, 0.0497605, -0.222414, 0.139295, 0.454438, 0.406014, 0.387904, -0.418208, -0.226425, -0.493233, -0.371157, -0.604527, 0.0888237, 0.530667, 0.196777, -0.116501, 0.138351, 0.216266, -0.0908521, -0.426985, -0.518974, 0.12238, 0.000161533, 0.044041, -0.331557, 0.263199, 0.129521, -1.39753, 0.730938, 0.0429383, -0.529465, 0.269316, 0.114588, 0.150055, -0.648083, -0.542797, -0.638088, -0.0144076, 0.840639, -0.151464, 0.0747321, 0.177526, -0.0106994, 0.191802, 0.0663864, 0.208434, -0.00333597, 0.0314092, 0.364848, -0.305517, -0.378961, -0.113118, -0.0732907, -0.529036, -0.120467, -0.795467, -1.03228, 0.157666, -0.117468, 0.378532, 0.252357, 0.281471, 0.0718551}, {-0.0870044, -0.166649, 0.219601, -0.445951, -0.320011, -0.772922, -0.00731929, 0.0585036, 0.147178, 0.045529, -0.202621, 0.1044, 0.0781369, -0.246416, -0.0709494, 0.14031, 0.0383824, -0.63185, 0.439177, 0.180715, -0.0197416, 0.0899174, -0.0346405, -0.28531, 0.0041356, 0.203529, -0.917536, -0.013883, 0.0796981, 0.00325995, 0.0683205, -0.0195875, -0.410113, 0.151821, 0.0472627, 0.273394, -0.20359, -0.143013, 0.212216, -0.255457, -0.0177708, 0.0759457, -0.277462, -0.125099, 0.214443, -0.421055, 0.117044, 0.117467, 0.102339, -0.469523, -0.0804812, 0.219085, -0.0748749, -0.237759, -0.0118727, -0.343969, 0.0398623, 0.279666, -0.157945, 0.0669028, 0.194382, -0.135317, 0.179108, -0.00534023, 0.151446, 0.0223691, -0.182868, -0.240294, -0.152454, -0.0657595, 0.000559976, -0.194156, 0.282783, 0.310364, 0.390974, -0.0981913, 0.00517264, 0.252237, -0.162359, 0.112557, -0.379873, -0.48704, -0.596127, -0.84487, -0.862323, -0.230898, 0.0873778, -0.0295807, -0.136069, -0.127409, -0.137025, -0.00650059, 0.202793, 0.083667, -0.137397, -0.0769973, -0.0751745, -0.0676476, 0.0881547, -0.133908}, {-0.162745, 0.133473, 0.176254, 0.00231808, 0.139102, -0.0857945, 0.00941795, -0.0211906, -0.0567367, -0.041051, -0.173935, 0.11897, -0.146169, 0.190528, 0.10764, 0.272548, 0.00718585, -0.905471, -0.341782, -0.165805, -0.724031, 0.0301992, -0.078967, -0.0549244, -0.179728, 0.0373438, 0.228816, 0.0438341, 0.0355568, 0.332963, 0.196084, -0.337979, 0.139384, -0.96213, 0.0953199, -0.119489, -0.866545, 0.177937, -0.494535, 0.185064, 0.330941, -0.308357, 0.463076, 0.224452, -0.32326, -0.261321, 0.266064, -0.369149, -0.211861, 0.344085, -0.449552, -0.202431, -0.648878, 0.463288, -0.2303, -0.0196044, 0.0106894, -0.0380369, -0.40556, -0.737947, -0.561349, -0.921053, -0.0254359, 0.452139, -0.605924, 0.209777, -0.264089, -0.258627, 0.520429, 0.297814, 0.0965386, -0.275552, -0.593233, -0.458122, 0.00699135, -0.460044, -0.765428, -0.0242578, -0.244942, -0.2651, 0.285703, 0.197871, 0.408343, -0.262319, -0.481265, 0.0294224, 0.00169751, -0.0378432, 0.530719, -0.428453, 0.0947696, -0.107641, 0.302271, -0.151004, -0.786035, -0.149523, -0.110501, 0.0533815, -0.330544, -0.0733629}, {0.0677797, -0.273162, 0.155851, 0.167133, -0.234803, -0.145395, 0.101552, 0.076373, -0.539552, 0.141027, 0.510398, 0.315598, -0.142712, 0.252436, 0.400306, -0.0848847, 0.51417, -0.124296, 0.113875, -0.617055, 0.0709779, 0.205886, 0.183006, -0.158868, -0.193394, -0.398641, 0.0335625, 0.097002, -0.515531, -0.116534, 0.122782, -0.0747367, 0.116102, 0.223551, 0.0400079, -0.164537, 0.0959041, -0.232379, 0.0735908, -0.0885815, -0.544618, -0.776521, 0.0397274, -0.189565, 0.0304069, -0.325899, -0.627566, -0.992632, -0.0538133, -0.0808324, 0.275604, 0.00612853, -0.421188, 0.21889, -0.0147156, 0.0808046, -0.233619, -0.805166, -0.270407, -0.446485, 0.0687367, 0.463502, 0.124618, 0.33422, -0.0531759, 0.21275, 0.193745, 0.0542998, -0.0905865, 0.219216, -0.173516, 0.21796, -0.0477536, -0.128913, -0.21455, 0.227006, -0.292485, -0.36391, 0.499659, 0.32381, 0.145794, -0.0824255, -0.172147, -0.0867384, -0.406082, -0.00454103, -0.81565, -0.230959, 0.36238, -0.178753, -0.03626, -0.493343, -0.013726, -0.649859, 0.291844, -0.0143181, -0.668633, -0.0719644, 0.0186309, 0.066442}, {-0.0166657, 0.211996, -0.0767604, -0.150293, -0.128257, 0.388075, -1.08714, -0.262486, -0.50856, 0.27304, -0.340477, -0.0624453, 0.00176467, 0.0809062, -0.148562, -0.409005, 0.316577, 0.324058, 0.0529191, 0.0818901, -0.354991, -0.532328, -0.0430914, 0.0740329, -0.127737, -0.365006, -0.49273, -0.321025, -0.0390133, 0.513971, -0.0241328, -0.311793, 0.573305, -0.145695, -0.192852, -0.401887, -0.225629, -0.318352, -0.405515, 0.434761, 0.310841, 0.120851, 0.0736375, 0.24942, 0.149825, 0.0801662, -0.186375, -0.124991, -0.192795, -0.340597, -0.454756, -0.932974, -0.113718, -0.00833924, 0.159143, -0.0601274, 0.317751, 0.18568, 0.215226, 0.213396, -0.746541, -0.60922, 0.300074, 0.116678, -0.233544, 0.369044, 0.15653, -0.236182, 0.267077, 0.512798, -0.086074, -0.343742, -0.748891, 0.00111984, -0.269362, -0.28543, -0.566151, -1.06292, -0.397244, 0.19694, 0.133399, 0.0439775, 0.222153, 0.224546, 0.490019, 0.0928201, -0.418917, -0.496432, -0.610026, -0.47281, -0.502958, 0.152735, 0.78088, 0.209831, -0.13964, 0.151741, 0.255222, 0.149559, -0.196849, -0.196295}, {-0.377473, -0.0733064, -0.38511, 0.35746, 0.0170786, 0.0819281, -0.433428, 0.319858, -0.0831262, -0.597615, -0.324219, -0.199715, 0.243176, 0.0517607, 0.222793, -0.0454254, -0.0340973, -0.00989338, 0.20671, 0.874812, -0.0367153, -0.0582591, 0.205405, -0.852014, -0.0157728, -0.304226, 0.328754, 0.452547, -0.36558, -0.90663, -0.386375, -0.703858, -0.645421, -0.116003, -0.524421, 0.0636935, 0.0202702, -0.807741, 0.22642, 0.283703, 0.0485439, 0.262216, -0.460233, -0.138365, 0.176396, -0.751527, -0.531429, -0.735812, -0.706306, 0.692955, 0.356336, -0.216544, 0.174552, -0.459469, -0.337651, -0.0100467, -0.00335411, 0.0147956, 0.127869, 0.648924, -0.647904, -0.226281, -0.114823, 0.163497, 0.0276812, 0.0808208, 0.0465087, 0.038302, -0.430731, 0.257014, 0.0403276, -0.288822, -0.0924577, -1.0402, -0.407338, -0.416978, 0.0832419, 0.0295133, 0.427914, -0.0865287, 0.0281643, -0.320052, 0.31157, -0.450712, -0.514887, -0.609212, -0.341017, -0.0343932, -0.142875, -0.113578, 0.305384, 0.102614, 0.344656, 0.113148, 0.0453586, -0.439117, 0.158674, -1.05735, -0.31256, -0.224381}, {0.229044, -0.0586163, -0.273526, 0.119878, -0.00307257, -0.0204129, 0.288315, 0.0838111, -0.206542, -0.0524669, 0.258009, -0.186252, -0.0967001, -0.245144, 0.0839498, 0.0367042, -0.144089, -0.0644395, 0.200878, -0.226183, -0.05675, -0.158177, -0.128876, -0.0412416, 0.116008, -0.287577, -0.358015, -0.178812, -0.26448, -0.085417, -0.0172789, -0.175544, 0.156735, 0.00342731, 0.341915, -0.158272, -0.368843, -0.193862, -0.0627467, -0.0730092, -0.203973, 0.0860037, 0.0869326, -0.543962, 0.311846, -0.284136, 0.0999695, -1.20983, 0.156047, -0.332587, 0.123614, 0.271182, 0.038926, -0.225384, -0.406849, 0.00793816, 0.305285, 0.329047, 0.123393, -0.0515356, 0.192777, -0.400447, 0.0765817, 0.230264, -0.859375, -0.329199, -0.606223, -0.480913, 0.17634, 0.0470195, 0.201217, 0.271414, -0.239449, 0.276577, 0.00271862, -0.459093, -0.762627, -0.928569, -1.04159, 0.209781, 0.137052, 0.13477, -0.0559239, 0.265678, -0.242943, -0.0384629, 0.166247, -0.560566, 0.278973, -0.110339, -0.655989, 0.360195, -0.0636653, -0.144486, 0.0174094, 0.23018, 0.235459, 0.380961, -0.00635552, 0.102186}, {-0.343641, 0.0204891, 0.129965, -0.104452, -0.609473, 0.49745, -0.185004, 0.141012, -0.502857, 0.00316507, -0.178049, 0.0794915, -0.953329, -0.39122, 0.253199, 0.462308, -0.0922856, -0.455904, -0.497243, 0.820339, -0.46491, -0.148901, -0.653003, -0.0796903, -0.247551, 0.549388, -0.729096, -0.720132, -1.14024, 0.0820058, -0.0236946, 0.538203, 0.176696, 0.0312691, -0.320517, 0.14692, -0.578113, -0.379684, -0.0449228, 0.182287, 0.187133, 0.106061, -0.688459, -0.727952, 0.23888, 0.0363444, 0.109222, -0.451443, 0.139398, -0.707269, 0.154766, -0.161381, 0.100834, 0.353028, -0.175755, -0.0084082, 0.230238, 0.142474, -0.0484884, -0.00171097, -0.587589, 0.218144, -0.0950996, 0.183416, -0.0589538, 0.251301, 0.390671, -0.148457, 0.167872, -0.227058, -0.239072, -0.0878047, 0.108742, -0.000812989, 0.0641004, 0.138944, -0.300771, 0.231552, -0.049806, -0.086721, 0.373348, 0.218122, -0.0677486, 0.2846, 0.511003, -0.366176, -0.723855, -0.0974449, -0.368699, 0.101139, -0.0122918, 0.351998, -0.556224, -0.0070666, 0.129364, -0.0870728, -0.084957, 0.27274, -0.663287, 0.239263}, {-0.183898, -0.103588, -0.432533, 0.254656, -0.203837, -0.000730724, 0.543398, 0.142328, 0.172361, -0.297907, -0.0296522, -0.123091, -0.11723, 0.00980375, 0.141518, 0.0239309, -0.348321, -0.362312, 0.289999, -0.509636, 0.259055, 0.270653, 0.0765224, 0.000930313, -0.393675, 0.125582, -0.811924, 0.141687, 0.2759, -0.152768, -0.619374, -0.234988, -0.302475, 0.524499, 0.244338, 0.0694104, 0.0061917, 0.264777, -0.24266, -0.0868759, 0.0511714, -0.0802273, -0.0728945, 0.221923, -0.599865, -0.215813, -0.21781, -0.56181, 0.206074, 0.191751, 0.00382793, 0.0105143, -0.181691, 0.135877, 0.10335, -0.612585, 0.107936, 0.228633, 0.272243, 0.0269679, -0.17769, -0.256082, -0.811381, 0.104244, 0.383208, 0.0407346, 0.0751065, -0.168163, 0.279163, -0.286398, -0.78392, 0.0814335, -0.31601, 0.193673, -0.95102, -0.404277, 0.374906, 0.0186122, -0.160382, -0.607512, -0.139989, -0.25417, 0.22855, 0.535541, 0.155804, -0.708137, 0.0953746, -0.24515, -0.0899172, -0.541293, -0.226849, 0.0346306, -0.105633, -0.274791, 0.193859, -0.45996, -0.428253, -0.0738053, 0.409823, 0.326489}, {-0.27862, -0.140049, 0.396897, -0.245086, -0.403528, -0.0348525, -0.287385, 0.0793897, -0.433637, -0.098156, 0.360584, 0.270134, 0.355189, 0.183124, -0.528525, -0.726276, -0.0648568, -0.749275, -0.289878, 0.00624201, -0.50464, -0.136898, -0.641734, 0.54186, 0.154876, 0.210242, 0.0952413, 0.50474, -0.335193, -0.751882, -0.1781, -0.390928, 0.178866, 0.304233, -0.155972, 0.0932741, 0.31454, 0.0890081, -0.593027, -0.556261, -0.330841, 0.151821, 0.302326, -0.513699, 0.266397, 0.268486, 0.317577, -0.0999777, -0.121826, 0.117051, 0.078015, 0.312587, -0.614444, -0.225041, -0.478329, -1.35847, -0.830044, -0.368576, 0.481564, 0.290613, -0.0870066, -0.1096, -0.337188, -0.0596774, -0.748985, 0.329396, 0.0636463, -0.647527, 0.301545, -0.117684, 0.083119, -0.145287, -0.615349, 0.207772, -0.374404, 0.0297474, -0.166891, -0.199007, -0.378074, 0.200322, -0.0228576, -0.192095, -0.29702, 0.0106723, -0.633229, 0.171931, 0.0501818, -0.00904519, 0.267543, -0.00141885, 0.282537, 0.149426, 0.362156, 0.0500754, -0.438968, -0.821013, 0.410962, 0.219233, 0.422966, 0.516383}, {0.150929, 0.240058, -0.126779, 0.0416313, -0.544494, -1.0067, -0.693536, -0.239748, -0.332812, -0.261216, 0.222152, 0.366165, -0.687526, -0.907405, -0.797978, -0.0472059, -0.39584, 0.274233, 0.217358, -0.14236, 0.126297, 0.046871, 0.247669, 0.206988, -0.0993983, -0.856055, 0.122982, 0.247978, -0.382581, 0.149986, -0.68007, -0.0891693, 0.231757, -0.516958, -0.0265865, -0.333002, 0.263853, 0.220056, -0.629782, 0.160829, -0.940759, 0.0871085, -0.48038, -0.439821, 0.422938, 0.0788073, -0.192005, 0.470184, -0.639523, -1.6096, -0.349233, -0.42406, -0.342415, -0.144531, -0.567527, 0.0441658, -0.31945, -0.30449, 0.424087, 0.434994, 0.139866, 0.0111357, -0.142099, -0.331285, -0.271049, -0.87855, -0.71077, -0.420572, -0.316749, -0.0655546, 0.473933, -0.206992, 0.115931, -0.578606, 0.231187, 0.326173, 0.227594, 0.435614, 0.10549, 0.165017, 0.0421702, 0.286224, -0.561378, -0.215783, -0.186456, 0.39219, -0.165367, -0.179753, 0.325503, -1.1582, -0.155537, 0.107754, -0.585676, -0.40692, 0.0406379, 0.334387, -0.796499, -0.43822, 0.117776, 0.221561}, {-0.999534, -1.20049, -0.125736, -0.448516, -0.441777, 0.158312, -0.548791, 0.206772, -0.532495, 0.070352, 0.165767, 0.00301724, 0.187456, -0.368511, -0.581112, 0.502412, 0.613186, -0.0616166, -0.541619, -0.664638, -0.132724, 0.000782357, -0.522172, 0.073934, 0.31457, -0.360121, -0.163269, -0.442178, -0.0420558, -0.501701, -0.0262262, -0.0404891, 0.218573, 0.292948, -0.704932, -0.404236, -0.790868, 0.267269, -0.779161, 0.540317, -0.725599, -0.15136, -0.300445, 0.319914, -0.854522, 0.246147, 0.357426, 0.286943, -0.688633, -0.612396, -0.509055, -0.29112, -0.745611, -1.93582, -0.0112447, -0.191808, 0.120137, 0.630784, -1.01413, -0.266034, -0.211625, -0.385198, -0.0511739, -0.0896707, -0.0270075, -0.643801, 0.0303345, 0.395581, 0.413724, 0.790203, -0.360709, -0.920871, 0.321922, -0.900928, -0.564642, -0.171412, -0.538808, 0.0527591, -0.30898, 0.186249, -0.0411236, -0.472584, -0.103732, 0.387786, -0.113967, -0.449519, -1.0279, 0.117843, -0.313067, 0.511, 0.253832, -0.257478, 0.0959256, 0.482895, -0.747059, 0.154587, 0.383852, -0.0786836, 0.397332, -0.287178}};
    float bias1[100][1] = {{0.233395}, {-0.216156}, {-0.421754}, {-0.358339}, {-0.0282418}, {0.282294}, {0.611693}, {0.372713}, {0.170727}, {-0.140521}, {-0.266675}, {-0.0537064}, {-0.257385}, {-0.0911396}, {0.118529}, {-0.717312}, {0.385105}, {0.309579}, {0.217854}, {-0.0381153}, {0.420311}, {-0.161781}, {-0.322617}, {0.172904}, {0.0584921}, {0.0585543}, {0.372803}, {0.185519}, {0.0912626}, {0.125942}, {0.212078}, {-0.167195}, {-0.0379154}, {0.512148}, {-0.112862}, {0.0444117}, {0.106313}, {0.126605}, {-0.222418}, {-0.559714}, {-0.0816789}, {-0.118409}, {0.695885}, {0.280301}, {-0.00961054}, {0.316247}, {-0.0463075}, {0.310944}, {0.954413}, {0.319816}, {0.187926}, {0.0162824}, {-0.0905752}, {0.189804}, {0.212681}, {-0.216582}, {0.281138}, {0.0427181}, {-0.118116}, {-0.495959}, {-0.51168}, {-0.0453621}, {0.0768373}, {0.207573}, {-0.0359675}, {0.280211}, {-0.450396}, {-0.182496}, {-0.270603}, {0.758602}, {-0.0475278}, {0.517494}, {-0.141343}, {-0.21321}, {0.364892}, {0.0252658}, {0.145947}, {-0.0319336}, {-0.25849}, {0.156654}, {0.0159508}, {-0.0602304}, {0.0590167}, {-0.125134}, {0.651475}, {-0.178}, {-0.311485}, {-0.217126}, {0.273446}, {0.251382}, {-0.228518}, {0.0855993}, {-0.366238}, {-0.338975}, {0.333055}, {0.327159}, {0.0137132}, {0.545689}, {-0.03411}, {0.166626}};
    float bias2[26][1] = {{0.124402}, {0.297942}, {-0.306768}, {0.320972}, {-0.305907}, {-0.267444}, {0.0304887}, {-0.0203303}, {-0.142001}, {0.0239957}, {0.167637}, {-0.0803451}, {0.574163}, {-0.376019}, {-0.680617}, {0.0517516}, {0.597158}, {-0.168735}, {-0.267477}, {-0.16438}, {-0.00883835}, {-0.669551}, {1.14808}, {-0.359585}, {0.293835}, {0.0635308}};

    int i = 0, j = 0;
    float h1[100],h2[26];

    for (int i = 0; i < 100; i++)
    {
        h1[i] = bias1[i][0];

    }


    for (i = 0; i < 100; i++)
    {
        for (j = 0; j < 784; j++)
        {
            h1[i] += X[j] * lay1[i][j];
        }
        h1[i] = 1.0 / (1.0 + exp(-1 * h1[i]));

    }

    int num = 0;
    float mm = -10.0;

    for (int i = 0; i < 26; i++)
    {
        h2[i] = bias2[i][0];

    }

    for (i = 0; i < 26; i++)
    {
        h2[i] = 0.0;
        for (j = 0; j < 100; j++)
        {
            h2[i] += (h1[j] * lay2[i][j]);
        }
        h2[i] = 1.0 / (1.0 + exp(-1 * h2[i]));

        if (h2[i] > mm)
        {

            mm = h2[i];
            num = i;
        }
    }
    return (char)(num + 'A');
}
